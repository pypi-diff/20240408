# Comparing `tmp/celldega-0.1.1.tar.gz` & `tmp/celldega-0.1.2.tar.gz`

## Comparing `celldega-0.1.1.tar` & `celldega-0.1.2.tar`

### file list

```diff
@@ -1,7 +1,7 @@
--rw-r--r--   0        0        0      777 2020-02-02 00:00:00.000000 celldega-0.1.1/src/celldega/__init__.py
--rw-r--r--   0        0        0      325 2020-02-02 00:00:00.000000 celldega-0.1.1/src/celldega/static/widget.css
--rw-r--r--   0        0        0   677471 2020-02-02 00:00:00.000000 celldega-0.1.1/src/celldega/static/widget.js
--rw-r--r--   0        0        0      346 2020-02-02 00:00:00.000000 celldega-0.1.1/.gitignore
--rw-r--r--   0        0        0      558 2020-02-02 00:00:00.000000 celldega-0.1.1/README.md
--rw-r--r--   0        0        0      773 2020-02-02 00:00:00.000000 celldega-0.1.1/pyproject.toml
--rw-r--r--   0        0        0      780 2020-02-02 00:00:00.000000 celldega-0.1.1/PKG-INFO
+-rw-r--r--   0        0        0      777 2020-02-02 00:00:00.000000 celldega-0.1.2/src/celldega/__init__.py
+-rw-r--r--   0        0        0      325 2020-02-02 00:00:00.000000 celldega-0.1.2/src/celldega/static/widget.css
+-rw-r--r--   0        0        0   913414 2020-02-02 00:00:00.000000 celldega-0.1.2/src/celldega/static/widget.js
+-rw-r--r--   0        0        0      368 2020-02-02 00:00:00.000000 celldega-0.1.2/.gitignore
+-rw-r--r--   0        0        0      558 2020-02-02 00:00:00.000000 celldega-0.1.2/README.md
+-rw-r--r--   0        0        0      773 2020-02-02 00:00:00.000000 celldega-0.1.2/pyproject.toml
+-rw-r--r--   0        0        0      780 2020-02-02 00:00:00.000000 celldega-0.1.2/PKG-INFO
```

### Comparing `celldega-0.1.1/src/celldega/__init__.py` & `celldega-0.1.2/src/celldega/__init__.py`

 * *Files identical despite different names*

### Comparing `celldega-0.1.1/src/celldega/static/widget.js` & `celldega-0.1.2/src/celldega/static/widget.js`

 * *Files 15% similar despite different names*

#### js-beautify {}

```diff
@@ -1,1520 +1,1520 @@
-var JT = Object.create;
-var ga = Object.defineProperty;
-var tb = Object.getOwnPropertyDescriptor;
-var eb = Object.getOwnPropertyNames;
-var rb = Object.getPrototypeOf,
-    ib = Object.prototype.hasOwnProperty;
-var sb = (e, t, r) => t in e ? ga(e, t, {
+var n3 = Object.create;
+var yh = Object.defineProperty;
+var s3 = Object.getOwnPropertyDescriptor;
+var o3 = Object.getOwnPropertyNames;
+var a3 = Object.getPrototypeOf,
+    c3 = Object.prototype.hasOwnProperty;
+var l3 = (e, t, r) => t in e ? yh(e, t, {
     enumerable: !0,
     configurable: !0,
     writable: !0,
     value: r
 }) : e[t] = r;
-var Np = (e, t) => () => (t || e((t = {
+var tT = (e, t) => () => (t || e((t = {
         exports: {}
     }).exports, t), t.exports),
-    Ji = (e, t) => {
-        for (var r in t) ga(e, r, {
+    Ze = (e, t) => {
+        for (var r in t) yh(e, r, {
             get: t[r],
             enumerable: !0
         })
     },
-    nb = (e, t, r, i) => {
+    u3 = (e, t, r, i) => {
         if (t && typeof t == "object" || typeof t == "function")
-            for (let s of eb(t)) !ib.call(e, s) && s !== r && ga(e, s, {
-                get: () => t[s],
-                enumerable: !(i = tb(t, s)) || i.enumerable
+            for (let n of o3(t)) !c3.call(e, n) && n !== r && yh(e, n, {
+                get: () => t[n],
+                enumerable: !(i = s3(t, n)) || i.enumerable
             });
         return e
     };
-var Fp = (e, t, r) => (r = e != null ? JT(rb(e)) : {}, nb(t || !e || !e.__esModule ? ga(r, "default", {
+var eT = (e, t, r) => (r = e != null ? n3(a3(e)) : {}, u3(t || !e || !e.__esModule ? yh(r, "default", {
     value: e,
     enumerable: !0
 }) : r, e));
-var p = (e, t, r) => (sb(e, typeof t != "symbol" ? t + "" : t, r), r);
-var dy = Np((CW, pl) => {
+var m = (e, t, r) => (l3(e, typeof t != "symbol" ? t + "" : t, r), r);
+var BA = tT((uet, _p) => {
     (function(e, t, r, i) {
         "use strict";
-        var s = ["", "webkit", "Moz", "MS", "ms", "o"],
-            n = t.createElement("div"),
+        var n = ["", "webkit", "Moz", "MS", "ms", "o"],
+            s = t.createElement("div"),
             o = "function",
             a = Math.round,
             c = Math.abs,
             l = Date.now;
 
-        function h(g, _, b) {
-            return setTimeout(v(g, b), _)
+        function u(g, _, w) {
+            return setTimeout(I(g, w), _)
         }
 
-        function f(g, _, b) {
-            return Array.isArray(g) ? (u(g, b[_], b), !0) : !1
+        function f(g, _, w) {
+            return Array.isArray(g) ? (h(g, w[_], w), !0) : !1
         }
 
-        function u(g, _, b) {
-            var P;
+        function h(g, _, w) {
+            var M;
             if (g)
-                if (g.forEach) g.forEach(_, b);
+                if (g.forEach) g.forEach(_, w);
                 else if (g.length !== i)
-                for (P = 0; P < g.length;) _.call(b, g[P], P, g), P++;
+                for (M = 0; M < g.length;) _.call(w, g[M], M, g), M++;
             else
-                for (P in g) g.hasOwnProperty(P) && _.call(b, g[P], P, g)
+                for (M in g) g.hasOwnProperty(M) && _.call(w, g[M], M, g)
         }
 
-        function d(g, _, b) {
-            var P = "DEPRECATED METHOD: " + _ + `
-` + b + ` AT 
+        function d(g, _, w) {
+            var M = "DEPRECATED METHOD: " + _ + `
+` + w + ` AT 
 `;
             return function() {
-                var F = new Error("get-stack-trace"),
-                    W = F && F.stack ? F.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
-                    tt = e.console && (e.console.warn || e.console.log);
-                return tt && tt.call(e.console, P, W), g.apply(this, arguments)
+                var D = new Error("get-stack-trace"),
+                    $ = D && D.stack ? D.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
+                    At = e.console && (e.console.warn || e.console.log);
+                return At && At.call(e.console, M, $), g.apply(this, arguments)
             }
         }
-        var m;
-        typeof Object.assign != "function" ? m = function(_) {
+        var p;
+        typeof Object.assign != "function" ? p = function(_) {
             if (_ === i || _ === null) throw new TypeError("Cannot convert undefined or null to object");
-            for (var b = Object(_), P = 1; P < arguments.length; P++) {
-                var F = arguments[P];
-                if (F !== i && F !== null)
-                    for (var W in F) F.hasOwnProperty(W) && (b[W] = F[W])
-            }
-            return b
-        } : m = Object.assign;
-        var y = d(function(_, b, P) {
-                for (var F = Object.keys(b), W = 0; W < F.length;)(!P || P && _[F[W]] === i) && (_[F[W]] = b[F[W]]), W++;
+            for (var w = Object(_), M = 1; M < arguments.length; M++) {
+                var D = arguments[M];
+                if (D !== i && D !== null)
+                    for (var $ in D) D.hasOwnProperty($) && (w[$] = D[$])
+            }
+            return w
+        } : p = Object.assign;
+        var y = d(function(_, w, M) {
+                for (var D = Object.keys(w), $ = 0; $ < D.length;)(!M || M && _[D[$]] === i) && (_[D[$]] = w[D[$]]), $++;
                 return _
             }, "extend", "Use `assign`."),
-            x = d(function(_, b) {
-                return y(_, b, !0)
+            b = d(function(_, w) {
+                return y(_, w, !0)
             }, "merge", "Use `assign`.");
 
-        function A(g, _, b) {
-            var P = _.prototype,
-                F;
-            F = g.prototype = Object.create(P), F.constructor = g, F._super = P, b && m(F, b)
+        function T(g, _, w) {
+            var M = _.prototype,
+                D;
+            D = g.prototype = Object.create(M), D.constructor = g, D._super = M, w && p(D, w)
         }
 
-        function v(g, _) {
+        function I(g, _) {
             return function() {
                 return g.apply(_, arguments)
             }
         }
 
-        function E(g, _) {
+        function S(g, _) {
             return typeof g == o ? g.apply(_ && _[0] || i, _) : g
         }
 
         function R(g, _) {
             return g === i ? _ : g
         }
 
-        function M(g, _, b) {
-            u(k(_), function(P) {
-                g.addEventListener(P, b, !1)
+        function P(g, _, w) {
+            h(k(_), function(M) {
+                g.addEventListener(M, w, !1)
             })
         }
 
-        function C(g, _, b) {
-            u(k(_), function(P) {
-                g.removeEventListener(P, b, !1)
+        function C(g, _, w) {
+            h(k(_), function(M) {
+                g.removeEventListener(M, w, !1)
             })
         }
 
-        function B(g, _) {
+        function V(g, _) {
             for (; g;) {
                 if (g == _) return !0;
                 g = g.parentNode
             }
             return !1
         }
 
-        function L(g, _) {
+        function U(g, _) {
             return g.indexOf(_) > -1
         }
 
         function k(g) {
             return g.trim().split(/\s+/g)
         }
 
-        function N(g, _, b) {
-            if (g.indexOf && !b) return g.indexOf(_);
-            for (var P = 0; P < g.length;) {
-                if (b && g[P][b] == _ || !b && g[P] === _) return P;
-                P++
+        function B(g, _, w) {
+            if (g.indexOf && !w) return g.indexOf(_);
+            for (var M = 0; M < g.length;) {
+                if (w && g[M][w] == _ || !w && g[M] === _) return M;
+                M++
             }
             return -1
         }
 
-        function H(g) {
+        function K(g) {
             return Array.prototype.slice.call(g, 0)
         }
 
-        function $(g, _, b) {
-            for (var P = [], F = [], W = 0; W < g.length;) {
-                var tt = _ ? g[W][_] : g[W];
-                N(F, tt) < 0 && P.push(g[W]), F[W] = tt, W++
-            }
-            return b && (_ ? P = P.sort(function(Pt, Dt) {
-                return Pt[_] > Dt[_]
-            }) : P = P.sort()), P
+        function st(g, _, w) {
+            for (var M = [], D = [], $ = 0; $ < g.length;) {
+                var At = _ ? g[$][_] : g[$];
+                B(D, At) < 0 && M.push(g[$]), D[$] = At, $++
+            }
+            return w && (_ ? M = M.sort(function(Te, Be) {
+                return Te[_] > Be[_]
+            }) : M = M.sort()), M
         }
 
-        function X(g, _) {
-            for (var b, P, F = _[0].toUpperCase() + _.slice(1), W = 0; W < s.length;) {
-                if (b = s[W], P = b ? b + F : _, P in g) return P;
-                W++
+        function G(g, _) {
+            for (var w, M, D = _[0].toUpperCase() + _.slice(1), $ = 0; $ < n.length;) {
+                if (w = n[$], M = w ? w + D : _, M in g) return M;
+                $++
             }
             return i
         }
-        var J = 1;
+        var Tt = 1;
 
-        function xt() {
-            return J++
+        function oe() {
+            return Tt++
         }
 
-        function ne(g) {
+        function Er(g) {
             var _ = g.ownerDocument || g;
             return _.defaultView || _.parentWindow || e
         }
-        var It = /mobile|tablet|ip(ad|hone|od)|android/i,
-            ci = "ontouchstart" in e,
-            wr = X(e, "PointerEvent") !== i,
-            fh = ci && It.test(navigator.userAgent),
-            sr = "touch",
-            uh = "pen",
-            Js = "mouse",
-            dh = "kinect",
-            ph = 25,
-            St = 1,
-            nr = 2,
-            dt = 4,
-            Rt = 8,
-            li = 1,
-            vr = 2,
-            Rr = 4,
-            Pr = 8,
-            Mr = 16,
-            oe = vr | Rr,
-            De = Pr | Mr,
-            Zi = oe | De,
-            Ki = ["x", "y"],
-            Qi = ["clientX", "clientY"];
-
-        function jt(g, _) {
-            var b = this;
-            this.manager = g, this.callback = _, this.element = g.element, this.target = g.options.inputTarget, this.domHandler = function(P) {
-                E(g.options.enable, [g]) && b.handler(P)
+        var Re = /mobile|tablet|ip(ad|hone|od)|android/i,
+            ro = "ontouchstart" in e,
+            os = G(e, "PointerEvent") !== i,
+            e_ = ro && Re.test(navigator.userAgent),
+            dn = "touch",
+            r_ = "pen",
+            Xc = "mouse",
+            i_ = "kinect",
+            n_ = 25,
+            ge = 1,
+            pn = 2,
+            Jt = 4,
+            we = 8,
+            io = 1,
+            as = 2,
+            cs = 4,
+            ls = 8,
+            us = 16,
+            Ir = as | cs,
+            Pi = ls | us,
+            pa = Ir | Pi,
+            ma = ["x", "y"],
+            ga = ["clientX", "clientY"];
+
+        function Ye(g, _) {
+            var w = this;
+            this.manager = g, this.callback = _, this.element = g.element, this.target = g.options.inputTarget, this.domHandler = function(M) {
+                S(g.options.enable, [g]) && w.handler(M)
             }, this.init()
         }
-        jt.prototype = {
+        Ye.prototype = {
             handler: function() {},
             init: function() {
-                this.evEl && M(this.element, this.evEl, this.domHandler), this.evTarget && M(this.target, this.evTarget, this.domHandler), this.evWin && M(ne(this.element), this.evWin, this.domHandler)
+                this.evEl && P(this.element, this.evEl, this.domHandler), this.evTarget && P(this.target, this.evTarget, this.domHandler), this.evWin && P(Er(this.element), this.evWin, this.domHandler)
             },
             destroy: function() {
-                this.evEl && C(this.element, this.evEl, this.domHandler), this.evTarget && C(this.target, this.evTarget, this.domHandler), this.evWin && C(ne(this.element), this.evWin, this.domHandler)
+                this.evEl && C(this.element, this.evEl, this.domHandler), this.evTarget && C(this.target, this.evTarget, this.domHandler), this.evWin && C(Er(this.element), this.evWin, this.domHandler)
             }
         };
 
-        function gh(g) {
-            var _, b = g.options.inputClass;
-            return b ? _ = b : wr ? _ = sn : fh ? _ = la : ci ? _ = yh : _ = Cr, new _(g, tn)
-        }
-
-        function tn(g, _, b) {
-            var P = b.pointers.length,
-                F = b.changedPointers.length,
-                W = _ & St && P - F === 0,
-                tt = _ & (dt | Rt) && P - F === 0;
-            b.isFirst = !!W, b.isFinal = !!tt, W && (g.session = {}), b.eventType = _, en(g, b), g.emit("hammer.input", b), g.recognize(b), g.session.prevInput = b
-        }
-
-        function en(g, _) {
-            var b = g.session,
-                P = _.pointers,
-                F = P.length;
-            b.firstInput || (b.firstInput = z(_)), F > 1 && !b.firstMultiple ? b.firstMultiple = z(_) : F === 1 && (b.firstMultiple = !1);
-            var W = b.firstInput,
-                tt = b.firstMultiple,
-                wt = tt ? tt.center : W.center,
-                Pt = _.center = Y(P);
-            _.timeStamp = l(), _.deltaTime = _.timeStamp - W.timeStamp, _.angle = Ht(wt, Pt), _.distance = et(wt, Pt), D(b, _), _.offsetDirection = Z(_.deltaX, _.deltaY);
-            var Dt = G(_.deltaTime, _.deltaX, _.deltaY);
-            _.overallVelocityX = Dt.x, _.overallVelocityY = Dt.y, _.overallVelocity = c(Dt.x) > c(Dt.y) ? Dt.x : Dt.y, _.scale = tt ? or(tt.pointers, P) : 1, _.rotation = tt ? ee(tt.pointers, P) : 0, _.maxPointers = b.prevInput ? _.pointers.length > b.prevInput.maxPointers ? _.pointers.length : b.prevInput.maxPointers : _.pointers.length, V(b, _);
-            var Be = g.element;
-            B(_.srcEvent.target, Be) && (Be = _.srcEvent.target), _.target = Be
-        }
-
-        function D(g, _) {
-            var b = _.center,
-                P = g.offsetDelta || {},
-                F = g.prevDelta || {},
-                W = g.prevInput || {};
-            (_.eventType === St || W.eventType === dt) && (F = g.prevDelta = {
-                x: W.deltaX || 0,
-                y: W.deltaY || 0
-            }, P = g.offsetDelta = {
-                x: b.x,
-                y: b.y
-            }), _.deltaX = F.x + (b.x - P.x), _.deltaY = F.y + (b.y - P.y)
+        function s_(g) {
+            var _, w = g.options.inputClass;
+            return w ? _ = w : os ? _ = Kc : e_ ? _ = hh : ro ? _ = c_ : _ = fs, new _(g, Yc)
+        }
+
+        function Yc(g, _, w) {
+            var M = w.pointers.length,
+                D = w.changedPointers.length,
+                $ = _ & ge && M - D === 0,
+                At = _ & (Jt | we) && M - D === 0;
+            w.isFirst = !!$, w.isFinal = !!At, $ && (g.session = {}), w.eventType = _, qc(g, w), g.emit("hammer.input", w), g.recognize(w), g.session.prevInput = w
+        }
+
+        function qc(g, _) {
+            var w = g.session,
+                M = _.pointers,
+                D = M.length;
+            w.firstInput || (w.firstInput = j(_)), D > 1 && !w.firstMultiple ? w.firstMultiple = j(_) : D === 1 && (w.firstMultiple = !1);
+            var $ = w.firstInput,
+                At = w.firstMultiple,
+                _e = At ? At.center : $.center,
+                Te = _.center = ot(M);
+            _.timeStamp = l(), _.deltaTime = _.timeStamp - $.timeStamp, _.angle = qe(_e, Te), _.distance = Et(_e, Te), L(w, _), _.offsetDirection = mt(_.deltaX, _.deltaY);
+            var Be = bt(_.deltaTime, _.deltaX, _.deltaY);
+            _.overallVelocityX = Be.x, _.overallVelocityY = Be.y, _.overallVelocity = c(Be.x) > c(Be.y) ? Be.x : Be.y, _.scale = At ? mn(At.pointers, M) : 1, _.rotation = At ? dr(At.pointers, M) : 0, _.maxPointers = w.prevInput ? _.pointers.length > w.prevInput.maxPointers ? _.pointers.length : w.prevInput.maxPointers : _.pointers.length, W(w, _);
+            var Ni = g.element;
+            V(_.srcEvent.target, Ni) && (Ni = _.srcEvent.target), _.target = Ni
         }
 
-        function V(g, _) {
-            var b = g.lastInterval || _,
-                P = _.timeStamp - b.timeStamp,
-                F, W, tt, wt;
-            if (_.eventType != Rt && (P > ph || b.velocity === i)) {
-                var Pt = _.deltaX - b.deltaX,
-                    Dt = _.deltaY - b.deltaY,
-                    Be = G(P, Pt, Dt);
-                W = Be.x, tt = Be.y, F = c(Be.x) > c(Be.y) ? Be.x : Be.y, wt = Z(Pt, Dt), g.lastInterval = _
-            } else F = b.velocity, W = b.velocityX, tt = b.velocityY, wt = b.direction;
-            _.velocity = F, _.velocityX = W, _.velocityY = tt, _.direction = wt
-        }
-
-        function z(g) {
-            for (var _ = [], b = 0; b < g.pointers.length;) _[b] = {
-                clientX: a(g.pointers[b].clientX),
-                clientY: a(g.pointers[b].clientY)
-            }, b++;
+        function L(g, _) {
+            var w = _.center,
+                M = g.offsetDelta || {},
+                D = g.prevDelta || {},
+                $ = g.prevInput || {};
+            (_.eventType === ge || $.eventType === Jt) && (D = g.prevDelta = {
+                x: $.deltaX || 0,
+                y: $.deltaY || 0
+            }, M = g.offsetDelta = {
+                x: w.x,
+                y: w.y
+            }), _.deltaX = D.x + (w.x - M.x), _.deltaY = D.y + (w.y - M.y)
+        }
+
+        function W(g, _) {
+            var w = g.lastInterval || _,
+                M = _.timeStamp - w.timeStamp,
+                D, $, At, _e;
+            if (_.eventType != we && (M > n_ || w.velocity === i)) {
+                var Te = _.deltaX - w.deltaX,
+                    Be = _.deltaY - w.deltaY,
+                    Ni = bt(M, Te, Be);
+                $ = Ni.x, At = Ni.y, D = c(Ni.x) > c(Ni.y) ? Ni.x : Ni.y, _e = mt(Te, Be), g.lastInterval = _
+            } else D = w.velocity, $ = w.velocityX, At = w.velocityY, _e = w.direction;
+            _.velocity = D, _.velocityX = $, _.velocityY = At, _.direction = _e
+        }
+
+        function j(g) {
+            for (var _ = [], w = 0; w < g.pointers.length;) _[w] = {
+                clientX: a(g.pointers[w].clientX),
+                clientY: a(g.pointers[w].clientY)
+            }, w++;
             return {
                 timeStamp: l(),
                 pointers: _,
-                center: Y(_),
+                center: ot(_),
                 deltaX: g.deltaX,
                 deltaY: g.deltaY
             }
         }
 
-        function Y(g) {
+        function ot(g) {
             var _ = g.length;
             if (_ === 1) return {
                 x: a(g[0].clientX),
                 y: a(g[0].clientY)
             };
-            for (var b = 0, P = 0, F = 0; F < _;) b += g[F].clientX, P += g[F].clientY, F++;
+            for (var w = 0, M = 0, D = 0; D < _;) w += g[D].clientX, M += g[D].clientY, D++;
             return {
-                x: a(b / _),
-                y: a(P / _)
+                x: a(w / _),
+                y: a(M / _)
             }
         }
 
-        function G(g, _, b) {
+        function bt(g, _, w) {
             return {
                 x: _ / g || 0,
-                y: b / g || 0
+                y: w / g || 0
             }
         }
 
-        function Z(g, _) {
-            return g === _ ? li : c(g) >= c(_) ? g < 0 ? vr : Rr : _ < 0 ? Pr : Mr
+        function mt(g, _) {
+            return g === _ ? io : c(g) >= c(_) ? g < 0 ? as : cs : _ < 0 ? ls : us
         }
 
-        function et(g, _, b) {
-            b || (b = Ki);
-            var P = _[b[0]] - g[b[0]],
-                F = _[b[1]] - g[b[1]];
-            return Math.sqrt(P * P + F * F)
+        function Et(g, _, w) {
+            w || (w = ma);
+            var M = _[w[0]] - g[w[0]],
+                D = _[w[1]] - g[w[1]];
+            return Math.sqrt(M * M + D * D)
         }
 
-        function Ht(g, _, b) {
-            b || (b = Ki);
-            var P = _[b[0]] - g[b[0]],
-                F = _[b[1]] - g[b[1]];
-            return Math.atan2(F, P) * 180 / Math.PI
+        function qe(g, _, w) {
+            w || (w = ma);
+            var M = _[w[0]] - g[w[0]],
+                D = _[w[1]] - g[w[1]];
+            return Math.atan2(D, M) * 180 / Math.PI
         }
 
-        function ee(g, _) {
-            return Ht(_[1], _[0], Qi) + Ht(g[1], g[0], Qi)
+        function dr(g, _) {
+            return qe(_[1], _[0], ga) + qe(g[1], g[0], ga)
         }
 
-        function or(g, _) {
-            return et(_[0], _[1], Qi) / et(g[0], g[1], Qi)
+        function mn(g, _) {
+            return Et(_[0], _[1], ga) / Et(g[0], g[1], ga)
         }
-        var re = {
-                mousedown: St,
-                mousemove: nr,
-                mouseup: dt
+        var pr = {
+                mousedown: ge,
+                mousemove: pn,
+                mouseup: Jt
             },
-            ke = "mousedown",
-            rn = "mousemove mouseup";
+            Ci = "mousedown",
+            Zc = "mousemove mouseup";
 
-        function Cr() {
-            this.evEl = ke, this.evWin = rn, this.pressed = !1, jt.apply(this, arguments)
+        function fs() {
+            this.evEl = Ci, this.evWin = Zc, this.pressed = !1, Ye.apply(this, arguments)
         }
-        A(Cr, jt, {
+        T(fs, Ye, {
             handler: function(_) {
-                var b = re[_.type];
-                b & St && _.button === 0 && (this.pressed = !0), b & nr && _.which !== 1 && (b = dt), this.pressed && (b & dt && (this.pressed = !1), this.callback(this.manager, b, {
+                var w = pr[_.type];
+                w & ge && _.button === 0 && (this.pressed = !0), w & pn && _.which !== 1 && (w = Jt), this.pressed && (w & Jt && (this.pressed = !1), this.callback(this.manager, w, {
                     pointers: [_],
                     changedPointers: [_],
-                    pointerType: Js,
+                    pointerType: Xc,
                     srcEvent: _
                 }))
             }
         });
-        var mh = {
-                pointerdown: St,
-                pointermove: nr,
-                pointerup: dt,
-                pointercancel: Rt,
-                pointerout: Rt
-            },
-            _h = {
-                2: sr,
-                3: uh,
-                4: Js,
-                5: dh
-            },
-            aa = "pointerdown",
-            ca = "pointermove pointerup pointercancel";
-        e.MSPointerEvent && !e.PointerEvent && (aa = "MSPointerDown", ca = "MSPointerMove MSPointerUp MSPointerCancel");
+        var o_ = {
+                pointerdown: ge,
+                pointermove: pn,
+                pointerup: Jt,
+                pointercancel: we,
+                pointerout: we
+            },
+            a_ = {
+                2: dn,
+                3: r_,
+                4: Xc,
+                5: i_
+            },
+            uh = "pointerdown",
+            fh = "pointermove pointerup pointercancel";
+        e.MSPointerEvent && !e.PointerEvent && (uh = "MSPointerDown", fh = "MSPointerMove MSPointerUp MSPointerCancel");
 
-        function sn() {
-            this.evEl = aa, this.evWin = ca, jt.apply(this, arguments), this.store = this.manager.session.pointerEvents = []
+        function Kc() {
+            this.evEl = uh, this.evWin = fh, Ye.apply(this, arguments), this.store = this.manager.session.pointerEvents = []
         }
-        A(sn, jt, {
+        T(Kc, Ye, {
             handler: function(_) {
-                var b = this.store,
-                    P = !1,
-                    F = _.type.toLowerCase().replace("ms", ""),
-                    W = mh[F],
-                    tt = _h[_.pointerType] || _.pointerType,
-                    wt = tt == sr,
-                    Pt = N(b, _.pointerId, "pointerId");
-                W & St && (_.button === 0 || wt) ? Pt < 0 && (b.push(_), Pt = b.length - 1) : W & (dt | Rt) && (P = !0), !(Pt < 0) && (b[Pt] = _, this.callback(this.manager, W, {
-                    pointers: b,
+                var w = this.store,
+                    M = !1,
+                    D = _.type.toLowerCase().replace("ms", ""),
+                    $ = o_[D],
+                    At = a_[_.pointerType] || _.pointerType,
+                    _e = At == dn,
+                    Te = B(w, _.pointerId, "pointerId");
+                $ & ge && (_.button === 0 || _e) ? Te < 0 && (w.push(_), Te = w.length - 1) : $ & (Jt | we) && (M = !0), !(Te < 0) && (w[Te] = _, this.callback(this.manager, $, {
+                    pointers: w,
                     changedPointers: [_],
-                    pointerType: tt,
+                    pointerType: At,
                     srcEvent: _
-                }), P && b.splice(Pt, 1))
+                }), M && w.splice(Te, 1))
             }
         });
-        var BT = {
-                touchstart: St,
-                touchmove: nr,
-                touchend: dt,
-                touchcancel: Rt
+        var jP = {
+                touchstart: ge,
+                touchmove: pn,
+                touchend: Jt,
+                touchcancel: we
             },
-            UT = "touchstart",
-            VT = "touchstart touchmove touchend touchcancel";
+            HP = "touchstart",
+            $P = "touchstart touchmove touchend touchcancel";
 
-        function Ap() {
-            this.evTarget = UT, this.evWin = VT, this.started = !1, jt.apply(this, arguments)
+        function jw() {
+            this.evTarget = HP, this.evWin = $P, this.started = !1, Ye.apply(this, arguments)
         }
-        A(Ap, jt, {
+        T(jw, Ye, {
             handler: function(_) {
-                var b = BT[_.type];
-                if (b === St && (this.started = !0), !!this.started) {
-                    var P = zT.call(this, _, b);
-                    b & (dt | Rt) && P[0].length - P[1].length === 0 && (this.started = !1), this.callback(this.manager, b, {
-                        pointers: P[0],
-                        changedPointers: P[1],
-                        pointerType: sr,
+                var w = jP[_.type];
+                if (w === ge && (this.started = !0), !!this.started) {
+                    var M = XP.call(this, _, w);
+                    w & (Jt | we) && M[0].length - M[1].length === 0 && (this.started = !1), this.callback(this.manager, w, {
+                        pointers: M[0],
+                        changedPointers: M[1],
+                        pointerType: dn,
                         srcEvent: _
                     })
                 }
             }
         });
 
-        function zT(g, _) {
-            var b = H(g.touches),
-                P = H(g.changedTouches);
-            return _ & (dt | Rt) && (b = $(b.concat(P), "identifier", !0)), [b, P]
-        }
-        var WT = {
-                touchstart: St,
-                touchmove: nr,
-                touchend: dt,
-                touchcancel: Rt
+        function XP(g, _) {
+            var w = K(g.touches),
+                M = K(g.changedTouches);
+            return _ & (Jt | we) && (w = st(w.concat(M), "identifier", !0)), [w, M]
+        }
+        var YP = {
+                touchstart: ge,
+                touchmove: pn,
+                touchend: Jt,
+                touchcancel: we
             },
-            jT = "touchstart touchmove touchend touchcancel";
+            qP = "touchstart touchmove touchend touchcancel";
 
-        function la() {
-            this.evTarget = jT, this.targetIds = {}, jt.apply(this, arguments)
+        function hh() {
+            this.evTarget = qP, this.targetIds = {}, Ye.apply(this, arguments)
         }
-        A(la, jt, {
+        T(hh, Ye, {
             handler: function(_) {
-                var b = WT[_.type],
-                    P = HT.call(this, _, b);
-                P && this.callback(this.manager, b, {
-                    pointers: P[0],
-                    changedPointers: P[1],
-                    pointerType: sr,
+                var w = YP[_.type],
+                    M = ZP.call(this, _, w);
+                M && this.callback(this.manager, w, {
+                    pointers: M[0],
+                    changedPointers: M[1],
+                    pointerType: dn,
                     srcEvent: _
                 })
             }
         });
 
-        function HT(g, _) {
-            var b = H(g.touches),
-                P = this.targetIds;
-            if (_ & (St | nr) && b.length === 1) return P[b[0].identifier] = !0, [b, b];
-            var F, W, tt = H(g.changedTouches),
-                wt = [],
-                Pt = this.target;
-            if (W = b.filter(function(Dt) {
-                    return B(Dt.target, Pt)
-                }), _ === St)
-                for (F = 0; F < W.length;) P[W[F].identifier] = !0, F++;
-            for (F = 0; F < tt.length;) P[tt[F].identifier] && wt.push(tt[F]), _ & (dt | Rt) && delete P[tt[F].identifier], F++;
-            if (wt.length) return [$(W.concat(wt), "identifier", !0), wt]
-        }
-        var XT = 2500,
-            Ep = 25;
-
-        function yh() {
-            jt.apply(this, arguments);
-            var g = v(this.handler, this);
-            this.touch = new la(this.manager, g), this.mouse = new Cr(this.manager, g), this.primaryTouch = null, this.lastTouches = []
-        }
-        A(yh, jt, {
-            handler: function(_, b, P) {
-                var F = P.pointerType == sr,
-                    W = P.pointerType == Js;
-                if (!(W && P.sourceCapabilities && P.sourceCapabilities.firesTouchEvents)) {
-                    if (F) $T.call(this, b, P);
-                    else if (W && YT.call(this, P)) return;
-                    this.callback(_, b, P)
+        function ZP(g, _) {
+            var w = K(g.touches),
+                M = this.targetIds;
+            if (_ & (ge | pn) && w.length === 1) return M[w[0].identifier] = !0, [w, w];
+            var D, $, At = K(g.changedTouches),
+                _e = [],
+                Te = this.target;
+            if ($ = w.filter(function(Be) {
+                    return V(Be.target, Te)
+                }), _ === ge)
+                for (D = 0; D < $.length;) M[$[D].identifier] = !0, D++;
+            for (D = 0; D < At.length;) M[At[D].identifier] && _e.push(At[D]), _ & (Jt | we) && delete M[At[D].identifier], D++;
+            if (_e.length) return [st($.concat(_e), "identifier", !0), _e]
+        }
+        var KP = 2500,
+            Hw = 25;
+
+        function c_() {
+            Ye.apply(this, arguments);
+            var g = I(this.handler, this);
+            this.touch = new hh(this.manager, g), this.mouse = new fs(this.manager, g), this.primaryTouch = null, this.lastTouches = []
+        }
+        T(c_, Ye, {
+            handler: function(_, w, M) {
+                var D = M.pointerType == dn,
+                    $ = M.pointerType == Xc;
+                if (!($ && M.sourceCapabilities && M.sourceCapabilities.firesTouchEvents)) {
+                    if (D) GP.call(this, w, M);
+                    else if ($ && JP.call(this, M)) return;
+                    this.callback(_, w, M)
                 }
             },
             destroy: function() {
                 this.touch.destroy(), this.mouse.destroy()
             }
         });
 
-        function $T(g, _) {
-            g & St ? (this.primaryTouch = _.changedPointers[0].identifier, Sp.call(this, _)) : g & (dt | Rt) && Sp.call(this, _)
+        function GP(g, _) {
+            g & ge ? (this.primaryTouch = _.changedPointers[0].identifier, $w.call(this, _)) : g & (Jt | we) && $w.call(this, _)
         }
 
-        function Sp(g) {
+        function $w(g) {
             var _ = g.changedPointers[0];
             if (_.identifier === this.primaryTouch) {
-                var b = {
+                var w = {
                     x: _.clientX,
                     y: _.clientY
                 };
-                this.lastTouches.push(b);
-                var P = this.lastTouches,
-                    F = function() {
-                        var W = P.indexOf(b);
-                        W > -1 && P.splice(W, 1)
+                this.lastTouches.push(w);
+                var M = this.lastTouches,
+                    D = function() {
+                        var $ = M.indexOf(w);
+                        $ > -1 && M.splice($, 1)
                     };
-                setTimeout(F, XT)
+                setTimeout(D, KP)
             }
         }
 
-        function YT(g) {
-            for (var _ = g.srcEvent.clientX, b = g.srcEvent.clientY, P = 0; P < this.lastTouches.length; P++) {
-                var F = this.lastTouches[P],
-                    W = Math.abs(_ - F.x),
-                    tt = Math.abs(b - F.y);
-                if (W <= Ep && tt <= Ep) return !0
+        function JP(g) {
+            for (var _ = g.srcEvent.clientX, w = g.srcEvent.clientY, M = 0; M < this.lastTouches.length; M++) {
+                var D = this.lastTouches[M],
+                    $ = Math.abs(_ - D.x),
+                    At = Math.abs(w - D.y);
+                if ($ <= Hw && At <= Hw) return !0
             }
             return !1
         }
-        var wp = X(n.style, "touchAction"),
-            vp = wp !== i,
-            Rp = "compute",
-            Pp = "auto",
-            xh = "manipulation",
-            hi = "none",
-            nn = "pan-x",
-            on = "pan-y",
-            ha = ZT();
+        var Xw = G(s.style, "touchAction"),
+            Yw = Xw !== i,
+            qw = "compute",
+            Zw = "auto",
+            l_ = "manipulation",
+            no = "none",
+            Gc = "pan-x",
+            Jc = "pan-y",
+            dh = t3();
 
-        function Th(g, _) {
+        function u_(g, _) {
             this.manager = g, this.set(_)
         }
-        Th.prototype = {
+        u_.prototype = {
             set: function(g) {
-                g == Rp && (g = this.compute()), vp && this.manager.element.style && ha[g] && (this.manager.element.style[wp] = g), this.actions = g.toLowerCase().trim()
+                g == qw && (g = this.compute()), Yw && this.manager.element.style && dh[g] && (this.manager.element.style[Xw] = g), this.actions = g.toLowerCase().trim()
             },
             update: function() {
                 this.set(this.manager.options.touchAction)
             },
             compute: function() {
                 var g = [];
-                return u(this.manager.recognizers, function(_) {
-                    E(_.options.enable, [_]) && (g = g.concat(_.getTouchAction()))
-                }), qT(g.join(" "))
+                return h(this.manager.recognizers, function(_) {
+                    S(_.options.enable, [_]) && (g = g.concat(_.getTouchAction()))
+                }), QP(g.join(" "))
             },
             preventDefaults: function(g) {
                 var _ = g.srcEvent,
-                    b = g.offsetDirection;
+                    w = g.offsetDirection;
                 if (this.manager.session.prevented) {
                     _.preventDefault();
                     return
                 }
-                var P = this.actions,
-                    F = L(P, hi) && !ha[hi],
-                    W = L(P, on) && !ha[on],
-                    tt = L(P, nn) && !ha[nn];
-                if (F) {
-                    var wt = g.pointers.length === 1,
-                        Pt = g.distance < 2,
-                        Dt = g.deltaTime < 250;
-                    if (wt && Pt && Dt) return
+                var M = this.actions,
+                    D = U(M, no) && !dh[no],
+                    $ = U(M, Jc) && !dh[Jc],
+                    At = U(M, Gc) && !dh[Gc];
+                if (D) {
+                    var _e = g.pointers.length === 1,
+                        Te = g.distance < 2,
+                        Be = g.deltaTime < 250;
+                    if (_e && Te && Be) return
                 }
-                if (!(tt && W) && (F || W && b & oe || tt && b & De)) return this.preventSrc(_)
+                if (!(At && $) && (D || $ && w & Ir || At && w & Pi)) return this.preventSrc(_)
             },
             preventSrc: function(g) {
                 this.manager.session.prevented = !0, g.preventDefault()
             }
         };
 
-        function qT(g) {
-            if (L(g, hi)) return hi;
-            var _ = L(g, nn),
-                b = L(g, on);
-            return _ && b ? hi : _ || b ? _ ? nn : on : L(g, xh) ? xh : Pp
+        function QP(g) {
+            if (U(g, no)) return no;
+            var _ = U(g, Gc),
+                w = U(g, Jc);
+            return _ && w ? no : _ || w ? _ ? Gc : Jc : U(g, l_) ? l_ : Zw
         }
 
-        function ZT() {
-            if (!vp) return !1;
+        function t3() {
+            if (!Yw) return !1;
             var g = {},
                 _ = e.CSS && e.CSS.supports;
-            return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(b) {
-                g[b] = _ ? e.CSS.supports("touch-action", b) : !0
+            return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(w) {
+                g[w] = _ ? e.CSS.supports("touch-action", w) : !0
             }), g
         }
-        var fa = 1,
-            ae = 2,
-            Gi = 4,
-            Ir = 8,
-            ar = Ir,
-            an = 16,
-            Le = 32;
+        var ph = 1,
+            Rr = 2,
+            _a = 4,
+            hs = 8,
+            gn = hs,
+            Qc = 16,
+            Oi = 32;
 
-        function cr(g) {
-            this.options = m({}, this.defaults, g || {}), this.id = xt(), this.manager = null, this.options.enable = R(this.options.enable, !0), this.state = fa, this.simultaneous = {}, this.requireFail = []
+        function _n(g) {
+            this.options = p({}, this.defaults, g || {}), this.id = oe(), this.manager = null, this.options.enable = R(this.options.enable, !0), this.state = ph, this.simultaneous = {}, this.requireFail = []
         }
-        cr.prototype = {
+        _n.prototype = {
             defaults: {},
             set: function(g) {
-                return m(this.options, g), this.manager && this.manager.touchAction.update(), this
+                return p(this.options, g), this.manager && this.manager.touchAction.update(), this
             },
             recognizeWith: function(g) {
                 if (f(g, "recognizeWith", this)) return this;
                 var _ = this.simultaneous;
-                return g = ua(g, this), _[g.id] || (_[g.id] = g, g.recognizeWith(this)), this
+                return g = mh(g, this), _[g.id] || (_[g.id] = g, g.recognizeWith(this)), this
             },
             dropRecognizeWith: function(g) {
-                return f(g, "dropRecognizeWith", this) ? this : (g = ua(g, this), delete this.simultaneous[g.id], this)
+                return f(g, "dropRecognizeWith", this) ? this : (g = mh(g, this), delete this.simultaneous[g.id], this)
             },
             requireFailure: function(g) {
                 if (f(g, "requireFailure", this)) return this;
                 var _ = this.requireFail;
-                return g = ua(g, this), N(_, g) === -1 && (_.push(g), g.requireFailure(this)), this
+                return g = mh(g, this), B(_, g) === -1 && (_.push(g), g.requireFailure(this)), this
             },
             dropRequireFailure: function(g) {
                 if (f(g, "dropRequireFailure", this)) return this;
-                g = ua(g, this);
-                var _ = N(this.requireFail, g);
+                g = mh(g, this);
+                var _ = B(this.requireFail, g);
                 return _ > -1 && this.requireFail.splice(_, 1), this
             },
             hasRequireFailures: function() {
                 return this.requireFail.length > 0
             },
             canRecognizeWith: function(g) {
                 return !!this.simultaneous[g.id]
             },
             emit: function(g) {
                 var _ = this,
-                    b = this.state;
+                    w = this.state;
 
-                function P(F) {
-                    _.manager.emit(F, g)
+                function M(D) {
+                    _.manager.emit(D, g)
                 }
-                b < Ir && P(_.options.event + Mp(b)), P(_.options.event), g.additionalEvent && P(g.additionalEvent), b >= Ir && P(_.options.event + Mp(b))
+                w < hs && M(_.options.event + Kw(w)), M(_.options.event), g.additionalEvent && M(g.additionalEvent), w >= hs && M(_.options.event + Kw(w))
             },
             tryEmit: function(g) {
                 if (this.canEmit()) return this.emit(g);
-                this.state = Le
+                this.state = Oi
             },
             canEmit: function() {
                 for (var g = 0; g < this.requireFail.length;) {
-                    if (!(this.requireFail[g].state & (Le | fa))) return !1;
+                    if (!(this.requireFail[g].state & (Oi | ph))) return !1;
                     g++
                 }
                 return !0
             },
             recognize: function(g) {
-                var _ = m({}, g);
-                if (!E(this.options.enable, [this, _])) {
-                    this.reset(), this.state = Le;
+                var _ = p({}, g);
+                if (!S(this.options.enable, [this, _])) {
+                    this.reset(), this.state = Oi;
                     return
                 }
-                this.state & (ar | an | Le) && (this.state = fa), this.state = this.process(_), this.state & (ae | Gi | Ir | an) && this.tryEmit(_)
+                this.state & (gn | Qc | Oi) && (this.state = ph), this.state = this.process(_), this.state & (Rr | _a | hs | Qc) && this.tryEmit(_)
             },
             process: function(g) {},
             getTouchAction: function() {},
             reset: function() {}
         };
 
-        function Mp(g) {
-            return g & an ? "cancel" : g & Ir ? "end" : g & Gi ? "move" : g & ae ? "start" : ""
+        function Kw(g) {
+            return g & Qc ? "cancel" : g & hs ? "end" : g & _a ? "move" : g & Rr ? "start" : ""
         }
 
-        function Cp(g) {
-            return g == Mr ? "down" : g == Pr ? "up" : g == vr ? "left" : g == Rr ? "right" : ""
+        function Gw(g) {
+            return g == us ? "down" : g == ls ? "up" : g == as ? "left" : g == cs ? "right" : ""
         }
 
-        function ua(g, _) {
-            var b = _.manager;
-            return b ? b.get(g) : g
+        function mh(g, _) {
+            var w = _.manager;
+            return w ? w.get(g) : g
         }
 
-        function be() {
-            cr.apply(this, arguments)
+        function Gr() {
+            _n.apply(this, arguments)
         }
-        A(be, cr, {
+        T(Gr, _n, {
             defaults: {
                 pointers: 1
             },
             attrTest: function(g) {
                 var _ = this.options.pointers;
                 return _ === 0 || g.pointers.length === _
             },
             process: function(g) {
                 var _ = this.state,
-                    b = g.eventType,
-                    P = _ & (ae | Gi),
-                    F = this.attrTest(g);
-                return P && (b & Rt || !F) ? _ | an : P || F ? b & dt ? _ | Ir : _ & ae ? _ | Gi : ae : Le
+                    w = g.eventType,
+                    M = _ & (Rr | _a),
+                    D = this.attrTest(g);
+                return M && (w & we || !D) ? _ | Qc : M || D ? w & Jt ? _ | hs : _ & Rr ? _ | _a : Rr : Oi
             }
         });
 
-        function da() {
-            be.apply(this, arguments), this.pX = null, this.pY = null
+        function gh() {
+            Gr.apply(this, arguments), this.pX = null, this.pY = null
         }
-        A(da, be, {
+        T(gh, Gr, {
             defaults: {
                 event: "pan",
                 threshold: 10,
                 pointers: 1,
-                direction: Zi
+                direction: pa
             },
             getTouchAction: function() {
                 var g = this.options.direction,
                     _ = [];
-                return g & oe && _.push(on), g & De && _.push(nn), _
+                return g & Ir && _.push(Jc), g & Pi && _.push(Gc), _
             },
             directionTest: function(g) {
                 var _ = this.options,
-                    b = !0,
-                    P = g.distance,
-                    F = g.direction,
-                    W = g.deltaX,
-                    tt = g.deltaY;
-                return F & _.direction || (_.direction & oe ? (F = W === 0 ? li : W < 0 ? vr : Rr, b = W != this.pX, P = Math.abs(g.deltaX)) : (F = tt === 0 ? li : tt < 0 ? Pr : Mr, b = tt != this.pY, P = Math.abs(g.deltaY))), g.direction = F, b && P > _.threshold && F & _.direction
+                    w = !0,
+                    M = g.distance,
+                    D = g.direction,
+                    $ = g.deltaX,
+                    At = g.deltaY;
+                return D & _.direction || (_.direction & Ir ? (D = $ === 0 ? io : $ < 0 ? as : cs, w = $ != this.pX, M = Math.abs(g.deltaX)) : (D = At === 0 ? io : At < 0 ? ls : us, w = At != this.pY, M = Math.abs(g.deltaY))), g.direction = D, w && M > _.threshold && D & _.direction
             },
             attrTest: function(g) {
-                return be.prototype.attrTest.call(this, g) && (this.state & ae || !(this.state & ae) && this.directionTest(g))
+                return Gr.prototype.attrTest.call(this, g) && (this.state & Rr || !(this.state & Rr) && this.directionTest(g))
             },
             emit: function(g) {
                 this.pX = g.deltaX, this.pY = g.deltaY;
-                var _ = Cp(g.direction);
+                var _ = Gw(g.direction);
                 _ && (g.additionalEvent = this.options.event + _), this._super.emit.call(this, g)
             }
         });
 
-        function bh() {
-            be.apply(this, arguments)
+        function f_() {
+            Gr.apply(this, arguments)
         }
-        A(bh, be, {
+        T(f_, Gr, {
             defaults: {
                 event: "pinch",
                 threshold: 0,
                 pointers: 2
             },
             getTouchAction: function() {
-                return [hi]
+                return [no]
             },
             attrTest: function(g) {
-                return this._super.attrTest.call(this, g) && (Math.abs(g.scale - 1) > this.options.threshold || this.state & ae)
+                return this._super.attrTest.call(this, g) && (Math.abs(g.scale - 1) > this.options.threshold || this.state & Rr)
             },
             emit: function(g) {
                 if (g.scale !== 1) {
                     var _ = g.scale < 1 ? "in" : "out";
                     g.additionalEvent = this.options.event + _
                 }
                 this._super.emit.call(this, g)
             }
         });
 
-        function Ah() {
-            cr.apply(this, arguments), this._timer = null, this._input = null
+        function h_() {
+            _n.apply(this, arguments), this._timer = null, this._input = null
         }
-        A(Ah, cr, {
+        T(h_, _n, {
             defaults: {
                 event: "press",
                 pointers: 1,
                 time: 251,
                 threshold: 9
             },
             getTouchAction: function() {
-                return [Pp]
+                return [Zw]
             },
             process: function(g) {
                 var _ = this.options,
-                    b = g.pointers.length === _.pointers,
-                    P = g.distance < _.threshold,
-                    F = g.deltaTime > _.time;
-                if (this._input = g, !P || !b || g.eventType & (dt | Rt) && !F) this.reset();
-                else if (g.eventType & St) this.reset(), this._timer = h(function() {
-                    this.state = ar, this.tryEmit()
+                    w = g.pointers.length === _.pointers,
+                    M = g.distance < _.threshold,
+                    D = g.deltaTime > _.time;
+                if (this._input = g, !M || !w || g.eventType & (Jt | we) && !D) this.reset();
+                else if (g.eventType & ge) this.reset(), this._timer = u(function() {
+                    this.state = gn, this.tryEmit()
                 }, _.time, this);
-                else if (g.eventType & dt) return ar;
-                return Le
+                else if (g.eventType & Jt) return gn;
+                return Oi
             },
             reset: function() {
                 clearTimeout(this._timer)
             },
             emit: function(g) {
-                this.state === ar && (g && g.eventType & dt ? this.manager.emit(this.options.event + "up", g) : (this._input.timeStamp = l(), this.manager.emit(this.options.event, this._input)))
+                this.state === gn && (g && g.eventType & Jt ? this.manager.emit(this.options.event + "up", g) : (this._input.timeStamp = l(), this.manager.emit(this.options.event, this._input)))
             }
         });
 
-        function Eh() {
-            be.apply(this, arguments)
+        function d_() {
+            Gr.apply(this, arguments)
         }
-        A(Eh, be, {
+        T(d_, Gr, {
             defaults: {
                 event: "rotate",
                 threshold: 0,
                 pointers: 2
             },
             getTouchAction: function() {
-                return [hi]
+                return [no]
             },
             attrTest: function(g) {
-                return this._super.attrTest.call(this, g) && (Math.abs(g.rotation) > this.options.threshold || this.state & ae)
+                return this._super.attrTest.call(this, g) && (Math.abs(g.rotation) > this.options.threshold || this.state & Rr)
             }
         });
 
-        function Sh() {
-            be.apply(this, arguments)
+        function p_() {
+            Gr.apply(this, arguments)
         }
-        A(Sh, be, {
+        T(p_, Gr, {
             defaults: {
                 event: "swipe",
                 threshold: 10,
                 velocity: .3,
-                direction: oe | De,
+                direction: Ir | Pi,
                 pointers: 1
             },
             getTouchAction: function() {
-                return da.prototype.getTouchAction.call(this)
+                return gh.prototype.getTouchAction.call(this)
             },
             attrTest: function(g) {
                 var _ = this.options.direction,
-                    b;
-                return _ & (oe | De) ? b = g.overallVelocity : _ & oe ? b = g.overallVelocityX : _ & De && (b = g.overallVelocityY), this._super.attrTest.call(this, g) && _ & g.offsetDirection && g.distance > this.options.threshold && g.maxPointers == this.options.pointers && c(b) > this.options.velocity && g.eventType & dt
+                    w;
+                return _ & (Ir | Pi) ? w = g.overallVelocity : _ & Ir ? w = g.overallVelocityX : _ & Pi && (w = g.overallVelocityY), this._super.attrTest.call(this, g) && _ & g.offsetDirection && g.distance > this.options.threshold && g.maxPointers == this.options.pointers && c(w) > this.options.velocity && g.eventType & Jt
             },
             emit: function(g) {
-                var _ = Cp(g.offsetDirection);
+                var _ = Gw(g.offsetDirection);
                 _ && this.manager.emit(this.options.event + _, g), this.manager.emit(this.options.event, g)
             }
         });
 
-        function pa() {
-            cr.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0
+        function _h() {
+            _n.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0
         }
-        A(pa, cr, {
+        T(_h, _n, {
             defaults: {
                 event: "tap",
                 pointers: 1,
                 taps: 1,
                 interval: 300,
                 time: 250,
                 threshold: 9,
                 posThreshold: 10
             },
             getTouchAction: function() {
-                return [xh]
+                return [l_]
             },
             process: function(g) {
                 var _ = this.options,
-                    b = g.pointers.length === _.pointers,
-                    P = g.distance < _.threshold,
-                    F = g.deltaTime < _.time;
-                if (this.reset(), g.eventType & St && this.count === 0) return this.failTimeout();
-                if (P && F && b) {
-                    if (g.eventType != dt) return this.failTimeout();
-                    var W = this.pTime ? g.timeStamp - this.pTime < _.interval : !0,
-                        tt = !this.pCenter || et(this.pCenter, g.center) < _.posThreshold;
-                    this.pTime = g.timeStamp, this.pCenter = g.center, !tt || !W ? this.count = 1 : this.count += 1, this._input = g;
-                    var wt = this.count % _.taps;
-                    if (wt === 0) return this.hasRequireFailures() ? (this._timer = h(function() {
-                        this.state = ar, this.tryEmit()
-                    }, _.interval, this), ae) : ar
+                    w = g.pointers.length === _.pointers,
+                    M = g.distance < _.threshold,
+                    D = g.deltaTime < _.time;
+                if (this.reset(), g.eventType & ge && this.count === 0) return this.failTimeout();
+                if (M && D && w) {
+                    if (g.eventType != Jt) return this.failTimeout();
+                    var $ = this.pTime ? g.timeStamp - this.pTime < _.interval : !0,
+                        At = !this.pCenter || Et(this.pCenter, g.center) < _.posThreshold;
+                    this.pTime = g.timeStamp, this.pCenter = g.center, !At || !$ ? this.count = 1 : this.count += 1, this._input = g;
+                    var _e = this.count % _.taps;
+                    if (_e === 0) return this.hasRequireFailures() ? (this._timer = u(function() {
+                        this.state = gn, this.tryEmit()
+                    }, _.interval, this), Rr) : gn
                 }
-                return Le
+                return Oi
             },
             failTimeout: function() {
-                return this._timer = h(function() {
-                    this.state = Le
-                }, this.options.interval, this), Le
+                return this._timer = u(function() {
+                    this.state = Oi
+                }, this.options.interval, this), Oi
             },
             reset: function() {
                 clearTimeout(this._timer)
             },
             emit: function() {
-                this.state == ar && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
+                this.state == gn && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
             }
         });
 
-        function Or(g, _) {
-            return _ = _ || {}, _.recognizers = R(_.recognizers, Or.defaults.preset), new wh(g, _)
+        function ds(g, _) {
+            return _ = _ || {}, _.recognizers = R(_.recognizers, ds.defaults.preset), new m_(g, _)
         }
-        Or.VERSION = "2.0.7", Or.defaults = {
+        ds.VERSION = "2.0.7", ds.defaults = {
             domEvents: !1,
-            touchAction: Rp,
+            touchAction: qw,
             enable: !0,
             inputTarget: null,
             inputClass: null,
             preset: [
-                [Eh, {
+                [d_, {
                     enable: !1
                 }],
-                [bh, {
+                [f_, {
                         enable: !1
                     },
                     ["rotate"]
                 ],
-                [Sh, {
-                    direction: oe
+                [p_, {
+                    direction: Ir
                 }],
-                [da, {
-                        direction: oe
+                [gh, {
+                        direction: Ir
                     },
                     ["swipe"]
                 ],
-                [pa],
-                [pa, {
+                [_h],
+                [_h, {
                         event: "doubletap",
                         taps: 2
                     },
                     ["tap"]
                 ],
-                [Ah]
+                [h_]
             ],
             cssProps: {
                 userSelect: "none",
                 touchSelect: "none",
                 touchCallout: "none",
                 contentZooming: "none",
                 userDrag: "none",
                 tapHighlightColor: "rgba(0,0,0,0)"
             }
         };
-        var KT = 1,
-            Ip = 2;
+        var e3 = 1,
+            Jw = 2;
 
-        function wh(g, _) {
-            this.options = m({}, Or.defaults, _ || {}), this.options.inputTarget = this.options.inputTarget || g, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = g, this.input = gh(this), this.touchAction = new Th(this, this.options.touchAction), Op(this, !0), u(this.options.recognizers, function(b) {
-                var P = this.add(new b[0](b[1]));
-                b[2] && P.recognizeWith(b[2]), b[3] && P.requireFailure(b[3])
+        function m_(g, _) {
+            this.options = p({}, ds.defaults, _ || {}), this.options.inputTarget = this.options.inputTarget || g, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = g, this.input = s_(this), this.touchAction = new u_(this, this.options.touchAction), Qw(this, !0), h(this.options.recognizers, function(w) {
+                var M = this.add(new w[0](w[1]));
+                w[2] && M.recognizeWith(w[2]), w[3] && M.requireFailure(w[3])
             }, this)
         }
-        wh.prototype = {
+        m_.prototype = {
             set: function(g) {
-                return m(this.options, g), g.touchAction && this.touchAction.update(), g.inputTarget && (this.input.destroy(), this.input.target = g.inputTarget, this.input.init()), this
+                return p(this.options, g), g.touchAction && this.touchAction.update(), g.inputTarget && (this.input.destroy(), this.input.target = g.inputTarget, this.input.init()), this
             },
             stop: function(g) {
-                this.session.stopped = g ? Ip : KT
+                this.session.stopped = g ? Jw : e3
             },
             recognize: function(g) {
                 var _ = this.session;
                 if (!_.stopped) {
                     this.touchAction.preventDefaults(g);
-                    var b, P = this.recognizers,
-                        F = _.curRecognizer;
-                    (!F || F && F.state & ar) && (F = _.curRecognizer = null);
-                    for (var W = 0; W < P.length;) b = P[W], _.stopped !== Ip && (!F || b == F || b.canRecognizeWith(F)) ? b.recognize(g) : b.reset(), !F && b.state & (ae | Gi | Ir) && (F = _.curRecognizer = b), W++
+                    var w, M = this.recognizers,
+                        D = _.curRecognizer;
+                    (!D || D && D.state & gn) && (D = _.curRecognizer = null);
+                    for (var $ = 0; $ < M.length;) w = M[$], _.stopped !== Jw && (!D || w == D || w.canRecognizeWith(D)) ? w.recognize(g) : w.reset(), !D && w.state & (Rr | _a | hs) && (D = _.curRecognizer = w), $++
                 }
             },
             get: function(g) {
-                if (g instanceof cr) return g;
-                for (var _ = this.recognizers, b = 0; b < _.length; b++)
-                    if (_[b].options.event == g) return _[b];
+                if (g instanceof _n) return g;
+                for (var _ = this.recognizers, w = 0; w < _.length; w++)
+                    if (_[w].options.event == g) return _[w];
                 return null
             },
             add: function(g) {
                 if (f(g, "add", this)) return this;
                 var _ = this.get(g.options.event);
                 return _ && this.remove(_), this.recognizers.push(g), g.manager = this, this.touchAction.update(), g
             },
             remove: function(g) {
                 if (f(g, "remove", this)) return this;
                 if (g = this.get(g), g) {
                     var _ = this.recognizers,
-                        b = N(_, g);
-                    b !== -1 && (_.splice(b, 1), this.touchAction.update())
+                        w = B(_, g);
+                    w !== -1 && (_.splice(w, 1), this.touchAction.update())
                 }
                 return this
             },
             on: function(g, _) {
                 if (g !== i && _ !== i) {
-                    var b = this.handlers;
-                    return u(k(g), function(P) {
-                        b[P] = b[P] || [], b[P].push(_)
+                    var w = this.handlers;
+                    return h(k(g), function(M) {
+                        w[M] = w[M] || [], w[M].push(_)
                     }), this
                 }
             },
             off: function(g, _) {
                 if (g !== i) {
-                    var b = this.handlers;
-                    return u(k(g), function(P) {
-                        _ ? b[P] && b[P].splice(N(b[P], _), 1) : delete b[P]
+                    var w = this.handlers;
+                    return h(k(g), function(M) {
+                        _ ? w[M] && w[M].splice(B(w[M], _), 1) : delete w[M]
                     }), this
                 }
             },
             emit: function(g, _) {
-                this.options.domEvents && QT(g, _);
-                var b = this.handlers[g] && this.handlers[g].slice();
-                if (!(!b || !b.length)) {
+                this.options.domEvents && r3(g, _);
+                var w = this.handlers[g] && this.handlers[g].slice();
+                if (!(!w || !w.length)) {
                     _.type = g, _.preventDefault = function() {
                         _.srcEvent.preventDefault()
                     };
-                    for (var P = 0; P < b.length;) b[P](_), P++
+                    for (var M = 0; M < w.length;) w[M](_), M++
                 }
             },
             destroy: function() {
-                this.element && Op(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null
+                this.element && Qw(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null
             }
         };
 
-        function Op(g, _) {
-            var b = g.element;
-            if (b.style) {
-                var P;
-                u(g.options.cssProps, function(F, W) {
-                    P = X(b.style, W), _ ? (g.oldCssProps[P] = b.style[P], b.style[P] = F) : b.style[P] = g.oldCssProps[P] || ""
+        function Qw(g, _) {
+            var w = g.element;
+            if (w.style) {
+                var M;
+                h(g.options.cssProps, function(D, $) {
+                    M = G(w.style, $), _ ? (g.oldCssProps[M] = w.style[M], w.style[M] = D) : w.style[M] = g.oldCssProps[M] || ""
                 }), _ || (g.oldCssProps = {})
             }
         }
 
-        function QT(g, _) {
-            var b = t.createEvent("Event");
-            b.initEvent(g, !0, !0), b.gesture = _, _.target.dispatchEvent(b)
-        }
-        m(Or, {
-            INPUT_START: St,
-            INPUT_MOVE: nr,
-            INPUT_END: dt,
-            INPUT_CANCEL: Rt,
-            STATE_POSSIBLE: fa,
-            STATE_BEGAN: ae,
-            STATE_CHANGED: Gi,
-            STATE_ENDED: Ir,
-            STATE_RECOGNIZED: ar,
-            STATE_CANCELLED: an,
-            STATE_FAILED: Le,
-            DIRECTION_NONE: li,
-            DIRECTION_LEFT: vr,
-            DIRECTION_RIGHT: Rr,
-            DIRECTION_UP: Pr,
-            DIRECTION_DOWN: Mr,
-            DIRECTION_HORIZONTAL: oe,
-            DIRECTION_VERTICAL: De,
-            DIRECTION_ALL: Zi,
-            Manager: wh,
-            Input: jt,
-            TouchAction: Th,
-            TouchInput: la,
-            MouseInput: Cr,
-            PointerEventInput: sn,
-            TouchMouseInput: yh,
-            SingleTouchInput: Ap,
-            Recognizer: cr,
-            AttrRecognizer: be,
-            Tap: pa,
-            Pan: da,
-            Swipe: Sh,
-            Pinch: bh,
-            Rotate: Eh,
-            Press: Ah,
-            on: M,
+        function r3(g, _) {
+            var w = t.createEvent("Event");
+            w.initEvent(g, !0, !0), w.gesture = _, _.target.dispatchEvent(w)
+        }
+        p(ds, {
+            INPUT_START: ge,
+            INPUT_MOVE: pn,
+            INPUT_END: Jt,
+            INPUT_CANCEL: we,
+            STATE_POSSIBLE: ph,
+            STATE_BEGAN: Rr,
+            STATE_CHANGED: _a,
+            STATE_ENDED: hs,
+            STATE_RECOGNIZED: gn,
+            STATE_CANCELLED: Qc,
+            STATE_FAILED: Oi,
+            DIRECTION_NONE: io,
+            DIRECTION_LEFT: as,
+            DIRECTION_RIGHT: cs,
+            DIRECTION_UP: ls,
+            DIRECTION_DOWN: us,
+            DIRECTION_HORIZONTAL: Ir,
+            DIRECTION_VERTICAL: Pi,
+            DIRECTION_ALL: pa,
+            Manager: m_,
+            Input: Ye,
+            TouchAction: u_,
+            TouchInput: hh,
+            MouseInput: fs,
+            PointerEventInput: Kc,
+            TouchMouseInput: c_,
+            SingleTouchInput: jw,
+            Recognizer: _n,
+            AttrRecognizer: Gr,
+            Tap: _h,
+            Pan: gh,
+            Swipe: p_,
+            Pinch: f_,
+            Rotate: d_,
+            Press: h_,
+            on: P,
             off: C,
-            each: u,
-            merge: x,
+            each: h,
+            merge: b,
             extend: y,
-            assign: m,
-            inherit: A,
-            bindFn: v,
-            prefixed: X
+            assign: p,
+            inherit: T,
+            bindFn: I,
+            prefixed: G
         });
-        var GT = typeof e < "u" ? e : typeof self < "u" ? self : {};
-        GT.Hammer = Or, typeof pl < "u" && pl.exports ? pl.exports = Or : e[r] = Or
+        var i3 = typeof e < "u" ? e : typeof self < "u" ? self : {};
+        i3.Hammer = ds, typeof _p < "u" && _p.exports ? _p.exports = ds : e[r] = ds
     })(window, document, "Hammer")
 });
-var Fx = Np((RX, np) => {
+var zI = tT((Zct, bx) => {
     "use strict";
-    np.exports = zl;
-    np.exports.default = zl;
+    bx.exports = Gp;
+    bx.exports.default = Gp;
 
-    function zl(e, t, r) {
+    function Gp(e, t, r) {
         r = r || 2;
         var i = t && t.length,
-            s = i ? t[0] * r : e.length,
-            n = Ix(e, 0, s, r, !0),
+            n = i ? t[0] * r : e.length,
+            s = kI(e, 0, n, r, !0),
             o = [];
-        if (!n || n.next === n.prev) return o;
-        var a, c, l, h, f, u, d;
-        if (i && (n = fM(e, t, n, r)), e.length > 80 * r) {
-            a = l = e[0], c = h = e[1];
-            for (var m = r; m < s; m += r) f = e[m], u = e[m + 1], f < a && (a = f), u < c && (c = u), f > l && (l = f), u > h && (h = u);
-            d = Math.max(l - a, h - c), d = d !== 0 ? 32767 / d : 0
-        }
-        return Yo(n, o, r, a, c, d, 0), o
+        if (!s || s.next === s.prev) return o;
+        var a, c, l, u, f, h, d;
+        if (i && (s = o4(e, t, s, r)), e.length > 80 * r) {
+            a = l = e[0], c = u = e[1];
+            for (var p = r; p < n; p += r) f = e[p], h = e[p + 1], f < a && (a = f), h < c && (c = h), f > l && (l = f), h > u && (u = h);
+            d = Math.max(l - a, u - c), d = d !== 0 ? 32767 / d : 0
+        }
+        return Xu(s, o, r, a, c, d, 0), o
     }
 
-    function Ix(e, t, r, i, s) {
-        var n, o;
-        if (s === sp(e, t, r, i) > 0)
-            for (n = t; n < r; n += i) o = Cx(n, e[n], e[n + 1], o);
+    function kI(e, t, r, i, n) {
+        var s, o;
+        if (n === yx(e, t, r, i) > 0)
+            for (s = t; s < r; s += i) o = LI(s, e[s], e[s + 1], o);
         else
-            for (n = r - i; n >= t; n -= i) o = Cx(n, e[n], e[n + 1], o);
-        return o && Wl(o, o.next) && (Zo(o), o = o.next), o
+            for (s = r - i; s >= t; s -= i) o = LI(s, e[s], e[s + 1], o);
+        return o && Jp(o, o.next) && (qu(o), o = o.next), o
     }
 
-    function $i(e, t) {
+    function Ho(e, t) {
         if (!e) return e;
         t || (t = e);
         var r = e,
             i;
         do
-            if (i = !1, !r.steiner && (Wl(r, r.next) || ut(r.prev, r, r.next) === 0)) {
-                if (Zo(r), r = t = r.prev, r === r.next) break;
+            if (i = !1, !r.steiner && (Jp(r, r.next) || Zt(r.prev, r, r.next) === 0)) {
+                if (qu(r), r = t = r.prev, r === r.next) break;
                 i = !0
             } else r = r.next; while (i || r !== t);
         return t
     }
 
-    function Yo(e, t, r, i, s, n, o) {
+    function Xu(e, t, r, i, n, s, o) {
         if (e) {
-            !o && n && mM(e, i, s, n);
+            !o && s && f4(e, i, n, s);
             for (var a = e, c, l; e.prev !== e.next;) {
-                if (c = e.prev, l = e.next, n ? cM(e, i, s, n) : aM(e)) {
-                    t.push(c.i / r | 0), t.push(e.i / r | 0), t.push(l.i / r | 0), Zo(e), e = l.next, a = l.next;
+                if (c = e.prev, l = e.next, s ? i4(e, i, n, s) : r4(e)) {
+                    t.push(c.i / r | 0), t.push(e.i / r | 0), t.push(l.i / r | 0), qu(e), e = l.next, a = l.next;
                     continue
                 }
                 if (e = l, e === a) {
-                    o ? o === 1 ? (e = lM($i(e), t, r), Yo(e, t, r, i, s, n, 2)) : o === 2 && hM(e, t, r, i, s, n) : Yo($i(e), t, r, i, s, n, 1);
+                    o ? o === 1 ? (e = n4(Ho(e), t, r), Xu(e, t, r, i, n, s, 2)) : o === 2 && s4(e, t, r, i, n, s) : Xu(Ho(e), t, r, i, n, s, 1);
                     break
                 }
             }
         }
     }
 
-    function aM(e) {
+    function r4(e) {
         var t = e.prev,
             r = e,
             i = e.next;
-        if (ut(t, r, i) >= 0) return !1;
-        for (var s = t.x, n = r.x, o = i.x, a = t.y, c = r.y, l = i.y, h = s < n ? s < o ? s : o : n < o ? n : o, f = a < c ? a < l ? a : l : c < l ? c : l, u = s > n ? s > o ? s : o : n > o ? n : o, d = a > c ? a > l ? a : l : c > l ? c : l, m = i.next; m !== t;) {
-            if (m.x >= h && m.x <= u && m.y >= f && m.y <= d && js(s, a, n, c, o, l, m.x, m.y) && ut(m.prev, m, m.next) >= 0) return !1;
-            m = m.next
+        if (Zt(t, r, i) >= 0) return !1;
+        for (var n = t.x, s = r.x, o = i.x, a = t.y, c = r.y, l = i.y, u = n < s ? n < o ? n : o : s < o ? s : o, f = a < c ? a < l ? a : l : c < l ? c : l, h = n > s ? n > o ? n : o : s > o ? s : o, d = a > c ? a > l ? a : l : c > l ? c : l, p = i.next; p !== t;) {
+            if (p.x >= u && p.x <= h && p.y >= f && p.y <= d && fc(n, a, s, c, o, l, p.x, p.y) && Zt(p.prev, p, p.next) >= 0) return !1;
+            p = p.next
         }
         return !0
     }
 
-    function cM(e, t, r, i) {
-        var s = e.prev,
-            n = e,
+    function i4(e, t, r, i) {
+        var n = e.prev,
+            s = e,
             o = e.next;
-        if (ut(s, n, o) >= 0) return !1;
-        for (var a = s.x, c = n.x, l = o.x, h = s.y, f = n.y, u = o.y, d = a < c ? a < l ? a : l : c < l ? c : l, m = h < f ? h < u ? h : u : f < u ? f : u, y = a > c ? a > l ? a : l : c > l ? c : l, x = h > f ? h > u ? h : u : f > u ? f : u, A = rp(d, m, t, r, i), v = rp(y, x, t, r, i), E = e.prevZ, R = e.nextZ; E && E.z >= A && R && R.z <= v;) {
-            if (E.x >= d && E.x <= y && E.y >= m && E.y <= x && E !== s && E !== o && js(a, h, c, f, l, u, E.x, E.y) && ut(E.prev, E, E.next) >= 0 || (E = E.prevZ, R.x >= d && R.x <= y && R.y >= m && R.y <= x && R !== s && R !== o && js(a, h, c, f, l, u, R.x, R.y) && ut(R.prev, R, R.next) >= 0)) return !1;
+        if (Zt(n, s, o) >= 0) return !1;
+        for (var a = n.x, c = s.x, l = o.x, u = n.y, f = s.y, h = o.y, d = a < c ? a < l ? a : l : c < l ? c : l, p = u < f ? u < h ? u : h : f < h ? f : h, y = a > c ? a > l ? a : l : c > l ? c : l, b = u > f ? u > h ? u : h : f > h ? f : h, T = gx(d, p, t, r, i), I = gx(y, b, t, r, i), S = e.prevZ, R = e.nextZ; S && S.z >= T && R && R.z <= I;) {
+            if (S.x >= d && S.x <= y && S.y >= p && S.y <= b && S !== n && S !== o && fc(a, u, c, f, l, h, S.x, S.y) && Zt(S.prev, S, S.next) >= 0 || (S = S.prevZ, R.x >= d && R.x <= y && R.y >= p && R.y <= b && R !== n && R !== o && fc(a, u, c, f, l, h, R.x, R.y) && Zt(R.prev, R, R.next) >= 0)) return !1;
             R = R.nextZ
         }
-        for (; E && E.z >= A;) {
-            if (E.x >= d && E.x <= y && E.y >= m && E.y <= x && E !== s && E !== o && js(a, h, c, f, l, u, E.x, E.y) && ut(E.prev, E, E.next) >= 0) return !1;
-            E = E.prevZ
+        for (; S && S.z >= T;) {
+            if (S.x >= d && S.x <= y && S.y >= p && S.y <= b && S !== n && S !== o && fc(a, u, c, f, l, h, S.x, S.y) && Zt(S.prev, S, S.next) >= 0) return !1;
+            S = S.prevZ
         }
-        for (; R && R.z <= v;) {
-            if (R.x >= d && R.x <= y && R.y >= m && R.y <= x && R !== s && R !== o && js(a, h, c, f, l, u, R.x, R.y) && ut(R.prev, R, R.next) >= 0) return !1;
+        for (; R && R.z <= I;) {
+            if (R.x >= d && R.x <= y && R.y >= p && R.y <= b && R !== n && R !== o && fc(a, u, c, f, l, h, R.x, R.y) && Zt(R.prev, R, R.next) >= 0) return !1;
             R = R.nextZ
         }
         return !0
     }
 
-    function lM(e, t, r) {
+    function n4(e, t, r) {
         var i = e;
         do {
-            var s = i.prev,
-                n = i.next.next;
-            !Wl(s, n) && Ox(s, i, i.next, n) && qo(s, n) && qo(n, s) && (t.push(s.i / r | 0), t.push(i.i / r | 0), t.push(n.i / r | 0), Zo(i), Zo(i.next), i = e = n), i = i.next
+            var n = i.prev,
+                s = i.next.next;
+            !Jp(n, s) && UI(n, i, i.next, s) && Yu(n, s) && Yu(s, n) && (t.push(n.i / r | 0), t.push(i.i / r | 0), t.push(s.i / r | 0), qu(i), qu(i.next), i = e = s), i = i.next
         } while (i !== e);
-        return $i(i)
+        return Ho(i)
     }
 
-    function hM(e, t, r, i, s, n) {
+    function s4(e, t, r, i, n, s) {
         var o = e;
         do {
             for (var a = o.next.next; a !== o.prev;) {
-                if (o.i !== a.i && xM(o, a)) {
-                    var c = Nx(o, a);
-                    o = $i(o, o.next), c = $i(c, c.next), Yo(o, t, r, i, s, n, 0), Yo(c, t, r, i, s, n, 0);
+                if (o.i !== a.i && p4(o, a)) {
+                    var c = VI(o, a);
+                    o = Ho(o, o.next), c = Ho(c, c.next), Xu(o, t, r, i, n, s, 0), Xu(c, t, r, i, n, s, 0);
                     return
                 }
                 a = a.next
             }
             o = o.next
         } while (o !== e)
     }
 
-    function fM(e, t, r, i) {
-        var s = [],
-            n, o, a, c, l;
-        for (n = 0, o = t.length; n < o; n++) a = t[n] * i, c = n < o - 1 ? t[n + 1] * i : e.length, l = Ix(e, a, c, i, !1), l === l.next && (l.steiner = !0), s.push(yM(l));
-        for (s.sort(uM), n = 0; n < s.length; n++) r = dM(s[n], r);
+    function o4(e, t, r, i) {
+        var n = [],
+            s, o, a, c, l;
+        for (s = 0, o = t.length; s < o; s++) a = t[s] * i, c = s < o - 1 ? t[s + 1] * i : e.length, l = kI(e, a, c, i, !1), l === l.next && (l.steiner = !0), n.push(d4(l));
+        for (n.sort(a4), s = 0; s < n.length; s++) r = c4(n[s], r);
         return r
     }
 
-    function uM(e, t) {
+    function a4(e, t) {
         return e.x - t.x
     }
 
-    function dM(e, t) {
-        var r = pM(e, t);
+    function c4(e, t) {
+        var r = l4(e, t);
         if (!r) return t;
-        var i = Nx(r, e);
-        return $i(i, i.next), $i(r, r.next)
+        var i = VI(r, e);
+        return Ho(i, i.next), Ho(r, r.next)
     }
 
-    function pM(e, t) {
+    function l4(e, t) {
         var r = t,
             i = e.x,
-            s = e.y,
-            n = -1 / 0,
+            n = e.y,
+            s = -1 / 0,
             o;
         do {
-            if (s <= r.y && s >= r.next.y && r.next.y !== r.y) {
-                var a = r.x + (s - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
-                if (a <= i && a > n && (n = a, o = r.x < r.next.x ? r : r.next, a === i)) return o
+            if (n <= r.y && n >= r.next.y && r.next.y !== r.y) {
+                var a = r.x + (n - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
+                if (a <= i && a > s && (s = a, o = r.x < r.next.x ? r : r.next, a === i)) return o
             }
             r = r.next
         } while (r !== t);
         if (!o) return null;
         var c = o,
             l = o.x,
-            h = o.y,
+            u = o.y,
             f = 1 / 0,
-            u;
+            h;
         r = o;
-        do i >= r.x && r.x >= l && i !== r.x && js(s < h ? i : n, s, l, h, s < h ? n : i, s, r.x, r.y) && (u = Math.abs(s - r.y) / (i - r.x), qo(r, e) && (u < f || u === f && (r.x > o.x || r.x === o.x && gM(o, r))) && (o = r, f = u)), r = r.next; while (r !== c);
+        do i >= r.x && r.x >= l && i !== r.x && fc(n < u ? i : s, n, l, u, n < u ? s : i, n, r.x, r.y) && (h = Math.abs(n - r.y) / (i - r.x), Yu(r, e) && (h < f || h === f && (r.x > o.x || r.x === o.x && u4(o, r))) && (o = r, f = h)), r = r.next; while (r !== c);
         return o
     }
 
-    function gM(e, t) {
-        return ut(e.prev, e, t.prev) < 0 && ut(t.next, e, e.next) < 0
+    function u4(e, t) {
+        return Zt(e.prev, e, t.prev) < 0 && Zt(t.next, e, e.next) < 0
     }
 
-    function mM(e, t, r, i) {
-        var s = e;
-        do s.z === 0 && (s.z = rp(s.x, s.y, t, r, i)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next; while (s !== e);
-        s.prevZ.nextZ = null, s.prevZ = null, _M(s)
+    function f4(e, t, r, i) {
+        var n = e;
+        do n.z === 0 && (n.z = gx(n.x, n.y, t, r, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next; while (n !== e);
+        n.prevZ.nextZ = null, n.prevZ = null, h4(n)
     }
 
-    function _M(e) {
-        var t, r, i, s, n, o, a, c, l = 1;
+    function h4(e) {
+        var t, r, i, n, s, o, a, c, l = 1;
         do {
-            for (r = e, e = null, n = null, o = 0; r;) {
+            for (r = e, e = null, s = null, o = 0; r;) {
                 for (o++, i = r, a = 0, t = 0; t < l && (a++, i = i.nextZ, !!i); t++);
-                for (c = l; a > 0 || c > 0 && i;) a !== 0 && (c === 0 || !i || r.z <= i.z) ? (s = r, r = r.nextZ, a--) : (s = i, i = i.nextZ, c--), n ? n.nextZ = s : e = s, s.prevZ = n, n = s;
+                for (c = l; a > 0 || c > 0 && i;) a !== 0 && (c === 0 || !i || r.z <= i.z) ? (n = r, r = r.nextZ, a--) : (n = i, i = i.nextZ, c--), s ? s.nextZ = n : e = n, n.prevZ = s, s = n;
                 r = i
             }
-            n.nextZ = null, l *= 2
+            s.nextZ = null, l *= 2
         } while (o > 1);
         return e
     }
 
-    function rp(e, t, r, i, s) {
-        return e = (e - r) * s | 0, t = (t - i) * s | 0, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e | t << 1
+    function gx(e, t, r, i, n) {
+        return e = (e - r) * n | 0, t = (t - i) * n | 0, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e | t << 1
     }
 
-    function yM(e) {
+    function d4(e) {
         var t = e,
             r = e;
         do(t.x < r.x || t.x === r.x && t.y < r.y) && (r = t), t = t.next; while (t !== e);
         return r
     }
 
-    function js(e, t, r, i, s, n, o, a) {
-        return (s - o) * (t - a) >= (e - o) * (n - a) && (e - o) * (i - a) >= (r - o) * (t - a) && (r - o) * (n - a) >= (s - o) * (i - a)
+    function fc(e, t, r, i, n, s, o, a) {
+        return (n - o) * (t - a) >= (e - o) * (s - a) && (e - o) * (i - a) >= (r - o) * (t - a) && (r - o) * (s - a) >= (n - o) * (i - a)
     }
 
-    function xM(e, t) {
-        return e.next.i !== t.i && e.prev.i !== t.i && !TM(e, t) && (qo(e, t) && qo(t, e) && bM(e, t) && (ut(e.prev, e, t.prev) || ut(e, t.prev, t)) || Wl(e, t) && ut(e.prev, e, e.next) > 0 && ut(t.prev, t, t.next) > 0)
+    function p4(e, t) {
+        return e.next.i !== t.i && e.prev.i !== t.i && !m4(e, t) && (Yu(e, t) && Yu(t, e) && g4(e, t) && (Zt(e.prev, e, t.prev) || Zt(e, t.prev, t)) || Jp(e, t) && Zt(e.prev, e, e.next) > 0 && Zt(t.prev, t, t.next) > 0)
     }
 
-    function ut(e, t, r) {
+    function Zt(e, t, r) {
         return (t.y - e.y) * (r.x - t.x) - (t.x - e.x) * (r.y - t.y)
     }
 
-    function Wl(e, t) {
+    function Jp(e, t) {
         return e.x === t.x && e.y === t.y
     }
 
-    function Ox(e, t, r, i) {
-        var s = Vl(ut(e, t, r)),
-            n = Vl(ut(e, t, i)),
-            o = Vl(ut(r, i, e)),
-            a = Vl(ut(r, i, t));
-        return !!(s !== n && o !== a || s === 0 && Ul(e, r, t) || n === 0 && Ul(e, i, t) || o === 0 && Ul(r, e, i) || a === 0 && Ul(r, t, i))
+    function UI(e, t, r, i) {
+        var n = Kp(Zt(e, t, r)),
+            s = Kp(Zt(e, t, i)),
+            o = Kp(Zt(r, i, e)),
+            a = Kp(Zt(r, i, t));
+        return !!(n !== s && o !== a || n === 0 && Zp(e, r, t) || s === 0 && Zp(e, i, t) || o === 0 && Zp(r, e, i) || a === 0 && Zp(r, t, i))
     }
 
-    function Ul(e, t, r) {
+    function Zp(e, t, r) {
         return t.x <= Math.max(e.x, r.x) && t.x >= Math.min(e.x, r.x) && t.y <= Math.max(e.y, r.y) && t.y >= Math.min(e.y, r.y)
     }
 
-    function Vl(e) {
+    function Kp(e) {
         return e > 0 ? 1 : e < 0 ? -1 : 0
     }
 
-    function TM(e, t) {
+    function m4(e, t) {
         var r = e;
         do {
-            if (r.i !== e.i && r.next.i !== e.i && r.i !== t.i && r.next.i !== t.i && Ox(r, r.next, e, t)) return !0;
+            if (r.i !== e.i && r.next.i !== e.i && r.i !== t.i && r.next.i !== t.i && UI(r, r.next, e, t)) return !0;
             r = r.next
         } while (r !== e);
         return !1
     }
 
-    function qo(e, t) {
-        return ut(e.prev, e, e.next) < 0 ? ut(e, t, e.next) >= 0 && ut(e, e.prev, t) >= 0 : ut(e, t, e.prev) < 0 || ut(e, e.next, t) < 0
+    function Yu(e, t) {
+        return Zt(e.prev, e, e.next) < 0 ? Zt(e, t, e.next) >= 0 && Zt(e, e.prev, t) >= 0 : Zt(e, t, e.prev) < 0 || Zt(e, e.next, t) < 0
     }
 
-    function bM(e, t) {
+    function g4(e, t) {
         var r = e,
             i = !1,
-            s = (e.x + t.x) / 2,
-            n = (e.y + t.y) / 2;
-        do r.y > n != r.next.y > n && r.next.y !== r.y && s < (r.next.x - r.x) * (n - r.y) / (r.next.y - r.y) + r.x && (i = !i), r = r.next; while (r !== e);
+            n = (e.x + t.x) / 2,
+            s = (e.y + t.y) / 2;
+        do r.y > s != r.next.y > s && r.next.y !== r.y && n < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (i = !i), r = r.next; while (r !== e);
         return i
     }
 
-    function Nx(e, t) {
-        var r = new ip(e.i, e.x, e.y),
-            i = new ip(t.i, t.x, t.y),
-            s = e.next,
-            n = t.prev;
-        return e.next = t, t.prev = e, r.next = s, s.prev = r, i.next = r, r.prev = i, n.next = i, i.prev = n, i
+    function VI(e, t) {
+        var r = new _x(e.i, e.x, e.y),
+            i = new _x(t.i, t.x, t.y),
+            n = e.next,
+            s = t.prev;
+        return e.next = t, t.prev = e, r.next = n, n.prev = r, i.next = r, r.prev = i, s.next = i, i.prev = s, i
     }
 
-    function Cx(e, t, r, i) {
-        var s = new ip(e, t, r);
-        return i ? (s.next = i.next, s.prev = i, i.next.prev = s, i.next = s) : (s.prev = s, s.next = s), s
+    function LI(e, t, r, i) {
+        var n = new _x(e, t, r);
+        return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n
     }
 
-    function Zo(e) {
+    function qu(e) {
         e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
     }
 
-    function ip(e, t, r) {
+    function _x(e, t, r) {
         this.i = e, this.x = t, this.y = r, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
     }
-    zl.deviation = function(e, t, r, i) {
-        var s = t && t.length,
-            n = s ? t[0] * r : e.length,
-            o = Math.abs(sp(e, 0, n, r));
-        if (s)
+    Gp.deviation = function(e, t, r, i) {
+        var n = t && t.length,
+            s = n ? t[0] * r : e.length,
+            o = Math.abs(yx(e, 0, s, r));
+        if (n)
             for (var a = 0, c = t.length; a < c; a++) {
                 var l = t[a] * r,
-                    h = a < c - 1 ? t[a + 1] * r : e.length;
-                o -= Math.abs(sp(e, l, h, r))
+                    u = a < c - 1 ? t[a + 1] * r : e.length;
+                o -= Math.abs(yx(e, l, u, r))
             }
         var f = 0;
         for (a = 0; a < i.length; a += 3) {
-            var u = i[a] * r,
+            var h = i[a] * r,
                 d = i[a + 1] * r,
-                m = i[a + 2] * r;
-            f += Math.abs((e[u] - e[m]) * (e[d + 1] - e[u + 1]) - (e[u] - e[d]) * (e[m + 1] - e[u + 1]))
+                p = i[a + 2] * r;
+            f += Math.abs((e[h] - e[p]) * (e[d + 1] - e[h + 1]) - (e[h] - e[d]) * (e[p + 1] - e[h + 1]))
         }
         return o === 0 && f === 0 ? 0 : Math.abs((f - o) / o)
     };
 
-    function sp(e, t, r, i) {
-        for (var s = 0, n = t, o = r - i; n < r; n += i) s += (e[o] - e[n]) * (e[n + 1] + e[o + 1]), o = n;
-        return s
+    function yx(e, t, r, i) {
+        for (var n = 0, s = t, o = r - i; s < r; s += i) n += (e[o] - e[s]) * (e[s + 1] + e[o + 1]), o = s;
+        return n
     }
-    zl.flatten = function(e) {
+    Gp.flatten = function(e) {
         for (var t = e[0][0].length, r = {
                 vertices: [],
                 holes: [],
                 dimensions: t
-            }, i = 0, s = 0; s < e.length; s++) {
-            for (var n = 0; n < e[s].length; n++)
-                for (var o = 0; o < t; o++) r.vertices.push(e[s][n][o]);
-            s > 0 && (i += e[s - 1].length, r.holes.push(i))
+            }, i = 0, n = 0; n < e.length; n++) {
+            for (var s = 0; s < e[n].length; s++)
+                for (var o = 0; o < t; o++) r.vertices.push(e[n][s][o]);
+            n > 0 && (i += e[n - 1].length, r.holes.push(i))
         }
         return r
     }
 });
 
-function Nr(e, t) {
+function ps(e, t) {
     if (!e) throw new Error(t || "loader assertion failed.")
 }
-var Ue = {
+var Bi = {
         self: typeof self < "u" && self,
         window: typeof window < "u" && window,
         global: typeof global < "u" && global,
         document: typeof document < "u" && document
     },
-    ob = Ue.self || Ue.window || Ue.global || {},
-    ab = Ue.window || Ue.self || Ue.global || {},
-    cb = Ue.global || Ue.self || Ue.window || {},
-    lb = Ue.document || {};
-var fi = !!(typeof process != "object" || String(process) !== "[object process]" || process.browser);
-var Dp = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version),
-    hb = Dp && parseFloat(Dp[1]) || 0;
+    f3 = Bi.self || Bi.window || Bi.global || {},
+    h3 = Bi.window || Bi.self || Bi.global || {},
+    d3 = Bi.global || Bi.self || Bi.window || {},
+    p3 = Bi.document || {};
+var so = !!(typeof process != "object" || String(process) !== "[object process]" || process.browser);
+var rT = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version),
+    m3 = rT && parseFloat(rT[1]) || 0;
 
-function vh(e, t) {
-    return kp(e || {}, t)
+function g_(e, t) {
+    return iT(e || {}, t)
 }
 
-function kp(e, t) {
+function iT(e, t) {
     let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
     if (r > 3) return t;
     let i = {
         ...e
     };
-    for (let [s, n] of Object.entries(t)) n && typeof n == "object" && !Array.isArray(n) ? i[s] = kp(i[s] || {}, t[s], r + 1) : i[s] = t[s];
+    for (let [n, s] of Object.entries(t)) s && typeof s == "object" && !Array.isArray(s) ? i[n] = iT(i[n] || {}, t[n], r + 1) : i[n] = t[n];
     return i
 }
-var Lp = "latest";
+var nT = "latest";
 
-function fb() {
+function g3() {
     var e;
     return (e = globalThis._loadersgl_) !== null && e !== void 0 && e.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = "4.1.4"), globalThis._loadersgl_.version
 }
-var Rh = fb();
+var __ = g3();
 
-function kt(e, t) {
+function Fe(e, t) {
     if (!e) throw new Error(t || "loaders.gl assertion failed.")
 }
-var Ve = {
+var Fi = {
         self: typeof self < "u" && self,
         window: typeof window < "u" && window,
         global: typeof global < "u" && global,
         document: typeof document < "u" && document
     },
-    DC = Ve.self || Ve.window || Ve.global || {},
-    kC = Ve.window || Ve.self || Ve.global || {},
-    LC = Ve.global || Ve.self || Ve.window || {},
-    BC = Ve.document || {};
-var ce = typeof process != "object" || String(process) !== "[object process]" || process.browser;
-var Up = typeof window < "u" && typeof window.orientation < "u",
-    Bp = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version),
-    UC = Bp && parseFloat(Bp[1]) || 0;
-var cn = class {
+    pz = Fi.self || Fi.window || Fi.global || {},
+    mz = Fi.window || Fi.self || Fi.global || {},
+    gz = Fi.global || Fi.self || Fi.window || {},
+    _z = Fi.document || {};
+var Mr = typeof process != "object" || String(process) !== "[object process]" || process.browser;
+var oT = typeof window < "u" && typeof window.orientation < "u",
+    sT = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version),
+    yz = sT && parseFloat(sT[1]) || 0;
+var tl = class {
     constructor(t, r) {
-        this.name = void 0, this.workerThread = void 0, this.isRunning = !0, this.result = void 0, this._resolve = () => {}, this._reject = () => {}, this.name = t, this.workerThread = r, this.result = new Promise((i, s) => {
-            this._resolve = i, this._reject = s
+        this.name = void 0, this.workerThread = void 0, this.isRunning = !0, this.result = void 0, this._resolve = () => {}, this._reject = () => {}, this.name = t, this.workerThread = r, this.result = new Promise((i, n) => {
+            this._resolve = i, this._reject = n
         })
     }
     postMessage(t, r) {
         this.workerThread.postMessage({
             source: "loaders.gl",
             type: t,
             payload: r
         })
     }
     done(t) {
-        kt(this.isRunning), this.isRunning = !1, this._resolve(t)
+        Fe(this.isRunning), this.isRunning = !1, this._resolve(t)
     }
     error(t) {
-        kt(this.isRunning), this.isRunning = !1, this._reject(t)
+        Fe(this.isRunning), this.isRunning = !1, this._reject(t)
     }
 };
-var ts = class {
+var ya = class {
     terminate() {}
 };
-var Ph = new Map;
+var y_ = new Map;
 
-function Vp(e) {
-    kt(e.source && !e.url || !e.source && e.url);
-    let t = Ph.get(e.source || e.url);
-    return t || (e.url && (t = ub(e.url), Ph.set(e.url, t)), e.source && (t = zp(e.source), Ph.set(e.source, t))), kt(t), t
+function aT(e) {
+    Fe(e.source && !e.url || !e.source && e.url);
+    let t = y_.get(e.source || e.url);
+    return t || (e.url && (t = _3(e.url), y_.set(e.url, t)), e.source && (t = cT(e.source), y_.set(e.source, t))), Fe(t), t
 }
 
-function ub(e) {
+function _3(e) {
     if (!e.startsWith("http")) return e;
-    let t = db(e);
-    return zp(t)
+    let t = y3(e);
+    return cT(t)
 }
 
-function zp(e) {
+function cT(e) {
     let t = new Blob([e], {
         type: "application/javascript"
     });
     return URL.createObjectURL(t)
 }
 
-function db(e) {
+function y3(e) {
     return `try {
   importScripts('${e}');
 } catch (error) {
   console.error(error);
   throw error;
 }`
 }
 
-function Mh(e) {
+function b_(e) {
     let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0,
         r = arguments.length > 2 ? arguments[2] : void 0,
         i = r || new Set;
     if (e) {
-        if (Wp(e)) i.add(e);
-        else if (Wp(e.buffer)) i.add(e.buffer);
+        if (lT(e)) i.add(e);
+        else if (lT(e.buffer)) i.add(e.buffer);
         else if (!ArrayBuffer.isView(e)) {
             if (t && typeof e == "object")
-                for (let s in e) Mh(e[s], t, i)
+                for (let n in e) b_(e[n], t, i)
         }
     }
     return r === void 0 ? Array.from(i) : []
 }
 
-function Wp(e) {
+function lT(e) {
     return e ? e instanceof ArrayBuffer || typeof MessagePort < "u" && e instanceof MessagePort || typeof ImageBitmap < "u" && e instanceof ImageBitmap || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas : !1
 }
-var Ch = () => {},
-    Fr = class {
+var x_ = () => {},
+    ms = class {
         static isSupported() {
-            return typeof Worker < "u" && ce || typeof ts < "u" && !ce
+            return typeof Worker < "u" && Mr || typeof ya < "u" && !Mr
         }
         constructor(t) {
             this.name = void 0, this.source = void 0, this.url = void 0, this.terminated = !1, this.worker = void 0, this.onMessage = void 0, this.onError = void 0, this._loadableURL = "";
             let {
                 name: r,
                 source: i,
-                url: s
+                url: n
             } = t;
-            kt(i || s), this.name = r, this.source = i, this.url = s, this.onMessage = Ch, this.onError = n => console.log(n), this.worker = ce ? this._createBrowserWorker() : this._createNodeWorker()
+            Fe(i || n), this.name = r, this.source = i, this.url = n, this.onMessage = x_, this.onError = s => console.log(s), this.worker = Mr ? this._createBrowserWorker() : this._createNodeWorker()
         }
         destroy() {
-            this.onMessage = Ch, this.onError = Ch, this.worker.terminate(), this.terminated = !0
+            this.onMessage = x_, this.onError = x_, this.worker.terminate(), this.terminated = !0
         }
         get isRunning() {
             return !!this.onMessage
         }
         postMessage(t, r) {
-            r = r || Mh(t), this.worker.postMessage(t, r)
+            r = r || b_(t), this.worker.postMessage(t, r)
         }
         _getErrorFromErrorEvent(t) {
             let r = "Failed to load ";
             return r += `worker ${this.name} from ${this.url}. `, t.message && (r += `${t.message} in `), t.lineno && (r += `:${t.lineno}:${t.colno}`), new Error(r)
         }
         _createBrowserWorker() {
-            this._loadableURL = Vp({
+            this._loadableURL = aT({
                 source: this.source,
                 url: this.url
             });
             let t = new Worker(this._loadableURL, {
                 name: this.name
             });
             return t.onmessage = r => {
@@ -1523,115 +1523,115 @@
                 this.onError(this._getErrorFromErrorEvent(r)), this.terminated = !0
             }, t.onmessageerror = r => console.error(r), t
         }
         _createNodeWorker() {
             let t;
             if (this.url) {
                 let i = this.url.includes(":/") || this.url.startsWith("/") ? this.url : `./${this.url}`;
-                t = new ts(i, {
+                t = new ya(i, {
                     eval: !1
                 })
-            } else if (this.source) t = new ts(this.source, {
+            } else if (this.source) t = new ya(this.source, {
                 eval: !0
             });
             else throw new Error("no worker");
             return t.on("message", r => {
                 this.onMessage(r)
             }), t.on("error", r => {
                 this.onError(r)
             }), t.on("exit", r => {}), t
         }
     };
-var ln = class {
+var el = class {
     static isSupported() {
-        return Fr.isSupported()
+        return ms.isSupported()
     }
     constructor(t) {
         this.name = "unnamed", this.source = void 0, this.url = void 0, this.maxConcurrency = 1, this.maxMobileConcurrency = 1, this.onDebug = () => {}, this.reuseWorkers = !0, this.props = {}, this.jobQueue = [], this.idleQueue = [], this.count = 0, this.isDestroyed = !1, this.source = t.source, this.url = t.url, this.setProps(t)
     }
     destroy() {
         this.idleQueue.forEach(t => t.destroy()), this.isDestroyed = !0
     }
     setProps(t) {
         this.props = {
             ...this.props,
             ...t
         }, t.name !== void 0 && (this.name = t.name), t.maxConcurrency !== void 0 && (this.maxConcurrency = t.maxConcurrency), t.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = t.maxMobileConcurrency), t.reuseWorkers !== void 0 && (this.reuseWorkers = t.reuseWorkers), t.onDebug !== void 0 && (this.onDebug = t.onDebug)
     }
     async startJob(t) {
-        let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (n, o, a) => n.done(a),
-            i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (n, o) => n.error(o),
-            s = new Promise(n => (this.jobQueue.push({
+        let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (s, o, a) => s.done(a),
+            i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (s, o) => s.error(o),
+            n = new Promise(s => (this.jobQueue.push({
                 name: t,
                 onMessage: r,
                 onError: i,
-                onStart: n
+                onStart: s
             }), this));
-        return this._startQueuedJob(), await s
+        return this._startQueuedJob(), await n
     }
     async _startQueuedJob() {
         if (!this.jobQueue.length) return;
         let t = this._getAvailableWorker();
         if (!t) return;
         let r = this.jobQueue.shift();
         if (r) {
             this.onDebug({
                 message: "Starting job",
                 name: r.name,
                 workerThread: t,
                 backlog: this.jobQueue.length
             });
-            let i = new cn(r.name, t);
-            t.onMessage = s => r.onMessage(i, s.type, s.payload), t.onError = s => r.onError(i, s), r.onStart(i);
+            let i = new tl(r.name, t);
+            t.onMessage = n => r.onMessage(i, n.type, n.payload), t.onError = n => r.onError(i, n), r.onStart(i);
             try {
                 await i.result
-            } catch (s) {
-                console.error(`Worker exception: ${s}`)
+            } catch (n) {
+                console.error(`Worker exception: ${n}`)
             } finally {
                 this.returnWorkerToQueue(t)
             }
         }
     }
     returnWorkerToQueue(t) {
-        !ce || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (t.destroy(), this.count--) : this.idleQueue.push(t), this.isDestroyed || this._startQueuedJob()
+        !Mr || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (t.destroy(), this.count--) : this.idleQueue.push(t), this.isDestroyed || this._startQueuedJob()
     }
     _getAvailableWorker() {
         if (this.idleQueue.length > 0) return this.idleQueue.shift() || null;
         if (this.count < this._getMaxConcurrency()) {
             this.count++;
             let t = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
-            return new Fr({
+            return new ms({
                 name: t,
                 source: this.source,
                 url: this.url
             })
         }
         return null
     }
     _getMaxConcurrency() {
-        return Up ? this.maxMobileConcurrency : this.maxConcurrency
+        return oT ? this.maxMobileConcurrency : this.maxConcurrency
     }
 };
-var pb = {
+var b3 = {
         maxConcurrency: 3,
         maxMobileConcurrency: 1,
         reuseWorkers: !0,
         onDebug: () => {}
     },
-    Dr = class e {
+    gs = class e {
         static isSupported() {
-            return Fr.isSupported()
+            return ms.isSupported()
         }
         static getWorkerFarm() {
             let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
             return e._workerFarm = e._workerFarm || new e({}), e._workerFarm.setProps(t), e._workerFarm
         }
         constructor(t) {
             this.props = void 0, this.workerPools = new Map, this.props = {
-                ...pb
+                ...b3
             }, this.setProps(t), this.workerPools = new Map
         }
         destroy() {
             for (let t of this.workerPools.values()) t.destroy();
             this.workerPools = new Map
         }
         setProps(t) {
@@ -1641,141 +1641,141 @@
             };
             for (let r of this.workerPools.values()) r.setProps(this._getWorkerPoolProps())
         }
         getWorkerPool(t) {
             let {
                 name: r,
                 source: i,
-                url: s
-            } = t, n = this.workerPools.get(r);
-            return n || (n = new ln({
+                url: n
+            } = t, s = this.workerPools.get(r);
+            return s || (s = new el({
                 name: r,
                 source: i,
-                url: s
-            }), n.setProps(this._getWorkerPoolProps()), this.workerPools.set(r, n)), n
+                url: n
+            }), s.setProps(this._getWorkerPoolProps()), this.workerPools.set(r, s)), s
         }
         _getWorkerPoolProps() {
             return {
                 maxConcurrency: this.props.maxConcurrency,
                 maxMobileConcurrency: this.props.maxMobileConcurrency,
                 reuseWorkers: this.props.reuseWorkers,
                 onDebug: this.props.onDebug
             }
         }
     };
-Dr._workerFarm = void 0;
+gs._workerFarm = void 0;
 
-function Ih(e) {
+function w_(e) {
     let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
         r = t[e.id] || {},
-        i = ce ? `${e.id}-worker.js` : `${e.id}-worker-node.js`,
-        s = r.workerUrl;
-    if (!s && e.id === "compression" && (s = t.workerUrl), t._workerType === "test" && (ce ? s = `modules/${e.module}/dist/${i}` : s = `modules/${e.module}/src/workers/${e.id}-worker-node.ts`), !s) {
-        let n = e.version;
-        n === "latest" && (n = Lp);
-        let o = n ? `@${n}` : "";
-        s = `https://unpkg.com/@loaders.gl/${e.module}${o}/dist/${i}`
+        i = Mr ? `${e.id}-worker.js` : `${e.id}-worker-node.js`,
+        n = r.workerUrl;
+    if (!n && e.id === "compression" && (n = t.workerUrl), t._workerType === "test" && (Mr ? n = `modules/${e.module}/dist/${i}` : n = `modules/${e.module}/src/workers/${e.id}-worker-node.ts`), !n) {
+        let s = e.version;
+        s === "latest" && (s = nT);
+        let o = s ? `@${s}` : "";
+        n = `https://unpkg.com/@loaders.gl/${e.module}${o}/dist/${i}`
     }
-    return kt(s), s
+    return Fe(n), n
 }
 
-function Oh(e) {
-    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Rh;
-    kt(e, "no worker provided");
+function T_(e) {
+    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : __;
+    Fe(e, "no worker provided");
     let r = e.version;
     return !(!t || !r)
 }
 
-function Nh(e, t) {
-    return !Dr.isSupported() || !ce && !(t != null && t._nodeWorkers) ? !1 : e.worker && t?.worker
+function v_(e, t) {
+    return !gs.isSupported() || !Mr && !(t != null && t._nodeWorkers) ? !1 : e.worker && t?.worker
 }
-async function Fh(e, t, r, i, s) {
-    let n = e.id,
-        o = Ih(e, r),
-        c = Dr.getWorkerFarm(r).getWorkerPool({
-            name: n,
+async function S_(e, t, r, i, n) {
+    let s = e.id,
+        o = w_(e, r),
+        c = gs.getWorkerFarm(r).getWorkerPool({
+            name: s,
             url: o
         });
     r = JSON.parse(JSON.stringify(r)), i = JSON.parse(JSON.stringify(i || {}));
-    let l = await c.startJob("process-on-worker", gb.bind(null, s));
+    let l = await c.startJob("process-on-worker", x3.bind(null, n));
     return l.postMessage("process", {
         input: t,
         options: r,
         context: i
     }), await (await l.result).result
 }
-async function gb(e, t, r, i) {
+async function x3(e, t, r, i) {
     switch (r) {
         case "done":
             t.done(i);
             break;
         case "error":
             t.error(new Error(i.error));
             break;
         case "process":
             let {
-                id: s, input: n, options: o
+                id: n, input: s, options: o
             } = i;
             try {
-                let a = await e(n, o);
+                let a = await e(s, o);
                 t.postMessage("done", {
-                    id: s,
+                    id: n,
                     result: a
                 })
             } catch (a) {
                 let c = a instanceof Error ? a.message : "unknown error";
                 t.postMessage("error", {
-                    id: s,
+                    id: n,
                     error: c
                 })
             }
             break;
         default:
             console.warn(`parse-with-worker unknown message ${r}`)
     }
 }
 
-function Dh(e, t, r) {
+function A_(e, t, r) {
     if (r = r || e.byteLength, e.byteLength < r || t.byteLength < r) return !1;
     let i = new Uint8Array(e),
-        s = new Uint8Array(t);
-    for (let n = 0; n < i.length; ++n)
-        if (i[n] !== s[n]) return !1;
+        n = new Uint8Array(t);
+    for (let s = 0; s < i.length; ++s)
+        if (i[s] !== n[s]) return !1;
     return !0
 }
 
-function kh() {
+function E_() {
     for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
-    return jp(t)
+    return uT(t)
 }
 
-function jp(e) {
-    let t = e.map(n => n instanceof ArrayBuffer ? new Uint8Array(n) : n),
-        r = t.reduce((n, o) => n + o.byteLength, 0),
+function uT(e) {
+    let t = e.map(s => s instanceof ArrayBuffer ? new Uint8Array(s) : s),
+        r = t.reduce((s, o) => s + o.byteLength, 0),
         i = new Uint8Array(r),
-        s = 0;
-    for (let n of t) i.set(n, s), s += n.byteLength;
+        n = 0;
+    for (let s of t) i.set(s, n), n += s.byteLength;
     return i.buffer
 }
-async function Lh(e) {
+async function I_(e) {
     let t = [];
     for await (let r of e) t.push(r);
-    return kh(...t)
+    return E_(...t)
 }
 
-function hn() {
+function rl() {
     let e;
     if (typeof window < "u" && window.performance) e = window.performance.now();
     else if (typeof process < "u" && process.hrtime) {
         let t = process.hrtime();
         e = t[0] * 1e3 + t[1] / 1e6
     } else e = Date.now();
     return e
 }
-var ui = class {
+var oo = class {
     constructor(t, r) {
         this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this.name = t, this.type = r, this.reset()
     }
     reset() {
         return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this
     }
     setSampleSize(t) {
@@ -1793,18 +1793,18 @@
     subtractCount(t) {
         return this._count -= t, this._samples++, this._checkSampling(), this
     }
     addTime(t) {
         return this._time += t, this.lastTiming = t, this._samples++, this._checkSampling(), this
     }
     timeStart() {
-        return this._startTime = hn(), this._timerPending = !0, this
+        return this._startTime = rl(), this._timerPending = !0, this
     }
     timeEnd() {
-        return this._timerPending ? (this.addTime(hn() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this
+        return this._timerPending ? (this.addTime(rl() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this
     }
     getSampleAverageCount() {
         return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0
     }
     getSampleAverageTime() {
         return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0
     }
@@ -1820,15 +1820,15 @@
     getHz() {
         return this.time > 0 ? this.samples / (this.time / 1e3) : 0
     }
     _checkSampling() {
         this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0)
     }
 };
-var Xt = class {
+var Ke = class {
     constructor(t) {
         this.stats = {}, this.id = t.id, this.stats = {}, this._initializeStats(t.stats), Object.seal(this)
     }
     get(t, r = "count") {
         return this._getOrCreate({
             name: t,
             type: r
@@ -1858,64 +1858,64 @@
     _initializeStats(t = []) {
         t.forEach(r => this._getOrCreate(r))
     }
     _getOrCreate(t) {
         let {
             name: r,
             type: i
-        } = t, s = this.stats[r];
-        return s || (t instanceof ui ? s = t : s = new ui(r, i), this.stats[r] = s), s
+        } = t, n = this.stats[r];
+        return n || (t instanceof oo ? n = t : n = new oo(r, i), this.stats[r] = n), n
     }
 };
-var mb = "Queued Requests",
-    _b = "Active Requests",
-    yb = "Cancelled Requests",
-    xb = "Queued Requests Ever",
-    Tb = "Active Requests Ever",
-    bb = {
+var w3 = "Queued Requests",
+    T3 = "Active Requests",
+    v3 = "Cancelled Requests",
+    S3 = "Queued Requests Ever",
+    A3 = "Active Requests Ever",
+    E3 = {
         id: "request-scheduler",
         throttleRequests: !0,
         maxRequests: 6,
         debounceTime: 0
     },
-    es = class {
+    ba = class {
         constructor() {
             let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
             this.props = void 0, this.stats = void 0, this.activeRequestCount = 0, this.requestQueue = [], this.requestMap = new Map, this.updateTimer = null, this.props = {
-                ...bb,
+                ...E3,
                 ...t
-            }, this.stats = new Xt({
+            }, this.stats = new Ke({
                 id: this.props.id
-            }), this.stats.get(mb), this.stats.get(_b), this.stats.get(yb), this.stats.get(xb), this.stats.get(Tb)
+            }), this.stats.get(w3), this.stats.get(T3), this.stats.get(v3), this.stats.get(S3), this.stats.get(A3)
         }
         scheduleRequest(t) {
             let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => 0;
             if (!this.props.throttleRequests) return Promise.resolve({
                 done: () => {}
             });
             if (this.requestMap.has(t)) return this.requestMap.get(t);
             let i = {
                     handle: t,
                     priority: 0,
                     getPriority: r
                 },
-                s = new Promise(n => (i.resolve = n, i));
-            return this.requestQueue.push(i), this.requestMap.set(t, s), this._issueNewRequests(), s
+                n = new Promise(s => (i.resolve = s, i));
+            return this.requestQueue.push(i), this.requestMap.set(t, n), this._issueNewRequests(), n
         }
         _issueRequest(t) {
             let {
                 handle: r,
                 resolve: i
-            } = t, s = !1, n = () => {
-                s || (s = !0, this.requestMap.delete(r), this.activeRequestCount--, this._issueNewRequests())
+            } = t, n = !1, s = () => {
+                n || (n = !0, this.requestMap.delete(r), this.activeRequestCount--, this._issueNewRequests())
             };
             return this.activeRequestCount++, i ? i({
-                done: n
+                done: s
             }) : Promise.resolve({
-                done: n
+                done: s
             })
         }
         _issueNewRequests() {
             this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = setTimeout(() => this._issueNewRequestsAsync(), this.props.debounceTime)
         }
         _issueNewRequestsAsync() {
             this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = null;
@@ -1936,292 +1936,292 @@
             }
             t.sort((r, i) => r.priority - i.priority)
         }
         _updateRequest(t) {
             return t.priority = t.getPriority(t.handle), t.priority < 0 ? (t.resolve(null), !1) : !0
         }
     };
-var Ab = "",
-    Hp = {};
+var I3 = "",
+    fT = {};
 
-function Bh(e) {
-    for (let t in Hp)
+function R_(e) {
+    for (let t in fT)
         if (e.startsWith(t)) {
-            let r = Hp[t];
+            let r = fT[t];
             e = e.replace(t, r)
-        } return !e.startsWith("http://") && !e.startsWith("https://") && (e = `${Ab}${e}`), e
+        } return !e.startsWith("http://") && !e.startsWith("https://") && (e = `${I3}${e}`), e
 }
 
-function Xp(e) {
+function hT(e) {
     return e && typeof e == "object" && e.isBuffer
 }
 
-function ma(e) {
-    if (Xp(e)) return e;
+function bh(e) {
+    if (hT(e)) return e;
     if (e instanceof ArrayBuffer) return e;
     if (ArrayBuffer.isView(e)) return e.byteOffset === 0 && e.byteLength === e.buffer.byteLength ? e.buffer : e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
     if (typeof e == "string") {
         let t = e;
         return new TextEncoder().encode(t).buffer
     }
     if (e && typeof e == "object" && e._toArrayBuffer) return e._toArrayBuffer();
     throw new Error("toArrayBuffer")
 }
-var di = {};
-Ji(di, {
-    dirname: () => Sb,
-    filename: () => Eb,
-    join: () => wb,
-    resolve: () => vb
+var ao = {};
+Ze(ao, {
+    dirname: () => M3,
+    filename: () => R3,
+    join: () => P3,
+    resolve: () => C3
 });
 
-function $p() {
+function dT() {
     var e;
     if (typeof process < "u" && typeof process.cwd < "u") return process.cwd();
     let t = (e = window.location) === null || e === void 0 ? void 0 : e.pathname;
     return t?.slice(0, t.lastIndexOf("/") + 1) || ""
 }
 
-function Eb(e) {
+function R3(e) {
     let t = e ? e.lastIndexOf("/") : -1;
     return t >= 0 ? e.substr(t + 1) : ""
 }
 
-function Sb(e) {
+function M3(e) {
     let t = e ? e.lastIndexOf("/") : -1;
     return t >= 0 ? e.substr(0, t) : ""
 }
 
-function wb() {
+function P3() {
     for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
     let i = "/";
-    return t = t.map((s, n) => (n && (s = s.replace(new RegExp(`^${i}`), "")), n !== t.length - 1 && (s = s.replace(new RegExp(`${i}$`), "")), s)), t.join(i)
+    return t = t.map((n, s) => (s && (n = n.replace(new RegExp(`^${i}`), "")), s !== t.length - 1 && (n = n.replace(new RegExp(`${i}$`), "")), n)), t.join(i)
 }
 
-function vb() {
+function C3() {
     let e = [];
-    for (let s = 0; s < arguments.length; s++) e[s] = s < 0 || arguments.length <= s ? void 0 : arguments[s];
+    for (let n = 0; n < arguments.length; n++) e[n] = n < 0 || arguments.length <= n ? void 0 : arguments[n];
     let t = "",
         r = !1,
         i;
-    for (let s = e.length - 1; s >= -1 && !r; s--) {
-        let n;
-        s >= 0 ? n = e[s] : (i === void 0 && (i = $p()), n = i), n.length !== 0 && (t = `${n}/${t}`, r = n.charCodeAt(0) === fn)
+    for (let n = e.length - 1; n >= -1 && !r; n--) {
+        let s;
+        n >= 0 ? s = e[n] : (i === void 0 && (i = dT()), s = i), s.length !== 0 && (t = `${s}/${t}`, r = s.charCodeAt(0) === il)
     }
-    return t = Rb(t, !r), r ? `/${t}` : t.length > 0 ? t : "."
+    return t = O3(t, !r), r ? `/${t}` : t.length > 0 ? t : "."
 }
-var fn = 47,
-    Uh = 46;
+var il = 47,
+    M_ = 46;
 
-function Rb(e, t) {
+function O3(e, t) {
     let r = "",
         i = -1,
-        s = 0,
-        n, o = !1;
+        n = 0,
+        s, o = !1;
     for (let a = 0; a <= e.length; ++a) {
-        if (a < e.length) n = e.charCodeAt(a);
+        if (a < e.length) s = e.charCodeAt(a);
         else {
-            if (n === fn) break;
-            n = fn
+            if (s === il) break;
+            s = il
         }
-        if (n === fn) {
-            if (!(i === a - 1 || s === 1))
-                if (i !== a - 1 && s === 2) {
-                    if (r.length < 2 || !o || r.charCodeAt(r.length - 1) !== Uh || r.charCodeAt(r.length - 2) !== Uh) {
+        if (s === il) {
+            if (!(i === a - 1 || n === 1))
+                if (i !== a - 1 && n === 2) {
+                    if (r.length < 2 || !o || r.charCodeAt(r.length - 1) !== M_ || r.charCodeAt(r.length - 2) !== M_) {
                         if (r.length > 2) {
                             let c = r.length - 1,
                                 l = c;
-                            for (; l >= 0 && r.charCodeAt(l) !== fn; --l);
+                            for (; l >= 0 && r.charCodeAt(l) !== il; --l);
                             if (l !== c) {
-                                r = l === -1 ? "" : r.slice(0, l), i = a, s = 0, o = !1;
+                                r = l === -1 ? "" : r.slice(0, l), i = a, n = 0, o = !1;
                                 continue
                             }
                         } else if (r.length === 2 || r.length === 1) {
-                            r = "", i = a, s = 0, o = !1;
+                            r = "", i = a, n = 0, o = !1;
                             continue
                         }
                     }
                     t && (r.length > 0 ? r += "/.." : r = "..", o = !0)
                 } else {
                     let c = e.slice(i + 1, a);
                     r.length > 0 ? r += `/${c}` : r = c, o = !1
-                } i = a, s = 0
-        } else n === Uh && s !== -1 ? ++s : s = -1
+                } i = a, n = 0
+        } else s === M_ && n !== -1 ? ++n : n = -1
     }
     return r
 }
-var Pb = e => typeof e == "boolean",
-    un = e => typeof e == "function",
-    pi = e => e !== null && typeof e == "object",
-    Vh = e => pi(e) && e.constructor === {}.constructor;
-var Yp = e => !!e && typeof e[Symbol.iterator] == "function",
-    qp = e => e && typeof e[Symbol.asyncIterator] == "function";
-var le = e => typeof Response < "u" && e instanceof Response || e && e.arrayBuffer && e.text && e.json;
-var he = e => typeof Blob < "u" && e instanceof Blob,
-    Zp = e => e && typeof e == "object" && e.isBuffer;
-var Mb = e => typeof ReadableStream < "u" && e instanceof ReadableStream || pi(e) && un(e.tee) && un(e.cancel) && un(e.getReader);
-var Cb = e => pi(e) && un(e.read) && un(e.pipe) && Pb(e.readable),
-    _a = e => Mb(e) || Cb(e);
-var Ib = /^data:([-\w.]+\/[-\w.+]+)(;|,)/,
-    Ob = /^([-\w.]+\/[-\w.+]+)/;
+var N3 = e => typeof e == "boolean",
+    nl = e => typeof e == "function",
+    co = e => e !== null && typeof e == "object",
+    P_ = e => co(e) && e.constructor === {}.constructor;
+var pT = e => !!e && typeof e[Symbol.iterator] == "function",
+    mT = e => e && typeof e[Symbol.asyncIterator] == "function";
+var Pr = e => typeof Response < "u" && e instanceof Response || e && e.arrayBuffer && e.text && e.json;
+var Cr = e => typeof Blob < "u" && e instanceof Blob,
+    gT = e => e && typeof e == "object" && e.isBuffer;
+var B3 = e => typeof ReadableStream < "u" && e instanceof ReadableStream || co(e) && nl(e.tee) && nl(e.cancel) && nl(e.getReader);
+var F3 = e => co(e) && nl(e.read) && nl(e.pipe) && N3(e.readable),
+    xh = e => B3(e) || F3(e);
+var D3 = /^data:([-\w.]+\/[-\w.+]+)(;|,)/,
+    L3 = /^([-\w.]+\/[-\w.+]+)/;
 
-function Kp(e) {
-    let t = Ob.exec(e);
+function _T(e) {
+    let t = L3.exec(e);
     return t ? t[1] : e
 }
 
-function zh(e) {
-    let t = Ib.exec(e);
+function C_(e) {
+    let t = D3.exec(e);
     return t ? t[1] : ""
 }
-var Qp = /\?.*/;
+var yT = /\?.*/;
 
-function Gp(e) {
-    let t = e.match(Qp);
+function bT(e) {
+    let t = e.match(yT);
     return t && t[0]
 }
 
-function rs(e) {
-    return e.replace(Qp, "")
+function xa(e) {
+    return e.replace(yT, "")
 }
 
-function gi(e) {
-    return le(e) ? e.url : he(e) ? e.name || "" : typeof e == "string" ? e : ""
+function lo(e) {
+    return Pr(e) ? e.url : Cr(e) ? e.name || "" : typeof e == "string" ? e : ""
 }
 
-function dn(e) {
-    if (le(e)) {
+function sl(e) {
+    if (Pr(e)) {
         let t = e,
             r = t.headers.get("content-type") || "",
-            i = rs(t.url);
-        return Kp(r) || zh(i)
+            i = xa(t.url);
+        return _T(r) || C_(i)
     }
-    return he(e) ? e.type || "" : typeof e == "string" ? zh(e) : ""
+    return Cr(e) ? e.type || "" : typeof e == "string" ? C_(e) : ""
 }
 
-function Jp(e) {
-    return le(e) ? e.headers["content-length"] || -1 : he(e) ? e.size : typeof e == "string" ? e.length : e instanceof ArrayBuffer || ArrayBuffer.isView(e) ? e.byteLength : -1
+function xT(e) {
+    return Pr(e) ? e.headers["content-length"] || -1 : Cr(e) ? e.size : typeof e == "string" ? e.length : e instanceof ArrayBuffer || ArrayBuffer.isView(e) ? e.byteLength : -1
 }
-async function ya(e) {
-    if (le(e)) return e;
+async function wh(e) {
+    if (Pr(e)) return e;
     let t = {},
-        r = Jp(e);
+        r = xT(e);
     r >= 0 && (t["content-length"] = String(r));
-    let i = gi(e),
-        s = dn(e);
-    s && (t["content-type"] = s);
-    let n = await Fb(e);
-    n && (t["x-first-bytes"] = n), typeof e == "string" && (e = new TextEncoder().encode(e));
+    let i = lo(e),
+        n = sl(e);
+    n && (t["content-type"] = n);
+    let s = await U3(e);
+    s && (t["x-first-bytes"] = s), typeof e == "string" && (e = new TextEncoder().encode(e));
     let o = new Response(e, {
         headers: t
     });
     return Object.defineProperty(o, "url", {
         value: i
     }), o
 }
-async function tg(e) {
+async function wT(e) {
     if (!e.ok) {
-        let t = await Nb(e);
+        let t = await k3(e);
         throw new Error(t)
     }
 }
-async function Nb(e) {
+async function k3(e) {
     let t = `Failed to fetch resource ${e.url} (${e.status}): `;
     try {
         let r = e.headers.get("Content-Type"),
             i = e.statusText;
         r != null && r.includes("application/json") && (i += ` ${await e.text()}`), t += i, t = t.length > 60 ? `${t.slice(0,60)}...` : t
     } catch {}
     return t
 }
-async function Fb(e) {
+async function U3(e) {
     if (typeof e == "string") return `data:,${e.slice(0,5)}`;
     if (e instanceof Blob) {
         let r = e.slice(0, 5);
         return await new Promise(i => {
-            let s = new FileReader;
-            s.onload = n => {
+            let n = new FileReader;
+            n.onload = s => {
                 var o;
-                return i(n == null || (o = n.target) === null || o === void 0 ? void 0 : o.result)
-            }, s.readAsDataURL(r)
+                return i(s == null || (o = s.target) === null || o === void 0 ? void 0 : o.result)
+            }, n.readAsDataURL(r)
         })
     }
     if (e instanceof ArrayBuffer) {
         let r = e.slice(0, 5);
-        return `data:base64,${Db(r)}`
+        return `data:base64,${V3(r)}`
     }
     return null
 }
 
-function Db(e) {
+function V3(e) {
     let t = "",
         r = new Uint8Array(e);
     for (let i = 0; i < r.byteLength; i++) t += String.fromCharCode(r[i]);
     return btoa(t)
 }
 
-function kb(e) {
-    return !Lb(e) && !Bb(e)
+function z3(e) {
+    return !W3(e) && !j3(e)
 }
 
-function Lb(e) {
+function W3(e) {
     return e.startsWith("http:") || e.startsWith("https:")
 }
 
-function Bb(e) {
+function j3(e) {
     return e.startsWith("data:")
 }
-async function Wh(e, t) {
+async function O_(e, t) {
     if (typeof e == "string") {
-        let s = Bh(e);
-        if (kb(s)) {
+        let n = R_(e);
+        if (z3(n)) {
             var r;
             if ((r = globalThis.loaders) !== null && r !== void 0 && r.fetchNode) {
                 var i;
-                return (i = globalThis.loaders) === null || i === void 0 ? void 0 : i.fetchNode(s, t)
+                return (i = globalThis.loaders) === null || i === void 0 ? void 0 : i.fetchNode(n, t)
             }
         }
-        return await fetch(s, t)
+        return await fetch(n, t)
     }
-    return await ya(e)
+    return await wh(e)
 }
-var xa = globalThis,
-    Ub = globalThis.document || {},
-    Ta = globalThis.process || {},
-    Vb = globalThis.console,
-    eg = globalThis.navigator || {};
+var Th = globalThis,
+    H3 = globalThis.document || {},
+    vh = globalThis.process || {},
+    $3 = globalThis.console,
+    TT = globalThis.navigator || {};
 
-function ba(e) {
+function Sh(e) {
     if (typeof window < "u" && window.process?.type === "renderer" || typeof process < "u" && process.versions?.electron) return !0;
     let t = typeof navigator < "u" && navigator.userAgent,
         r = e || t;
     return !!(r && r.indexOf("Electron") >= 0)
 }
 
-function Ot() {
-    return !(typeof process == "object" && String(process) === "[object process]" && !process?.browser) || ba()
+function Me() {
+    return !(typeof process == "object" && String(process) === "[object process]" && !process?.browser) || Sh()
 }
 
-function jh(e) {
-    return !e && !Ot() ? "Node" : ba(e) ? "Electron" : (e || eg.userAgent || "").indexOf("Edge") > -1 ? "Edge" : globalThis.chrome ? "Chrome" : globalThis.safari ? "Safari" : globalThis.mozInnerScreenX ? "Firefox" : "Unknown"
+function N_(e) {
+    return !e && !Me() ? "Node" : Sh(e) ? "Electron" : (e || TT.userAgent || "").indexOf("Edge") > -1 ? "Edge" : globalThis.chrome ? "Chrome" : globalThis.safari ? "Safari" : globalThis.mozInnerScreenX ? "Firefox" : "Unknown"
 }
-var Hh = "4.0.7";
+var B_ = "4.0.7";
 
-function Wb(e) {
+function Y3(e) {
     try {
         let t = window[e],
             r = "__storage_test__";
         return t.setItem(r, r), t.removeItem(r), t
     } catch {
         return null
     }
 }
-var Aa = class {
+var Ah = class {
     constructor(t, r, i = "sessionStorage") {
-        this.storage = Wb(i), this.id = t, this.config = r, this._loadConfiguration()
+        this.storage = Y3(i), this.id = t, this.config = r, this._loadConfiguration()
     }
     getConfiguration() {
         return this.config
     }
     setConfiguration(t) {
         if (Object.assign(this.config, t), this.storage) {
             let r = JSON.stringify(this.config);
@@ -2234,102 +2234,102 @@
             let r = this.storage.getItem(this.id);
             t = r ? JSON.parse(r) : {}
         }
         return Object.assign(this.config, t), this
     }
 };
 
-function rg(e) {
+function vT(e) {
     let t;
     return e < 10 ? t = `${e.toFixed(2)}ms` : e < 100 ? t = `${e.toFixed(1)}ms` : e < 1e3 ? t = `${e.toFixed(0)}ms` : t = `${(e/1e3).toFixed(2)}s`, t
 }
 
-function ig(e, t = 8) {
+function ST(e, t = 8) {
     let r = Math.max(t - e.length, 0);
     return `${" ".repeat(r)}${e}`
 }
-var Ea;
+var Eh;
 (function(e) {
     e[e.BLACK = 30] = "BLACK", e[e.RED = 31] = "RED", e[e.GREEN = 32] = "GREEN", e[e.YELLOW = 33] = "YELLOW", e[e.BLUE = 34] = "BLUE", e[e.MAGENTA = 35] = "MAGENTA", e[e.CYAN = 36] = "CYAN", e[e.WHITE = 37] = "WHITE", e[e.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", e[e.BRIGHT_RED = 91] = "BRIGHT_RED", e[e.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", e[e.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", e[e.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", e[e.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", e[e.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", e[e.BRIGHT_WHITE = 97] = "BRIGHT_WHITE"
-})(Ea || (Ea = {}));
-var jb = 10;
+})(Eh || (Eh = {}));
+var q3 = 10;
 
-function sg(e) {
-    return typeof e != "string" ? e : (e = e.toUpperCase(), Ea[e] || Ea.WHITE)
+function AT(e) {
+    return typeof e != "string" ? e : (e = e.toUpperCase(), Eh[e] || Eh.WHITE)
 }
 
-function ng(e, t, r) {
-    return !Ot && typeof e == "string" && (t && (e = `\x1B[${sg(t)}m${e}\x1B[39m`), r && (e = `\x1B[${sg(r)+jb}m${e}\x1B[49m`)), e
+function ET(e, t, r) {
+    return !Me && typeof e == "string" && (t && (e = `\x1B[${AT(t)}m${e}\x1B[39m`), r && (e = `\x1B[${AT(r)+q3}m${e}\x1B[49m`)), e
 }
 
-function og(e, t = ["constructor"]) {
+function IT(e, t = ["constructor"]) {
     let r = Object.getPrototypeOf(e),
         i = Object.getOwnPropertyNames(r),
-        s = e;
-    for (let n of i) {
-        let o = s[n];
-        typeof o == "function" && (t.find(a => n === a) || (s[n] = o.bind(e)))
+        n = e;
+    for (let s of i) {
+        let o = n[s];
+        typeof o == "function" && (t.find(a => s === a) || (n[s] = o.bind(e)))
     }
 }
 
-function pn(e, t) {
+function ol(e, t) {
     if (!e) throw new Error(t || "Assertion failed")
 }
 
-function mi() {
+function uo() {
     let e;
-    if (Ot() && xa.performance) e = xa?.performance?.now?.();
-    else if ("hrtime" in Ta) {
-        let t = Ta?.hrtime?.();
+    if (Me() && Th.performance) e = Th?.performance?.now?.();
+    else if ("hrtime" in vh) {
+        let t = vh?.hrtime?.();
         e = t[0] * 1e3 + t[1] / 1e6
     } else e = Date.now();
     return e
 }
-var is = {
-        debug: Ot() && console.debug || console.log,
+var wa = {
+        debug: Me() && console.debug || console.log,
         log: console.log,
         info: console.info,
         warn: console.warn,
         error: console.error
     },
-    Hb = {
+    Z3 = {
         enabled: !0,
         level: 0
     };
 
-function ss() {}
-var ag = {},
-    cg = {
+function Ta() {}
+var RT = {},
+    MT = {
         once: !0
     },
-    $t = class {
+    ye = class {
         constructor({
             id: t
         } = {
             id: ""
         }) {
-            this.VERSION = Hh, this._startTs = mi(), this._deltaTs = mi(), this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = t, this.userData = {}, this._storage = new Aa(`__probe-${this.id}__`, Hb), this.timeStamp(`${this.id} started`), og(this), Object.seal(this)
+            this.VERSION = B_, this._startTs = uo(), this._deltaTs = uo(), this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = t, this.userData = {}, this._storage = new Ah(`__probe-${this.id}__`, Z3), this.timeStamp(`${this.id} started`), IT(this), Object.seal(this)
         }
         set level(t) {
             this.setLevel(t)
         }
         get level() {
             return this.getLevel()
         }
         isEnabled() {
             return this._storage.config.enabled
         }
         getLevel() {
             return this._storage.config.level
         }
         getTotal() {
-            return Number((mi() - this._startTs).toPrecision(10))
+            return Number((uo() - this._startTs).toPrecision(10))
         }
         getDelta() {
-            return Number((mi() - this._deltaTs).toPrecision(10))
+            return Number((uo() - this._deltaTs).toPrecision(10))
         }
         set priority(t) {
             this.level = t
         }
         get priority() {
             return this.level
         }
@@ -2357,184 +2357,184 @@
         settings() {
             console.table ? console.table(this._storage.config) : console.log(this._storage.config)
         }
         assert(t, r) {
             if (!t) throw new Error(r || "Assertion failed")
         }
         warn(t) {
-            return this._getLogFunction(0, t, is.warn, arguments, cg)
+            return this._getLogFunction(0, t, wa.warn, arguments, MT)
         }
         error(t) {
-            return this._getLogFunction(0, t, is.error, arguments)
+            return this._getLogFunction(0, t, wa.error, arguments)
         }
         deprecated(t, r) {
             return this.warn(`\`${t}\` is deprecated and will be removed in a later version. Use \`${r}\` instead`)
         }
         removed(t, r) {
             return this.error(`\`${t}\` has been removed. Use \`${r}\` instead`)
         }
         probe(t, r) {
-            return this._getLogFunction(t, r, is.log, arguments, {
+            return this._getLogFunction(t, r, wa.log, arguments, {
                 time: !0,
                 once: !0
             })
         }
         log(t, r) {
-            return this._getLogFunction(t, r, is.debug, arguments)
+            return this._getLogFunction(t, r, wa.debug, arguments)
         }
         info(t, r) {
             return this._getLogFunction(t, r, console.info, arguments)
         }
         once(t, r) {
-            return this._getLogFunction(t, r, is.debug || is.info, arguments, cg)
+            return this._getLogFunction(t, r, wa.debug || wa.info, arguments, MT)
         }
         table(t, r, i) {
-            return r ? this._getLogFunction(t, r, console.table || ss, i && [i], {
-                tag: $b(r)
-            }) : ss
+            return r ? this._getLogFunction(t, r, console.table || Ta, i && [i], {
+                tag: G3(r)
+            }) : Ta
         }
         time(t, r) {
             return this._getLogFunction(t, r, console.time ? console.time : console.info)
         }
         timeEnd(t, r) {
             return this._getLogFunction(t, r, console.timeEnd ? console.timeEnd : console.info)
         }
         timeStamp(t, r) {
-            return this._getLogFunction(t, r, console.timeStamp || ss)
+            return this._getLogFunction(t, r, console.timeStamp || Ta)
         }
         group(t, r, i = {
             collapsed: !1
         }) {
-            let s = lg({
+            let n = PT({
                     logLevel: t,
                     message: r,
                     opts: i
                 }),
                 {
-                    collapsed: n
+                    collapsed: s
                 } = i;
-            return s.method = (n ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(s)
+            return n.method = (s ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(n)
         }
         groupCollapsed(t, r, i = {}) {
             return this.group(t, r, Object.assign({}, i, {
                 collapsed: !0
             }))
         }
         groupEnd(t) {
-            return this._getLogFunction(t, "", console.groupEnd || ss)
+            return this._getLogFunction(t, "", console.groupEnd || Ta)
         }
         withGroup(t, r, i) {
             this.group(t, r)();
             try {
                 i()
             } finally {
                 this.groupEnd(t)()
             }
         }
         trace() {
             console.trace && console.trace()
         }
         _shouldLog(t) {
-            return this.isEnabled() && this.getLevel() >= hg(t)
+            return this.isEnabled() && this.getLevel() >= CT(t)
         }
-        _getLogFunction(t, r, i, s, n) {
+        _getLogFunction(t, r, i, n, s) {
             if (this._shouldLog(t)) {
-                n = lg({
+                s = PT({
                     logLevel: t,
                     message: r,
-                    args: s,
-                    opts: n
-                }), i = i || n.method, pn(i), n.total = this.getTotal(), n.delta = this.getDelta(), this._deltaTs = mi();
-                let o = n.tag || n.message;
-                if (n.once && o)
-                    if (!ag[o]) ag[o] = mi();
-                    else return ss;
-                return r = Xb(this.id, n.message, n), i.bind(console, r, ...n.args)
+                    args: n,
+                    opts: s
+                }), i = i || s.method, ol(i), s.total = this.getTotal(), s.delta = this.getDelta(), this._deltaTs = uo();
+                let o = s.tag || s.message;
+                if (s.once && o)
+                    if (!RT[o]) RT[o] = uo();
+                    else return Ta;
+                return r = K3(this.id, s.message, s), i.bind(console, r, ...s.args)
             }
-            return ss
+            return Ta
         }
     };
-$t.VERSION = Hh;
+ye.VERSION = B_;
 
-function hg(e) {
+function CT(e) {
     if (!e) return 0;
     let t;
     switch (typeof e) {
         case "number":
             t = e;
             break;
         case "object":
             t = e.logLevel || e.priority || 0;
             break;
         default:
             return 0
     }
-    return pn(Number.isFinite(t) && t >= 0), t
+    return ol(Number.isFinite(t) && t >= 0), t
 }
 
-function lg(e) {
+function PT(e) {
     let {
         logLevel: t,
         message: r
     } = e;
-    e.logLevel = hg(t);
+    e.logLevel = CT(t);
     let i = e.args ? Array.from(e.args) : [];
     for (; i.length && i.shift() !== r;);
     switch (typeof t) {
         case "string":
         case "function":
             r !== void 0 && i.unshift(r), e.message = t;
             break;
         case "object":
             Object.assign(e, t);
             break;
         default:
     }
     typeof e.message == "function" && (e.message = e.message());
-    let s = typeof e.message;
-    return pn(s === "string" || s === "object"), Object.assign(e, {
+    let n = typeof e.message;
+    return ol(n === "string" || n === "object"), Object.assign(e, {
         args: i
     }, e.opts)
 }
 
-function Xb(e, t, r) {
+function K3(e, t, r) {
     if (typeof t == "string") {
-        let i = r.time ? ig(rg(r.total)) : "";
-        t = r.time ? `${e}: ${i}  ${t}` : `${e}: ${t}`, t = ng(t, r.color, r.background)
+        let i = r.time ? ST(vT(r.total)) : "";
+        t = r.time ? `${e}: ${i}  ${t}` : `${e}: ${t}`, t = ET(t, r.color, r.background)
     }
     return t
 }
 
-function $b(e) {
+function G3(e) {
     for (let t in e)
         for (let r in e[t]) return r || "untitled";
     return "empty"
 }
 globalThis.probe = {};
-var YI = new $t({
+var EW = new ye({
     id: "@probe.gl/log"
 });
-var Xh = new $t({
+var F_ = new ye({
         id: "loaders.gl"
     }),
-    Sa = class {
+    Ih = class {
         log() {
             return () => {}
         }
         info() {
             return () => {}
         }
         warn() {
             return () => {}
         }
         error() {
             return () => {}
         }
     },
-    wa = class {
+    Rh = class {
         constructor() {
             this.console = void 0, this.console = console
         }
         log() {
             for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];
             return this.console.log.bind(this.console, ...r)
         }
@@ -2547,35 +2547,35 @@
             return this.console.warn.bind(this.console, ...r)
         }
         error() {
             for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];
             return this.console.error.bind(this.console, ...r)
         }
     };
-var $h = {
+var D_ = {
         fetch: null,
         mimeType: void 0,
         nothrow: !1,
-        log: new wa,
+        log: new Rh,
         useLocalLibraries: !1,
         CDN: "https://unpkg.com/@loaders.gl",
         worker: !0,
         maxConcurrency: 3,
         maxMobileConcurrency: 1,
-        reuseWorkers: fi,
+        reuseWorkers: so,
         _nodeWorkers: !1,
         _workerType: "",
         limit: 0,
         _limitMB: 0,
         batchSize: "auto",
         batchDebounceMs: 0,
         metadata: !1,
         transforms: []
     },
-    fg = {
+    OT = {
         throws: "nothrow",
         dataType: "(no longer used)",
         uri: "baseUri",
         method: "fetch.method",
         headers: "fetch.headers",
         body: "fetch.body",
         mode: "fetch.mode",
@@ -2585,830 +2585,830 @@
         referrer: "fetch.referrer",
         referrerPolicy: "fetch.referrerPolicy",
         integrity: "fetch.integrity",
         keepalive: "fetch.keepalive",
         signal: "fetch.signal"
     };
 
-function Yh() {
+function L_() {
     globalThis.loaders = globalThis.loaders || {};
     let {
         loaders: e
     } = globalThis;
     return e._state = e._state || {}, e._state
 }
 
-function qh() {
-    let e = Yh();
+function k_() {
+    let e = L_();
     return e.globalOptions = e.globalOptions || {
-        ...$h
+        ...D_
     }, e.globalOptions
 }
 
-function pg(e, t, r, i) {
-    return r = r || [], r = Array.isArray(r) ? r : [r], Yb(e, r), Zb(t, e, i)
+function FT(e, t, r, i) {
+    return r = r || [], r = Array.isArray(r) ? r : [r], J3(e, r), t2(t, e, i)
 }
 
-function Yb(e, t) {
-    ug(e, null, $h, fg, t);
+function J3(e, t) {
+    NT(e, null, D_, OT, t);
     for (let r of t) {
         let i = e && e[r.id] || {},
-            s = r.options && r.options[r.id] || {},
-            n = r.deprecatedOptions && r.deprecatedOptions[r.id] || {};
-        ug(i, r.id, s, n, t)
+            n = r.options && r.options[r.id] || {},
+            s = r.deprecatedOptions && r.deprecatedOptions[r.id] || {};
+        NT(i, r.id, n, s, t)
     }
 }
 
-function ug(e, t, r, i, s) {
-    let n = t || "Top level",
+function NT(e, t, r, i, n) {
+    let s = t || "Top level",
         o = t ? `${t}.` : "";
     for (let a in e) {
-        let c = !t && pi(e[a]),
+        let c = !t && co(e[a]),
             l = a === "baseUri" && !t,
-            h = a === "workerUrl" && t;
-        if (!(a in r) && !l && !h) {
-            if (a in i) Xh.warn(`${n} loader option '${o}${a}' no longer supported, use '${i[a]}'`)();
+            u = a === "workerUrl" && t;
+        if (!(a in r) && !l && !u) {
+            if (a in i) F_.warn(`${s} loader option '${o}${a}' no longer supported, use '${i[a]}'`)();
             else if (!c) {
-                let f = qb(a, s);
-                Xh.warn(`${n} loader option '${o}${a}' not recognized. ${f}`)()
+                let f = Q3(a, n);
+                F_.warn(`${s} loader option '${o}${a}' not recognized. ${f}`)()
             }
         }
     }
 }
 
-function qb(e, t) {
+function Q3(e, t) {
     let r = e.toLowerCase(),
         i = "";
-    for (let s of t)
-        for (let n in s.options) {
-            if (e === n) return `Did you mean '${s.id}.${n}'?`;
-            let o = n.toLowerCase();
-            (r.startsWith(o) || o.startsWith(r)) && (i = i || `Did you mean '${s.id}.${n}'?`)
+    for (let n of t)
+        for (let s in n.options) {
+            if (e === s) return `Did you mean '${n.id}.${s}'?`;
+            let o = s.toLowerCase();
+            (r.startsWith(o) || o.startsWith(r)) && (i = i || `Did you mean '${n.id}.${s}'?`)
         }
     return i
 }
 
-function Zb(e, t, r) {
-    let s = {
+function t2(e, t, r) {
+    let n = {
         ...e.options || {}
     };
-    return Kb(s, r), s.log === null && (s.log = new Sa), dg(s, qh()), dg(s, t), s
+    return e2(n, r), n.log === null && (n.log = new Ih), BT(n, k_()), BT(n, t), n
 }
 
-function dg(e, t) {
+function BT(e, t) {
     for (let r in t)
         if (r in t) {
             let i = t[r];
-            Vh(i) && Vh(e[r]) ? e[r] = {
+            P_(i) && P_(e[r]) ? e[r] = {
                 ...e[r],
                 ...t[r]
             } : e[r] = t[r]
         }
 }
 
-function Kb(e, t) {
+function e2(e, t) {
     t && !("baseUri" in e) && (e.baseUri = t)
 }
 
-function gn(e) {
+function al(e) {
     var t;
     return e ? (Array.isArray(e) && (e = e[0]), Array.isArray((t = e) === null || t === void 0 ? void 0 : t.extensions)) : !1
 }
 
-function mn(e) {
+function cl(e) {
     var t, r;
-    Nr(e, "null loader"), Nr(gn(e), "invalid loader");
+    ps(e, "null loader"), ps(al(e), "invalid loader");
     let i;
     return Array.isArray(e) && (i = e[1], e = e[0], e = {
         ...e,
         options: {
             ...e.options,
             ...i
         }
     }), ((t = e) !== null && t !== void 0 && t.parseTextSync || (r = e) !== null && r !== void 0 && r.parseText) && (e.text = !0), e.text || (e.binary = !0), e
 }
-var gg = () => {
-    let e = Yh();
+var DT = () => {
+    let e = L_();
     return e.loaderRegistry = e.loaderRegistry || [], e.loaderRegistry
 };
 
-function Zh(e) {
-    let t = gg();
+function U_(e) {
+    let t = DT();
     e = Array.isArray(e) ? e : [e];
     for (let r of e) {
-        let i = mn(r);
-        t.find(s => i === s) || t.unshift(i)
+        let i = cl(r);
+        t.find(n => i === n) || t.unshift(i)
     }
 }
 
-function mg() {
-    return gg()
+function LT() {
+    return DT()
 }
-var _g = new $t({
+var kT = new ye({
     id: "loaders.gl"
 });
-var Qb = /\.([^.]+)$/;
-async function Tg(e) {
+var r2 = /\.([^.]+)$/;
+async function zT(e) {
     let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
         r = arguments.length > 2 ? arguments[2] : void 0,
         i = arguments.length > 3 ? arguments[3] : void 0;
-    if (!bg(e)) return null;
-    let s = yg(e, t, {
+    if (!WT(e)) return null;
+    let n = UT(e, t, {
         ...r,
         nothrow: !0
     }, i);
-    if (s) return s;
-    if (he(e) && (e = await e.slice(0, 10).arrayBuffer(), s = yg(e, t, r, i)), !s && !(r != null && r.nothrow)) throw new Error(Ag(e));
-    return s
+    if (n) return n;
+    if (Cr(e) && (e = await e.slice(0, 10).arrayBuffer(), n = UT(e, t, r, i)), !n && !(r != null && r.nothrow)) throw new Error(jT(e));
+    return n
 }
 
-function yg(e) {
+function UT(e) {
     let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
         r = arguments.length > 2 ? arguments[2] : void 0,
         i = arguments.length > 3 ? arguments[3] : void 0;
-    if (!bg(e)) return null;
-    if (t && !Array.isArray(t)) return mn(t);
-    let s = [];
-    t && (s = s.concat(t)), r != null && r.ignoreRegisteredLoaders || s.push(...mg()), Jb(s);
-    let n = Gb(e, s, r, i);
-    if (!n && !(r != null && r.nothrow)) throw new Error(Ag(e));
-    return n
+    if (!WT(e)) return null;
+    if (t && !Array.isArray(t)) return cl(t);
+    let n = [];
+    t && (n = n.concat(t)), r != null && r.ignoreRegisteredLoaders || n.push(...LT()), n2(n);
+    let s = i2(e, n, r, i);
+    if (!s && !(r != null && r.nothrow)) throw new Error(jT(e));
+    return s
 }
 
-function Gb(e, t, r, i) {
-    let s = gi(e),
-        n = dn(e),
-        o = rs(s) || i?.url,
+function i2(e, t, r, i) {
+    let n = lo(e),
+        s = sl(e),
+        o = xa(n) || i?.url,
         a = null,
         c = "";
-    if (r != null && r.mimeType && (a = Kh(t, r?.mimeType), c = `match forced by supplied MIME type ${r?.mimeType}`), a = a || t1(t, o), c = c || (a ? `matched url ${o}` : ""), a = a || Kh(t, n), c = c || (a ? `matched MIME type ${n}` : ""), a = a || r1(t, e), c = c || (a ? `matched initial data ${Eg(e)}` : ""), r != null && r.fallbackMimeType && (a = a || Kh(t, r?.fallbackMimeType), c = c || (a ? `matched fallback MIME type ${n}` : "")), c) {
+    if (r != null && r.mimeType && (a = V_(t, r?.mimeType), c = `match forced by supplied MIME type ${r?.mimeType}`), a = a || s2(t, o), c = c || (a ? `matched url ${o}` : ""), a = a || V_(t, s), c = c || (a ? `matched MIME type ${s}` : ""), a = a || a2(t, e), c = c || (a ? `matched initial data ${HT(e)}` : ""), r != null && r.fallbackMimeType && (a = a || V_(t, r?.fallbackMimeType), c = c || (a ? `matched fallback MIME type ${s}` : "")), c) {
         var l;
-        _g.log(1, `selectLoader selected ${(l=a)===null||l===void 0?void 0:l.name}: ${c}.`)
+        kT.log(1, `selectLoader selected ${(l=a)===null||l===void 0?void 0:l.name}: ${c}.`)
     }
     return a
 }
 
-function bg(e) {
+function WT(e) {
     return !(e instanceof Response && e.status === 204)
 }
 
-function Ag(e) {
-    let t = gi(e),
-        r = dn(e),
+function jT(e) {
+    let t = lo(e),
+        r = sl(e),
         i = "No valid loader found (";
-    i += t ? `${di.filename(t)}, ` : "no url provided, ", i += `MIME type: ${r?`"${r}"`:"not provided"}, `;
-    let s = e ? Eg(e) : "";
-    return i += s ? ` first bytes: "${s}"` : "first bytes: not available", i += ")", i
+    i += t ? `${ao.filename(t)}, ` : "no url provided, ", i += `MIME type: ${r?`"${r}"`:"not provided"}, `;
+    let n = e ? HT(e) : "";
+    return i += n ? ` first bytes: "${n}"` : "first bytes: not available", i += ")", i
 }
 
-function Jb(e) {
-    for (let t of e) mn(t)
+function n2(e) {
+    for (let t of e) cl(t)
 }
 
-function t1(e, t) {
-    let r = t && Qb.exec(t),
+function s2(e, t) {
+    let r = t && r2.exec(t),
         i = r && r[1];
-    return i ? e1(e, i) : null
+    return i ? o2(e, i) : null
 }
 
-function e1(e, t) {
+function o2(e, t) {
     t = t.toLowerCase();
     for (let r of e)
         for (let i of r.extensions)
             if (i.toLowerCase() === t) return r;
     return null
 }
 
-function Kh(e, t) {
+function V_(e, t) {
     for (let r of e)
         if (r.mimeTypes && r.mimeTypes.includes(t) || t === `application/x.${r.id}`) return r;
     return null
 }
 
-function r1(e, t) {
+function a2(e, t) {
     if (!t) return null;
     for (let r of e)
         if (typeof t == "string") {
-            if (i1(t, r)) return r
+            if (c2(t, r)) return r
         } else if (ArrayBuffer.isView(t)) {
-        if (xg(t.buffer, t.byteOffset, r)) return r
-    } else if (t instanceof ArrayBuffer && xg(t, 0, r)) return r;
+        if (VT(t.buffer, t.byteOffset, r)) return r
+    } else if (t instanceof ArrayBuffer && VT(t, 0, r)) return r;
     return null
 }
 
-function i1(e, t) {
+function c2(e, t) {
     return t.testText ? t.testText(e) : (Array.isArray(t.tests) ? t.tests : [t.tests]).some(i => e.startsWith(i))
 }
 
-function xg(e, t, r) {
-    return (Array.isArray(r.tests) ? r.tests : [r.tests]).some(s => s1(e, t, r, s))
+function VT(e, t, r) {
+    return (Array.isArray(r.tests) ? r.tests : [r.tests]).some(n => l2(e, t, r, n))
 }
 
-function s1(e, t, r, i) {
-    if (i instanceof ArrayBuffer) return Dh(i, e, i.byteLength);
+function l2(e, t, r, i) {
+    if (i instanceof ArrayBuffer) return A_(i, e, i.byteLength);
     switch (typeof i) {
         case "function":
             return i(e);
         case "string":
-            let s = Qh(e, t, i.length);
-            return i === s;
+            let n = z_(e, t, i.length);
+            return i === n;
         default:
             return !1
     }
 }
 
-function Eg(e) {
+function HT(e) {
     let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
-    return typeof e == "string" ? e.slice(0, t) : ArrayBuffer.isView(e) ? Qh(e.buffer, e.byteOffset, t) : e instanceof ArrayBuffer ? Qh(e, 0, t) : ""
+    return typeof e == "string" ? e.slice(0, t) : ArrayBuffer.isView(e) ? z_(e.buffer, e.byteOffset, t) : e instanceof ArrayBuffer ? z_(e, 0, t) : ""
 }
 
-function Qh(e, t, r) {
+function z_(e, t, r) {
     if (e.byteLength < t + r) return "";
     let i = new DataView(e),
-        s = "";
-    for (let n = 0; n < r; n++) s += String.fromCharCode(i.getUint8(t + n));
-    return s
+        n = "";
+    for (let s = 0; s < r; s++) n += String.fromCharCode(i.getUint8(t + s));
+    return n
 }
 
-function* Sg(e, t) {
+function* $T(e, t) {
     let r = t?.chunkSize || 262144,
         i = 0,
-        s = new TextEncoder;
+        n = new TextEncoder;
     for (; i < e.length;) {
-        let n = Math.min(e.length - i, r),
-            o = e.slice(i, i + n);
-        i += n, yield s.encode(o)
+        let s = Math.min(e.length - i, r),
+            o = e.slice(i, i + s);
+        i += s, yield n.encode(o)
     }
 }
 
-function wg(e) {
+function XT(e) {
     let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
     return function*() {
         let {
             chunkSize: r = 262144
         } = t, i = 0;
         for (; i < e.byteLength;) {
-            let s = Math.min(e.byteLength - i, r),
-                n = new ArrayBuffer(s),
-                o = new Uint8Array(e, i, s);
-            new Uint8Array(n).set(o), i += s, yield n
+            let n = Math.min(e.byteLength - i, r),
+                s = new ArrayBuffer(n),
+                o = new Uint8Array(e, i, n);
+            new Uint8Array(s).set(o), i += n, yield s
         }
     }()
 }
-async function* vg(e, t) {
+async function* YT(e, t) {
     let r = t?.chunkSize || 1048576,
         i = 0;
     for (; i < e.size;) {
-        let s = i + r,
-            n = await e.slice(i, s).arrayBuffer();
-        i = s, yield n
+        let n = i + r,
+            s = await e.slice(i, n).arrayBuffer();
+        i = n, yield s
     }
 }
 
-function Gh(e, t) {
-    return fi ? n1(e, t) : o1(e, t)
+function W_(e, t) {
+    return so ? u2(e, t) : f2(e, t)
 }
-async function* n1(e, t) {
+async function* u2(e, t) {
     let r = e.getReader(),
         i;
     try {
         for (;;) {
-            let s = i || r.read();
+            let n = i || r.read();
             t != null && t._streamReadAhead && (i = r.read());
             let {
-                done: n,
+                done: s,
                 value: o
-            } = await s;
-            if (n) return;
-            yield ma(o)
+            } = await n;
+            if (s) return;
+            yield bh(o)
         }
     } catch {
         r.releaseLock()
     }
 }
-async function* o1(e, t) {
-    for await (let r of e) yield ma(r)
+async function* f2(e, t) {
+    for await (let r of e) yield bh(r)
 }
 
-function Rg(e, t) {
-    if (typeof e == "string") return Sg(e, t);
-    if (e instanceof ArrayBuffer) return wg(e, t);
-    if (he(e)) return vg(e, t);
-    if (_a(e)) return Gh(e, t);
-    if (le(e)) return Gh(e.body, t);
+function qT(e, t) {
+    if (typeof e == "string") return $T(e, t);
+    if (e instanceof ArrayBuffer) return XT(e, t);
+    if (Cr(e)) return YT(e, t);
+    if (xh(e)) return W_(e, t);
+    if (Pr(e)) return W_(e.body, t);
     throw new Error("makeIterator")
 }
-var Pg = "Cannot convert supplied data type";
+var ZT = "Cannot convert supplied data type";
 
-function a1(e, t, r) {
+function h2(e, t, r) {
     if (t.text && typeof e == "string") return e;
-    if (Zp(e) && (e = e.buffer), e instanceof ArrayBuffer) {
+    if (gT(e) && (e = e.buffer), e instanceof ArrayBuffer) {
         let i = e;
         return t.text && !t.binary ? new TextDecoder("utf8").decode(i) : i
     }
     if (ArrayBuffer.isView(e)) {
         if (t.text && !t.binary) return new TextDecoder("utf8").decode(e);
         let i = e.buffer,
-            s = e.byteLength || e.length;
-        return (e.byteOffset !== 0 || s !== i.byteLength) && (i = i.slice(e.byteOffset, e.byteOffset + s)), i
+            n = e.byteLength || e.length;
+        return (e.byteOffset !== 0 || n !== i.byteLength) && (i = i.slice(e.byteOffset, e.byteOffset + n)), i
     }
-    throw new Error(Pg)
+    throw new Error(ZT)
 }
-async function Mg(e, t, r) {
+async function KT(e, t, r) {
     let i = e instanceof ArrayBuffer || ArrayBuffer.isView(e);
-    if (typeof e == "string" || i) return a1(e, t, r);
-    if (he(e) && (e = await ya(e)), le(e)) {
-        let s = e;
-        return await tg(s), t.binary ? await s.arrayBuffer() : await s.text()
+    if (typeof e == "string" || i) return h2(e, t, r);
+    if (Cr(e) && (e = await wh(e)), Pr(e)) {
+        let n = e;
+        return await wT(n), t.binary ? await n.arrayBuffer() : await n.text()
     }
-    if (_a(e) && (e = Rg(e, r)), Yp(e) || qp(e)) return Lh(e);
-    throw new Error(Pg)
+    if (xh(e) && (e = qT(e, r)), pT(e) || mT(e)) return I_(e);
+    throw new Error(ZT)
 }
 
-function va(e, t) {
-    let r = qh(),
+function Mh(e, t) {
+    let r = k_(),
         i = e || r;
-    return typeof i.fetch == "function" ? i.fetch : pi(i.fetch) ? s => Wh(s, i.fetch) : t != null && t.fetch ? t?.fetch : Wh
+    return typeof i.fetch == "function" ? i.fetch : co(i.fetch) ? n => O_(n, i.fetch) : t != null && t.fetch ? t?.fetch : O_
 }
 
-function Cg(e, t, r) {
+function GT(e, t, r) {
     if (r) return r;
     let i = {
-        fetch: va(t, e),
+        fetch: Mh(t, e),
         ...e
     };
     if (i.url) {
-        let s = rs(i.url);
-        i.baseUrl = s, i.queryString = Gp(i.url), i.filename = di.filename(s), i.baseUrl = di.dirname(s)
+        let n = xa(i.url);
+        i.baseUrl = n, i.queryString = bT(i.url), i.filename = ao.filename(n), i.baseUrl = ao.dirname(n)
     }
     return Array.isArray(i.loaders) || (i.loaders = null), i
 }
 
-function Ig(e, t) {
+function JT(e, t) {
     if (e && !Array.isArray(e)) return e;
     let r;
     if (e && (r = Array.isArray(e) ? e : [e]), t && t.loaders) {
         let i = Array.isArray(t.loaders) ? t.loaders : [t.loaders];
         r = r ? [...r, ...i] : i
     }
     return r && r.length ? r : void 0
 }
-async function _n(e, t, r, i) {
-    t && !Array.isArray(t) && !gn(t) && (i = void 0, r = t, t = void 0), e = await e, r = r || {};
-    let s = gi(e),
-        o = Ig(t, i),
-        a = await Tg(e, o, r);
-    return a ? (r = pg(r, a, o, s), i = Cg({
-        url: s,
-        _parse: _n,
+async function ll(e, t, r, i) {
+    t && !Array.isArray(t) && !al(t) && (i = void 0, r = t, t = void 0), e = await e, r = r || {};
+    let n = lo(e),
+        o = JT(t, i),
+        a = await zT(e, o, r);
+    return a ? (r = FT(r, a, o, n), i = GT({
+        url: n,
+        _parse: ll,
         loaders: o
-    }, r, i || null), await c1(a, e, r, i)) : null
+    }, r, i || null), await d2(a, e, r, i)) : null
 }
-async function c1(e, t, r, i) {
-    if (Oh(e), r = vh(e.options, r), le(t)) {
-        let n = t,
+async function d2(e, t, r, i) {
+    if (T_(e), r = g_(e.options, r), Pr(t)) {
+        let s = t,
             {
                 ok: o,
                 redirected: a,
                 status: c,
                 statusText: l,
-                type: h,
+                type: u,
                 url: f
-            } = n,
-            u = Object.fromEntries(n.headers.entries());
+            } = s,
+            h = Object.fromEntries(s.headers.entries());
         i.response = {
-            headers: u,
+            headers: h,
             ok: o,
             redirected: a,
             status: c,
             statusText: l,
-            type: h,
+            type: u,
             url: f
         }
     }
-    t = await Mg(t, e, r);
-    let s = e;
-    if (s.parseTextSync && typeof t == "string") return s.parseTextSync(t, r, i);
-    if (Nh(e, r)) return await Fh(e, t, r, i, _n);
-    if (s.parseText && typeof t == "string") return await s.parseText(t, r, i);
-    if (s.parse) return await s.parse(t, r, i);
-    throw kt(!s.parseSync), new Error(`${e.id} loader - no parser found and worker is disabled`)
-}
-async function kr(e, t, r, i) {
-    let s, n;
-    !Array.isArray(t) && !gn(t) ? (s = [], n = t, i = void 0) : (s = t, n = r);
-    let o = va(n),
+    t = await KT(t, e, r);
+    let n = e;
+    if (n.parseTextSync && typeof t == "string") return n.parseTextSync(t, r, i);
+    if (v_(e, r)) return await S_(e, t, r, i, ll);
+    if (n.parseText && typeof t == "string") return await n.parseText(t, r, i);
+    if (n.parse) return await n.parse(t, r, i);
+    throw Fe(!n.parseSync), new Error(`${e.id} loader - no parser found and worker is disabled`)
+}
+async function va(e, t, r, i) {
+    let n, s;
+    !Array.isArray(t) && !al(t) ? (n = [], s = t, i = void 0) : (n = t, s = r);
+    let o = Mh(s),
         a = e;
-    return typeof e == "string" && (a = await o(e)), he(e) && (a = await o(e)), Array.isArray(s) ? await _n(a, s, n) : await _n(a, s, n)
+    return typeof e == "string" && (a = await o(e)), Cr(e) && (a = await o(e)), Array.isArray(n) ? await ll(a, n, s) : await ll(a, n, s)
 }
-var Og = "4.1.4";
-var Jh, l1 = (Jh = globalThis.loaders) === null || Jh === void 0 ? void 0 : Jh.parseImageNode,
-    tf = typeof Image < "u",
-    ef = typeof ImageBitmap < "u",
-    h1 = !!l1,
-    rf = fi ? !0 : h1;
+var QT = "4.1.4";
+var j_, p2 = (j_ = globalThis.loaders) === null || j_ === void 0 ? void 0 : j_.parseImageNode,
+    H_ = typeof Image < "u",
+    $_ = typeof ImageBitmap < "u",
+    m2 = !!p2,
+    X_ = so ? !0 : m2;
 
-function Ng(e) {
+function tv(e) {
     switch (e) {
         case "auto":
-            return ef || tf || rf;
+            return $_ || H_ || X_;
         case "imagebitmap":
-            return ef;
+            return $_;
         case "image":
-            return tf;
+            return H_;
         case "data":
-            return rf;
+            return X_;
         default:
             throw new Error(`@loaders.gl/images: image ${e} not supported in this environment`)
     }
 }
 
-function Fg() {
-    if (ef) return "imagebitmap";
-    if (tf) return "image";
-    if (rf) return "data";
+function ev() {
+    if ($_) return "imagebitmap";
+    if (H_) return "image";
+    if (X_) return "data";
     throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js")
 }
 
-function f1(e) {
-    let t = u1(e);
+function g2(e) {
+    let t = _2(e);
     if (!t) throw new Error("Not an image");
     return t
 }
 
-function Dg(e) {
-    switch (f1(e)) {
+function rv(e) {
+    switch (g2(e)) {
         case "data":
             return e;
         case "image":
         case "imagebitmap":
             let t = document.createElement("canvas"),
                 r = t.getContext("2d");
             if (!r) throw new Error("getImageData");
             return t.width = e.width, t.height = e.height, r.drawImage(e, 0, 0), r.getImageData(0, 0, e.width, e.height);
         default:
             throw new Error("getImageData")
     }
 }
 
-function u1(e) {
+function _2(e) {
     return typeof ImageBitmap < "u" && e instanceof ImageBitmap ? "imagebitmap" : typeof Image < "u" && e instanceof Image ? "image" : e && typeof e == "object" && e.data && e.width && e.height ? "data" : null
 }
-var d1 = /^data:image\/svg\+xml/,
-    p1 = /\.svg((\?|#).*)?$/;
+var y2 = /^data:image\/svg\+xml/,
+    b2 = /\.svg((\?|#).*)?$/;
 
-function Ra(e) {
-    return e && (d1.test(e) || p1.test(e))
+function Ph(e) {
+    return e && (y2.test(e) || b2.test(e))
 }
 
-function kg(e, t) {
-    if (Ra(t)) {
+function iv(e, t) {
+    if (Ph(t)) {
         let i = new TextDecoder().decode(e);
         try {
             typeof unescape == "function" && typeof encodeURIComponent == "function" && (i = unescape(encodeURIComponent(i)))
-        } catch (n) {
-            throw new Error(n.message)
+        } catch (s) {
+            throw new Error(s.message)
         }
         return `data:image/svg+xml;base64,${btoa(i)}`
     }
-    return sf(e, t)
+    return Y_(e, t)
 }
 
-function sf(e, t) {
-    if (Ra(t)) throw new Error("SVG cannot be parsed directly to imagebitmap");
+function Y_(e, t) {
+    if (Ph(t)) throw new Error("SVG cannot be parsed directly to imagebitmap");
     return new Blob([new Uint8Array(e)])
 }
-async function Pa(e, t, r) {
-    let i = kg(e, r),
-        s = self.URL || self.webkitURL,
-        n = typeof i != "string" && s.createObjectURL(i);
+async function Ch(e, t, r) {
+    let i = iv(e, r),
+        n = self.URL || self.webkitURL,
+        s = typeof i != "string" && n.createObjectURL(i);
     try {
-        return await g1(n || i, t)
+        return await x2(s || i, t)
     } finally {
-        n && s.revokeObjectURL(n)
+        s && n.revokeObjectURL(s)
     }
 }
-async function g1(e, t) {
+async function x2(e, t) {
     let r = new Image;
-    return r.src = e, t.image && t.image.decode && r.decode ? (await r.decode(), r) : await new Promise((i, s) => {
+    return r.src = e, t.image && t.image.decode && r.decode ? (await r.decode(), r) : await new Promise((i, n) => {
         try {
-            r.onload = () => i(r), r.onerror = n => {
-                let o = n instanceof Error ? n.message : "error";
-                s(new Error(o))
+            r.onload = () => i(r), r.onerror = s => {
+                let o = s instanceof Error ? s.message : "error";
+                n(new Error(o))
             }
-        } catch (n) {
-            s(n)
+        } catch (s) {
+            n(s)
         }
     })
 }
-var m1 = {},
-    Lg = !0;
-async function Bg(e, t, r) {
+var w2 = {},
+    nv = !0;
+async function sv(e, t, r) {
     let i;
-    Ra(r) ? i = await Pa(e, t, r) : i = sf(e, r);
-    let s = t && t.imagebitmap;
-    return await _1(i, s)
+    Ph(r) ? i = await Ch(e, t, r) : i = Y_(e, r);
+    let n = t && t.imagebitmap;
+    return await T2(i, n)
 }
-async function _1(e) {
+async function T2(e) {
     let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
-    if ((y1(t) || !Lg) && (t = null), t) try {
+    if ((v2(t) || !nv) && (t = null), t) try {
         return await createImageBitmap(e, t)
     } catch (r) {
-        console.warn(r), Lg = !1
+        console.warn(r), nv = !1
     }
     return await createImageBitmap(e)
 }
 
-function y1(e) {
-    for (let t in e || m1) return !1;
+function v2(e) {
+    for (let t in e || w2) return !1;
     return !0
 }
 
-function Ug(e) {
-    return !A1(e, "ftyp", 4) || !(e[8] & 96) ? null : x1(e)
+function ov(e) {
+    return !I2(e, "ftyp", 4) || !(e[8] & 96) ? null : S2(e)
 }
 
-function x1(e) {
-    switch (T1(e, 8, 12).replace("\0", " ").trim()) {
+function S2(e) {
+    switch (A2(e, 8, 12).replace("\0", " ").trim()) {
         case "avif":
         case "avis":
             return {
                 extension: "avif", mimeType: "image/avif"
             };
         default:
             return null
     }
 }
 
-function T1(e, t, r) {
+function A2(e, t, r) {
     return String.fromCharCode(...e.slice(t, r))
 }
 
-function b1(e) {
+function E2(e) {
     return [...e].map(t => t.charCodeAt(0))
 }
 
-function A1(e, t) {
+function I2(e, t) {
     let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
-        i = b1(t);
-    for (let s = 0; s < i.length; ++s)
-        if (i[s] !== e[s + r]) return !1;
+        i = E2(t);
+    for (let n = 0; n < i.length; ++n)
+        if (i[n] !== e[n + r]) return !1;
     return !0
 }
-var ze = !1,
-    yn = !0;
+var Di = !1,
+    ul = !0;
 
-function Ma(e) {
-    let t = xn(e);
-    return S1(t) || R1(t) || w1(t) || v1(t) || E1(t)
+function Oh(e) {
+    let t = fl(e);
+    return M2(t) || O2(t) || P2(t) || C2(t) || R2(t)
 }
 
-function E1(e) {
+function R2(e) {
     let t = new Uint8Array(e instanceof DataView ? e.buffer : e),
-        r = Ug(t);
+        r = ov(t);
     return r ? {
         mimeType: r.mimeType,
         width: 0,
         height: 0
     } : null
 }
 
-function S1(e) {
-    let t = xn(e);
-    return t.byteLength >= 24 && t.getUint32(0, ze) === 2303741511 ? {
+function M2(e) {
+    let t = fl(e);
+    return t.byteLength >= 24 && t.getUint32(0, Di) === 2303741511 ? {
         mimeType: "image/png",
-        width: t.getUint32(16, ze),
-        height: t.getUint32(20, ze)
+        width: t.getUint32(16, Di),
+        height: t.getUint32(20, Di)
     } : null
 }
 
-function w1(e) {
-    let t = xn(e);
-    return t.byteLength >= 10 && t.getUint32(0, ze) === 1195984440 ? {
+function P2(e) {
+    let t = fl(e);
+    return t.byteLength >= 10 && t.getUint32(0, Di) === 1195984440 ? {
         mimeType: "image/gif",
-        width: t.getUint16(6, yn),
-        height: t.getUint16(8, yn)
+        width: t.getUint16(6, ul),
+        height: t.getUint16(8, ul)
     } : null
 }
 
-function v1(e) {
-    let t = xn(e);
-    return t.byteLength >= 14 && t.getUint16(0, ze) === 16973 && t.getUint32(2, yn) === t.byteLength ? {
+function C2(e) {
+    let t = fl(e);
+    return t.byteLength >= 14 && t.getUint16(0, Di) === 16973 && t.getUint32(2, ul) === t.byteLength ? {
         mimeType: "image/bmp",
-        width: t.getUint32(18, yn),
-        height: t.getUint32(22, yn)
+        width: t.getUint32(18, ul),
+        height: t.getUint32(22, ul)
     } : null
 }
 
-function R1(e) {
-    let t = xn(e);
-    if (!(t.byteLength >= 3 && t.getUint16(0, ze) === 65496 && t.getUint8(2) === 255)) return null;
+function O2(e) {
+    let t = fl(e);
+    if (!(t.byteLength >= 3 && t.getUint16(0, Di) === 65496 && t.getUint8(2) === 255)) return null;
     let {
         tableMarkers: i,
-        sofMarkers: s
-    } = P1(), n = 2;
-    for (; n + 9 < t.byteLength;) {
-        let o = t.getUint16(n, ze);
-        if (s.has(o)) return {
+        sofMarkers: n
+    } = N2(), s = 2;
+    for (; s + 9 < t.byteLength;) {
+        let o = t.getUint16(s, Di);
+        if (n.has(o)) return {
             mimeType: "image/jpeg",
-            height: t.getUint16(n + 5, ze),
-            width: t.getUint16(n + 7, ze)
+            height: t.getUint16(s + 5, Di),
+            width: t.getUint16(s + 7, Di)
         };
         if (!i.has(o)) return null;
-        n += 2, n += t.getUint16(n, ze)
+        s += 2, s += t.getUint16(s, Di)
     }
     return null
 }
 
-function P1() {
+function N2() {
     let e = new Set([65499, 65476, 65484, 65501, 65534]);
     for (let r = 65504; r < 65520; ++r) e.add(r);
     return {
         tableMarkers: e,
         sofMarkers: new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502])
     }
 }
 
-function xn(e) {
+function fl(e) {
     if (e instanceof DataView) return e;
     if (ArrayBuffer.isView(e)) return new DataView(e.buffer);
     if (e instanceof ArrayBuffer) return new DataView(e);
     throw new Error("toDataView")
 }
-async function Vg(e, t) {
+async function av(e, t) {
     var r;
     let {
         mimeType: i
-    } = Ma(e) || {}, s = (r = globalThis.loaders) === null || r === void 0 ? void 0 : r.parseImageNode;
-    return Nr(s), await s(e, i)
+    } = Oh(e) || {}, n = (r = globalThis.loaders) === null || r === void 0 ? void 0 : r.parseImageNode;
+    return ps(n), await n(e, i)
 }
-async function zg(e, t, r) {
+async function cv(e, t, r) {
     t = t || {};
-    let s = (t.image || {}).type || "auto",
+    let n = (t.image || {}).type || "auto",
         {
-            url: n
+            url: s
         } = r || {},
-        o = M1(s),
+        o = B2(n),
         a;
     switch (o) {
         case "imagebitmap":
-            a = await Bg(e, t, n);
+            a = await sv(e, t, s);
             break;
         case "image":
-            a = await Pa(e, t, n);
+            a = await Ch(e, t, s);
             break;
         case "data":
-            a = await Vg(e, t);
+            a = await av(e, t);
             break;
         default:
-            Nr(!1)
+            ps(!1)
     }
-    return s === "data" && (a = Dg(a)), a
+    return n === "data" && (a = rv(a)), a
 }
 
-function M1(e) {
+function B2(e) {
     switch (e) {
         case "auto":
         case "data":
-            return Fg();
+            return ev();
         default:
-            return Ng(e), e
+            return tv(e), e
     }
 }
-var C1 = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"],
-    I1 = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/avif", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"],
-    O1 = {
+var F2 = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"],
+    D2 = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/avif", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"],
+    L2 = {
         image: {
             type: "auto",
             decode: !0
         }
     },
-    nf = {
+    q_ = {
         id: "image",
         module: "images",
         name: "Images",
-        version: Og,
-        mimeTypes: I1,
-        extensions: C1,
-        parse: zg,
-        tests: [e => !!Ma(new DataView(e))],
-        options: O1
+        version: QT,
+        mimeTypes: D2,
+        extensions: F2,
+        parse: cv,
+        tests: [e => !!Oh(new DataView(e))],
+        options: L2
     };
-var N1 = new $t({
+var k2 = new ye({
         id: "deck"
     }),
-    j = N1;
-var of = {};
+    Z = k2;
+var Z_ = {};
 
-function Wg(e) {
-    of = e
+function lv(e) {
+    Z_ = e
 }
 
-function pt(e, t, r, i) {
-    j.level > 0 && of [e] && of [e].call(null, t, r, i)
+function Qt(e, t, r, i) {
+    Z.level > 0 && Z_[e] && Z_[e].call(null, t, r, i)
 }
 
-function F1(e) {
+function U2(e) {
     let t = e[0],
         r = e[e.length - 1];
     return t === "{" && r === "}" || t === "[" && r === "]"
 }
-var jg = {
+var uv = {
     id: "JSON",
     name: "JSON",
     module: "",
     version: "",
     options: {},
     extensions: ["json", "geojson"],
     mimeTypes: ["application/json", "application/geo+json"],
-    testText: F1,
+    testText: U2,
     parseTextSync: JSON.parse
 };
 
-function D1() {
+function V2() {
     let e = "9.0.5",
         t = globalThis.deck && globalThis.deck.VERSION;
     if (t && t !== e) throw new Error(`deck.gl - multiple versions detected: ${t} vs ${e}`);
-    return t || (j.log(1, `deck.gl ${e}`)(), globalThis.deck = {
+    return t || (Z.log(1, `deck.gl ${e}`)(), globalThis.deck = {
         ...globalThis.deck,
         VERSION: e,
         version: e,
-        log: j,
-        _registerLoggers: Wg
-    }, Zh([jg, [nf, {
+        log: Z,
+        _registerLoggers: lv
+    }, U_([uv, [q_, {
         imagebitmap: {
             premultiplyAlpha: "none"
         }
     }]])), e
 }
-var af = D1();
+var K_ = V2();
 
-function We(e, t) {
+function Li(e, t) {
     if (!e) throw new Error(t || "shadertools: assertion failed.")
 }
-var cf = {
+var G_ = {
     number: {
         type: "number",
         validate(e, t) {
             return Number.isFinite(e) && typeof t == "object" && (t.max === void 0 || e <= t.max) && (t.min === void 0 || e >= t.min)
         }
     },
     array: {
         type: "array",
         validate(e, t) {
             return Array.isArray(e) || ArrayBuffer.isView(e)
         }
     }
 };
 
-function Xg(e) {
+function hv(e) {
     let t = {};
-    for (let [r, i] of Object.entries(e)) t[r] = k1(i);
+    for (let [r, i] of Object.entries(e)) t[r] = z2(i);
     return t
 }
 
-function $g(e, t, r) {
+function dv(e, t, r) {
     let i = {};
-    for (let [s, n] of Object.entries(t)) e && s in e && !n.private ? (n.validate && We(n.validate(e[s], n), `${r}: invalid ${s}`), i[s] = e[s]) : i[s] = n.value;
+    for (let [n, s] of Object.entries(t)) e && n in e && !s.private ? (s.validate && Li(s.validate(e[n], s), `${r}: invalid ${n}`), i[n] = e[n]) : i[n] = s.value;
     return i
 }
 
-function k1(e) {
-    let t = Hg(e);
+function z2(e) {
+    let t = fv(e);
     if (t !== "object") return {
         value: e,
-        ...cf[t],
+        ...G_[t],
         type: t
     };
     if (typeof e == "object") return e ? e.type !== void 0 ? {
         ...e,
-        ...cf[e.type],
+        ...G_[e.type],
         type: e.type
     } : e.value === void 0 ? {
         type: "object",
         value: e
-    } : (t = Hg(e.value), {
+    } : (t = fv(e.value), {
         ...e,
-        ...cf[t],
+        ...G_[t],
         type: t
     }) : {
         type: "object",
         value: null
     };
     throw new Error("props")
 }
 
-function Hg(e) {
+function fv(e) {
     return Array.isArray(e) || ArrayBuffer.isView(e) ? "array" : typeof e
 }
-var Yg = `#ifdef MODULE_LOGDEPTH
+var pv = `#ifdef MODULE_LOGDEPTH
 logdepth_adjustPosition(gl_Position);
 #endif
 `,
-    qg = `#ifdef MODULE_MATERIAL
+    mv = `#ifdef MODULE_MATERIAL
 gl_FragColor = material_filterColor(gl_FragColor);
 #endif
 #ifdef MODULE_LIGHTING
 gl_FragColor = lighting_filterColor(gl_FragColor);
 #endif
 #ifdef MODULE_FOG
 gl_FragColor = fog_filterColor(gl_FragColor);
@@ -3417,141 +3417,141 @@
 gl_FragColor = picking_filterHighlightColor(gl_FragColor);
 gl_FragColor = picking_filterPickingColor(gl_FragColor);
 #endif
 #ifdef MODULE_LOGDEPTH
 logdepth_setFragDepth();
 #endif
 `;
-var L1 = {
-        vertex: Yg,
-        fragment: qg
-    },
-    Zg = /void\s+main\s*\([^)]*\)\s*\{\n?/,
-    Kg = /}\n?[^{}]*$/,
-    lf = [],
-    Tn = "__LUMA_INJECT_DECLARATIONS__";
+var W2 = {
+        vertex: pv,
+        fragment: mv
+    },
+    gv = /void\s+main\s*\([^)]*\)\s*\{\n?/,
+    _v = /}\n?[^{}]*$/,
+    J_ = [],
+    hl = "__LUMA_INJECT_DECLARATIONS__";
 
-function Qg(e) {
+function yv(e) {
     let t = {
         vertex: {},
         fragment: {}
     };
     for (let r in e) {
         let i = e[r],
-            s = B1(r);
+            n = j2(r);
         typeof i == "string" && (i = {
             order: 0,
             injection: i
-        }), t[s][r] = i
+        }), t[n][r] = i
     }
     return t
 }
 
-function B1(e) {
+function j2(e) {
     let t = e.slice(0, 2);
     switch (t) {
         case "vs":
             return "vertex";
         case "fs":
             return "fragment";
         default:
             throw new Error(t)
     }
 }
 
-function bn(e, t, r, i = !1) {
-    let s = t === "vertex";
-    for (let n in r) {
-        let o = r[n];
-        o.sort((c, l) => c.order - l.order), lf.length = o.length;
-        for (let c = 0, l = o.length; c < l; ++c) lf[c] = o[c].injection;
-        let a = `${lf.join(`
+function dl(e, t, r, i = !1) {
+    let n = t === "vertex";
+    for (let s in r) {
+        let o = r[s];
+        o.sort((c, l) => c.order - l.order), J_.length = o.length;
+        for (let c = 0, l = o.length; c < l; ++c) J_[c] = o[c].injection;
+        let a = `${J_.join(`
 `)}
 `;
-        switch (n) {
+        switch (s) {
             case "vs:#decl":
-                s && (e = e.replace(Tn, a));
+                n && (e = e.replace(hl, a));
                 break;
             case "vs:#main-start":
-                s && (e = e.replace(Zg, c => c + a));
+                n && (e = e.replace(gv, c => c + a));
                 break;
             case "vs:#main-end":
-                s && (e = e.replace(Kg, c => a + c));
+                n && (e = e.replace(_v, c => a + c));
                 break;
             case "fs:#decl":
-                s || (e = e.replace(Tn, a));
+                n || (e = e.replace(hl, a));
                 break;
             case "fs:#main-start":
-                s || (e = e.replace(Zg, c => c + a));
+                n || (e = e.replace(gv, c => c + a));
                 break;
             case "fs:#main-end":
-                s || (e = e.replace(Kg, c => a + c));
+                n || (e = e.replace(_v, c => a + c));
                 break;
             default:
-                e = e.replace(n, c => c + a)
+                e = e.replace(s, c => c + a)
         }
     }
-    return e = e.replace(Tn, ""), i && (e = e.replace(/\}\s*$/, n => n + L1[t])), e
+    return e = e.replace(hl, ""), i && (e = e.replace(/\}\s*$/, s => s + W2[t])), e
 }
-var U1 = 1,
-    ns = class e {
+var H2 = 1,
+    Sa = class e {
         constructor(t) {
-            p(this, "name");
-            p(this, "vs");
-            p(this, "fs");
-            p(this, "getModuleUniforms");
-            p(this, "dependencies");
-            p(this, "deprecations");
-            p(this, "defines");
-            p(this, "injections");
-            p(this, "uniforms", {});
-            p(this, "uniformTypes", {});
+            m(this, "name");
+            m(this, "vs");
+            m(this, "fs");
+            m(this, "getModuleUniforms");
+            m(this, "dependencies");
+            m(this, "deprecations");
+            m(this, "defines");
+            m(this, "injections");
+            m(this, "uniforms", {});
+            m(this, "uniformTypes", {});
             let {
                 name: r,
                 vs: i,
-                fs: s,
-                dependencies: n = [],
+                fs: n,
+                dependencies: s = [],
                 uniformPropTypes: o = {},
                 getUniforms: a,
                 deprecations: c = [],
                 defines: l = {},
-                inject: h = {}
+                inject: u = {}
             } = t;
-            We(typeof r == "string"), this.name = r, this.vs = i, this.fs = s, this.getModuleUniforms = a, this.dependencies = e.instantiateModules(n), this.deprecations = this._parseDeprecationDefinitions(c), this.defines = l, this.injections = Qg(h), o && (this.uniforms = Xg(o))
+            Li(typeof r == "string"), this.name = r, this.vs = i, this.fs = n, this.getModuleUniforms = a, this.dependencies = e.instantiateModules(s), this.deprecations = this._parseDeprecationDefinitions(c), this.defines = l, this.injections = yv(u), o && (this.uniforms = hv(o))
         }
         static instantiateModules(t) {
             return t.map(r => {
                 if (r instanceof e) return r;
-                We(typeof r != "string", `Shader module use by name is deprecated. Import shader module '${JSON.stringify(r)}' and use it directly.`), r.name || (console.warn("shader module has no name"), r.name = `shader-module-${U1++}`);
+                Li(typeof r != "string", `Shader module use by name is deprecated. Import shader module '${JSON.stringify(r)}' and use it directly.`), r.name || (console.warn("shader module has no name"), r.name = `shader-module-${H2++}`);
                 let i = new e(r);
                 return i.dependencies = e.instantiateModules(r.dependencies || []), i
             })
         }
         getModuleSource(t) {
             let r;
             switch (t) {
                 case "vertex":
                     r = this.vs || "";
                     break;
                 case "fragment":
                     r = this.fs || "";
                     break;
                 default:
-                    We(!1)
+                    Li(!1)
             }
             let i = this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
             return `// ----- MODULE ${this.name} ---------------
 
 #define MODULE_${i}
 ${r}
 
 `
         }
         getUniforms(t, r) {
-            return this.getModuleUniforms ? this.getModuleUniforms(t, r) : $g(t, this.uniforms, this.name)
+            return this.getModuleUniforms ? this.getModuleUniforms(t, r) : dv(t, this.uniforms, this.name)
         }
         getDefines() {
             return this.defines
         }
         checkDeprecations(t, r) {
             this.deprecations.forEach(i => {
                 i.regex?.test(t) && (i.deprecated ? r.deprecated(i.old, i.new)() : r.removed(i.old, i.new)())
@@ -3567,84 +3567,84 @@
                         r.regex = new RegExp(`${r.type} ${r.old};`)
                 }
             }), t
         }
         _defaultGetUniforms(t = {}) {
             let r = {},
                 i = this.uniforms;
-            for (let s in i) {
-                let n = i[s];
-                s in t && !n.private ? (n.validate && We(n.validate(t[s], n), `${this.name}: invalid ${s}`), r[s] = t[s]) : r[s] = n.value
+            for (let n in i) {
+                let s = i[n];
+                n in t && !s.private ? (s.validate && Li(s.validate(t[n], s), `${this.name}: invalid ${n}`), r[n] = t[n]) : r[n] = s.value
             }
             return r
         }
     };
 
-function hf(e) {
+function Q_(e) {
     if (e.source && e.platformInfo.type === "webgpu") return {
         ...e,
         vs: void 0,
         fs: void 0
     };
     if (!e.vs) throw new Error("no vertex shader");
-    let t = Gg(e.platformInfo, e.vs),
+    let t = bv(e.platformInfo, e.vs),
         r;
-    return e.fs && (r = Gg(e.platformInfo, e.fs)), {
+    return e.fs && (r = bv(e.platformInfo, e.fs)), {
         ...e,
         vs: t,
         fs: r
     }
 }
 
-function Gg(e, t) {
+function bv(e, t) {
     if (typeof t == "string") return t;
     switch (e.type) {
         case "webgpu":
             if (t?.wgsl) return t.wgsl;
             throw new Error("WebGPU does not support GLSL shaders");
         default:
             if (t?.glsl) return t.glsl;
             throw new Error("WebGL does not support WGSL shaders")
     }
 }
 
-function _i(e) {
-    let t = ns.instantiateModules(e);
-    return V1(t)
+function fo(e) {
+    let t = Sa.instantiateModules(e);
+    return $2(t)
 }
 
-function V1(e) {
+function $2(e) {
     let t = {},
         r = {};
-    return Jg({
+    return xv({
         modules: e,
         level: 0,
         moduleMap: t,
         moduleDepth: r
-    }), Object.keys(r).sort((i, s) => r[s] - r[i]).map(i => t[i])
+    }), Object.keys(r).sort((i, n) => r[n] - r[i]).map(i => t[i])
 }
 
-function Jg(e) {
+function xv(e) {
     let {
         modules: t,
         level: r,
         moduleMap: i,
-        moduleDepth: s
+        moduleDepth: n
     } = e;
     if (r >= 5) throw new Error("Possible loop in shader dependency graph");
-    for (let n of t) i[n.name] = n, (s[n.name] === void 0 || s[n.name] < r) && (s[n.name] = r);
-    for (let n of t) n.dependencies && Jg({
-        modules: n.dependencies,
+    for (let s of t) i[s.name] = s, (n[s.name] === void 0 || n[s.name] < r) && (n[s.name] = r);
+    for (let s of t) s.dependencies && xv({
+        modules: s.dependencies,
         level: r + 1,
         moduleMap: i,
-        moduleDepth: s
+        moduleDepth: n
     })
 }
 
-function tm(e) {
+function wv(e) {
     switch (e?.gpu.toLowerCase()) {
         case "apple":
             return `#define APPLE_GPU
 #define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
 #define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
 #define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
 `;
@@ -3666,332 +3666,332 @@
 #define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
 #define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
 #define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
 `
     }
 }
 
-function rm(e, t) {
+function vv(e, t) {
     if (Number(e.match(/^#version[ \t]+(\d+)/m)?.[1] || 100) !== 300) throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
     switch (t) {
         case "vertex":
-            return e = em(e, z1), e;
+            return e = Tv(e, X2), e;
         case "fragment":
-            return e = em(e, W1), e;
+            return e = Tv(e, Y2), e;
         default:
             throw new Error(t)
     }
 }
-var im = [
+var Sv = [
         [/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, `#version 300 es
 `],
         [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
         [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
     ],
-    z1 = [...im, [ff("attribute"), "in $1"],
-        [ff("varying"), "out $1"]
+    X2 = [...Sv, [ty("attribute"), "in $1"],
+        [ty("varying"), "out $1"]
     ],
-    W1 = [...im, [ff("varying"), "in $1"]];
+    Y2 = [...Sv, [ty("varying"), "in $1"]];
 
-function em(e, t) {
+function Tv(e, t) {
     for (let [r, i] of t) e = e.replace(r, i);
     return e
 }
 
-function ff(e) {
+function ty(e) {
     return new RegExp(`\\b${e}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g")
 }
 
-function uf(e, t) {
+function ey(e, t) {
     let r = "";
     for (let i in e) {
-        let s = e[i];
-        if (r += `void ${s.signature} {
-`, s.header && (r += `  ${s.header}`), t[i]) {
-            let n = t[i];
-            n.sort((o, a) => o.order - a.order);
-            for (let o of n) r += `  ${o.injection}
+        let n = e[i];
+        if (r += `void ${n.signature} {
+`, n.header && (r += `  ${n.header}`), t[i]) {
+            let s = t[i];
+            s.sort((o, a) => o.order - a.order);
+            for (let o of s) r += `  ${o.injection}
 `
         }
-        s.footer && (r += `  ${s.footer}`), r += `}
+        n.footer && (r += `  ${n.footer}`), r += `}
 `
     }
     return r
 }
 
-function df(e) {
+function ry(e) {
     let t = {
         vertex: {},
         fragment: {}
     };
     for (let r of e) {
-        let i, s;
-        typeof r != "string" ? (i = r, s = i.hook) : (i = {}, s = r), s = s.trim();
-        let [n, o] = s.split(":"), a = s.replace(/\(.+/, ""), c = Object.assign(i, {
+        let i, n;
+        typeof r != "string" ? (i = r, n = i.hook) : (i = {}, n = r), n = n.trim();
+        let [s, o] = n.split(":"), a = n.replace(/\(.+/, ""), c = Object.assign(i, {
             signature: o
         });
-        switch (n) {
+        switch (s) {
             case "vs":
                 t.vertex[a] = c;
                 break;
             case "fs":
                 t.fragment[a] = c;
                 break;
             default:
-                throw new Error(n)
+                throw new Error(s)
         }
     }
     return t
 }
 
-function sm(e, t) {
+function Av(e, t) {
     return {
-        name: j1(e, t),
+        name: q2(e, t),
         language: "glsl",
-        version: H1(e)
+        version: Z2(e)
     }
 }
 
-function j1(e, t = "unnamed") {
+function q2(e, t = "unnamed") {
     let i = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(e);
     return i ? i[1] : t
 }
 
-function H1(e) {
+function Z2(e) {
     let t = 100,
         r = e.match(/[^\s]+/g);
     if (r && r.length >= 2 && r[0] === "#version") {
         let i = parseInt(r[1], 10);
         Number.isFinite(i) && (t = i)
     }
     if (t !== 100 && t !== 300) throw new Error(`Invalid GLSL version ${t}`);
     return t
 }
-var om = `
+var Iv = `
 
-${Tn}
+${hl}
 `,
-    X1 = `precision highp float;
+    K2 = `precision highp float;
 `;
 
-function am(e) {
-    let t = _i(e.modules || []);
+function Rv(e) {
+    let t = fo(e.modules || []);
     return {
-        source: pf(e.platformInfo, {
+        source: iy(e.platformInfo, {
             ...e,
             source: e.source,
             stage: "vertex",
             modules: t
         }),
-        getUniforms: gf(t)
+        getUniforms: ny(t)
     }
 }
 
-function cm(e) {
-    let t = _i(e.modules || []);
+function Mv(e) {
+    let t = fo(e.modules || []);
     return {
-        vs: pf(e.platformInfo, {
+        vs: iy(e.platformInfo, {
             ...e,
             source: e.vs,
             stage: "vertex",
             modules: t
         }),
-        fs: pf(e.platformInfo, {
+        fs: iy(e.platformInfo, {
             ...e,
             source: e.fs,
             stage: "fragment",
             modules: t
         }),
-        getUniforms: gf(t)
+        getUniforms: ny(t)
     }
 }
 
-function lm(e) {
+function Pv(e) {
     let {
         vs: t,
         fs: r
-    } = e, i = _i(e.modules || []);
+    } = e, i = fo(e.modules || []);
     return {
-        vs: nm(e.platformInfo, {
+        vs: Ev(e.platformInfo, {
             ...e,
             source: t,
             stage: "vertex",
             modules: i
         }),
-        fs: nm(e.platformInfo, {
+        fs: Ev(e.platformInfo, {
             ...e,
             source: r,
             stage: "fragment",
             modules: i
         }),
-        getUniforms: gf(i)
+        getUniforms: ny(i)
     }
 }
 
-function pf(e, t) {
+function iy(e, t) {
     let {
         source: r,
         stage: i,
-        modules: s,
-        hookFunctions: n = [],
+        modules: n,
+        hookFunctions: s = [],
         inject: o = {},
         log: a
     } = t;
-    We(typeof r == "string", "shader source must be a string");
+    Li(typeof r == "string", "shader source must be a string");
     let c = r,
         l = "",
-        h = df(n),
+        u = ry(s),
         f = {},
-        u = {},
+        h = {},
         d = {};
     for (let y in o) {
-        let x = typeof o[y] == "string" ? {
+        let b = typeof o[y] == "string" ? {
                 injection: o[y],
                 order: 0
             } : o[y],
-            A = /^(v|f)s:(#)?([\w-]+)$/.exec(y);
-        if (A) {
-            let v = A[2],
-                E = A[3];
-            v ? E === "decl" ? u[y] = [x] : d[y] = [x] : f[y] = [x]
-        } else d[y] = [x]
+            T = /^(v|f)s:(#)?([\w-]+)$/.exec(y);
+        if (T) {
+            let I = T[2],
+                S = T[3];
+            I ? S === "decl" ? h[y] = [b] : d[y] = [b] : f[y] = [b]
+        } else d[y] = [b]
     }
-    let m = e.type !== "webgpu" ? s : [];
-    for (let y of m) {
+    let p = e.type !== "webgpu" ? n : [];
+    for (let y of p) {
         a && y.checkDeprecations(c, a);
-        let x = y.getModuleSource(i, "wgsl");
-        l += x;
-        let A = y.injections[i];
-        for (let v in A) {
-            let E = /^(v|f)s:#([\w-]+)$/.exec(v);
-            if (E) {
-                let M = E[2] === "decl" ? u : d;
-                M[v] = M[v] || [], M[v].push(A[v])
-            } else f[v] = f[v] || [], f[v].push(A[v])
+        let b = y.getModuleSource(i, "wgsl");
+        l += b;
+        let T = y.injections[i];
+        for (let I in T) {
+            let S = /^(v|f)s:#([\w-]+)$/.exec(I);
+            if (S) {
+                let P = S[2] === "decl" ? h : d;
+                P[I] = P[I] || [], P[I].push(T[I])
+            } else f[I] = f[I] || [], f[I].push(T[I])
         }
     }
-    return l += om, l = bn(l, i, u), l += uf(h[i], f), l += c, l = bn(l, i, d), l
+    return l += Iv, l = dl(l, i, h), l += ey(u[i], f), l += c, l = dl(l, i, d), l
 }
 
-function nm(e, t) {
+function Ev(e, t) {
     let {
         id: r,
         source: i,
-        stage: s,
-        language: n = "glsl",
+        stage: n,
+        language: s = "glsl",
         modules: o,
         defines: a = {},
         hookFunctions: c = [],
         inject: l = {},
-        prologue: h = !0,
+        prologue: u = !0,
         log: f
     } = t;
-    We(typeof i == "string", "shader source must be a string");
-    let u = n === "glsl" ? sm(i).version : -1,
+    Li(typeof i == "string", "shader source must be a string");
+    let h = s === "glsl" ? Av(i).version : -1,
         d = e.shaderLanguageVersion,
-        m = u === 100 ? "#version 100" : "#version 300 es",
-        x = i.split(`
+        p = h === 100 ? "#version 100" : "#version 300 es",
+        b = i.split(`
 `).slice(1).join(`
 `),
-        A = {};
-    o.forEach(B => {
-        Object.assign(A, B.getDefines())
-    }), Object.assign(A, a);
-    let v = "";
-    switch (n) {
+        T = {};
+    o.forEach(V => {
+        Object.assign(T, V.getDefines())
+    }), Object.assign(T, a);
+    let I = "";
+    switch (s) {
         case "wgsl":
             break;
         case "glsl":
-            v = h ? `${m}
+            I = u ? `${p}
 
 // ----- PROLOGUE -------------------------
-${$1({id:r,source:i,stage:s})}
-${`#define SHADER_TYPE_${s.toUpperCase()}`}
-${tm(e)}
-${s==="fragment"?X1:""}
+${G2({id:r,source:i,stage:n})}
+${`#define SHADER_TYPE_${n.toUpperCase()}`}
+${wv(e)}
+${n==="fragment"?K2:""}
 
 // ----- APPLICATION DEFINES -------------------------
 
-${Y1(A)}
+${J2(T)}
 
-` : `${m}
+` : `${p}
 `;
             break
     }
-    let E = df(c),
+    let S = ry(c),
         R = {},
-        M = {},
+        P = {},
         C = {};
-    for (let B in l) {
-        let L = typeof l[B] == "string" ? {
-                injection: l[B],
+    for (let V in l) {
+        let U = typeof l[V] == "string" ? {
+                injection: l[V],
                 order: 0
-            } : l[B],
-            k = /^(v|f)s:(#)?([\w-]+)$/.exec(B);
+            } : l[V],
+            k = /^(v|f)s:(#)?([\w-]+)$/.exec(V);
         if (k) {
-            let N = k[2],
-                H = k[3];
-            N ? H === "decl" ? M[B] = [L] : C[B] = [L] : R[B] = [L]
-        } else C[B] = [L]
-    }
-    for (let B of o) {
-        f && B.checkDeprecations(x, f);
-        let L = B.getModuleSource(s);
-        v += L;
-        let k = B.injections[s];
-        for (let N in k) {
-            let H = /^(v|f)s:#([\w-]+)$/.exec(N);
-            if (H) {
-                let X = H[2] === "decl" ? M : C;
-                X[N] = X[N] || [], X[N].push(k[N])
-            } else R[N] = R[N] || [], R[N].push(k[N])
+            let B = k[2],
+                K = k[3];
+            B ? K === "decl" ? P[V] = [U] : C[V] = [U] : R[V] = [U]
+        } else C[V] = [U]
+    }
+    for (let V of o) {
+        f && V.checkDeprecations(b, f);
+        let U = V.getModuleSource(n);
+        I += U;
+        let k = V.injections[n];
+        for (let B in k) {
+            let K = /^(v|f)s:#([\w-]+)$/.exec(B);
+            if (K) {
+                let G = K[2] === "decl" ? P : C;
+                G[B] = G[B] || [], G[B].push(k[B])
+            } else R[B] = R[B] || [], R[B].push(k[B])
         }
     }
-    return v += "// ----- MAIN SHADER SOURCE -------------------------", v += om, v = bn(v, s, M), v += uf(E[s], R), v += x, v = bn(v, s, C), n === "glsl" && u !== d && (v = rm(v, s)), v.trim()
+    return I += "// ----- MAIN SHADER SOURCE -------------------------", I += Iv, I = dl(I, n, P), I += ey(S[n], R), I += b, I = dl(I, n, C), s === "glsl" && h !== d && (I = vv(I, n)), I.trim()
 }
 
-function gf(e) {
+function ny(e) {
     return function(r) {
         let i = {};
-        for (let s of e) {
-            let n = s.getUniforms(r, i);
-            Object.assign(i, n)
+        for (let n of e) {
+            let s = n.getUniforms(r, i);
+            Object.assign(i, s)
         }
         return i
     }
 }
 
-function $1(e) {
+function G2(e) {
     let {
         id: t,
         source: r,
         stage: i
     } = e;
     return t && r.indexOf("SHADER_NAME") === -1 ? `
 #define SHADER_NAME ${t}_${i}
 
 ` : ""
 }
 
-function Y1(e = {}) {
+function J2(e = {}) {
     let t = "";
     for (let r in e) {
         let i = e[r];
         (i || Number.isFinite(i)) && (t += `#define ${r.toUpperCase()} ${e[r]}
 `)
     }
     return t
 }
-var yi = class yi {
+var ho = class ho {
     constructor() {
-        p(this, "_hookFunctions", []);
-        p(this, "_defaultModules", [])
+        m(this, "_hookFunctions", []);
+        m(this, "_defaultModules", [])
     }
     static getDefaultShaderAssembler() {
-        return yi.defaultShaderAssembler = yi.defaultShaderAssembler || new yi, yi.defaultShaderAssembler
+        return ho.defaultShaderAssembler = ho.defaultShaderAssembler || new ho, ho.defaultShaderAssembler
     }
     addDefaultModule(t) {
         this._defaultModules.find(r => r.name === (typeof t == "string" ? t : t.name)) || this._defaultModules.push(t)
     }
     removeDefaultModule(t) {
         let r = typeof t == "string" ? t : t.name;
         this._defaultModules = this._defaultModules.filter(i => i.name !== r)
@@ -4000,187 +4000,187 @@
         r && (t = Object.assign(r, {
             hook: t
         })), this._hookFunctions.push(t)
     }
     assembleShader(t) {
         let r = this._getModuleList(t.modules),
             i = this._hookFunctions,
-            s = hf(t);
+            n = Q_(t);
         return {
-            ...am({
+            ...Rv({
                 platformInfo: t.platformInfo,
-                ...s,
+                ...n,
                 modules: r,
                 hookFunctions: i
             }),
             modules: r
         }
     }
     assembleShaderPair(t) {
-        let r = hf(t),
+        let r = Q_(t),
             i = this._getModuleList(t.modules),
-            s = this._hookFunctions,
+            n = this._hookFunctions,
             {
-                platformInfo: n
+                platformInfo: s
             } = t;
         return {
-            ...t.platformInfo.shaderLanguage === "wgsl" ? cm({
-                platformInfo: n,
+            ...t.platformInfo.shaderLanguage === "wgsl" ? Mv({
+                platformInfo: s,
                 ...r,
                 modules: i,
-                hookFunctions: s
-            }) : lm({
-                platformInfo: n,
+                hookFunctions: n
+            }) : Pv({
+                platformInfo: s,
                 ...r,
                 modules: i,
-                hookFunctions: s
+                hookFunctions: n
             }),
             modules: i
         }
     }
     _getModuleList(t = []) {
         let r = new Array(this._defaultModules.length + t.length),
             i = {},
-            s = 0;
-        for (let n = 0, o = this._defaultModules.length; n < o; ++n) {
-            let a = this._defaultModules[n],
+            n = 0;
+        for (let s = 0, o = this._defaultModules.length; s < o; ++s) {
+            let a = this._defaultModules[s],
                 c = a.name;
-            r[s++] = a, i[c] = !0
+            r[n++] = a, i[c] = !0
         }
-        for (let n = 0, o = t.length; n < o; ++n) {
-            let a = t[n],
+        for (let s = 0, o = t.length; s < o; ++s) {
+            let a = t[s],
                 c = a.name;
-            i[c] || (r[s++] = a, i[c] = !0)
+            i[c] || (r[n++] = a, i[c] = !0)
         }
-        return r.length = s, ns.instantiateModules(r)
+        return r.length = n, Sa.instantiateModules(r)
     }
 };
-p(yi, "defaultShaderAssembler");
-var xi = yi;
-var q1 = `out vec4 transform_output;
+m(ho, "defaultShaderAssembler");
+var po = ho;
+var Q2 = `out vec4 transform_output;
 void main() {
 transform_output = vec4(0);
 }`,
-    Z1 = `#version 300 es
-${q1}`;
+    tC = `#version 300 es
+${Q2}`;
 
-function mf(e) {
+function sy(e) {
     let {
         input: t,
         inputChannels: r,
         output: i
     } = e || {};
-    if (!t) return Z1;
+    if (!t) return tC;
     if (!r) throw new Error("inputChannels");
-    let s = K1(r),
-        n = hm(t, r);
+    let n = eC(r),
+        s = Cv(t, r);
     return `#version 300 es
-in ${s} ${t};
+in ${n} ${t};
 out vec4 ${i};
 void main() {
-  ${i} = ${n};
+  ${i} = ${s};
 }`
 }
 
-function K1(e) {
+function eC(e) {
     switch (e) {
         case 1:
             return "float";
         case 2:
             return "vec2";
         case 3:
             return "vec3";
         case 4:
             return "vec4";
         default:
             throw new Error(`invalid channels: ${e}`)
     }
 }
 
-function hm(e, t) {
+function Cv(e, t) {
     switch (t) {
         case 1:
             return `vec4(${e}, 0.0, 0.0, 1.0)`;
         case 2:
             return `vec4(${e}, 0.0, 1.0)`;
         case 3:
             return `vec4(${e}, 1.0)`;
         case 4:
             return e;
         default:
             throw new Error(`invalid channels: ${t}`)
     }
 }
-var O = new $t({
+var N = new ye({
     id: "luma.gl"
 });
-var _f = class {
+var oy = class {
         constructor() {
-            p(this, "stats", new Map)
+            m(this, "stats", new Map)
         }
         getStats(t) {
             return this.get(t)
         }
         get(t) {
-            return this.stats.has(t) || this.stats.set(t, new Xt({
+            return this.stats.has(t) || this.stats.set(t, new Ke({
                 id: t
             })), this.stats.get(t)
         }
     },
-    os = new _f;
+    Aa = new oy;
 
-function Q1() {
+function rC() {
     let e = "9.0.9",
         t = "set luma.log.level=1 (or higher) to trace rendering";
     if (globalThis.luma && globalThis.luma.VERSION !== e) throw new Error(`luma.gl - multiple VERSIONs detected: ${globalThis.luma.VERSION} vs ${e}`);
-    return globalThis.luma || (Ot() && O.log(1, `${e} - ${t}`)(), globalThis.luma = globalThis.luma || {
+    return globalThis.luma || (Me() && N.log(1, `${e} - ${t}`)(), globalThis.luma = globalThis.luma || {
         VERSION: e,
         version: e,
-        log: O,
-        stats: os
+        log: N,
+        stats: Aa
     }), e
 }
-var fm = Q1();
+var Ov = rC();
 
-function G1(e) {
+function iC(e) {
     return ArrayBuffer.isView(e) && !(e instanceof DataView) ? e : null
 }
 
-function Lr(e) {
-    return Array.isArray(e) ? e.length === 0 || typeof e[0] == "number" ? e : null : G1(e)
+function _s(e) {
+    return Array.isArray(e) ? e.length === 0 || typeof e[0] == "number" ? e : null : iC(e)
 }
-var yf = {};
+var ay = {};
 
-function Lt(e = "id") {
-    yf[e] = yf[e] || 1;
-    let t = yf[e]++;
+function De(e = "id") {
+    ay[e] = ay[e] || 1;
+    let t = ay[e]++;
     return `${e}-${t}`
 }
 
-function Br(e) {
+function ys(e) {
     let t = !0;
     for (let r in e) {
         t = !1;
         break
     }
     return t
 }
-var q = class {
+var dt = class {
     constructor(t, r, i) {
-        p(this, "id");
-        p(this, "props");
-        p(this, "userData", {});
-        p(this, "_device");
-        p(this, "destroyed", !1);
-        p(this, "allocatedBytes", 0);
-        p(this, "_attachedResources", new Set);
+        m(this, "id");
+        m(this, "props");
+        m(this, "userData", {});
+        m(this, "_device");
+        m(this, "destroyed", !1);
+        m(this, "allocatedBytes", 0);
+        m(this, "_attachedResources", new Set);
         if (!t) throw new Error("no device");
-        this._device = t, this.props = J1(r, i);
-        let s = this.props.id !== "undefined" ? this.props.id : Lt(this[Symbol.toStringTag]);
-        this.props.id = s, this.id = s, this.userData = this.props.userData || {}, this.addStats()
+        this._device = t, this.props = nC(r, i);
+        let n = this.props.id !== "undefined" ? this.props.id : De(this[Symbol.toStringTag]);
+        this.props.id = n, this.id = n, this.userData = this.props.userData || {}, this.addStats()
     }
     destroy() {
         this.destroyResource()
     }
     delete() {
         return this.destroy(), this
     }
@@ -4221,132 +4221,132 @@
     }
     addStats() {
         let t = this._device.statsManager.getStats("Resource Counts"),
             r = this[Symbol.toStringTag];
         t.get("Resources Created").incrementCount(), t.get(`${r}s Created`).incrementCount(), t.get(`${r}s Active`).incrementCount()
     }
 };
-p(q, "defaultProps", {
+m(dt, "defaultProps", {
     id: "undefined",
     handle: void 0,
     userData: void 0
 });
 
-function J1(e, t) {
+function nC(e, t) {
     let r = {
         ...t
     };
     for (let i in e) e[i] !== void 0 && (r[i] = e[i]);
     return r
 }
-var Mt = class Mt extends q {
+var ve = class ve extends dt {
     constructor(r, i) {
-        let s = {
+        let n = {
             ...i
         };
-        (i.usage || 0) & Mt.INDEX && !i.indexType && (i.data instanceof Uint32Array ? s.indexType = "uint32" : i.data instanceof Uint16Array && (s.indexType = "uint16"));
-        super(r, s, Mt.defaultProps);
-        p(this, "usage");
-        p(this, "indexType");
-        p(this, "updateTimestamp");
-        p(this, "debugData", new ArrayBuffer(0));
-        this.usage = i.usage || 0, this.indexType = s.indexType, this.updateTimestamp = r.incrementTimestamp()
+        (i.usage || 0) & ve.INDEX && !i.indexType && (i.data instanceof Uint32Array ? n.indexType = "uint32" : i.data instanceof Uint16Array && (n.indexType = "uint16"));
+        super(r, n, ve.defaultProps);
+        m(this, "usage");
+        m(this, "indexType");
+        m(this, "updateTimestamp");
+        m(this, "debugData", new ArrayBuffer(0));
+        this.usage = i.usage || 0, this.indexType = n.indexType, this.updateTimestamp = r.incrementTimestamp()
     }
     get[Symbol.toStringTag]() {
         return "Buffer"
     }
     readSyncWebGL(r, i) {
         throw new Error("not implemented")
     }
-    _setDebugData(r, i, s) {
-        let n = ArrayBuffer.isView(r) ? r.buffer : r,
-            o = Math.min(r ? r.byteLength : s, Mt.DEBUG_DATA_MAX_LENGTH);
-        r === null ? this.debugData = new ArrayBuffer(o) : i === 0 && s === r.byteLength ? this.debugData = n.slice(0, o) : this.debugData = n.slice(i, i + o)
+    _setDebugData(r, i, n) {
+        let s = ArrayBuffer.isView(r) ? r.buffer : r,
+            o = Math.min(r ? r.byteLength : n, ve.DEBUG_DATA_MAX_LENGTH);
+        r === null ? this.debugData = new ArrayBuffer(o) : i === 0 && n === r.byteLength ? this.debugData = s.slice(0, o) : this.debugData = s.slice(i, i + o)
     }
 };
-p(Mt, "defaultProps", {
-    ...q.defaultProps,
+m(ve, "defaultProps", {
+    ...dt.defaultProps,
     usage: 0,
     byteLength: 0,
     byteOffset: 0,
     data: null,
     indexType: "uint16",
     mappedAtCreation: !1
-}), p(Mt, "MAP_READ", 1), p(Mt, "MAP_WRITE", 2), p(Mt, "COPY_SRC", 4), p(Mt, "COPY_DST", 8), p(Mt, "INDEX", 16), p(Mt, "VERTEX", 32), p(Mt, "UNIFORM", 64), p(Mt, "STORAGE", 128), p(Mt, "INDIRECT", 256), p(Mt, "QUERY_RESOLVE", 512), p(Mt, "DEBUG_DATA_MAX_LENGTH", 32);
-var it = Mt;
+}), m(ve, "MAP_READ", 1), m(ve, "MAP_WRITE", 2), m(ve, "COPY_SRC", 4), m(ve, "COPY_DST", 8), m(ve, "INDEX", 16), m(ve, "VERTEX", 32), m(ve, "UNIFORM", 64), m(ve, "STORAGE", 128), m(ve, "INDIRECT", 256), m(ve, "QUERY_RESOLVE", 512), m(ve, "DEBUG_DATA_MAX_LENGTH", 32);
+var Mt = ve;
 
-function Ca(e) {
-    let t = um[e],
-        r = tA(t),
+function Nh(e) {
+    let t = Nv[e],
+        r = sC(t),
         i = e.includes("norm"),
-        s = !i && !e.startsWith("float"),
-        n = e.startsWith("s");
+        n = !i && !e.startsWith("float"),
+        s = e.startsWith("s");
     return {
-        dataType: um[e],
+        dataType: Nv[e],
         byteLength: r,
-        integer: s,
-        signed: n,
+        integer: n,
+        signed: s,
         normalized: i
     }
 }
 
-function tA(e) {
-    return eA[e]
+function sC(e) {
+    return oC[e]
 }
-var um = {
+var Nv = {
         uint8: "uint8",
         sint8: "sint8",
         unorm8: "uint8",
         snorm8: "sint8",
         uint16: "uint16",
         sint16: "sint16",
         unorm16: "uint16",
         snorm16: "sint16",
         float16: "float16",
         float32: "float32",
         uint32: "uint32",
         sint32: "sint32"
     },
-    eA = {
+    oC = {
         uint8: 1,
         sint8: 1,
         uint16: 2,
         sint16: 2,
         float16: 2,
         float32: 4,
         uint32: 4,
         sint32: 4
     };
-var rA = ["bc1", "bc2", "bc3", "bc4", "bc5", "bc6", "bc7", "etc1", "etc2", "eac", "atc", "astc", "pvrtc"],
-    iA = /^(rg?b?a?)([0-9]*)([a-z]*)(-srgb)?(-webgl|-unsized)?$/;
+var aC = ["bc1", "bc2", "bc3", "bc4", "bc5", "bc6", "bc7", "etc1", "etc2", "eac", "atc", "astc", "pvrtc"],
+    cC = /^(rg?b?a?)([0-9]*)([a-z]*)(-srgb)?(-webgl|-unsized)?$/;
 
-function dm(e) {
-    return rA.some(t => e.startsWith(t))
+function Bv(e) {
+    return aC.some(t => e.startsWith(t))
 }
 
-function Ia(e) {
-    let t = iA.exec(e);
+function Bh(e) {
+    let t = cC.exec(e);
     if (t) {
-        let [, r, i, s, n, o] = t;
+        let [, r, i, n, s, o] = t;
         if (r) {
-            let a = `${s}${i}`,
-                c = Ca(a);
+            let a = `${n}${i}`,
+                c = Nh(a);
             return {
                 format: r,
                 components: r.length,
-                srgb: n === "-srgb",
+                srgb: s === "-srgb",
                 unsized: o === "-unsized",
                 webgl: o === "-webgl",
                 ...c
             }
         }
     }
-    return nA(e)
+    return uC(e)
 }
-var sA = {
+var lC = {
     "rgba4unorm-webgl": {
         format: "rgba",
         bpp: 2
     },
     "rgb565unorm-webgl": {
         format: "rgb",
         bpp: 2
@@ -4404,56 +4404,56 @@
     "depth32float-stencil8": {
         components: 2,
         bpp: 4,
         a: "depth-stencil"
     }
 };
 
-function nA(e) {
-    let t = sA[e];
+function uC(e) {
+    let t = lC[e];
     if (!t) throw new Error(`Unknown format ${e}`);
     return {
         format: t.format || "",
         components: t.components || t.format?.length || 1,
         byteLength: t.bpp || 1,
         srgb: !1,
         unsized: !1
     }
 }
-var En = class {},
-    Sn = class {
+var ml = class {},
+    gl = class {
         constructor(t = [], r) {
-            p(this, "features");
-            p(this, "disabledFeatures");
+            m(this, "features");
+            m(this, "disabledFeatures");
             this.features = new Set(t), this.disabledFeatures = r || {}
         }*[Symbol.iterator]() {
             yield* this.features
         }
         has(t) {
             return !this.disabledFeatures[t] && this.features.has(t)
         }
     },
-    An = class An {
+    pl = class pl {
         constructor(t) {
-            p(this, "id");
-            p(this, "props");
-            p(this, "userData", {});
-            p(this, "statsManager", os);
-            p(this, "_lumaData", {});
-            p(this, "timestamp", 0);
+            m(this, "id");
+            m(this, "props");
+            m(this, "userData", {});
+            m(this, "statsManager", Aa);
+            m(this, "_lumaData", {});
+            m(this, "timestamp", 0);
             this.props = {
-                ...An.defaultProps,
+                ...pl.defaultProps,
                 ...t
-            }, this.id = this.props.id || Lt(this[Symbol.toStringTag].toLowerCase())
+            }, this.id = this.props.id || De(this[Symbol.toStringTag].toLowerCase())
         }
         get[Symbol.toStringTag]() {
             return "Device"
         }
         isTextureFormatCompressed(t) {
-            return dm(t)
+            return Bv(t)
         }
         loseDevice() {
             return !1
         }
         getCanvasContext() {
             if (!this.canvasContext) throw new Error("Device has no CanvasContext");
             return this.canvasContext
@@ -4496,153 +4496,153 @@
         _getBufferProps(t) {
             (t instanceof ArrayBuffer || ArrayBuffer.isView(t)) && (t = {
                 data: t
             });
             let r = {
                 ...t
             };
-            return (t.usage || 0) & it.INDEX && !t.indexType && (t.data instanceof Uint32Array ? r.indexType = "uint32" : t.data instanceof Uint16Array ? r.indexType = "uint16" : O.warn("indices buffer content must be of integer type")()), r
+            return (t.usage || 0) & Mt.INDEX && !t.indexType && (t.data instanceof Uint32Array ? r.indexType = "uint32" : t.data instanceof Uint16Array ? r.indexType = "uint16" : N.warn("indices buffer content must be of integer type")()), r
         }
     };
-p(An, "defaultProps", {
+m(pl, "defaultProps", {
     id: null,
     canvas: null,
     container: null,
     manageState: !0,
     width: 800,
     height: 600,
     requestMaxLimits: !0,
-    debug: !!O.get("debug"),
-    spector: !!O.get("spector"),
+    debug: !!N.get("debug"),
+    spector: !!N.get("spector"),
     break: [],
     initalizeFeatures: !0,
     disabledFeatures: {
         "compilation-status-async-webgl": !0
     },
     gl: null,
-    onError: t => O.error(t.message)
-}), p(An, "VERSION", fm);
-var je = An;
+    onError: t => N.error(t.message)
+}), m(pl, "VERSION", Ov);
+var ki = pl;
 
-function Q(e, t) {
+function _t(e, t) {
     if (!e) throw new Error(t || "luma.gl: assertion failed.")
 }
-var wn = new Map,
-    fe = class {
+var _l = new Map,
+    Or = class {
         static registerDevices(t) {
-            for (let r of t) Q(r.type && r.isSupported && r.create), wn.set(r.type, r)
+            for (let r of t) _t(r.type && r.isSupported && r.create), _l.set(r.type, r)
         }
         static getAvailableDevices() {
-            return Array.from(wn).map(t => t.type)
+            return Array.from(_l).map(t => t.type)
         }
         static getSupportedDevices() {
-            return Array.from(wn).filter(t => t.isSupported()).map(t => t.type)
+            return Array.from(_l).filter(t => t.isSupported()).map(t => t.type)
         }
         static setDefaultDeviceProps(t) {
-            Object.assign(je.defaultProps, t)
+            Object.assign(ki.defaultProps, t)
         }
         static async attachDevice(t) {
-            let r = pm(t.devices) || wn;
+            let r = Fv(t.devices) || _l;
             if (t.handle instanceof WebGL2RenderingContext) {
                 let i = r.get("webgl");
                 if (i) return await i.attach(t.handle)
             }
             if (t.handle === null) {
                 let i = r.get("unknown");
                 if (i) return await i.attach(null)
             }
             throw new Error("Failed to attach device. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.")
         }
         static async createDevice(t = {}) {
             t = {
-                ...je.defaultProps,
+                ...ki.defaultProps,
                 ...t
             }, t.gl && (t.type = "webgl");
-            let r = pm(t.devices) || wn;
+            let r = Fv(t.devices) || _l;
             switch (t.type) {
                 case "webgpu":
                     let i = r.get("webgpu");
                     if (i) return await i.create(t);
                     break;
                 case "webgl":
-                    let s = r.get("webgl");
-                    if (s) return await s.create(t);
+                    let n = r.get("webgl");
+                    if (n) return await n.create(t);
                     break;
                 case "unknown":
-                    let n = r.get("unknown");
-                    if (n) return await n.create(t);
+                    let s = r.get("unknown");
+                    if (s) return await s.create(t);
                     break;
                 case "best-available":
                     if (i = r.get("webgpu"), i?.isSupported?.()) return await i.create(t);
-                    if (s = r.get("webgl"), s?.isSupported?.()) return await s.create(t);
+                    if (n = r.get("webgl"), n?.isSupported?.()) return await n.create(t);
                     break
             }
             throw new Error("No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.")
         }
     };
-p(fe, "defaultProps", {
-    ...je.defaultProps,
+m(Or, "defaultProps", {
+    ...ki.defaultProps,
     type: "best-available",
     devices: void 0
-}), p(fe, "stats", os), p(fe, "log", O);
+}), m(Or, "stats", Aa), m(Or, "log", N);
 
-function pm(e) {
+function Fv(e) {
     if (!e || e?.length === 0) return null;
     let t = new Map;
     for (let r of e) t.set(r.type, r);
     return t
 }
-var oA = Ot() && typeof document < "u",
-    Oa = () => oA && document.readyState === "complete",
-    aA = {
+var fC = Me() && typeof document < "u",
+    Fh = () => fC && document.readyState === "complete",
+    hC = {
         canvas: null,
         width: 800,
         height: 600,
         useDevicePixels: !0,
         autoResize: !0,
         container: null,
         visible: !0,
         colorSpace: "srgb",
         alphaMode: "opaque"
     },
-    Ur = class {
+    bs = class {
         constructor(t) {
-            p(this, "id");
-            p(this, "props");
-            p(this, "canvas");
-            p(this, "htmlCanvas");
-            p(this, "offscreenCanvas");
-            p(this, "type");
-            p(this, "width", 1);
-            p(this, "height", 1);
-            p(this, "resizeObserver");
-            p(this, "_canvasSizeInfo", {
+            m(this, "id");
+            m(this, "props");
+            m(this, "canvas");
+            m(this, "htmlCanvas");
+            m(this, "offscreenCanvas");
+            m(this, "type");
+            m(this, "width", 1);
+            m(this, "height", 1);
+            m(this, "resizeObserver");
+            m(this, "_canvasSizeInfo", {
                 clientWidth: 0,
                 clientHeight: 0,
                 devicePixelRatio: 1
             });
             if (this.props = {
-                    ...aA,
+                    ...hC,
                     ...t
-                }, t = this.props, !Ot()) {
+                }, t = this.props, !Me()) {
                 this.id = "node-canvas-context", this.type = "node", this.width = this.props.width, this.height = this.props.height, this.canvas = null;
                 return
             }
-            if (t.canvas) typeof t.canvas == "string" ? this.canvas = hA(t.canvas) : this.canvas = t.canvas;
+            if (t.canvas) typeof t.canvas == "string" ? this.canvas = mC(t.canvas) : this.canvas = t.canvas;
             else {
-                let r = fA(t),
-                    i = lA(t?.container || null);
+                let r = gC(t),
+                    i = pC(t?.container || null);
                 i.insertBefore(r, i.firstChild), this.canvas = r, t?.visible || (this.canvas.style.visibility = "hidden")
             }
             this.canvas instanceof HTMLCanvasElement ? (this.id = this.canvas.id, this.type = "html-canvas", this.htmlCanvas = this.canvas) : (this.id = "offscreen-canvas", this.type = "offscreen-canvas", this.offscreenCanvas = this.canvas), this.canvas instanceof HTMLCanvasElement && t.autoResize && (this.resizeObserver = new ResizeObserver(r => {
                 for (let i of r) i.target === this.canvas && this.update()
             }), this.resizeObserver.observe(this.canvas))
         }
         static get isPageLoaded() {
-            return Oa()
+            return Fh()
         }
         getDevicePixelRatio(t) {
             return typeof OffscreenCanvas < "u" && this.canvas instanceof OffscreenCanvas || (t = t === void 0 ? this.props.useDevicePixels : t, !t || t <= 0) ? 1 : t === !0 ? typeof window < "u" && window.devicePixelRatio || 1 : t
         }
         getPixelSize() {
             switch (this.type) {
                 case "node":
@@ -4669,244 +4669,244 @@
                 return r ? t / r : 1
             } catch {
                 return 1
             }
         }
         cssToDevicePixels(t, r = !0) {
             let i = this.cssToDeviceRatio(),
-                [s, n] = this.getDrawingBufferSize();
-            return uA(t, i, s, n, r)
+                [n, s] = this.getDrawingBufferSize();
+            return _C(t, i, n, s, r)
         }
         setDevicePixelRatio(t, r = {}) {
             if (!this.htmlCanvas) return;
             let i = "width" in r ? r.width : this.htmlCanvas.clientWidth,
-                s = "height" in r ? r.height : this.htmlCanvas.clientHeight;
-            (!i || !s) && (O.log(1, "Canvas clientWidth/clientHeight is 0")(), t = 1, i = this.htmlCanvas.width || 1, s = this.htmlCanvas.height || 1);
-            let n = this._canvasSizeInfo;
-            if (n.clientWidth !== i || n.clientHeight !== s || n.devicePixelRatio !== t) {
+                n = "height" in r ? r.height : this.htmlCanvas.clientHeight;
+            (!i || !n) && (N.log(1, "Canvas clientWidth/clientHeight is 0")(), t = 1, i = this.htmlCanvas.width || 1, n = this.htmlCanvas.height || 1);
+            let s = this._canvasSizeInfo;
+            if (s.clientWidth !== i || s.clientHeight !== n || s.devicePixelRatio !== t) {
                 let o = t,
                     a = Math.floor(i * o),
-                    c = Math.floor(s * o);
+                    c = Math.floor(n * o);
                 this.htmlCanvas.width = a, this.htmlCanvas.height = c;
-                let [l, h] = this.getDrawingBufferSize();
-                (l !== a || h !== c) && (o = Math.min(l / i, h / s), this.htmlCanvas.width = Math.floor(i * o), this.htmlCanvas.height = Math.floor(s * o), O.warn("Device pixel ratio clamped")()), this._canvasSizeInfo.clientWidth = i, this._canvasSizeInfo.clientHeight = s, this._canvasSizeInfo.devicePixelRatio = t
+                let [l, u] = this.getDrawingBufferSize();
+                (l !== a || u !== c) && (o = Math.min(l / i, u / n), this.htmlCanvas.width = Math.floor(i * o), this.htmlCanvas.height = Math.floor(n * o), N.warn("Device pixel ratio clamped")()), this._canvasSizeInfo.clientWidth = i, this._canvasSizeInfo.clientHeight = n, this._canvasSizeInfo.devicePixelRatio = t
             }
         }
         getDrawingBufferSize() {
             let t = this.device.gl;
             if (!t) throw new Error("canvas size");
             return [t.drawingBufferWidth, t.drawingBufferHeight]
         }
         _setAutoCreatedCanvasId(t) {
             this.htmlCanvas?.id === "lumagl-auto-created-canvas" && (this.htmlCanvas.id = t)
         }
     };
-p(Ur, "pageLoaded", cA());
+m(bs, "pageLoaded", dC());
 
-function cA() {
-    return Oa() || typeof window > "u" ? Promise.resolve() : new Promise(e => {
+function dC() {
+    return Fh() || typeof window > "u" ? Promise.resolve() : new Promise(e => {
         window.addEventListener("load", () => e())
     })
 }
 
-function lA(e) {
+function pC(e) {
     if (typeof e == "string") {
         let t = document.getElementById(e);
-        if (!t && !Oa()) throw new Error(`Accessing '${e}' before page was loaded`);
+        if (!t && !Fh()) throw new Error(`Accessing '${e}' before page was loaded`);
         if (!t) throw new Error(`${e} is not an HTML element`);
         return t
     } else if (e) return e;
     return document.body
 }
 
-function hA(e) {
+function mC(e) {
     let t = document.getElementById(e);
-    if (!t && !Oa()) throw new Error(`Accessing '${e}' before page was loaded`);
+    if (!t && !Fh()) throw new Error(`Accessing '${e}' before page was loaded`);
     if (!(t instanceof HTMLCanvasElement)) throw new Error("Object is not a canvas element");
     return t
 }
 
-function fA(e) {
+function gC(e) {
     let {
         width: t,
         height: r
     } = e, i = document.createElement("canvas");
     return i.id = "lumagl-auto-created-canvas", i.width = t || 1, i.height = r || 1, i.style.width = Number.isFinite(t) ? `${t}px` : "100%", i.style.height = Number.isFinite(r) ? `${r}px` : "100%", i
 }
 
-function uA(e, t, r, i, s) {
-    let n = e,
-        o = gm(n[0], t, r),
-        a = mm(n[1], t, i, s),
-        c = gm(n[0] + 1, t, r),
+function _C(e, t, r, i, n) {
+    let s = e,
+        o = Dv(s[0], t, r),
+        a = Lv(s[1], t, i, n),
+        c = Dv(s[0] + 1, t, r),
         l = c === r - 1 ? c : c - 1;
-    c = mm(n[1] + 1, t, i, s);
-    let h;
-    return s ? (c = c === 0 ? c : c + 1, h = a, a = c) : h = c === i - 1 ? c : c - 1, {
+    c = Lv(s[1] + 1, t, i, n);
+    let u;
+    return n ? (c = c === 0 ? c : c + 1, u = a, a = c) : u = c === i - 1 ? c : c - 1, {
         x: o,
         y: a,
         width: Math.max(l - o + 1, 1),
-        height: Math.max(h - a + 1, 1)
+        height: Math.max(u - a + 1, 1)
     }
 }
 
-function gm(e, t, r) {
+function Dv(e, t, r) {
     return Math.min(Math.round(e * t), r - 1)
 }
 
-function mm(e, t, r, i) {
+function Lv(e, t, r, i) {
     return i ? Math.max(0, r - 1 - Math.round(e * t)) : Math.min(Math.round(e * t), r - 1)
 }
-var lr = class lr extends q {
-    constructor(r, i, s = lr.defaultProps) {
-        super(r, i, s);
-        p(this, "dimension");
-        p(this, "format");
-        p(this, "width");
-        p(this, "height");
-        p(this, "depth");
-        p(this, "updateTimestamp");
+var yn = class yn extends dt {
+    constructor(r, i, n = yn.defaultProps) {
+        super(r, i, n);
+        m(this, "dimension");
+        m(this, "format");
+        m(this, "width");
+        m(this, "height");
+        m(this, "depth");
+        m(this, "updateTimestamp");
         this.dimension = this.props.dimension, this.format = this.props.format, this.width = this.props.width, this.height = this.props.height, this.depth = this.props.depth, this.updateTimestamp = r.incrementTimestamp()
     }
     get[Symbol.toStringTag]() {
         return "Texture"
     }
 };
-p(lr, "defaultProps", {
-    ...q.defaultProps,
+m(yn, "defaultProps", {
+    ...dt.defaultProps,
     data: null,
     dimension: "2d",
     format: "rgba8unorm",
     width: void 0,
     height: void 0,
     depth: 1,
     mipmaps: !0,
     compressed: !1,
     usage: 0,
     mipLevels: void 0,
     samples: void 0,
     type: void 0,
     sampler: {},
     view: void 0
-}), p(lr, "COPY_SRC", 1), p(lr, "COPY_DST", 2), p(lr, "TEXTURE_BINDING", 4), p(lr, "STORAGE_BINDING", 8), p(lr, "RENDER_ATTACHMENT", 16);
-var Tt = lr;
-var Na = class Na extends q {
+}), m(yn, "COPY_SRC", 1), m(yn, "COPY_DST", 2), m(yn, "TEXTURE_BINDING", 4), m(yn, "STORAGE_BINDING", 8), m(yn, "RENDER_ATTACHMENT", 16);
+var ae = yn;
+var Dh = class Dh extends dt {
     get[Symbol.toStringTag]() {
         return "TextureView"
     }
     constructor(t, r) {
-        super(t, r, Na.defaultProps)
+        super(t, r, Dh.defaultProps)
     }
 };
-p(Na, "defaultProps", {
-    ...q.defaultProps,
+m(Dh, "defaultProps", {
+    ...dt.defaultProps,
     format: void 0,
     dimension: void 0,
     aspect: "all",
     baseMipLevel: 0,
     mipLevelCount: void 0,
     baseArrayLayer: 0,
     arrayLayerCount: void 0
 });
-var Ti = Na;
+var mo = Dh;
 
-function ym(e, t, r) {
+function Uv(e, t, r) {
     let i = "",
-        s = t.split(/\r?\n/),
-        n = e.slice().sort((o, a) => o.lineNum - a.lineNum);
+        n = t.split(/\r?\n/),
+        s = e.slice().sort((o, a) => o.lineNum - a.lineNum);
     switch (r?.showSourceCode || "no") {
         case "all":
             let o = 0;
-            for (let a = 1; a <= s.length; a++)
-                for (i += xm(s[a - 1], a, r); n.length > o && n[o].lineNum === a;) {
-                    let c = n[o++];
-                    i += _m(c, s, c.lineNum, {
+            for (let a = 1; a <= n.length; a++)
+                for (i += Vv(n[a - 1], a, r); s.length > o && s[o].lineNum === a;) {
+                    let c = s[o++];
+                    i += kv(c, n, c.lineNum, {
                         ...r,
                         inlineSource: !1
                     })
                 }
             return i;
         case "issues":
         case "no":
-            for (let a of e) i += _m(a, s, a.lineNum, {
+            for (let a of e) i += kv(a, n, a.lineNum, {
                 inlineSource: r?.showSourceCode !== "no"
             });
             return i
     }
 }
 
-function _m(e, t, r, i) {
+function kv(e, t, r, i) {
     if (i?.inlineSource) {
-        let s = dA(t, r),
-            n = e.linePos > 0 ? `${" ".repeat(e.linePos+5)}^^^
+        let n = yC(t, r),
+            s = e.linePos > 0 ? `${" ".repeat(e.linePos+5)}^^^
 ` : "";
         return `
-${s}${n}${e.type.toUpperCase()}: ${e.message}
+${n}${s}${e.type.toUpperCase()}: ${e.message}
 
 `
     }
     return i?.html ? `<div class='luma-compiler-log-error' style="color:red;"><b> ${e.type.toUpperCase()}: ${e.message}</b></div>` : `${e.type.toUpperCase()}: ${e.message}`
 }
 
-function dA(e, t, r) {
+function yC(e, t, r) {
     let i = "";
-    for (let s = t - 2; s <= t; s++) {
-        let n = e[s - 1];
-        n !== void 0 && (i += xm(n, t, r))
+    for (let n = t - 2; n <= t; n++) {
+        let s = e[n - 1];
+        s !== void 0 && (i += Vv(s, t, r))
     }
     return i
 }
 
-function xm(e, t, r) {
-    let i = r?.html ? gA(e) : e;
-    return `${pA(String(t),4)}: ${i}${r?.html?"<br/>":`
+function Vv(e, t, r) {
+    let i = r?.html ? xC(e) : e;
+    return `${bC(String(t),4)}: ${i}${r?.html?"<br/>":`
 `}`
 }
 
-function pA(e, t) {
+function bC(e, t) {
     let r = "";
     for (let i = e.length; i < t; ++i) r += " ";
     return r + e
 }
 
-function gA(e) {
+function xC(e) {
     return e.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;")
 }
 
-function xf(e, t) {
+function cy(e, t) {
     return {
-        name: mA(e, t),
+        name: wC(e, t),
         language: "glsl",
-        version: _A(e)
+        version: TC(e)
     }
 }
 
-function mA(e, t = "unnamed") {
+function wC(e, t = "unnamed") {
     let i = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/.exec(e);
     return i ? i[1] : t
 }
 
-function _A(e) {
+function TC(e) {
     let t = 100,
         r = e.match(/[^\s]+/g);
     if (r && r.length >= 2 && r[0] === "#version") {
         let i = parseInt(r[1], 10);
         Number.isFinite(i) && (t = i)
     }
     return t
 }
-var Fa = class Fa extends q {
+var Lh = class Lh extends dt {
     constructor(r, i) {
         super(r, {
-            id: yA(i),
+            id: vC(i),
             ...i
-        }, Fa.defaultProps);
-        p(this, "stage");
-        p(this, "source");
-        p(this, "compilationStatus", "pending");
+        }, Lh.defaultProps);
+        m(this, "stage");
+        m(this, "source");
+        m(this, "compilationStatus", "pending");
         this.stage = this.props.stage, this.source = this.props.source
     }
     get[Symbol.toStringTag]() {
         return "Shader"
     }
     getCompilationInfoSync() {
         return null
@@ -4926,171 +4926,171 @@
                 break
         }
         let i = await this.getCompilationInfo();
         this.props.debug === "warnings" && i?.length === 0 || this._displayShaderLog(i)
     }
     _displayShaderLog(r) {
         if (typeof document > "u" || !document?.createElement) return;
-        let i = xf(this.source).name,
-            s = `${this.stage} ${i}`,
-            n = ym(r, this.source, {
+        let i = cy(this.source).name,
+            n = `${this.stage} ${i}`,
+            s = Uv(r, this.source, {
                 showSourceCode: "all",
                 html: !0
             }),
             o = this.getTranslatedSource();
-        o && (n += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${o}</pre></code>`);
+        o && (s += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${o}</pre></code>`);
         let a = document.createElement("Button");
         a.innerHTML = `
-<h1>Shader Compilation Error in ${s}</h1><br /><br />
+<h1>Shader Compilation Error in ${n}</h1><br /><br />
 <code style="user-select:text;"><pre>
-${n}
+${s}
 </pre></code>`, a.style.top = "10px", a.style.left = "10px", a.style.position = "absolute", a.style.zIndex = "9999", a.style.width = "100%", a.style.textAlign = "left", document.body.appendChild(a);
         let c = document.getElementsByClassName("luma-compiler-log-error");
         c[0]?.scrollIntoView && c[0].scrollIntoView(), a.onclick = () => {
             let l = `data:text/plain,${encodeURIComponent(this.source)}`;
             navigator.clipboard.writeText(l)
         }
     }
 };
-p(Fa, "defaultProps", {
-    ...q.defaultProps,
+m(Lh, "defaultProps", {
+    ...dt.defaultProps,
     language: "auto",
     stage: void 0,
     source: "",
     sourceMap: null,
     entryPoint: "main",
     debug: "errors"
 });
-var bi = Fa;
+var go = Lh;
 
-function yA(e) {
-    return xf(e.source).name || e.id || Lt(`unnamed ${e.stage}-shader`)
+function vC(e) {
+    return cy(e.source).name || e.id || De(`unnamed ${e.stage}-shader`)
 }
-var Da = class Da extends q {
+var kh = class kh extends dt {
     get[Symbol.toStringTag]() {
         return "Sampler"
     }
     constructor(t, r) {
-        super(t, r, Da.defaultProps)
+        super(t, r, kh.defaultProps)
     }
 };
-p(Da, "defaultProps", {
-    ...q.defaultProps,
+m(kh, "defaultProps", {
+    ...dt.defaultProps,
     type: "color-sampler",
     addressModeU: "clamp-to-edge",
     addressModeV: "clamp-to-edge",
     addressModeW: "clamp-to-edge",
     magFilter: "nearest",
     minFilter: "nearest",
     mipmapFilter: "nearest",
     lodMinClamp: 0,
     lodMaxClamp: 32,
     compare: "less-equal",
     maxAnisotropy: 1
 });
-var Ai = Da;
-var ka = class ka extends q {
+var _o = kh;
+var Uh = class Uh extends dt {
     constructor(r, i = {}) {
-        super(r, i, ka.defaultProps);
-        p(this, "width");
-        p(this, "height");
-        p(this, "colorAttachments", []);
-        p(this, "depthStencilAttachment", null);
+        super(r, i, Uh.defaultProps);
+        m(this, "width");
+        m(this, "height");
+        m(this, "colorAttachments", []);
+        m(this, "depthStencilAttachment", null);
         this.width = this.props.width, this.height = this.props.height
     }
     get[Symbol.toStringTag]() {
         return "Framebuffer"
     }
     resize(r) {
         let i = !r;
         if (r) {
-            let [s, n] = Array.isArray(r) ? r : [r.width, r.height];
-            i = i || n !== this.height || s !== this.width, this.width = s, this.height = n
+            let [n, s] = Array.isArray(r) ? r : [r.width, r.height];
+            i = i || s !== this.height || n !== this.width, this.width = n, this.height = s
         }
-        i && (O.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)(), this.resizeAttachments(this.width, this.height))
+        i && (N.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)(), this.resizeAttachments(this.width, this.height))
     }
     autoCreateAttachmentTextures() {
         if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment) throw new Error("Framebuffer has noattachments");
         this.colorAttachments = this.props.colorAttachments.map(i => {
             if (typeof i == "string") {
-                let s = this.createColorTexture(i);
-                return this.attachResource(s), s.view
+                let n = this.createColorTexture(i);
+                return this.attachResource(n), n.view
             }
-            return i instanceof Tt ? i.view : i
+            return i instanceof ae ? i.view : i
         });
         let r = this.props.depthStencilAttachment;
         if (r)
             if (typeof r == "string") {
                 let i = this.createDepthStencilTexture(r);
                 this.attachResource(i), this.depthStencilAttachment = i.view
-            } else r instanceof Tt ? this.depthStencilAttachment = r.view : this.depthStencilAttachment = r
+            } else r instanceof ae ? this.depthStencilAttachment = r.view : this.depthStencilAttachment = r
     }
     createColorTexture(r) {
         return this.device.createTexture({
             id: "color-attachment",
-            usage: Tt.RENDER_ATTACHMENT,
+            usage: ae.RENDER_ATTACHMENT,
             format: r,
             width: this.width,
             height: this.height
         })
     }
     createDepthStencilTexture(r) {
         return this.device.createTexture({
             id: "depth-stencil-attachment",
-            usage: Tt.RENDER_ATTACHMENT,
+            usage: ae.RENDER_ATTACHMENT,
             format: r,
             width: this.width,
             height: this.height
         })
     }
     resizeAttachments(r, i) {
-        for (let s = 0; s < this.colorAttachments.length; ++s)
-            if (this.colorAttachments[s]) {
-                let n = this.device._createTexture({
-                    ...this.colorAttachments[s].props,
+        for (let n = 0; n < this.colorAttachments.length; ++n)
+            if (this.colorAttachments[n]) {
+                let s = this.device._createTexture({
+                    ...this.colorAttachments[n].props,
                     width: r,
                     height: i
                 });
-                this.destroyAttachedResource(this.colorAttachments[s]), this.colorAttachments[s] = n.view, this.attachResource(n.view)
+                this.destroyAttachedResource(this.colorAttachments[n]), this.colorAttachments[n] = s.view, this.attachResource(s.view)
             } if (this.depthStencilAttachment) {
-            let s = this.device._createTexture({
+            let n = this.device._createTexture({
                 ...this.depthStencilAttachment.props,
                 width: r,
                 height: i
             });
-            this.destroyAttachedResource(this.depthStencilAttachment), this.depthStencilAttachment = s.view, this.attachResource(s)
+            this.destroyAttachedResource(this.depthStencilAttachment), this.depthStencilAttachment = n.view, this.attachResource(n)
         }
     }
 };
-p(ka, "defaultProps", {
-    ...q.defaultProps,
+m(Uh, "defaultProps", {
+    ...dt.defaultProps,
     width: 1,
     height: 1,
     colorAttachments: [],
     depthStencilAttachment: null
 });
-var Ei = ka;
-var La = class La extends q {
+var yo = Uh;
+var Vh = class Vh extends dt {
     constructor(r, i) {
-        super(r, i, La.defaultProps);
-        p(this, "shaderLayout");
-        p(this, "bufferLayout");
-        p(this, "linkStatus", "pending");
-        p(this, "hash", "");
+        super(r, i, Vh.defaultProps);
+        m(this, "shaderLayout");
+        m(this, "bufferLayout");
+        m(this, "linkStatus", "pending");
+        m(this, "hash", "");
         this.shaderLayout = this.props.shaderLayout, this.bufferLayout = this.props.bufferLayout || []
     }
     get[Symbol.toStringTag]() {
         return "RenderPipeline"
     }
     setUniformsWebGL(r) {
         throw new Error("Use uniform blocks")
     }
 };
-p(La, "defaultProps", {
-    ...q.defaultProps,
+m(Vh, "defaultProps", {
+    ...dt.defaultProps,
     vs: null,
     vertexEntryPoint: "vertexMain",
     vsConstants: {},
     fs: null,
     fragmentEntryPoint: "fragmentMain",
     fsConstants: {},
     shaderLayout: null,
@@ -5098,95 +5098,95 @@
     topology: "triangle-list",
     parameters: {},
     vertexCount: 0,
     instanceCount: 0,
     bindings: {},
     uniforms: {}
 });
-var He = La;
-var Ba = class Ba extends q {
+var Ui = Vh;
+var zh = class zh extends dt {
     get[Symbol.toStringTag]() {
         return "RenderPass"
     }
     constructor(t, r) {
-        super(t, r, Ba.defaultProps)
+        super(t, r, zh.defaultProps)
     }
 };
-p(Ba, "defaultProps", {
-    ...q.defaultProps,
+m(zh, "defaultProps", {
+    ...dt.defaultProps,
     framebuffer: null,
     parameters: void 0,
     clearColor: [0, 0, 0, 0],
     clearDepth: 1,
     clearStencil: 0,
     depthReadOnly: !1,
     stencilReadOnly: !1,
     discard: !1,
     occlusionQuerySet: void 0,
     timestampQuerySet: void 0,
     beginTimestampIndex: void 0,
     endTimestampIndex: void 0
 });
-var vn = Ba;
-var Ua = class Ua extends q {
+var yl = zh;
+var Wh = class Wh extends dt {
     constructor(r, i) {
-        super(r, i, Ua.defaultProps);
-        p(this, "hash", "")
+        super(r, i, Wh.defaultProps);
+        m(this, "hash", "")
     }
     get[Symbol.toStringTag]() {
         return "ComputePipeline"
     }
 };
-p(Ua, "defaultProps", {
-    ...q.defaultProps,
+m(Wh, "defaultProps", {
+    ...dt.defaultProps,
     shader: void 0,
     entryPoint: void 0,
     constants: {},
     shaderLayout: void 0
 });
-var as = Ua;
-var Va = class Va extends q {
+var Ea = Wh;
+var jh = class jh extends dt {
     get[Symbol.toStringTag]() {
         return "CommandEncoder"
     }
     constructor(t, r) {
-        super(t, r, Va.defaultProps)
+        super(t, r, jh.defaultProps)
     }
 };
-p(Va, "defaultProps", {
-    ...q.defaultProps,
+m(jh, "defaultProps", {
+    ...dt.defaultProps,
     measureExecutionTime: void 0
 });
-var Rn = Va;
-var za = class za extends q {
+var bl = jh;
+var Hh = class Hh extends dt {
     get[Symbol.toStringTag]() {
         return "CommandBuffer"
     }
     constructor(t, r) {
-        super(t, r, za.defaultProps)
+        super(t, r, Hh.defaultProps)
     }
 };
-p(za, "defaultProps", {
-    ...q.defaultProps
+m(Hh, "defaultProps", {
+    ...dt.defaultProps
 });
-var Pn = za;
+var xl = Hh;
 
-function Tm(e) {
-    let [t, r] = TA[e], i = t === "i32" || t === "u32", s = t !== "u32", n = bA[t] * r, o = xA(t, r);
+function zv(e) {
+    let [t, r] = AC[e], i = t === "i32" || t === "u32", n = t !== "u32", s = EC[t] * r, o = SC(t, r);
     return {
         dataType: t,
         components: r,
         defaultVertexFormat: o,
-        byteLength: n,
+        byteLength: s,
         integer: i,
-        signed: s
+        signed: n
     }
 }
 
-function xA(e, t) {
+function SC(e, t) {
     let r;
     switch (e) {
         case "f32":
             r = "float32";
             break;
         case "i32":
             r = "sint32";
@@ -5195,15 +5195,15 @@
             r = "uint32";
             break;
         case "f16":
             return t <= 2 ? "float16x2" : "float16x4"
     }
     return t === 1 ? r : `${r}x${t}`
 }
-var TA = {
+var AC = {
         f32: ["f32", 1],
         "vec2<f32>": ["f32", 2],
         "vec3<f32>": ["f32", 3],
         "vec4<f32>": ["f32", 4],
         f16: ["f16", 1],
         "vec2<f16>": ["f16", 2],
         "vec3<f16>": ["f16", 3],
@@ -5213,185 +5213,185 @@
         "vec3<i32>": ["i32", 3],
         "vec4<i32>": ["i32", 4],
         u32: ["u32", 1],
         "vec2<u32>": ["u32", 2],
         "vec3<u32>": ["u32", 3],
         "vec4<u32>": ["u32", 4]
     },
-    bA = {
+    EC = {
         f32: 4,
         f16: 2,
         i32: 4,
         u32: 4
     };
 
-function Tf(e) {
+function ly(e) {
     let t;
     e.endsWith("-webgl") && (e.replace("-webgl", ""), t = !0);
-    let [r, i] = e.split("x"), s = r, n = i ? parseInt(i) : 1, o = Ca(s), a = {
-        type: s,
-        components: n,
-        byteLength: o.byteLength * n,
+    let [r, i] = e.split("x"), n = r, s = i ? parseInt(i) : 1, o = Nh(n), a = {
+        type: n,
+        components: s,
+        byteLength: o.byteLength * s,
         integer: o.integer,
         signed: o.signed,
         normalized: o.normalized
     };
     return t && (a.webglOnly = !0), a
 }
 
-function Wa(e, t) {
+function $h(e, t) {
     let r = {};
-    for (let i of e.attributes) r[i.name] = AA(e, t, i.name);
+    for (let i of e.attributes) r[i.name] = IC(e, t, i.name);
     return r
 }
 
-function bm(e, t, r = 16) {
-    let i = Wa(e, t),
-        s = new Array(r).fill(null);
-    for (let n of Object.values(i)) s[n.location] = n;
-    return s
+function Wv(e, t, r = 16) {
+    let i = $h(e, t),
+        n = new Array(r).fill(null);
+    for (let s of Object.values(i)) n[s.location] = s;
+    return n
 }
 
-function AA(e, t, r) {
-    let i = EA(e, r),
-        s = SA(t, r);
+function IC(e, t, r) {
+    let i = RC(e, r),
+        n = MC(t, r);
     if (!i) return null;
-    let n = Tm(i.type),
-        o = s?.vertexFormat || n.defaultVertexFormat,
-        a = Tf(o);
+    let s = zv(i.type),
+        o = n?.vertexFormat || s.defaultVertexFormat,
+        a = ly(o);
     return {
-        attributeName: s?.attributeName || i.name,
-        bufferName: s?.bufferName || i.name,
+        attributeName: n?.attributeName || i.name,
+        bufferName: n?.bufferName || i.name,
         location: i.location,
         shaderType: i.type,
-        shaderDataType: n.dataType,
-        shaderComponents: n.components,
+        shaderDataType: s.dataType,
+        shaderComponents: s.components,
         vertexFormat: o,
         bufferDataType: a.type,
         bufferComponents: a.components,
         normalized: a.normalized,
-        integer: n.integer,
-        stepMode: s?.stepMode || i.stepMode,
-        byteOffset: s?.byteOffset || 0,
-        byteStride: s?.byteStride || 0
+        integer: s.integer,
+        stepMode: n?.stepMode || i.stepMode,
+        byteOffset: n?.byteOffset || 0,
+        byteStride: n?.byteStride || 0
     }
 }
 
-function EA(e, t) {
+function RC(e, t) {
     let r = e.attributes.find(i => i.name === t);
-    return r || O.warn(`shader layout attribute "${t}" not present in shader`), r || null
+    return r || N.warn(`shader layout attribute "${t}" not present in shader`), r || null
 }
 
-function SA(e, t) {
-    wA(e);
-    let r = vA(e, t);
-    return r || (r = RA(e, t), r) ? r : (O.warn(`layout for attribute "${t}" not present in buffer layout`), null)
+function MC(e, t) {
+    PC(e);
+    let r = CC(e, t);
+    return r || (r = OC(e, t), r) ? r : (N.warn(`layout for attribute "${t}" not present in buffer layout`), null)
 }
 
-function wA(e) {
-    for (let t of e)(t.attributes && t.format || !t.attributes && !t.format) && O.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`)
+function PC(e) {
+    for (let t of e)(t.attributes && t.format || !t.attributes && !t.format) && N.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`)
 }
 
-function vA(e, t) {
+function CC(e, t) {
     for (let r of e)
         if (r.format && r.name === t) return {
             attributeName: r.name,
             bufferName: t,
             stepMode: r.stepMode,
             vertexFormat: r.format,
             byteOffset: 0,
             byteStride: r.byteStride || 0
         };
     return null
 }
 
-function RA(e, t) {
+function OC(e, t) {
     for (let r of e) {
         let i = r.byteStride;
         if (typeof r.byteStride != "number")
-            for (let n of r.attributes || []) {
-                let o = Tf(n.format);
+            for (let s of r.attributes || []) {
+                let o = ly(s.format);
                 i += o.byteLength
             }
-        let s = r.attributes?.find(n => n.attribute === t);
-        if (s) return {
-            attributeName: s.attribute,
+        let n = r.attributes?.find(s => s.attribute === t);
+        if (n) return {
+            attributeName: n.attribute,
             bufferName: r.name,
             stepMode: r.stepMode,
-            vertexFormat: s.format,
-            byteOffset: s.byteOffset,
+            vertexFormat: n.format,
+            byteOffset: n.byteOffset,
             byteStride: i
         }
     }
     return null
 }
 
-function bf(e, t) {
+function uy(e, t) {
     let r = {
         ...e,
         attributes: e.attributes.map(i => ({
             ...i
         }))
     };
     for (let i of t?.attributes || []) {
-        let s = r.attributes.find(n => n.name === i.name);
-        s ? (s.type = i.type || s.type, s.stepMode = i.stepMode || s.stepMode) : O.warn(`shader layout attribute ${i.name} not present in shader`)
+        let n = r.attributes.find(s => s.name === i.name);
+        n ? (n.type = i.type || n.type, n.stepMode = i.stepMode || n.stepMode) : N.warn(`shader layout attribute ${i.name} not present in shader`)
     }
     return r
 }
-var ja = class ja extends q {
+var Xh = class Xh extends dt {
     constructor(r, i) {
-        super(r, i, ja.defaultProps);
-        p(this, "maxVertexAttributes");
-        p(this, "attributeInfos");
-        p(this, "indexBuffer", null);
-        p(this, "attributes");
-        this.maxVertexAttributes = r.limits.maxVertexAttributes, this.attributes = new Array(this.maxVertexAttributes).fill(null), this.attributeInfos = bm(i.renderPipeline.shaderLayout, i.renderPipeline.bufferLayout, this.maxVertexAttributes)
+        super(r, i, Xh.defaultProps);
+        m(this, "maxVertexAttributes");
+        m(this, "attributeInfos");
+        m(this, "indexBuffer", null);
+        m(this, "attributes");
+        this.maxVertexAttributes = r.limits.maxVertexAttributes, this.attributes = new Array(this.maxVertexAttributes).fill(null), this.attributeInfos = Wv(i.renderPipeline.shaderLayout, i.renderPipeline.bufferLayout, this.maxVertexAttributes)
     }
     get[Symbol.toStringTag]() {
         return "VertexArray"
     }
     setConstantWebGL(r, i) {
         throw new Error("constant attributes not supported")
     }
 };
-p(ja, "defaultProps", {
-    ...q.defaultProps,
+m(Xh, "defaultProps", {
+    ...dt.defaultProps,
     renderPipeline: null
 });
-var Mn = ja;
-var Ha = class Ha extends q {
+var wl = Xh;
+var Yh = class Yh extends dt {
     get[Symbol.toStringTag]() {
         return "TransformFeedback"
     }
     constructor(t, r) {
-        super(t, r, Ha.defaultProps)
+        super(t, r, Yh.defaultProps)
     }
 };
-p(Ha, "defaultProps", {
-    ...q.defaultProps,
+m(Yh, "defaultProps", {
+    ...dt.defaultProps,
     layout: void 0,
     buffers: {}
 });
-var Cn = Ha;
-var Xa = class Xa extends q {
+var Tl = Yh;
+var qh = class qh extends dt {
     get[Symbol.toStringTag]() {
         return "QuerySet"
     }
     constructor(t, r) {
-        super(t, r, Xa.defaultProps)
+        super(t, r, qh.defaultProps)
     }
 };
-p(Xa, "defaultProps", {
-    ...q.defaultProps,
+m(qh, "defaultProps", {
+    ...dt.defaultProps,
     type: void 0,
     count: void 0
 });
-var In = Xa;
-var PA = {
+var vl = qh;
+var NC = {
     f32: {
         type: "f32",
         components: 1
     },
     i32: {
         type: "i32",
         components: 1
@@ -5470,177 +5470,177 @@
     },
     "mat4x4<f32>": {
         type: "f32",
         components: 16
     }
 };
 
-function Am(e) {
-    let t = PA[e];
-    return Q(e), t
+function jv(e) {
+    let t = NC[e];
+    return _t(e), t
 }
 
-function Em(e, t) {
+function Hv(e, t) {
     switch (t) {
         case 1:
             return e;
         case 2:
             return e + e % 2;
         default:
             return e + (4 - e % 4) % 4
     }
 }
-var $a;
+var Zh;
 
-function Ya(e) {
-    return (!$a || $a.byteLength < e) && ($a = new ArrayBuffer(e)), $a
+function Kh(e) {
+    return (!Zh || Zh.byteLength < e) && (Zh = new ArrayBuffer(e)), Zh
 }
 
-function Af(e, t) {
-    let r = Ya(e.BYTES_PER_ELEMENT * t);
+function fy(e, t) {
+    let r = Kh(e.BYTES_PER_ELEMENT * t);
     return new e(r, 0, t)
 }
 
-function Ef(e) {
+function hy(e) {
     let {
         target: t,
         source: r,
         start: i = 0,
-        count: s = 1
-    } = e, n = r.length, o = s * n, a = 0;
-    for (let c = i; a < n; a++) t[c++] = r[a];
+        count: n = 1
+    } = e, s = r.length, o = n * s, a = 0;
+    for (let c = i; a < s; a++) t[c++] = r[a];
     for (; a < o;) a < o - a ? (t.copyWithin(i + a, i, i + a), a *= 2) : (t.copyWithin(i + a, i, i + o - a), a = o);
     return e.target
 }
-var Sm = 1024,
-    qa = class {
+var $v = 1024,
+    Gh = class {
         constructor(t) {
-            p(this, "layout", {});
-            p(this, "byteLength");
+            m(this, "layout", {});
+            m(this, "byteLength");
             let r = 0;
-            for (let [s, n] of Object.entries(t)) {
-                let o = Am(n),
+            for (let [n, s] of Object.entries(t)) {
+                let o = jv(s),
                     {
                         type: a,
                         components: c
                     } = o;
-                r = Em(r, c);
+                r = Hv(r, c);
                 let l = r;
-                r += c, this.layout[s] = {
+                r += c, this.layout[n] = {
                     type: a,
                     size: c,
                     offset: l
                 }
             }
             r += (4 - r % 4) % 4;
             let i = r * 4;
-            this.byteLength = Math.max(i, Sm)
+            this.byteLength = Math.max(i, $v)
         }
         getData(t) {
-            let r = Math.max(this.byteLength, Sm),
-                i = Ya(r),
-                s = {
+            let r = Math.max(this.byteLength, $v),
+                i = Kh(r),
+                n = {
                     i32: new Int32Array(i),
                     u32: new Uint32Array(i),
                     f32: new Float32Array(i),
                     f16: new Uint16Array(i)
                 };
-            for (let [n, o] of Object.entries(t)) {
-                let a = this.layout[n];
+            for (let [s, o] of Object.entries(t)) {
+                let a = this.layout[s];
                 if (!a) {
-                    O.warn(`Supplied uniform value ${n} not present in uniform block layout`)();
+                    N.warn(`Supplied uniform value ${s} not present in uniform block layout`)();
                     continue
                 }
                 let {
                     type: c,
                     size: l,
-                    offset: h
-                } = a, f = s[c];
+                    offset: u
+                } = a, f = n[c];
                 if (l === 1) {
                     if (typeof o != "number" && typeof o != "boolean") {
-                        O.warn(`Supplied value for single component uniform ${n} is not a number: ${o}`)();
+                        N.warn(`Supplied value for single component uniform ${s} is not a number: ${o}`)();
                         continue
                     }
-                    f[h] = Number(o)
+                    f[u] = Number(o)
                 } else {
-                    let u = Lr(o);
-                    if (!u) {
-                        O.warn(`Supplied value for multi component / array uniform ${n} is not a numeric array: ${o}`)();
+                    let h = _s(o);
+                    if (!h) {
+                        N.warn(`Supplied value for multi component / array uniform ${s} is not a numeric array: ${o}`)();
                         continue
                     }
-                    f.set(u, h)
+                    f.set(h, u)
                 }
             }
             return new Uint8Array(i)
         }
         has(t) {
             return !!this.layout[t]
         }
         get(t) {
             return this.layout[t]
         }
     };
 
-function wm(e, t, r = 16) {
+function Xv(e, t, r = 16) {
     if (e !== t) return !1;
-    let i = Lr(e);
+    let i = _s(e);
     if (!i) return !1;
-    let s = Lr(t);
-    if (s && i.length === s.length) {
-        for (let n = 0; n < i.length; ++n)
-            if (s[n] !== i[n]) return !1
+    let n = _s(t);
+    if (n && i.length === n.length) {
+        for (let s = 0; s < i.length; ++s)
+            if (n[s] !== i[s]) return !1
     }
     return !0
 }
 
-function vm(e) {
-    let t = Lr(e);
+function Yv(e) {
+    let t = _s(e);
     return t ? t.slice() : e
 }
-var Za = class {
+var Jh = class {
     constructor(t) {
-        p(this, "name");
-        p(this, "uniforms", {});
-        p(this, "modifiedUniforms", {});
-        p(this, "modified", !0);
-        p(this, "bindingLayout", {});
-        p(this, "needsRedraw", "initialized");
+        m(this, "name");
+        m(this, "uniforms", {});
+        m(this, "modifiedUniforms", {});
+        m(this, "modified", !0);
+        m(this, "bindingLayout", {});
+        m(this, "needsRedraw", "initialized");
         if (this.name = t?.name, t?.name && t?.shaderLayout) {
-            let r = t?.shaderLayout.bindings?.find(s => s.type === "uniform" && s.name === t?.name);
+            let r = t?.shaderLayout.bindings?.find(n => n.type === "uniform" && n.name === t?.name);
             if (!r) throw new Error(t?.name);
             let i = r;
-            for (let s of i.uniforms || []) this.bindingLayout[s.name] = s
+            for (let n of i.uniforms || []) this.bindingLayout[n.name] = n
         }
     }
     setUniforms(t) {
         for (let [r, i] of Object.entries(t)) this._setUniform(r, i), this.needsRedraw || this.setNeedsRedraw(`${this.name}.${r}=${i}`)
     }
     setNeedsRedraw(t) {
         this.needsRedraw = this.needsRedraw || t
     }
     getAllUniforms() {
         return this.modifiedUniforms = {}, this.needsRedraw = !1, this.uniforms || {}
     }
     _setUniform(t, r) {
-        wm(this.uniforms[t], r) || (this.uniforms[t] = vm(r), this.modifiedUniforms[t] = !0, this.modified = !0)
+        Xv(this.uniforms[t], r) || (this.uniforms[t] = Yv(r), this.modifiedUniforms[t] = !0, this.modified = !0)
     }
 };
-var On = class {
+var Sl = class {
     constructor(t) {
-        p(this, "uniformBlocks", new Map);
-        p(this, "uniformBufferLayouts", new Map);
-        p(this, "uniformBuffers", new Map);
+        m(this, "uniformBlocks", new Map);
+        m(this, "uniformBufferLayouts", new Map);
+        m(this, "uniformBuffers", new Map);
         for (let [r, i] of Object.entries(t)) {
-            let s = r,
-                n = new qa(i.uniformTypes || {});
-            this.uniformBufferLayouts.set(s, n);
-            let o = new Za({
+            let n = r,
+                s = new Gh(i.uniformTypes || {});
+            this.uniformBufferLayouts.set(n, s);
+            let o = new Jh({
                 name: r
             });
-            o.setUniforms(i.defaultUniforms || {}), this.uniformBlocks.set(s, o)
+            o.setUniforms(i.defaultUniforms || {}), this.uniformBlocks.set(n, o)
         }
     }
     destroy() {
         for (let t of this.uniformBuffers.values()) t.destroy()
     }
     setUniforms(t) {
         for (let [r, i] of Object.entries(t)) this.uniformBlocks.get(r).setUniforms(i);
@@ -5651,57 +5651,57 @@
     }
     getUniformBufferData(t) {
         let r = this.uniformBlocks.get(t).getAllUniforms();
         return this.uniformBufferLayouts.get(t).getData(r)
     }
     createUniformBuffer(t, r, i) {
         i && this.setUniforms(i);
-        let s = this.getUniformBufferByteLength(r),
-            n = t.createBuffer({
-                usage: it.UNIFORM | it.COPY_DST,
-                byteLength: s
+        let n = this.getUniformBufferByteLength(r),
+            s = t.createBuffer({
+                usage: Mt.UNIFORM | Mt.COPY_DST,
+                byteLength: n
             }),
             o = this.getUniformBufferData(r);
-        return n.write(o), n
+        return s.write(o), s
     }
     getManagedUniformBuffer(t, r) {
         if (!this.uniformBuffers.get(r)) {
             let i = this.getUniformBufferByteLength(r),
-                s = t.createBuffer({
-                    usage: it.UNIFORM | it.COPY_DST,
+                n = t.createBuffer({
+                    usage: Mt.UNIFORM | Mt.COPY_DST,
                     byteLength: i
                 });
-            this.uniformBuffers.set(r, s)
+            this.uniformBuffers.set(r, n)
         }
         return this.uniformBuffers.get(r)
     }
     updateUniformBuffers() {
         let t = !1;
         for (let r of this.uniformBlocks.keys()) {
             let i = this.updateUniformBuffer(r);
             t || (t = i)
         }
-        return t && O.log(3, `UniformStore.updateUniformBuffers(): ${t}`)(), t
+        return t && N.log(3, `UniformStore.updateUniformBuffers(): ${t}`)(), t
     }
     updateUniformBuffer(t) {
         let r = this.uniformBlocks.get(t),
             i = this.uniformBuffers.get(t),
-            s = !1;
+            n = !1;
         if (i && r.needsRedraw) {
-            s || (s = r.needsRedraw);
-            let n = this.getUniformBufferData(t);
-            this.uniformBuffers.get(t).write(n);
+            n || (n = r.needsRedraw);
+            let s = this.getUniformBufferData(t);
+            this.uniformBuffers.get(t).write(s);
             let a = this.uniformBlocks.get(t).getAllUniforms();
-            O.log(4, `Writing to uniform buffer ${String(t)}`, n, a)()
+            N.log(4, `Writing to uniform buffer ${String(t)}`, s, a)()
         }
-        return s
+        return n
     }
 };
 
-function Ka(e) {
+function Qh(e) {
     let t = ArrayBuffer.isView(e) ? e.constructor : e;
     switch (t) {
         case Float32Array:
             return "float32";
         case Uint16Array:
             return "uint16";
         case Uint32Array:
@@ -5716,15 +5716,15 @@
         case Int32Array:
             return "sint32";
         default:
             throw new Error(t.constructor.name)
     }
 }
 
-function Nn(e) {
+function Al(e) {
     switch (e) {
         case "float32":
             return Float32Array;
         case "uint32":
             return Uint32Array;
         case "sint32":
             return Int32Array;
@@ -5741,345 +5741,345 @@
         case "snorm8":
             return Int8Array;
         default:
             throw new Error(e)
     }
 }
 
-function Sf(e, t, r) {
+function dy(e, t, r) {
     if (!t || t > 4) throw new Error(`size ${t}`);
     let i = t,
-        s = Ka(e);
-    if (s === "uint8" || s === "sint8") {
+        n = Qh(e);
+    if (n === "uint8" || n === "sint8") {
         if (i === 1 || i === 3) throw new Error(`size: ${t}`);
-        return r && (s = s.replace("int", "norm")), `${s}x${i}`
+        return r && (n = n.replace("int", "norm")), `${n}x${i}`
     }
-    if (s === "uint16" || s === "sint16") {
+    if (n === "uint16" || n === "sint16") {
         if (i === 1 || i === 3) throw new Error(`size: ${t}`);
-        return r && (s = s.replace("int", "norm")), `${s}x${i}`
+        return r && (n = n.replace("int", "norm")), `${n}x${i}`
     }
-    return i === 1 ? s : `${s}x${i}`
+    return i === 1 ? n : `${n}x${i}`
 }
 
-function Rm(e) {
-    return Lr(e) !== null || typeof e == "number" || typeof e == "boolean"
+function qv(e) {
+    return _s(e) !== null || typeof e == "number" || typeof e == "boolean"
 }
 
-function Fn(e) {
+function El(e) {
     let t = {
         bindings: {},
         uniforms: {}
     };
     return Object.keys(e).forEach(r => {
         let i = e[r];
-        Rm(i) ? t.uniforms[r] = i : t.bindings[r] = i
+        qv(i) ? t.uniforms[r] = i : t.bindings[r] = i
     }), t
 }
 
-function wf(e, t, r) {
+function py(e, t, r) {
     let {
         removedProps: i = {},
-        deprecatedProps: s = {},
-        replacedProps: n = {}
+        deprecatedProps: n = {},
+        replacedProps: s = {}
     } = r;
     for (let a in i)
         if (a in t) {
             let l = i[a] ? `${e}.${i[a]}` : "N/A";
-            O.removed(`${e}.${a}`, l)()
-        } for (let a in s)
+            N.removed(`${e}.${a}`, l)()
+        } for (let a in n)
         if (a in t) {
-            let c = s[a];
-            O.deprecated(`${e}.${a}`, `${e}.${c}`)()
+            let c = n[a];
+            N.deprecated(`${e}.${a}`, `${e}.${c}`)()
         } let o = null;
-    for (let [a, c] of Object.entries(n)) a in t && (O.deprecated(`${e}.${a}`, `${e}.${c}`)(), o = o || Object.assign({}, t), o[c] = t[a], delete o[a]);
+    for (let [a, c] of Object.entries(s)) a in t && (N.deprecated(`${e}.${a}`, `${e}.${c}`)(), o = o || Object.assign({}, t), o[c] = t[a], delete o[a]);
     return o || t
 }
-var MA = "";
-async function vf(e, t) {
+var BC = "";
+async function my(e, t) {
     return await new Promise((r, i) => {
         try {
-            let s = new Image;
-            s.onload = () => r(s), s.onerror = () => i(new Error(`Could not load image ${e}.`)), s.crossOrigin = t?.crossOrigin || "anonymous", s.src = e.startsWith("http") ? e : MA + e
-        } catch (s) {
-            i(s)
+            let n = new Image;
+            n.onload = () => r(n), n.onerror = () => i(new Error(`Could not load image ${e}.`)), n.crossOrigin = t?.crossOrigin || "anonymous", n.src = e.startsWith("http") ? e : BC + e
+        } catch (n) {
+            i(n)
         }
     })
 }
-async function Dn(e, t) {
+async function Il(e, t) {
     let r = document.getElementsByTagName("head")[0];
     if (!r) throw new Error("loadScript");
     let i = document.createElement("script");
-    return i.setAttribute("type", "text/javascript"), i.setAttribute("src", e), t && (i.id = t), new Promise((s, n) => {
-        i.onload = s, i.onerror = o => n(new Error(`Unable to load script '${e}': ${o}`)), r.appendChild(i)
+    return i.setAttribute("type", "text/javascript"), i.setAttribute("src", e), t && (i.id = t), new Promise((n, s) => {
+        i.onload = n, i.onerror = o => s(new Error(`Unable to load script '${e}': ${o}`)), r.appendChild(i)
     })
 }
 
-function kn(e, t, r) {
+function Rl(e, t, r) {
     if (e === t) return !0;
     if (!r || !e || !t) return !1;
     if (Array.isArray(e)) {
         if (!Array.isArray(t) || e.length !== t.length) return !1;
         for (let i = 0; i < e.length; i++)
-            if (!kn(e[i], t[i], r - 1)) return !1;
+            if (!Rl(e[i], t[i], r - 1)) return !1;
         return !0
     }
     if (Array.isArray(t)) return !1;
     if (typeof e == "object" && typeof t == "object") {
         let i = Object.keys(e),
-            s = Object.keys(t);
-        if (i.length !== s.length) return !1;
-        for (let n of i)
-            if (!t.hasOwnProperty(n) || !kn(e[n], t[n], r - 1)) return !1;
+            n = Object.keys(t);
+        if (i.length !== n.length) return !1;
+        for (let s of i)
+            if (!t.hasOwnProperty(s) || !Rl(e[s], t[s], r - 1)) return !1;
         return !0
     }
     return !1
 }
 
-function Rf(e) {
+function gy(e) {
     return typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame(e) : setTimeout(e, 1e3 / 60)
 }
 
-function Pf(e) {
+function _y(e) {
     return typeof window < "u" && window.cancelAnimationFrame ? window.cancelAnimationFrame(e) : clearTimeout(e)
 }
-var Mf = class {
+var yy = class {
         constructor() {
             this.constants = new Map, this.aliases = new Map, this.structs = new Map
         }
     },
-    fr = class {
+    xn = class {
         constructor() {}
         get isAstNode() {
             return !0
         }
         get astNodeType() {
             return ""
         }
         evaluate(t) {
             throw new Error("Cannot evaluate node")
         }
         evaluateString(t) {
             return this.evaluate(t).toString()
         }
     },
-    ht = class extends fr {
+    Xt = class extends xn {
         constructor() {
             super()
         }
     },
-    Qa = class extends ht {
-        constructor(t, r, i, s) {
-            super(), this.name = t, this.args = r, this.returnType = i, this.body = s
+    td = class extends Xt {
+        constructor(t, r, i, n) {
+            super(), this.name = t, this.args = r, this.returnType = i, this.body = n
         }
         get astNodeType() {
             return "function"
         }
     },
-    Cf = class extends ht {
+    by = class extends Xt {
         constructor(t) {
             super(), this.expression = t
         }
         get astNodeType() {
             return "staticAssert"
         }
     },
-    If = class extends ht {
+    xy = class extends Xt {
         constructor(t, r) {
             super(), this.condition = t, this.body = r
         }
         get astNodeType() {
             return "while"
         }
     },
-    Of = class extends ht {
+    wy = class extends Xt {
         constructor(t) {
             super(), this.body = t
         }
         get astNodeType() {
             return "continuing"
         }
     },
-    Nf = class extends ht {
-        constructor(t, r, i, s) {
-            super(), this.init = t, this.condition = r, this.increment = i, this.body = s
+    Ty = class extends Xt {
+        constructor(t, r, i, n) {
+            super(), this.init = t, this.condition = r, this.increment = i, this.body = n
         }
         get astNodeType() {
             return "for"
         }
     },
-    zr = class extends ht {
-        constructor(t, r, i, s, n) {
-            super(), this.name = t, this.type = r, this.storage = i, this.access = s, this.value = n
+    ws = class extends Xt {
+        constructor(t, r, i, n, s) {
+            super(), this.name = t, this.type = r, this.storage = i, this.access = n, this.value = s
         }
         get astNodeType() {
             return "var"
         }
     },
-    Ga = class extends ht {
+    ed = class extends Xt {
         constructor(t, r, i) {
             super(), this.name = t, this.type = r, this.value = i
         }
         get astNodeType() {
             return "override"
         }
     },
-    Ja = class extends ht {
-        constructor(t, r, i, s, n) {
-            super(), this.name = t, this.type = r, this.storage = i, this.access = s, this.value = n
+    rd = class extends Xt {
+        constructor(t, r, i, n, s) {
+            super(), this.name = t, this.type = r, this.storage = i, this.access = n, this.value = s
         }
         get astNodeType() {
             return "let"
         }
     },
-    tc = class extends ht {
-        constructor(t, r, i, s, n) {
-            super(), this.name = t, this.type = r, this.storage = i, this.access = s, this.value = n
+    id = class extends Xt {
+        constructor(t, r, i, n, s) {
+            super(), this.name = t, this.type = r, this.storage = i, this.access = n, this.value = s
         }
         get astNodeType() {
             return "const"
         }
         evaluate(t) {
             return this.value.evaluate(t)
         }
     },
-    fs;
+    Pa;
 (function(e) {
     e.increment = "++", e.decrement = "--"
-})(fs || (fs = {}));
+})(Pa || (Pa = {}));
 (function(e) {
     function t(r) {
         let i = r;
         if (i == "parse") throw new Error("Invalid value for IncrementOperator");
         return e[i]
     }
     e.parse = t
-})(fs || (fs = {}));
-var Ff = class extends ht {
+})(Pa || (Pa = {}));
+var vy = class extends Xt {
         constructor(t, r) {
             super(), this.operator = t, this.variable = r
         }
         get astNodeType() {
             return "increment"
         }
     },
-    Bn;
+    Pl;
 (function(e) {
     e.assign = "=", e.addAssign = "+=", e.subtractAssin = "-=", e.multiplyAssign = "*=", e.divideAssign = "/=", e.moduloAssign = "%=", e.andAssign = "&=", e.orAssign = "|=", e.xorAssign = "^=", e.shiftLeftAssign = "<<=", e.shiftRightAssign = ">>="
-})(Bn || (Bn = {}));
+})(Pl || (Pl = {}));
 (function(e) {
     function t(r) {
         let i = r;
         if (i == "parse") throw new Error("Invalid value for AssignOperator");
         return e[i]
     }
     e.parse = t
-})(Bn || (Bn = {}));
-var Df = class extends ht {
+})(Pl || (Pl = {}));
+var Sy = class extends Xt {
         constructor(t, r, i) {
             super(), this.operator = t, this.variable = r, this.value = i
         }
         get astNodeType() {
             return "assign"
         }
     },
-    kf = class extends ht {
+    Ay = class extends Xt {
         constructor(t, r) {
             super(), this.name = t, this.args = r
         }
         get astNodeType() {
             return "call"
         }
     },
-    Lf = class extends ht {
+    Ey = class extends Xt {
         constructor(t, r) {
             super(), this.body = t, this.continuing = r
         }
         get astNodeType() {
             return "loop"
         }
     },
-    Bf = class extends ht {
+    Iy = class extends Xt {
         constructor(t, r) {
             super(), this.condition = t, this.body = r
         }
         get astNodeType() {
             return "body"
         }
     },
-    Uf = class extends ht {
-        constructor(t, r, i, s) {
-            super(), this.condition = t, this.body = r, this.elseif = i, this.else = s
+    Ry = class extends Xt {
+        constructor(t, r, i, n) {
+            super(), this.condition = t, this.body = r, this.elseif = i, this.else = n
         }
         get astNodeType() {
             return "if"
         }
     },
-    Vf = class extends ht {
+    My = class extends Xt {
         constructor(t) {
             super(), this.value = t
         }
         get astNodeType() {
             return "return"
         }
     },
-    zf = class extends ht {
+    Py = class extends Xt {
         constructor(t) {
             super(), this.name = t
         }
         get astNodeType() {
             return "enable"
         }
     },
-    ec = class extends ht {
+    nd = class extends Xt {
         constructor(t, r) {
             super(), this.name = t, this.type = r
         }
         get astNodeType() {
             return "alias"
         }
     },
-    Wf = class extends ht {
+    Cy = class extends Xt {
         constructor() {
             super()
         }
         get astNodeType() {
             return "discard"
         }
     },
-    jf = class extends ht {
+    Oy = class extends Xt {
         constructor() {
             super()
         }
         get astNodeType() {
             return "break"
         }
     },
-    Hf = class extends ht {
+    Ny = class extends Xt {
         constructor() {
             super()
         }
         get astNodeType() {
             return "continue"
         }
     },
-    ur = class extends ht {
+    wn = class extends Xt {
         constructor(t) {
             super(), this.name = t
         }
         get astNodeType() {
             return "type"
         }
         get isStruct() {
             return !1
         }
         get isArray() {
             return !1
         }
     },
-    hr = class extends ur {
+    bn = class extends wn {
         constructor(t, r) {
             super(t), this.members = r
         }
         get astNodeType() {
             return "struct"
         }
         get isStruct() {
@@ -6087,77 +6087,77 @@
         }
         getMemberIndex(t) {
             for (let r = 0; r < this.members.length; r++)
                 if (this.members[r].name == t) return r;
             return -1
         }
     },
-    rc = class extends ur {
+    sd = class extends wn {
         constructor(t, r, i) {
             super(t), this.format = r, this.access = i
         }
         get astNodeType() {
             return "template"
         }
     },
-    Xf = class extends ur {
-        constructor(t, r, i, s) {
-            super(t), this.storage = r, this.type = i, this.access = s
+    By = class extends wn {
+        constructor(t, r, i, n) {
+            super(t), this.storage = r, this.type = i, this.access = n
         }
         get astNodeType() {
             return "pointer"
         }
     },
-    ic = class extends ur {
-        constructor(t, r, i, s) {
-            super(t), this.attributes = r, this.format = i, this.count = s
+    od = class extends wn {
+        constructor(t, r, i, n) {
+            super(t), this.attributes = r, this.format = i, this.count = n
         }
         get astNodeType() {
             return "array"
         }
         get isArray() {
             return !0
         }
     },
-    Si = class extends ur {
+    bo = class extends wn {
         constructor(t, r, i) {
             super(t), this.format = r, this.access = i
         }
         get astNodeType() {
             return "sampler"
         }
     },
-    de = class extends fr {
+    Br = class extends xn {
         constructor() {
             super()
         }
     },
-    sc = class extends de {
+    ad = class extends Br {
         constructor(t) {
             super(), this.value = t
         }
         get astNodeType() {
             return "stringExpr"
         }
         toString() {
             return this.value
         }
         evaluateString() {
             return this.value
         }
     },
-    wi = class extends de {
+    xo = class extends Br {
         constructor(t, r) {
             super(), this.type = t, this.args = r
         }
         get astNodeType() {
             return "createExpr"
         }
     },
-    $f = class extends de {
+    Fy = class extends Br {
         constructor(t, r) {
             super(), this.name = t, this.args = r
         }
         get astNodeType() {
             return "callExpr"
         }
         evaluate(t) {
@@ -6240,89 +6240,89 @@
                 case "trunc":
                     return Math.trunc(this.args[0].evaluate(t));
                 default:
                     throw new Error("Non const function: " + this.name)
             }
         }
     },
-    Yf = class extends de {
+    Dy = class extends Br {
         constructor(t) {
             super(), this.name = t
         }
         get astNodeType() {
             return "varExpr"
         }
     },
-    nc = class extends de {
+    cd = class extends Br {
         constructor(t, r) {
             super(), this.name = t, this.initializer = r
         }
         get astNodeType() {
             return "constExpr"
         }
         evaluate(t) {
             var r, i;
-            if (this.initializer instanceof wi) {
-                let s = (r = this.postfix) === null || r === void 0 ? void 0 : r.evaluateString(t),
-                    n = (i = this.initializer.type) === null || i === void 0 ? void 0 : i.name,
-                    o = t.structs.get(n),
-                    a = o?.getMemberIndex(s);
+            if (this.initializer instanceof xo) {
+                let n = (r = this.postfix) === null || r === void 0 ? void 0 : r.evaluateString(t),
+                    s = (i = this.initializer.type) === null || i === void 0 ? void 0 : i.name,
+                    o = t.structs.get(s),
+                    a = o?.getMemberIndex(n);
                 if (a != -1) return this.initializer.args[a].evaluate(t);
                 console.log(a)
             }
             return this.initializer.evaluate(t)
         }
     },
-    oc = class extends de {
+    ld = class extends Br {
         constructor(t) {
             super(), this.value = t
         }
         get astNodeType() {
             return "literalExpr"
         }
         evaluate() {
             return this.value
         }
     },
-    qf = class extends de {
+    Ly = class extends Br {
         constructor(t, r) {
             super(), this.type = t, this.value = r
         }
         get astNodeType() {
             return "bitcastExpr"
         }
     },
-    Zf = class extends de {
+    ky = class extends Br {
         constructor(t, r) {
             super(), this.type = t, this.args = r
         }
         get astNodeType() {
             return "typecastExpr"
         }
         evaluate(t) {
             return this.args[0].evaluate(t)
         }
     },
-    ac = class extends de {
+    ud = class extends Br {
         constructor(t) {
             super(), this.contents = t
         }
         get astNodeType() {
             return "groupExpr"
         }
         evaluate(t) {
             return this.contents[0].evaluate(t)
         }
     },
-    cc = class extends de {
+    fd = class extends Br {
         constructor() {
             super()
         }
     },
-    Kf = class extends cc {
+    Uy = class extends fd {
         constructor(t, r) {
             super(), this.operator = t, this.right = r
         }
         get astNodeType() {
             return "unaryOp"
         }
         evaluate(t) {
@@ -6336,15 +6336,15 @@
                 case "~":
                     return ~this.right.evaluate(t);
                 default:
                     throw new Error("Unknown unary operator: " + this.operator)
             }
         }
     },
-    ue = class extends cc {
+    Nr = class extends fd {
         constructor(t, r, i) {
             super(), this.operator = t, this.left = r, this.right = i
         }
         get astNodeType() {
             return "binaryOp"
         }
         evaluate(t) {
@@ -6376,314 +6376,314 @@
                 case "||":
                     return this.left.evaluate(t) || this.right.evaluate(t) ? 1 : 0;
                 default:
                     throw new Error(`Unknown operator ${this.operator}`)
             }
         }
     },
-    lc = class extends fr {
+    hd = class extends xn {
         constructor() {
             super()
         }
     },
-    Qf = class extends lc {
+    Vy = class extends hd {
         constructor(t, r) {
             super(), this.selector = t, this.body = r
         }
         get astNodeType() {
             return "case"
         }
     },
-    Gf = class extends lc {
+    zy = class extends hd {
         constructor(t) {
             super(), this.body = t
         }
         get astNodeType() {
             return "default"
         }
     },
-    Jf = class extends fr {
+    Wy = class extends xn {
         constructor(t, r, i) {
             super(), this.name = t, this.type = r, this.attributes = i
         }
         get astNodeType() {
             return "argument"
         }
     },
-    tu = class extends fr {
+    jy = class extends xn {
         constructor(t, r) {
             super(), this.condition = t, this.body = r
         }
         get astNodeType() {
             return "elseif"
         }
     },
-    eu = class extends fr {
+    Hy = class extends xn {
         constructor(t, r, i) {
             super(), this.name = t, this.type = r, this.attributes = i
         }
         get astNodeType() {
             return "member"
         }
     },
-    hc = class extends fr {
+    dd = class extends xn {
         constructor(t, r) {
             super(), this.name = t, this.value = r
         }
         get astNodeType() {
             return "attribute"
         }
     },
-    I, w;
+    O, E;
 (function(e) {
     e[e.token = 0] = "token", e[e.keyword = 1] = "keyword", e[e.reserved = 2] = "reserved"
-})(w || (w = {}));
-var S = class {
+})(E || (E = {}));
+var A = class {
         constructor(t, r, i) {
             this.name = t, this.type = r, this.rule = i
         }
         toString() {
             return this.name
         }
     },
-    T = class {};
-I = T;
-T.none = new S("", w.reserved, "");
-T.eof = new S("EOF", w.token, "");
-T.reserved = {
-    asm: new S("asm", w.reserved, "asm"),
-    bf16: new S("bf16", w.reserved, "bf16"),
-    do: new S("do", w.reserved, "do"),
-    enum: new S("enum", w.reserved, "enum"),
-    f16: new S("f16", w.reserved, "f16"),
-    f64: new S("f64", w.reserved, "f64"),
-    handle: new S("handle", w.reserved, "handle"),
-    i8: new S("i8", w.reserved, "i8"),
-    i16: new S("i16", w.reserved, "i16"),
-    i64: new S("i64", w.reserved, "i64"),
-    mat: new S("mat", w.reserved, "mat"),
-    premerge: new S("premerge", w.reserved, "premerge"),
-    regardless: new S("regardless", w.reserved, "regardless"),
-    typedef: new S("typedef", w.reserved, "typedef"),
-    u8: new S("u8", w.reserved, "u8"),
-    u16: new S("u16", w.reserved, "u16"),
-    u64: new S("u64", w.reserved, "u64"),
-    unless: new S("unless", w.reserved, "unless"),
-    using: new S("using", w.reserved, "using"),
-    vec: new S("vec", w.reserved, "vec"),
-    void: new S("void", w.reserved, "void")
-};
-T.keywords = {
-    array: new S("array", w.keyword, "array"),
-    atomic: new S("atomic", w.keyword, "atomic"),
-    bool: new S("bool", w.keyword, "bool"),
-    f32: new S("f32", w.keyword, "f32"),
-    i32: new S("i32", w.keyword, "i32"),
-    mat2x2: new S("mat2x2", w.keyword, "mat2x2"),
-    mat2x3: new S("mat2x3", w.keyword, "mat2x3"),
-    mat2x4: new S("mat2x4", w.keyword, "mat2x4"),
-    mat3x2: new S("mat3x2", w.keyword, "mat3x2"),
-    mat3x3: new S("mat3x3", w.keyword, "mat3x3"),
-    mat3x4: new S("mat3x4", w.keyword, "mat3x4"),
-    mat4x2: new S("mat4x2", w.keyword, "mat4x2"),
-    mat4x3: new S("mat4x3", w.keyword, "mat4x3"),
-    mat4x4: new S("mat4x4", w.keyword, "mat4x4"),
-    ptr: new S("ptr", w.keyword, "ptr"),
-    sampler: new S("sampler", w.keyword, "sampler"),
-    sampler_comparison: new S("sampler_comparison", w.keyword, "sampler_comparison"),
-    struct: new S("struct", w.keyword, "struct"),
-    texture_1d: new S("texture_1d", w.keyword, "texture_1d"),
-    texture_2d: new S("texture_2d", w.keyword, "texture_2d"),
-    texture_2d_array: new S("texture_2d_array", w.keyword, "texture_2d_array"),
-    texture_3d: new S("texture_3d", w.keyword, "texture_3d"),
-    texture_cube: new S("texture_cube", w.keyword, "texture_cube"),
-    texture_cube_array: new S("texture_cube_array", w.keyword, "texture_cube_array"),
-    texture_multisampled_2d: new S("texture_multisampled_2d", w.keyword, "texture_multisampled_2d"),
-    texture_storage_1d: new S("texture_storage_1d", w.keyword, "texture_storage_1d"),
-    texture_storage_2d: new S("texture_storage_2d", w.keyword, "texture_storage_2d"),
-    texture_storage_2d_array: new S("texture_storage_2d_array", w.keyword, "texture_storage_2d_array"),
-    texture_storage_3d: new S("texture_storage_3d", w.keyword, "texture_storage_3d"),
-    texture_depth_2d: new S("texture_depth_2d", w.keyword, "texture_depth_2d"),
-    texture_depth_2d_array: new S("texture_depth_2d_array", w.keyword, "texture_depth_2d_array"),
-    texture_depth_cube: new S("texture_depth_cube", w.keyword, "texture_depth_cube"),
-    texture_depth_cube_array: new S("texture_depth_cube_array", w.keyword, "texture_depth_cube_array"),
-    texture_depth_multisampled_2d: new S("texture_depth_multisampled_2d", w.keyword, "texture_depth_multisampled_2d"),
-    texture_external: new S("texture_external", w.keyword, "texture_external"),
-    u32: new S("u32", w.keyword, "u32"),
-    vec2: new S("vec2", w.keyword, "vec2"),
-    vec3: new S("vec3", w.keyword, "vec3"),
-    vec4: new S("vec4", w.keyword, "vec4"),
-    bitcast: new S("bitcast", w.keyword, "bitcast"),
-    block: new S("block", w.keyword, "block"),
-    break: new S("break", w.keyword, "break"),
-    case: new S("case", w.keyword, "case"),
-    continue: new S("continue", w.keyword, "continue"),
-    continuing: new S("continuing", w.keyword, "continuing"),
-    default: new S("default", w.keyword, "default"),
-    discard: new S("discard", w.keyword, "discard"),
-    else: new S("else", w.keyword, "else"),
-    enable: new S("enable", w.keyword, "enable"),
-    fallthrough: new S("fallthrough", w.keyword, "fallthrough"),
-    false: new S("false", w.keyword, "false"),
-    fn: new S("fn", w.keyword, "fn"),
-    for: new S("for", w.keyword, "for"),
-    function: new S("function", w.keyword, "function"),
-    if: new S("if", w.keyword, "if"),
-    let: new S("let", w.keyword, "let"),
-    const: new S("const", w.keyword, "const"),
-    loop: new S("loop", w.keyword, "loop"),
-    while: new S("while", w.keyword, "while"),
-    private: new S("private", w.keyword, "private"),
-    read: new S("read", w.keyword, "read"),
-    read_write: new S("read_write", w.keyword, "read_write"),
-    return: new S("return", w.keyword, "return"),
-    storage: new S("storage", w.keyword, "storage"),
-    switch: new S("switch", w.keyword, "switch"),
-    true: new S("true", w.keyword, "true"),
-    alias: new S("alias", w.keyword, "alias"),
-    type: new S("type", w.keyword, "type"),
-    uniform: new S("uniform", w.keyword, "uniform"),
-    var: new S("var", w.keyword, "var"),
-    override: new S("override", w.keyword, "override"),
-    workgroup: new S("workgroup", w.keyword, "workgroup"),
-    write: new S("write", w.keyword, "write"),
-    r8unorm: new S("r8unorm", w.keyword, "r8unorm"),
-    r8snorm: new S("r8snorm", w.keyword, "r8snorm"),
-    r8uint: new S("r8uint", w.keyword, "r8uint"),
-    r8sint: new S("r8sint", w.keyword, "r8sint"),
-    r16uint: new S("r16uint", w.keyword, "r16uint"),
-    r16sint: new S("r16sint", w.keyword, "r16sint"),
-    r16float: new S("r16float", w.keyword, "r16float"),
-    rg8unorm: new S("rg8unorm", w.keyword, "rg8unorm"),
-    rg8snorm: new S("rg8snorm", w.keyword, "rg8snorm"),
-    rg8uint: new S("rg8uint", w.keyword, "rg8uint"),
-    rg8sint: new S("rg8sint", w.keyword, "rg8sint"),
-    r32uint: new S("r32uint", w.keyword, "r32uint"),
-    r32sint: new S("r32sint", w.keyword, "r32sint"),
-    r32float: new S("r32float", w.keyword, "r32float"),
-    rg16uint: new S("rg16uint", w.keyword, "rg16uint"),
-    rg16sint: new S("rg16sint", w.keyword, "rg16sint"),
-    rg16float: new S("rg16float", w.keyword, "rg16float"),
-    rgba8unorm: new S("rgba8unorm", w.keyword, "rgba8unorm"),
-    rgba8unorm_srgb: new S("rgba8unorm_srgb", w.keyword, "rgba8unorm_srgb"),
-    rgba8snorm: new S("rgba8snorm", w.keyword, "rgba8snorm"),
-    rgba8uint: new S("rgba8uint", w.keyword, "rgba8uint"),
-    rgba8sint: new S("rgba8sint", w.keyword, "rgba8sint"),
-    bgra8unorm: new S("bgra8unorm", w.keyword, "bgra8unorm"),
-    bgra8unorm_srgb: new S("bgra8unorm_srgb", w.keyword, "bgra8unorm_srgb"),
-    rgb10a2unorm: new S("rgb10a2unorm", w.keyword, "rgb10a2unorm"),
-    rg11b10float: new S("rg11b10float", w.keyword, "rg11b10float"),
-    rg32uint: new S("rg32uint", w.keyword, "rg32uint"),
-    rg32sint: new S("rg32sint", w.keyword, "rg32sint"),
-    rg32float: new S("rg32float", w.keyword, "rg32float"),
-    rgba16uint: new S("rgba16uint", w.keyword, "rgba16uint"),
-    rgba16sint: new S("rgba16sint", w.keyword, "rgba16sint"),
-    rgba16float: new S("rgba16float", w.keyword, "rgba16float"),
-    rgba32uint: new S("rgba32uint", w.keyword, "rgba32uint"),
-    rgba32sint: new S("rgba32sint", w.keyword, "rgba32sint"),
-    rgba32float: new S("rgba32float", w.keyword, "rgba32float"),
-    static_assert: new S("static_assert", w.keyword, "static_assert")
-};
-T.tokens = {
-    decimal_float_literal: new S("decimal_float_literal", w.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),
-    hex_float_literal: new S("hex_float_literal", w.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),
-    int_literal: new S("int_literal", w.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
-    uint_literal: new S("uint_literal", w.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
-    ident: new S("ident", w.token, /[a-zA-Z][0-9a-zA-Z_]*/),
-    and: new S("and", w.token, "&"),
-    and_and: new S("and_and", w.token, "&&"),
-    arrow: new S("arrow ", w.token, "->"),
-    attr: new S("attr", w.token, "@"),
-    attr_left: new S("attr_left", w.token, "[["),
-    attr_right: new S("attr_right", w.token, "]]"),
-    forward_slash: new S("forward_slash", w.token, "/"),
-    bang: new S("bang", w.token, "!"),
-    bracket_left: new S("bracket_left", w.token, "["),
-    bracket_right: new S("bracket_right", w.token, "]"),
-    brace_left: new S("brace_left", w.token, "{"),
-    brace_right: new S("brace_right", w.token, "}"),
-    colon: new S("colon", w.token, ":"),
-    comma: new S("comma", w.token, ","),
-    equal: new S("equal", w.token, "="),
-    equal_equal: new S("equal_equal", w.token, "=="),
-    not_equal: new S("not_equal", w.token, "!="),
-    greater_than: new S("greater_than", w.token, ">"),
-    greater_than_equal: new S("greater_than_equal", w.token, ">="),
-    shift_right: new S("shift_right", w.token, ">>"),
-    less_than: new S("less_than", w.token, "<"),
-    less_than_equal: new S("less_than_equal", w.token, "<="),
-    shift_left: new S("shift_left", w.token, "<<"),
-    modulo: new S("modulo", w.token, "%"),
-    minus: new S("minus", w.token, "-"),
-    minus_minus: new S("minus_minus", w.token, "--"),
-    period: new S("period", w.token, "."),
-    plus: new S("plus", w.token, "+"),
-    plus_plus: new S("plus_plus", w.token, "++"),
-    or: new S("or", w.token, "|"),
-    or_or: new S("or_or", w.token, "||"),
-    paren_left: new S("paren_left", w.token, "("),
-    paren_right: new S("paren_right", w.token, ")"),
-    semicolon: new S("semicolon", w.token, ";"),
-    star: new S("star", w.token, "*"),
-    tilde: new S("tilde", w.token, "~"),
-    underscore: new S("underscore", w.token, "_"),
-    xor: new S("xor", w.token, "^"),
-    plus_equal: new S("plus_equal", w.token, "+="),
-    minus_equal: new S("minus_equal", w.token, "-="),
-    times_equal: new S("times_equal", w.token, "*="),
-    division_equal: new S("division_equal", w.token, "/="),
-    modulo_equal: new S("modulo_equal", w.token, "%="),
-    and_equal: new S("and_equal", w.token, "&="),
-    or_equal: new S("or_equal", w.token, "|="),
-    xor_equal: new S("xor_equal", w.token, "^="),
-    shift_right_equal: new S("shift_right_equal", w.token, ">>="),
-    shift_left_equal: new S("shift_left_equal", w.token, "<<=")
-};
-T.storage_class = [I.keywords.function, I.keywords.private, I.keywords.workgroup, I.keywords.uniform, I.keywords.storage];
-T.access_mode = [I.keywords.read, I.keywords.write, I.keywords.read_write];
-T.sampler_type = [I.keywords.sampler, I.keywords.sampler_comparison];
-T.sampled_texture_type = [I.keywords.texture_1d, I.keywords.texture_2d, I.keywords.texture_2d_array, I.keywords.texture_3d, I.keywords.texture_cube, I.keywords.texture_cube_array];
-T.multisampled_texture_type = [I.keywords.texture_multisampled_2d];
-T.storage_texture_type = [I.keywords.texture_storage_1d, I.keywords.texture_storage_2d, I.keywords.texture_storage_2d_array, I.keywords.texture_storage_3d];
-T.depth_texture_type = [I.keywords.texture_depth_2d, I.keywords.texture_depth_2d_array, I.keywords.texture_depth_cube, I.keywords.texture_depth_cube_array, I.keywords.texture_depth_multisampled_2d];
-T.texture_external_type = [I.keywords.texture_external];
-T.any_texture_type = [...I.sampled_texture_type, ...I.multisampled_texture_type, ...I.storage_texture_type, ...I.depth_texture_type, ...I.texture_external_type];
-T.texel_format = [I.keywords.r8unorm, I.keywords.r8snorm, I.keywords.r8uint, I.keywords.r8sint, I.keywords.r16uint, I.keywords.r16sint, I.keywords.r16float, I.keywords.rg8unorm, I.keywords.rg8snorm, I.keywords.rg8uint, I.keywords.rg8sint, I.keywords.r32uint, I.keywords.r32sint, I.keywords.r32float, I.keywords.rg16uint, I.keywords.rg16sint, I.keywords.rg16float, I.keywords.rgba8unorm, I.keywords.rgba8unorm_srgb, I.keywords.rgba8snorm, I.keywords.rgba8uint, I.keywords.rgba8sint, I.keywords.bgra8unorm, I.keywords.bgra8unorm_srgb, I.keywords.rgb10a2unorm, I.keywords.rg11b10float, I.keywords.rg32uint, I.keywords.rg32sint, I.keywords.rg32float, I.keywords.rgba16uint, I.keywords.rgba16sint, I.keywords.rgba16float, I.keywords.rgba32uint, I.keywords.rgba32sint, I.keywords.rgba32float];
-T.const_literal = [I.tokens.int_literal, I.tokens.uint_literal, I.tokens.decimal_float_literal, I.tokens.hex_float_literal, I.keywords.true, I.keywords.false];
-T.literal_or_ident = [I.tokens.ident, I.tokens.int_literal, I.tokens.uint_literal, I.tokens.decimal_float_literal, I.tokens.hex_float_literal];
-T.element_count_expression = [I.tokens.int_literal, I.tokens.uint_literal, I.tokens.ident];
-T.template_types = [I.keywords.vec2, I.keywords.vec3, I.keywords.vec4, I.keywords.mat2x2, I.keywords.mat2x3, I.keywords.mat2x4, I.keywords.mat3x2, I.keywords.mat3x3, I.keywords.mat3x4, I.keywords.mat4x2, I.keywords.mat4x3, I.keywords.mat4x4, I.keywords.atomic, I.keywords.bitcast, ...I.any_texture_type];
-T.attribute_name = [I.tokens.ident, I.keywords.block];
-T.assignment_operators = [I.tokens.equal, I.tokens.plus_equal, I.tokens.minus_equal, I.tokens.times_equal, I.tokens.division_equal, I.tokens.modulo_equal, I.tokens.and_equal, I.tokens.or_equal, I.tokens.xor_equal, I.tokens.shift_right_equal, I.tokens.shift_left_equal];
-T.increment_operators = [I.tokens.plus_plus, I.tokens.minus_minus];
-var fc = class {
+    x = class {};
+O = x;
+x.none = new A("", E.reserved, "");
+x.eof = new A("EOF", E.token, "");
+x.reserved = {
+    asm: new A("asm", E.reserved, "asm"),
+    bf16: new A("bf16", E.reserved, "bf16"),
+    do: new A("do", E.reserved, "do"),
+    enum: new A("enum", E.reserved, "enum"),
+    f16: new A("f16", E.reserved, "f16"),
+    f64: new A("f64", E.reserved, "f64"),
+    handle: new A("handle", E.reserved, "handle"),
+    i8: new A("i8", E.reserved, "i8"),
+    i16: new A("i16", E.reserved, "i16"),
+    i64: new A("i64", E.reserved, "i64"),
+    mat: new A("mat", E.reserved, "mat"),
+    premerge: new A("premerge", E.reserved, "premerge"),
+    regardless: new A("regardless", E.reserved, "regardless"),
+    typedef: new A("typedef", E.reserved, "typedef"),
+    u8: new A("u8", E.reserved, "u8"),
+    u16: new A("u16", E.reserved, "u16"),
+    u64: new A("u64", E.reserved, "u64"),
+    unless: new A("unless", E.reserved, "unless"),
+    using: new A("using", E.reserved, "using"),
+    vec: new A("vec", E.reserved, "vec"),
+    void: new A("void", E.reserved, "void")
+};
+x.keywords = {
+    array: new A("array", E.keyword, "array"),
+    atomic: new A("atomic", E.keyword, "atomic"),
+    bool: new A("bool", E.keyword, "bool"),
+    f32: new A("f32", E.keyword, "f32"),
+    i32: new A("i32", E.keyword, "i32"),
+    mat2x2: new A("mat2x2", E.keyword, "mat2x2"),
+    mat2x3: new A("mat2x3", E.keyword, "mat2x3"),
+    mat2x4: new A("mat2x4", E.keyword, "mat2x4"),
+    mat3x2: new A("mat3x2", E.keyword, "mat3x2"),
+    mat3x3: new A("mat3x3", E.keyword, "mat3x3"),
+    mat3x4: new A("mat3x4", E.keyword, "mat3x4"),
+    mat4x2: new A("mat4x2", E.keyword, "mat4x2"),
+    mat4x3: new A("mat4x3", E.keyword, "mat4x3"),
+    mat4x4: new A("mat4x4", E.keyword, "mat4x4"),
+    ptr: new A("ptr", E.keyword, "ptr"),
+    sampler: new A("sampler", E.keyword, "sampler"),
+    sampler_comparison: new A("sampler_comparison", E.keyword, "sampler_comparison"),
+    struct: new A("struct", E.keyword, "struct"),
+    texture_1d: new A("texture_1d", E.keyword, "texture_1d"),
+    texture_2d: new A("texture_2d", E.keyword, "texture_2d"),
+    texture_2d_array: new A("texture_2d_array", E.keyword, "texture_2d_array"),
+    texture_3d: new A("texture_3d", E.keyword, "texture_3d"),
+    texture_cube: new A("texture_cube", E.keyword, "texture_cube"),
+    texture_cube_array: new A("texture_cube_array", E.keyword, "texture_cube_array"),
+    texture_multisampled_2d: new A("texture_multisampled_2d", E.keyword, "texture_multisampled_2d"),
+    texture_storage_1d: new A("texture_storage_1d", E.keyword, "texture_storage_1d"),
+    texture_storage_2d: new A("texture_storage_2d", E.keyword, "texture_storage_2d"),
+    texture_storage_2d_array: new A("texture_storage_2d_array", E.keyword, "texture_storage_2d_array"),
+    texture_storage_3d: new A("texture_storage_3d", E.keyword, "texture_storage_3d"),
+    texture_depth_2d: new A("texture_depth_2d", E.keyword, "texture_depth_2d"),
+    texture_depth_2d_array: new A("texture_depth_2d_array", E.keyword, "texture_depth_2d_array"),
+    texture_depth_cube: new A("texture_depth_cube", E.keyword, "texture_depth_cube"),
+    texture_depth_cube_array: new A("texture_depth_cube_array", E.keyword, "texture_depth_cube_array"),
+    texture_depth_multisampled_2d: new A("texture_depth_multisampled_2d", E.keyword, "texture_depth_multisampled_2d"),
+    texture_external: new A("texture_external", E.keyword, "texture_external"),
+    u32: new A("u32", E.keyword, "u32"),
+    vec2: new A("vec2", E.keyword, "vec2"),
+    vec3: new A("vec3", E.keyword, "vec3"),
+    vec4: new A("vec4", E.keyword, "vec4"),
+    bitcast: new A("bitcast", E.keyword, "bitcast"),
+    block: new A("block", E.keyword, "block"),
+    break: new A("break", E.keyword, "break"),
+    case: new A("case", E.keyword, "case"),
+    continue: new A("continue", E.keyword, "continue"),
+    continuing: new A("continuing", E.keyword, "continuing"),
+    default: new A("default", E.keyword, "default"),
+    discard: new A("discard", E.keyword, "discard"),
+    else: new A("else", E.keyword, "else"),
+    enable: new A("enable", E.keyword, "enable"),
+    fallthrough: new A("fallthrough", E.keyword, "fallthrough"),
+    false: new A("false", E.keyword, "false"),
+    fn: new A("fn", E.keyword, "fn"),
+    for: new A("for", E.keyword, "for"),
+    function: new A("function", E.keyword, "function"),
+    if: new A("if", E.keyword, "if"),
+    let: new A("let", E.keyword, "let"),
+    const: new A("const", E.keyword, "const"),
+    loop: new A("loop", E.keyword, "loop"),
+    while: new A("while", E.keyword, "while"),
+    private: new A("private", E.keyword, "private"),
+    read: new A("read", E.keyword, "read"),
+    read_write: new A("read_write", E.keyword, "read_write"),
+    return: new A("return", E.keyword, "return"),
+    storage: new A("storage", E.keyword, "storage"),
+    switch: new A("switch", E.keyword, "switch"),
+    true: new A("true", E.keyword, "true"),
+    alias: new A("alias", E.keyword, "alias"),
+    type: new A("type", E.keyword, "type"),
+    uniform: new A("uniform", E.keyword, "uniform"),
+    var: new A("var", E.keyword, "var"),
+    override: new A("override", E.keyword, "override"),
+    workgroup: new A("workgroup", E.keyword, "workgroup"),
+    write: new A("write", E.keyword, "write"),
+    r8unorm: new A("r8unorm", E.keyword, "r8unorm"),
+    r8snorm: new A("r8snorm", E.keyword, "r8snorm"),
+    r8uint: new A("r8uint", E.keyword, "r8uint"),
+    r8sint: new A("r8sint", E.keyword, "r8sint"),
+    r16uint: new A("r16uint", E.keyword, "r16uint"),
+    r16sint: new A("r16sint", E.keyword, "r16sint"),
+    r16float: new A("r16float", E.keyword, "r16float"),
+    rg8unorm: new A("rg8unorm", E.keyword, "rg8unorm"),
+    rg8snorm: new A("rg8snorm", E.keyword, "rg8snorm"),
+    rg8uint: new A("rg8uint", E.keyword, "rg8uint"),
+    rg8sint: new A("rg8sint", E.keyword, "rg8sint"),
+    r32uint: new A("r32uint", E.keyword, "r32uint"),
+    r32sint: new A("r32sint", E.keyword, "r32sint"),
+    r32float: new A("r32float", E.keyword, "r32float"),
+    rg16uint: new A("rg16uint", E.keyword, "rg16uint"),
+    rg16sint: new A("rg16sint", E.keyword, "rg16sint"),
+    rg16float: new A("rg16float", E.keyword, "rg16float"),
+    rgba8unorm: new A("rgba8unorm", E.keyword, "rgba8unorm"),
+    rgba8unorm_srgb: new A("rgba8unorm_srgb", E.keyword, "rgba8unorm_srgb"),
+    rgba8snorm: new A("rgba8snorm", E.keyword, "rgba8snorm"),
+    rgba8uint: new A("rgba8uint", E.keyword, "rgba8uint"),
+    rgba8sint: new A("rgba8sint", E.keyword, "rgba8sint"),
+    bgra8unorm: new A("bgra8unorm", E.keyword, "bgra8unorm"),
+    bgra8unorm_srgb: new A("bgra8unorm_srgb", E.keyword, "bgra8unorm_srgb"),
+    rgb10a2unorm: new A("rgb10a2unorm", E.keyword, "rgb10a2unorm"),
+    rg11b10float: new A("rg11b10float", E.keyword, "rg11b10float"),
+    rg32uint: new A("rg32uint", E.keyword, "rg32uint"),
+    rg32sint: new A("rg32sint", E.keyword, "rg32sint"),
+    rg32float: new A("rg32float", E.keyword, "rg32float"),
+    rgba16uint: new A("rgba16uint", E.keyword, "rgba16uint"),
+    rgba16sint: new A("rgba16sint", E.keyword, "rgba16sint"),
+    rgba16float: new A("rgba16float", E.keyword, "rgba16float"),
+    rgba32uint: new A("rgba32uint", E.keyword, "rgba32uint"),
+    rgba32sint: new A("rgba32sint", E.keyword, "rgba32sint"),
+    rgba32float: new A("rgba32float", E.keyword, "rgba32float"),
+    static_assert: new A("static_assert", E.keyword, "static_assert")
+};
+x.tokens = {
+    decimal_float_literal: new A("decimal_float_literal", E.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),
+    hex_float_literal: new A("hex_float_literal", E.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),
+    int_literal: new A("int_literal", E.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
+    uint_literal: new A("uint_literal", E.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
+    ident: new A("ident", E.token, /[a-zA-Z][0-9a-zA-Z_]*/),
+    and: new A("and", E.token, "&"),
+    and_and: new A("and_and", E.token, "&&"),
+    arrow: new A("arrow ", E.token, "->"),
+    attr: new A("attr", E.token, "@"),
+    attr_left: new A("attr_left", E.token, "[["),
+    attr_right: new A("attr_right", E.token, "]]"),
+    forward_slash: new A("forward_slash", E.token, "/"),
+    bang: new A("bang", E.token, "!"),
+    bracket_left: new A("bracket_left", E.token, "["),
+    bracket_right: new A("bracket_right", E.token, "]"),
+    brace_left: new A("brace_left", E.token, "{"),
+    brace_right: new A("brace_right", E.token, "}"),
+    colon: new A("colon", E.token, ":"),
+    comma: new A("comma", E.token, ","),
+    equal: new A("equal", E.token, "="),
+    equal_equal: new A("equal_equal", E.token, "=="),
+    not_equal: new A("not_equal", E.token, "!="),
+    greater_than: new A("greater_than", E.token, ">"),
+    greater_than_equal: new A("greater_than_equal", E.token, ">="),
+    shift_right: new A("shift_right", E.token, ">>"),
+    less_than: new A("less_than", E.token, "<"),
+    less_than_equal: new A("less_than_equal", E.token, "<="),
+    shift_left: new A("shift_left", E.token, "<<"),
+    modulo: new A("modulo", E.token, "%"),
+    minus: new A("minus", E.token, "-"),
+    minus_minus: new A("minus_minus", E.token, "--"),
+    period: new A("period", E.token, "."),
+    plus: new A("plus", E.token, "+"),
+    plus_plus: new A("plus_plus", E.token, "++"),
+    or: new A("or", E.token, "|"),
+    or_or: new A("or_or", E.token, "||"),
+    paren_left: new A("paren_left", E.token, "("),
+    paren_right: new A("paren_right", E.token, ")"),
+    semicolon: new A("semicolon", E.token, ";"),
+    star: new A("star", E.token, "*"),
+    tilde: new A("tilde", E.token, "~"),
+    underscore: new A("underscore", E.token, "_"),
+    xor: new A("xor", E.token, "^"),
+    plus_equal: new A("plus_equal", E.token, "+="),
+    minus_equal: new A("minus_equal", E.token, "-="),
+    times_equal: new A("times_equal", E.token, "*="),
+    division_equal: new A("division_equal", E.token, "/="),
+    modulo_equal: new A("modulo_equal", E.token, "%="),
+    and_equal: new A("and_equal", E.token, "&="),
+    or_equal: new A("or_equal", E.token, "|="),
+    xor_equal: new A("xor_equal", E.token, "^="),
+    shift_right_equal: new A("shift_right_equal", E.token, ">>="),
+    shift_left_equal: new A("shift_left_equal", E.token, "<<=")
+};
+x.storage_class = [O.keywords.function, O.keywords.private, O.keywords.workgroup, O.keywords.uniform, O.keywords.storage];
+x.access_mode = [O.keywords.read, O.keywords.write, O.keywords.read_write];
+x.sampler_type = [O.keywords.sampler, O.keywords.sampler_comparison];
+x.sampled_texture_type = [O.keywords.texture_1d, O.keywords.texture_2d, O.keywords.texture_2d_array, O.keywords.texture_3d, O.keywords.texture_cube, O.keywords.texture_cube_array];
+x.multisampled_texture_type = [O.keywords.texture_multisampled_2d];
+x.storage_texture_type = [O.keywords.texture_storage_1d, O.keywords.texture_storage_2d, O.keywords.texture_storage_2d_array, O.keywords.texture_storage_3d];
+x.depth_texture_type = [O.keywords.texture_depth_2d, O.keywords.texture_depth_2d_array, O.keywords.texture_depth_cube, O.keywords.texture_depth_cube_array, O.keywords.texture_depth_multisampled_2d];
+x.texture_external_type = [O.keywords.texture_external];
+x.any_texture_type = [...O.sampled_texture_type, ...O.multisampled_texture_type, ...O.storage_texture_type, ...O.depth_texture_type, ...O.texture_external_type];
+x.texel_format = [O.keywords.r8unorm, O.keywords.r8snorm, O.keywords.r8uint, O.keywords.r8sint, O.keywords.r16uint, O.keywords.r16sint, O.keywords.r16float, O.keywords.rg8unorm, O.keywords.rg8snorm, O.keywords.rg8uint, O.keywords.rg8sint, O.keywords.r32uint, O.keywords.r32sint, O.keywords.r32float, O.keywords.rg16uint, O.keywords.rg16sint, O.keywords.rg16float, O.keywords.rgba8unorm, O.keywords.rgba8unorm_srgb, O.keywords.rgba8snorm, O.keywords.rgba8uint, O.keywords.rgba8sint, O.keywords.bgra8unorm, O.keywords.bgra8unorm_srgb, O.keywords.rgb10a2unorm, O.keywords.rg11b10float, O.keywords.rg32uint, O.keywords.rg32sint, O.keywords.rg32float, O.keywords.rgba16uint, O.keywords.rgba16sint, O.keywords.rgba16float, O.keywords.rgba32uint, O.keywords.rgba32sint, O.keywords.rgba32float];
+x.const_literal = [O.tokens.int_literal, O.tokens.uint_literal, O.tokens.decimal_float_literal, O.tokens.hex_float_literal, O.keywords.true, O.keywords.false];
+x.literal_or_ident = [O.tokens.ident, O.tokens.int_literal, O.tokens.uint_literal, O.tokens.decimal_float_literal, O.tokens.hex_float_literal];
+x.element_count_expression = [O.tokens.int_literal, O.tokens.uint_literal, O.tokens.ident];
+x.template_types = [O.keywords.vec2, O.keywords.vec3, O.keywords.vec4, O.keywords.mat2x2, O.keywords.mat2x3, O.keywords.mat2x4, O.keywords.mat3x2, O.keywords.mat3x3, O.keywords.mat3x4, O.keywords.mat4x2, O.keywords.mat4x3, O.keywords.mat4x4, O.keywords.atomic, O.keywords.bitcast, ...O.any_texture_type];
+x.attribute_name = [O.tokens.ident, O.keywords.block];
+x.assignment_operators = [O.tokens.equal, O.tokens.plus_equal, O.tokens.minus_equal, O.tokens.times_equal, O.tokens.division_equal, O.tokens.modulo_equal, O.tokens.and_equal, O.tokens.or_equal, O.tokens.xor_equal, O.tokens.shift_right_equal, O.tokens.shift_left_equal];
+x.increment_operators = [O.tokens.plus_plus, O.tokens.minus_minus];
+var pd = class {
         constructor(t, r, i) {
             this.type = t, this.lexeme = r, this.line = i
         }
         toString() {
             return this.lexeme
         }
         isTemplateType() {
-            return T.template_types.indexOf(this.type) != -1
+            return x.template_types.indexOf(this.type) != -1
         }
         isArrayType() {
-            return this.type == T.keywords.array
+            return this.type == x.keywords.array
         }
         isArrayOrTemplateType() {
             return this.isArrayType() || this.isTemplateType()
         }
     },
-    ru = class {
+    $y = class {
         constructor(t) {
             this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = t ?? ""
         }
         scanTokens() {
             for (; !this._isAtEnd();)
                 if (this._start = this._current, !this.scanToken()) throw `Invalid syntax at line ${this._line}`;
-            return this._tokens.push(new fc(T.eof, "", this._line)), this._tokens
+            return this._tokens.push(new pd(x.eof, "", this._line)), this._tokens
         }
         scanToken() {
             let t = this._advance();
             if (t == `
 `) return this._line++, !0;
             if (this._isWhitespace(t)) return !0;
             if (t == "/") {
@@ -6704,53 +6704,53 @@
                         else if (t == "*") {
                             if (this._peekAhead() == "/" && (this._advance(), i--, i == 0)) return !0
                         } else t == "/" && this._peekAhead() == "*" && (this._advance(), i++)
                     }
                     return !0
                 }
             }
-            let r = T.none;
+            let r = x.none;
             for (;;) {
                 let i = this._findType(t),
-                    s = this._peekAhead();
-                if (t == ">" && (s == ">" || s == "=")) {
-                    let n = !1,
+                    n = this._peekAhead();
+                if (t == ">" && (n == ">" || n == "=")) {
+                    let s = !1,
                         o = this._tokens.length - 1;
                     for (let a = 0; a < 5 && o >= 0; ++a, --o)
-                        if (this._tokens[o].type === T.tokens.less_than) {
-                            o > 0 && this._tokens[o - 1].isArrayOrTemplateType() && (n = !0);
+                        if (this._tokens[o].type === x.tokens.less_than) {
+                            o > 0 && this._tokens[o - 1].isArrayOrTemplateType() && (s = !0);
                             break
-                        } if (n) return this._addToken(i), !0
+                        } if (s) return this._addToken(i), !0
                 }
-                if (i === T.none) {
-                    let n = t,
+                if (i === x.none) {
+                    let s = t,
                         o = 0,
                         a = 2;
                     for (let c = 0; c < a; ++c)
-                        if (n += this._peekAhead(c), i = this._findType(n), i !== T.none) {
+                        if (s += this._peekAhead(c), i = this._findType(s), i !== x.none) {
                             o = c;
                             break
-                        } if (i === T.none) return r === T.none ? !1 : (this._current--, this._addToken(r), !0);
-                    t = n, this._current += o + 1
+                        } if (i === x.none) return r === x.none ? !1 : (this._current--, this._addToken(r), !0);
+                    t = s, this._current += o + 1
                 }
                 if (r = i, this._isAtEnd()) break;
                 t += this._advance()
             }
-            return r === T.none ? !1 : (this._addToken(r), !0)
+            return r === x.none ? !1 : (this._addToken(r), !0)
         }
         _findType(t) {
-            for (let r in T.keywords) {
-                let i = T.keywords[r];
+            for (let r in x.keywords) {
+                let i = x.keywords[r];
                 if (this._match(t, i.rule)) return i
             }
-            for (let r in T.tokens) {
-                let i = T.tokens[r];
+            for (let r in x.tokens) {
+                let i = x.tokens[r];
                 if (this._match(t, i.rule)) return i
             }
-            return T.none
+            return x.none
         }
         _match(t, r) {
             if (typeof r == "string") {
                 if (r == t) return !0
             } else {
                 let i = r.exec(t);
                 if (i && i.index == 0 && i[0] == t) return !0
@@ -6768,35 +6768,35 @@
             return t = t || 0, t++, this._current += t, r
         }
         _peekAhead(t = 0) {
             return t = t || 0, this._current + t >= this._source.length ? "\0" : this._source[this._current + t]
         }
         _addToken(t) {
             let r = this._source.substring(this._start, this._current);
-            this._tokens.push(new fc(t, r, this._line))
+            this._tokens.push(new pd(t, r, this._line))
         }
     },
-    iu = class {
+    Xy = class {
         constructor() {
-            this._tokens = [], this._current = 0, this._context = new Mf
+            this._tokens = [], this._current = 0, this._context = new yy
         }
         parse(t) {
             this._initialize(t);
             let r = [];
             for (; !this._isAtEnd();) {
                 let i = this._global_decl_or_directive();
                 if (!i) break;
                 r.push(i)
             }
             return r
         }
         _initialize(t) {
             if (t)
                 if (typeof t == "string") {
-                    let r = new ru(t);
+                    let r = new $y(t);
                     this._tokens = r.scanTokens()
                 } else this._tokens = t;
             else this._tokens = [];
             this._current = 0
         }
         _error(t, r) {
             return console.error(t, r), {
@@ -6804,21 +6804,21 @@
                 message: r,
                 toString: function() {
                     return `${r}`
                 }
             }
         }
         _isAtEnd() {
-            return this._current >= this._tokens.length || this._peek().type == T.eof
+            return this._current >= this._tokens.length || this._peek().type == x.eof
         }
         _match(t) {
-            if (t instanceof S) return this._check(t) ? (this._advance(), !0) : !1;
+            if (t instanceof A) return this._check(t) ? (this._advance(), !0) : !1;
             for (let r = 0, i = t.length; r < i; ++r) {
-                let s = t[r];
-                if (this._check(s)) return this._advance(), !0
+                let n = t[r];
+                if (this._check(n)) return this._advance(), !0
             }
             return !1
         }
         _consume(t, r) {
             if (this._check(t)) return this._advance();
             throw this._error(this._peek(), r)
         }
@@ -6837,596 +6837,596 @@
         _peek() {
             return this._tokens[this._current]
         }
         _previous() {
             return this._tokens[this._current - 1]
         }
         _global_decl_or_directive() {
-            for (; this._match(T.tokens.semicolon) && !this._isAtEnd(););
-            if (this._match(T.keywords.alias)) {
+            for (; this._match(x.tokens.semicolon) && !this._isAtEnd(););
+            if (this._match(x.keywords.alias)) {
                 let r = this._type_alias();
-                return this._consume(T.tokens.semicolon, "Expected ';'"), r
+                return this._consume(x.tokens.semicolon, "Expected ';'"), r
             }
-            if (this._match(T.keywords.enable)) {
+            if (this._match(x.keywords.enable)) {
                 let r = this._enable_directive();
-                return this._consume(T.tokens.semicolon, "Expected ';'"), r
+                return this._consume(x.tokens.semicolon, "Expected ';'"), r
             }
             let t = this._attribute();
-            if (this._check(T.keywords.var)) {
+            if (this._check(x.keywords.var)) {
                 let r = this._global_variable_decl();
-                return r != null && (r.attributes = t), this._consume(T.tokens.semicolon, "Expected ';'."), r
+                return r != null && (r.attributes = t), this._consume(x.tokens.semicolon, "Expected ';'."), r
             }
-            if (this._check(T.keywords.override)) {
+            if (this._check(x.keywords.override)) {
                 let r = this._override_variable_decl();
-                return r != null && (r.attributes = t), this._consume(T.tokens.semicolon, "Expected ';'."), r
+                return r != null && (r.attributes = t), this._consume(x.tokens.semicolon, "Expected ';'."), r
             }
-            if (this._check(T.keywords.let)) {
+            if (this._check(x.keywords.let)) {
                 let r = this._global_let_decl();
-                return r != null && (r.attributes = t), this._consume(T.tokens.semicolon, "Expected ';'."), r
+                return r != null && (r.attributes = t), this._consume(x.tokens.semicolon, "Expected ';'."), r
             }
-            if (this._check(T.keywords.const)) {
+            if (this._check(x.keywords.const)) {
                 let r = this._global_const_decl();
-                return r != null && (r.attributes = t), this._consume(T.tokens.semicolon, "Expected ';'."), r
+                return r != null && (r.attributes = t), this._consume(x.tokens.semicolon, "Expected ';'."), r
             }
-            if (this._check(T.keywords.struct)) {
+            if (this._check(x.keywords.struct)) {
                 let r = this._struct_decl();
                 return r != null && (r.attributes = t), r
             }
-            if (this._check(T.keywords.fn)) {
+            if (this._check(x.keywords.fn)) {
                 let r = this._function_decl();
                 return r != null && (r.attributes = t), r
             }
             return null
         }
         _function_decl() {
-            if (!this._match(T.keywords.fn)) return null;
-            let t = this._consume(T.tokens.ident, "Expected function name.").toString();
-            this._consume(T.tokens.paren_left, "Expected '(' for function arguments.");
+            if (!this._match(x.keywords.fn)) return null;
+            let t = this._consume(x.tokens.ident, "Expected function name.").toString();
+            this._consume(x.tokens.paren_left, "Expected '(' for function arguments.");
             let r = [];
-            if (!this._check(T.tokens.paren_right))
+            if (!this._check(x.tokens.paren_right))
                 do {
-                    if (this._check(T.tokens.paren_right)) break;
-                    let n = this._attribute(),
-                        o = this._consume(T.tokens.ident, "Expected argument name.").toString();
-                    this._consume(T.tokens.colon, "Expected ':' for argument type.");
+                    if (this._check(x.tokens.paren_right)) break;
+                    let s = this._attribute(),
+                        o = this._consume(x.tokens.ident, "Expected argument name.").toString();
+                    this._consume(x.tokens.colon, "Expected ':' for argument type.");
                     let a = this._attribute(),
                         c = this._type_decl();
-                    c != null && (c.attributes = a, r.push(new Jf(o, c, n)))
-                } while (this._match(T.tokens.comma));
-            this._consume(T.tokens.paren_right, "Expected ')' after function arguments.");
+                    c != null && (c.attributes = a, r.push(new Wy(o, c, s)))
+                } while (this._match(x.tokens.comma));
+            this._consume(x.tokens.paren_right, "Expected ')' after function arguments.");
             let i = null;
-            if (this._match(T.tokens.arrow)) {
-                let n = this._attribute();
-                i = this._type_decl(), i != null && (i.attributes = n)
+            if (this._match(x.tokens.arrow)) {
+                let s = this._attribute();
+                i = this._type_decl(), i != null && (i.attributes = s)
             }
-            let s = this._compound_statement();
-            return new Qa(t, r, i, s)
+            let n = this._compound_statement();
+            return new td(t, r, i, n)
         }
         _compound_statement() {
             let t = [];
-            for (this._consume(T.tokens.brace_left, "Expected '{' for block."); !this._check(T.tokens.brace_right);) {
+            for (this._consume(x.tokens.brace_left, "Expected '{' for block."); !this._check(x.tokens.brace_right);) {
                 let r = this._statement();
                 r !== null && t.push(r)
             }
-            return this._consume(T.tokens.brace_right, "Expected '}' for block."), t
+            return this._consume(x.tokens.brace_right, "Expected '}' for block."), t
         }
         _statement() {
-            for (; this._match(T.tokens.semicolon) && !this._isAtEnd(););
-            if (this._check(T.keywords.if)) return this._if_statement();
-            if (this._check(T.keywords.switch)) return this._switch_statement();
-            if (this._check(T.keywords.loop)) return this._loop_statement();
-            if (this._check(T.keywords.for)) return this._for_statement();
-            if (this._check(T.keywords.while)) return this._while_statement();
-            if (this._check(T.keywords.continuing)) return this._continuing_statement();
-            if (this._check(T.keywords.static_assert)) return this._static_assert_statement();
-            if (this._check(T.tokens.brace_left)) return this._compound_statement();
+            for (; this._match(x.tokens.semicolon) && !this._isAtEnd(););
+            if (this._check(x.keywords.if)) return this._if_statement();
+            if (this._check(x.keywords.switch)) return this._switch_statement();
+            if (this._check(x.keywords.loop)) return this._loop_statement();
+            if (this._check(x.keywords.for)) return this._for_statement();
+            if (this._check(x.keywords.while)) return this._while_statement();
+            if (this._check(x.keywords.continuing)) return this._continuing_statement();
+            if (this._check(x.keywords.static_assert)) return this._static_assert_statement();
+            if (this._check(x.tokens.brace_left)) return this._compound_statement();
             let t = null;
-            return this._check(T.keywords.return) ? t = this._return_statement() : this._check([T.keywords.var, T.keywords.let, T.keywords.const]) ? t = this._variable_statement() : this._match(T.keywords.discard) ? t = new Wf : this._match(T.keywords.break) ? t = new jf : this._match(T.keywords.continue) ? t = new Hf : t = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement(), t != null && this._consume(T.tokens.semicolon, "Expected ';' after statement."), t
+            return this._check(x.keywords.return) ? t = this._return_statement() : this._check([x.keywords.var, x.keywords.let, x.keywords.const]) ? t = this._variable_statement() : this._match(x.keywords.discard) ? t = new Cy : this._match(x.keywords.break) ? t = new Oy : this._match(x.keywords.continue) ? t = new Ny : t = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement(), t != null && this._consume(x.tokens.semicolon, "Expected ';' after statement."), t
         }
         _static_assert_statement() {
-            if (!this._match(T.keywords.static_assert)) return null;
+            if (!this._match(x.keywords.static_assert)) return null;
             let t = this._optional_paren_expression();
-            return new Cf(t)
+            return new by(t)
         }
         _while_statement() {
-            if (!this._match(T.keywords.while)) return null;
+            if (!this._match(x.keywords.while)) return null;
             let t = this._optional_paren_expression(),
                 r = this._compound_statement();
-            return new If(t, r)
+            return new xy(t, r)
         }
         _continuing_statement() {
-            if (!this._match(T.keywords.continuing)) return null;
+            if (!this._match(x.keywords.continuing)) return null;
             let t = this._compound_statement();
-            return new Of(t)
+            return new wy(t)
         }
         _for_statement() {
-            if (!this._match(T.keywords.for)) return null;
-            this._consume(T.tokens.paren_left, "Expected '('.");
-            let t = this._check(T.tokens.semicolon) ? null : this._for_init();
-            this._consume(T.tokens.semicolon, "Expected ';'.");
-            let r = this._check(T.tokens.semicolon) ? null : this._short_circuit_or_expression();
-            this._consume(T.tokens.semicolon, "Expected ';'.");
-            let i = this._check(T.tokens.paren_right) ? null : this._for_increment();
-            this._consume(T.tokens.paren_right, "Expected ')'.");
-            let s = this._compound_statement();
-            return new Nf(t, r, i, s)
+            if (!this._match(x.keywords.for)) return null;
+            this._consume(x.tokens.paren_left, "Expected '('.");
+            let t = this._check(x.tokens.semicolon) ? null : this._for_init();
+            this._consume(x.tokens.semicolon, "Expected ';'.");
+            let r = this._check(x.tokens.semicolon) ? null : this._short_circuit_or_expression();
+            this._consume(x.tokens.semicolon, "Expected ';'.");
+            let i = this._check(x.tokens.paren_right) ? null : this._for_increment();
+            this._consume(x.tokens.paren_right, "Expected ')'.");
+            let n = this._compound_statement();
+            return new Ty(t, r, i, n)
         }
         _for_init() {
             return this._variable_statement() || this._func_call_statement() || this._assignment_statement()
         }
         _for_increment() {
             return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement()
         }
         _variable_statement() {
-            if (this._check(T.keywords.var)) {
+            if (this._check(x.keywords.var)) {
                 let t = this._variable_decl();
                 if (t === null) throw this._error(this._peek(), "Variable declaration expected.");
                 let r = null;
-                return this._match(T.tokens.equal) && (r = this._short_circuit_or_expression()), new zr(t.name, t.type, t.storage, t.access, r)
+                return this._match(x.tokens.equal) && (r = this._short_circuit_or_expression()), new ws(t.name, t.type, t.storage, t.access, r)
             }
-            if (this._match(T.keywords.let)) {
-                let t = this._consume(T.tokens.ident, "Expected name for let.").toString(),
+            if (this._match(x.keywords.let)) {
+                let t = this._consume(x.tokens.ident, "Expected name for let.").toString(),
                     r = null;
-                if (this._match(T.tokens.colon)) {
-                    let s = this._attribute();
-                    r = this._type_decl(), r != null && (r.attributes = s)
+                if (this._match(x.tokens.colon)) {
+                    let n = this._attribute();
+                    r = this._type_decl(), r != null && (r.attributes = n)
                 }
-                this._consume(T.tokens.equal, "Expected '=' for let.");
+                this._consume(x.tokens.equal, "Expected '=' for let.");
                 let i = this._short_circuit_or_expression();
-                return new Ja(t, r, null, null, i)
+                return new rd(t, r, null, null, i)
             }
-            if (this._match(T.keywords.const)) {
-                let t = this._consume(T.tokens.ident, "Expected name for const.").toString(),
+            if (this._match(x.keywords.const)) {
+                let t = this._consume(x.tokens.ident, "Expected name for const.").toString(),
                     r = null;
-                if (this._match(T.tokens.colon)) {
-                    let s = this._attribute();
-                    r = this._type_decl(), r != null && (r.attributes = s)
+                if (this._match(x.tokens.colon)) {
+                    let n = this._attribute();
+                    r = this._type_decl(), r != null && (r.attributes = n)
                 }
-                this._consume(T.tokens.equal, "Expected '=' for const.");
+                this._consume(x.tokens.equal, "Expected '=' for const.");
                 let i = this._short_circuit_or_expression();
-                return new tc(t, r, null, null, i)
+                return new id(t, r, null, null, i)
             }
             return null
         }
         _increment_decrement_statement() {
             let t = this._current,
                 r = this._unary_expression();
             if (r == null) return null;
-            if (!this._check(T.increment_operators)) return this._current = t, null;
-            let i = this._consume(T.increment_operators, "Expected increment operator");
-            return new Ff(i.type === T.tokens.plus_plus ? fs.increment : fs.decrement, r)
+            if (!this._check(x.increment_operators)) return this._current = t, null;
+            let i = this._consume(x.increment_operators, "Expected increment operator");
+            return new vy(i.type === x.tokens.plus_plus ? Pa.increment : Pa.decrement, r)
         }
         _assignment_statement() {
             let t = null;
-            if (this._check(T.tokens.brace_right)) return null;
-            let r = this._match(T.tokens.underscore);
+            if (this._check(x.tokens.brace_right)) return null;
+            let r = this._match(x.tokens.underscore);
             if (r || (t = this._unary_expression()), !r && t == null) return null;
-            let i = this._consume(T.assignment_operators, "Expected assignment operator."),
-                s = this._short_circuit_or_expression();
-            return new Df(Bn.parse(i.lexeme), t, s)
+            let i = this._consume(x.assignment_operators, "Expected assignment operator."),
+                n = this._short_circuit_or_expression();
+            return new Sy(Pl.parse(i.lexeme), t, n)
         }
         _func_call_statement() {
-            if (!this._check(T.tokens.ident)) return null;
+            if (!this._check(x.tokens.ident)) return null;
             let t = this._current,
-                r = this._consume(T.tokens.ident, "Expected function name."),
+                r = this._consume(x.tokens.ident, "Expected function name."),
                 i = this._argument_expression_list();
-            return i === null ? (this._current = t, null) : new kf(r.lexeme, i)
+            return i === null ? (this._current = t, null) : new Ay(r.lexeme, i)
         }
         _loop_statement() {
-            if (!this._match(T.keywords.loop)) return null;
-            this._consume(T.tokens.brace_left, "Expected '{' for loop.");
+            if (!this._match(x.keywords.loop)) return null;
+            this._consume(x.tokens.brace_left, "Expected '{' for loop.");
             let t = [],
                 r = this._statement();
             for (; r !== null;) {
                 if (Array.isArray(r))
-                    for (let s of r) t.push(s);
+                    for (let n of r) t.push(n);
                 else t.push(r);
                 r = this._statement()
             }
             let i = null;
-            return this._match(T.keywords.continuing) && (i = this._compound_statement()), this._consume(T.tokens.brace_right, "Expected '}' for loop."), new Lf(t, i)
+            return this._match(x.keywords.continuing) && (i = this._compound_statement()), this._consume(x.tokens.brace_right, "Expected '}' for loop."), new Ey(t, i)
         }
         _switch_statement() {
-            if (!this._match(T.keywords.switch)) return null;
+            if (!this._match(x.keywords.switch)) return null;
             let t = this._optional_paren_expression();
-            this._consume(T.tokens.brace_left, "Expected '{' for switch.");
+            this._consume(x.tokens.brace_left, "Expected '{' for switch.");
             let r = this._switch_body();
             if (r == null || r.length == 0) throw this._error(this._previous(), "Expected 'case' or 'default'.");
-            return this._consume(T.tokens.brace_right, "Expected '}' for switch."), new Bf(t, r)
+            return this._consume(x.tokens.brace_right, "Expected '}' for switch."), new Iy(t, r)
         }
         _switch_body() {
             let t = [];
-            if (this._match(T.keywords.case)) {
+            if (this._match(x.keywords.case)) {
                 let r = this._case_selectors();
-                this._match(T.tokens.colon), this._consume(T.tokens.brace_left, "Exected '{' for switch case.");
+                this._match(x.tokens.colon), this._consume(x.tokens.brace_left, "Exected '{' for switch case.");
                 let i = this._case_body();
-                this._consume(T.tokens.brace_right, "Exected '}' for switch case."), t.push(new Qf(r, i))
+                this._consume(x.tokens.brace_right, "Exected '}' for switch case."), t.push(new Vy(r, i))
             }
-            if (this._match(T.keywords.default)) {
-                this._match(T.tokens.colon), this._consume(T.tokens.brace_left, "Exected '{' for switch default.");
+            if (this._match(x.keywords.default)) {
+                this._match(x.tokens.colon), this._consume(x.tokens.brace_left, "Exected '{' for switch default.");
                 let r = this._case_body();
-                this._consume(T.tokens.brace_right, "Exected '}' for switch default."), t.push(new Gf(r))
+                this._consume(x.tokens.brace_right, "Exected '}' for switch default."), t.push(new zy(r))
             }
-            if (this._check([T.keywords.default, T.keywords.case])) {
+            if (this._check([x.keywords.default, x.keywords.case])) {
                 let r = this._switch_body();
                 t.push(r[0])
             }
             return t
         }
         _case_selectors() {
-            var t, r, i, s;
-            let n = [(r = (t = this._shift_expression()) === null || t === void 0 ? void 0 : t.evaluate(this._context).toString()) !== null && r !== void 0 ? r : ""];
-            for (; this._match(T.tokens.comma);) n.push((s = (i = this._shift_expression()) === null || i === void 0 ? void 0 : i.evaluate(this._context).toString()) !== null && s !== void 0 ? s : "");
-            return n
+            var t, r, i, n;
+            let s = [(r = (t = this._shift_expression()) === null || t === void 0 ? void 0 : t.evaluate(this._context).toString()) !== null && r !== void 0 ? r : ""];
+            for (; this._match(x.tokens.comma);) s.push((n = (i = this._shift_expression()) === null || i === void 0 ? void 0 : i.evaluate(this._context).toString()) !== null && n !== void 0 ? n : "");
+            return s
         }
         _case_body() {
-            if (this._match(T.keywords.fallthrough)) return this._consume(T.tokens.semicolon, "Expected ';'"), [];
+            if (this._match(x.keywords.fallthrough)) return this._consume(x.tokens.semicolon, "Expected ';'"), [];
             let t = this._statement();
             if (t == null) return [];
             t instanceof Array || (t = [t]);
             let r = this._case_body();
             return r.length == 0 ? t : [...t, r[0]]
         }
         _if_statement() {
-            if (!this._match(T.keywords.if)) return null;
+            if (!this._match(x.keywords.if)) return null;
             let t = this._optional_paren_expression(),
                 r = this._compound_statement(),
                 i = [];
             this._match_elseif() && (i = this._elseif_statement(i));
-            let s = null;
-            return this._match(T.keywords.else) && (s = this._compound_statement()), new Uf(t, r, i, s)
+            let n = null;
+            return this._match(x.keywords.else) && (n = this._compound_statement()), new Ry(t, r, i, n)
         }
         _match_elseif() {
-            return this._tokens[this._current].type === T.keywords.else && this._tokens[this._current + 1].type === T.keywords.if ? (this._advance(), this._advance(), !0) : !1
+            return this._tokens[this._current].type === x.keywords.else && this._tokens[this._current + 1].type === x.keywords.if ? (this._advance(), this._advance(), !0) : !1
         }
         _elseif_statement(t = []) {
             let r = this._optional_paren_expression(),
                 i = this._compound_statement();
-            return t.push(new tu(r, i)), this._match_elseif() && this._elseif_statement(t), t
+            return t.push(new jy(r, i)), this._match_elseif() && this._elseif_statement(t), t
         }
         _return_statement() {
-            if (!this._match(T.keywords.return)) return null;
+            if (!this._match(x.keywords.return)) return null;
             let t = this._short_circuit_or_expression();
-            return new Vf(t)
+            return new My(t)
         }
         _short_circuit_or_expression() {
             let t = this._short_circuit_and_expr();
-            for (; this._match(T.tokens.or_or);) t = new ue(this._previous().toString(), t, this._short_circuit_and_expr());
+            for (; this._match(x.tokens.or_or);) t = new Nr(this._previous().toString(), t, this._short_circuit_and_expr());
             return t
         }
         _short_circuit_and_expr() {
             let t = this._inclusive_or_expression();
-            for (; this._match(T.tokens.and_and);) t = new ue(this._previous().toString(), t, this._inclusive_or_expression());
+            for (; this._match(x.tokens.and_and);) t = new Nr(this._previous().toString(), t, this._inclusive_or_expression());
             return t
         }
         _inclusive_or_expression() {
             let t = this._exclusive_or_expression();
-            for (; this._match(T.tokens.or);) t = new ue(this._previous().toString(), t, this._exclusive_or_expression());
+            for (; this._match(x.tokens.or);) t = new Nr(this._previous().toString(), t, this._exclusive_or_expression());
             return t
         }
         _exclusive_or_expression() {
             let t = this._and_expression();
-            for (; this._match(T.tokens.xor);) t = new ue(this._previous().toString(), t, this._and_expression());
+            for (; this._match(x.tokens.xor);) t = new Nr(this._previous().toString(), t, this._and_expression());
             return t
         }
         _and_expression() {
             let t = this._equality_expression();
-            for (; this._match(T.tokens.and);) t = new ue(this._previous().toString(), t, this._equality_expression());
+            for (; this._match(x.tokens.and);) t = new Nr(this._previous().toString(), t, this._equality_expression());
             return t
         }
         _equality_expression() {
             let t = this._relational_expression();
-            return this._match([T.tokens.equal_equal, T.tokens.not_equal]) ? new ue(this._previous().toString(), t, this._relational_expression()) : t
+            return this._match([x.tokens.equal_equal, x.tokens.not_equal]) ? new Nr(this._previous().toString(), t, this._relational_expression()) : t
         }
         _relational_expression() {
             let t = this._shift_expression();
-            for (; this._match([T.tokens.less_than, T.tokens.greater_than, T.tokens.less_than_equal, T.tokens.greater_than_equal]);) t = new ue(this._previous().toString(), t, this._shift_expression());
+            for (; this._match([x.tokens.less_than, x.tokens.greater_than, x.tokens.less_than_equal, x.tokens.greater_than_equal]);) t = new Nr(this._previous().toString(), t, this._shift_expression());
             return t
         }
         _shift_expression() {
             let t = this._additive_expression();
-            for (; this._match([T.tokens.shift_left, T.tokens.shift_right]);) t = new ue(this._previous().toString(), t, this._additive_expression());
+            for (; this._match([x.tokens.shift_left, x.tokens.shift_right]);) t = new Nr(this._previous().toString(), t, this._additive_expression());
             return t
         }
         _additive_expression() {
             let t = this._multiplicative_expression();
-            for (; this._match([T.tokens.plus, T.tokens.minus]);) t = new ue(this._previous().toString(), t, this._multiplicative_expression());
+            for (; this._match([x.tokens.plus, x.tokens.minus]);) t = new Nr(this._previous().toString(), t, this._multiplicative_expression());
             return t
         }
         _multiplicative_expression() {
             let t = this._unary_expression();
-            for (; this._match([T.tokens.star, T.tokens.forward_slash, T.tokens.modulo]);) t = new ue(this._previous().toString(), t, this._unary_expression());
+            for (; this._match([x.tokens.star, x.tokens.forward_slash, x.tokens.modulo]);) t = new Nr(this._previous().toString(), t, this._unary_expression());
             return t
         }
         _unary_expression() {
-            return this._match([T.tokens.minus, T.tokens.bang, T.tokens.tilde, T.tokens.star, T.tokens.and]) ? new Kf(this._previous().toString(), this._unary_expression()) : this._singular_expression()
+            return this._match([x.tokens.minus, x.tokens.bang, x.tokens.tilde, x.tokens.star, x.tokens.and]) ? new Uy(this._previous().toString(), this._unary_expression()) : this._singular_expression()
         }
         _singular_expression() {
             let t = this._primary_expression(),
                 r = this._postfix_expression();
             return r && (t.postfix = r), t
         }
         _postfix_expression() {
-            if (this._match(T.tokens.bracket_left)) {
+            if (this._match(x.tokens.bracket_left)) {
                 let t = this._short_circuit_or_expression();
-                this._consume(T.tokens.bracket_right, "Expected ']'.");
+                this._consume(x.tokens.bracket_right, "Expected ']'.");
                 let r = this._postfix_expression();
                 return r && (t.postfix = r), t
             }
-            if (this._match(T.tokens.period)) {
-                let t = this._consume(T.tokens.ident, "Expected member name."),
+            if (this._match(x.tokens.period)) {
+                let t = this._consume(x.tokens.ident, "Expected member name."),
                     r = this._postfix_expression(),
-                    i = new sc(t.lexeme);
+                    i = new ad(t.lexeme);
                 return r && (i.postfix = r), i
             }
             return null
         }
         _getStruct(t) {
             return this._context.aliases.has(t) ? this._context.aliases.get(t).type : this._context.structs.has(t) ? this._context.structs.get(t) : null
         }
         _primary_expression() {
-            if (this._match(T.tokens.ident)) {
+            if (this._match(x.tokens.ident)) {
                 let i = this._previous().toString();
-                if (this._check(T.tokens.paren_left)) {
-                    let s = this._argument_expression_list(),
-                        n = this._getStruct(i);
-                    return n != null ? new wi(n, s) : new $f(i, s)
+                if (this._check(x.tokens.paren_left)) {
+                    let n = this._argument_expression_list(),
+                        s = this._getStruct(i);
+                    return s != null ? new xo(s, n) : new Fy(i, n)
                 }
                 if (this._context.constants.has(i)) {
-                    let s = this._context.constants.get(i);
-                    return new nc(i, s.value)
+                    let n = this._context.constants.get(i);
+                    return new cd(i, n.value)
                 }
-                return new Yf(i)
+                return new Dy(i)
             }
-            if (this._match(T.const_literal)) return new oc(parseFloat(this._previous().toString()));
-            if (this._check(T.tokens.paren_left)) return this._paren_expression();
-            if (this._match(T.keywords.bitcast)) {
-                this._consume(T.tokens.less_than, "Expected '<'.");
+            if (this._match(x.const_literal)) return new ld(parseFloat(this._previous().toString()));
+            if (this._check(x.tokens.paren_left)) return this._paren_expression();
+            if (this._match(x.keywords.bitcast)) {
+                this._consume(x.tokens.less_than, "Expected '<'.");
                 let i = this._type_decl();
-                this._consume(T.tokens.greater_than, "Expected '>'.");
-                let s = this._paren_expression();
-                return new qf(i, s)
+                this._consume(x.tokens.greater_than, "Expected '>'.");
+                let n = this._paren_expression();
+                return new Ly(i, n)
             }
             let t = this._type_decl(),
                 r = this._argument_expression_list();
-            return new Zf(t, r)
+            return new ky(t, r)
         }
         _argument_expression_list() {
-            if (!this._match(T.tokens.paren_left)) return null;
+            if (!this._match(x.tokens.paren_left)) return null;
             let t = [];
             do {
-                if (this._check(T.tokens.paren_right)) break;
+                if (this._check(x.tokens.paren_right)) break;
                 let r = this._short_circuit_or_expression();
                 t.push(r)
-            } while (this._match(T.tokens.comma));
-            return this._consume(T.tokens.paren_right, "Expected ')' for agument list"), t
+            } while (this._match(x.tokens.comma));
+            return this._consume(x.tokens.paren_right, "Expected ')' for agument list"), t
         }
         _optional_paren_expression() {
-            this._match(T.tokens.paren_left);
+            this._match(x.tokens.paren_left);
             let t = this._short_circuit_or_expression();
-            return this._match(T.tokens.paren_right), new ac([t])
+            return this._match(x.tokens.paren_right), new ud([t])
         }
         _paren_expression() {
-            this._consume(T.tokens.paren_left, "Expected '('.");
+            this._consume(x.tokens.paren_left, "Expected '('.");
             let t = this._short_circuit_or_expression();
-            return this._consume(T.tokens.paren_right, "Expected ')'."), new ac([t])
+            return this._consume(x.tokens.paren_right, "Expected ')'."), new ud([t])
         }
         _struct_decl() {
-            if (!this._match(T.keywords.struct)) return null;
-            let t = this._consume(T.tokens.ident, "Expected name for struct.").toString();
-            this._consume(T.tokens.brace_left, "Expected '{' for struct body.");
+            if (!this._match(x.keywords.struct)) return null;
+            let t = this._consume(x.tokens.ident, "Expected name for struct.").toString();
+            this._consume(x.tokens.brace_left, "Expected '{' for struct body.");
             let r = [];
-            for (; !this._check(T.tokens.brace_right);) {
-                let s = this._attribute(),
-                    n = this._consume(T.tokens.ident, "Expected variable name.").toString();
-                this._consume(T.tokens.colon, "Expected ':' for struct member type.");
+            for (; !this._check(x.tokens.brace_right);) {
+                let n = this._attribute(),
+                    s = this._consume(x.tokens.ident, "Expected variable name.").toString();
+                this._consume(x.tokens.colon, "Expected ':' for struct member type.");
                 let o = this._attribute(),
                     a = this._type_decl();
-                a != null && (a.attributes = o), this._check(T.tokens.brace_right) ? this._match(T.tokens.comma) : this._consume(T.tokens.comma, "Expected ',' for struct member."), r.push(new eu(n, a, s))
+                a != null && (a.attributes = o), this._check(x.tokens.brace_right) ? this._match(x.tokens.comma) : this._consume(x.tokens.comma, "Expected ',' for struct member."), r.push(new Hy(s, a, n))
             }
-            this._consume(T.tokens.brace_right, "Expected '}' after struct body.");
-            let i = new hr(t, r);
+            this._consume(x.tokens.brace_right, "Expected '}' after struct body.");
+            let i = new bn(t, r);
             return this._context.structs.set(t, i), i
         }
         _global_variable_decl() {
             let t = this._variable_decl();
-            return t && this._match(T.tokens.equal) && (t.value = this._const_expression()), t
+            return t && this._match(x.tokens.equal) && (t.value = this._const_expression()), t
         }
         _override_variable_decl() {
             let t = this._override_decl();
-            return t && this._match(T.tokens.equal) && (t.value = this._const_expression()), t
+            return t && this._match(x.tokens.equal) && (t.value = this._const_expression()), t
         }
         _global_const_decl() {
-            if (!this._match(T.keywords.const)) return null;
-            let t = this._consume(T.tokens.ident, "Expected variable name"),
+            if (!this._match(x.keywords.const)) return null;
+            let t = this._consume(x.tokens.ident, "Expected variable name"),
                 r = null;
-            if (this._match(T.tokens.colon)) {
-                let n = this._attribute();
-                r = this._type_decl(), r != null && (r.attributes = n)
+            if (this._match(x.tokens.colon)) {
+                let s = this._attribute();
+                r = this._type_decl(), r != null && (r.attributes = s)
             }
             let i = null;
-            if (this._match(T.tokens.equal)) {
-                let n = this._short_circuit_or_expression();
-                if (n instanceof wi) i = n;
-                else if (n instanceof nc && n.initializer instanceof wi) i = n.initializer;
+            if (this._match(x.tokens.equal)) {
+                let s = this._short_circuit_or_expression();
+                if (s instanceof xo) i = s;
+                else if (s instanceof cd && s.initializer instanceof xo) i = s.initializer;
                 else try {
-                    let o = n.evaluate(this._context);
-                    i = new oc(o)
+                    let o = s.evaluate(this._context);
+                    i = new ld(o)
                 } catch {
-                    i = n
+                    i = s
                 }
             }
-            let s = new tc(t.toString(), r, "", "", i);
-            return this._context.constants.set(s.name, s), s
+            let n = new id(t.toString(), r, "", "", i);
+            return this._context.constants.set(n.name, n), n
         }
         _global_let_decl() {
-            if (!this._match(T.keywords.let)) return null;
-            let t = this._consume(T.tokens.ident, "Expected variable name"),
+            if (!this._match(x.keywords.let)) return null;
+            let t = this._consume(x.tokens.ident, "Expected variable name"),
                 r = null;
-            if (this._match(T.tokens.colon)) {
-                let s = this._attribute();
-                r = this._type_decl(), r != null && (r.attributes = s)
+            if (this._match(x.tokens.colon)) {
+                let n = this._attribute();
+                r = this._type_decl(), r != null && (r.attributes = n)
             }
             let i = null;
-            return this._match(T.tokens.equal) && (i = this._const_expression()), new Ja(t.toString(), r, "", "", i)
+            return this._match(x.tokens.equal) && (i = this._const_expression()), new rd(t.toString(), r, "", "", i)
         }
         _const_expression() {
-            if (this._match(T.const_literal)) return new sc(this._previous().toString());
+            if (this._match(x.const_literal)) return new ad(this._previous().toString());
             let t = this._type_decl();
-            this._consume(T.tokens.paren_left, "Expected '('.");
+            this._consume(x.tokens.paren_left, "Expected '('.");
             let r = [];
-            for (; !this._check(T.tokens.paren_right) && (r.push(this._const_expression()), !!this._check(T.tokens.comma));) this._advance();
-            return this._consume(T.tokens.paren_right, "Expected ')'."), new wi(t, r)
+            for (; !this._check(x.tokens.paren_right) && (r.push(this._const_expression()), !!this._check(x.tokens.comma));) this._advance();
+            return this._consume(x.tokens.paren_right, "Expected ')'."), new xo(t, r)
         }
         _variable_decl() {
-            if (!this._match(T.keywords.var)) return null;
+            if (!this._match(x.keywords.var)) return null;
             let t = "",
                 r = "";
-            this._match(T.tokens.less_than) && (t = this._consume(T.storage_class, "Expected storage_class.").toString(), this._match(T.tokens.comma) && (r = this._consume(T.access_mode, "Expected access_mode.").toString()), this._consume(T.tokens.greater_than, "Expected '>'."));
-            let i = this._consume(T.tokens.ident, "Expected variable name"),
-                s = null;
-            if (this._match(T.tokens.colon)) {
-                let n = this._attribute();
-                s = this._type_decl(), s != null && (s.attributes = n)
+            this._match(x.tokens.less_than) && (t = this._consume(x.storage_class, "Expected storage_class.").toString(), this._match(x.tokens.comma) && (r = this._consume(x.access_mode, "Expected access_mode.").toString()), this._consume(x.tokens.greater_than, "Expected '>'."));
+            let i = this._consume(x.tokens.ident, "Expected variable name"),
+                n = null;
+            if (this._match(x.tokens.colon)) {
+                let s = this._attribute();
+                n = this._type_decl(), n != null && (n.attributes = s)
             }
-            return new zr(i.toString(), s, t, r, null)
+            return new ws(i.toString(), n, t, r, null)
         }
         _override_decl() {
-            if (!this._match(T.keywords.override)) return null;
-            let t = this._consume(T.tokens.ident, "Expected variable name"),
+            if (!this._match(x.keywords.override)) return null;
+            let t = this._consume(x.tokens.ident, "Expected variable name"),
                 r = null;
-            if (this._match(T.tokens.colon)) {
+            if (this._match(x.tokens.colon)) {
                 let i = this._attribute();
                 r = this._type_decl(), r != null && (r.attributes = i)
             }
-            return new Ga(t.toString(), r, null)
+            return new ed(t.toString(), r, null)
         }
         _enable_directive() {
-            let t = this._consume(T.tokens.ident, "identity expected.");
-            return new zf(t.toString())
+            let t = this._consume(x.tokens.ident, "identity expected.");
+            return new Py(t.toString())
         }
         _type_alias() {
-            let t = this._consume(T.tokens.ident, "identity expected.");
-            this._consume(T.tokens.equal, "Expected '=' for type alias.");
+            let t = this._consume(x.tokens.ident, "identity expected.");
+            this._consume(x.tokens.equal, "Expected '=' for type alias.");
             let r = this._type_decl();
             if (r === null) throw this._error(this._peek(), "Expected Type for Alias.");
             this._context.aliases.has(r.name) && (r = this._context.aliases.get(r.name).type);
-            let i = new ec(t.toString(), r);
+            let i = new nd(t.toString(), r);
             return this._context.aliases.set(i.name, i), i
         }
         _type_decl() {
-            if (this._check([T.tokens.ident, ...T.texel_format, T.keywords.bool, T.keywords.f32, T.keywords.i32, T.keywords.u32])) {
+            if (this._check([x.tokens.ident, ...x.texel_format, x.keywords.bool, x.keywords.f32, x.keywords.i32, x.keywords.u32])) {
                 let i = this._advance(),
-                    s = i.toString();
-                return this._context.structs.has(s) ? this._context.structs.get(s) : this._context.aliases.has(s) ? this._context.aliases.get(s).type : new ur(i.toString())
+                    n = i.toString();
+                return this._context.structs.has(n) ? this._context.structs.get(n) : this._context.aliases.has(n) ? this._context.aliases.get(n).type : new wn(i.toString())
             }
             let t = this._texture_sampler_types();
             if (t) return t;
-            if (this._check(T.template_types)) {
+            if (this._check(x.template_types)) {
                 let i = this._advance().toString(),
-                    s = null,
-                    n = null;
-                return this._match(T.tokens.less_than) && (s = this._type_decl(), n = null, this._match(T.tokens.comma) && (n = this._consume(T.access_mode, "Expected access_mode for pointer").toString()), this._consume(T.tokens.greater_than, "Expected '>' for type.")), new rc(i, s, n)
+                    n = null,
+                    s = null;
+                return this._match(x.tokens.less_than) && (n = this._type_decl(), s = null, this._match(x.tokens.comma) && (s = this._consume(x.access_mode, "Expected access_mode for pointer").toString()), this._consume(x.tokens.greater_than, "Expected '>' for type.")), new sd(i, n, s)
             }
-            if (this._match(T.keywords.ptr)) {
+            if (this._match(x.keywords.ptr)) {
                 let i = this._previous().toString();
-                this._consume(T.tokens.less_than, "Expected '<' for pointer.");
-                let s = this._consume(T.storage_class, "Expected storage_class for pointer");
-                this._consume(T.tokens.comma, "Expected ',' for pointer.");
-                let n = this._type_decl(),
+                this._consume(x.tokens.less_than, "Expected '<' for pointer.");
+                let n = this._consume(x.storage_class, "Expected storage_class for pointer");
+                this._consume(x.tokens.comma, "Expected ',' for pointer.");
+                let s = this._type_decl(),
                     o = null;
-                return this._match(T.tokens.comma) && (o = this._consume(T.access_mode, "Expected access_mode for pointer").toString()), this._consume(T.tokens.greater_than, "Expected '>' for pointer."), new Xf(i, s.toString(), n, o)
+                return this._match(x.tokens.comma) && (o = this._consume(x.access_mode, "Expected access_mode for pointer").toString()), this._consume(x.tokens.greater_than, "Expected '>' for pointer."), new By(i, n.toString(), s, o)
             }
             let r = this._attribute();
-            if (this._match(T.keywords.array)) {
+            if (this._match(x.keywords.array)) {
                 let i = null,
-                    s = -1,
-                    n = this._previous();
-                if (this._match(T.tokens.less_than)) {
+                    n = -1,
+                    s = this._previous();
+                if (this._match(x.tokens.less_than)) {
                     i = this._type_decl(), this._context.aliases.has(i.name) && (i = this._context.aliases.get(i.name).type);
                     let o = "";
-                    this._match(T.tokens.comma) && (o = this._shift_expression().evaluate(this._context).toString()), this._consume(T.tokens.greater_than, "Expected '>' for array."), s = o ? parseInt(o) : 0
+                    this._match(x.tokens.comma) && (o = this._shift_expression().evaluate(this._context).toString()), this._consume(x.tokens.greater_than, "Expected '>' for array."), n = o ? parseInt(o) : 0
                 }
-                return new ic(n.toString(), r, i, s)
+                return new od(s.toString(), r, i, n)
             }
             return null
         }
         _texture_sampler_types() {
-            if (this._match(T.sampler_type)) return new Si(this._previous().toString(), null, null);
-            if (this._match(T.depth_texture_type)) return new Si(this._previous().toString(), null, null);
-            if (this._match(T.sampled_texture_type) || this._match(T.multisampled_texture_type)) {
+            if (this._match(x.sampler_type)) return new bo(this._previous().toString(), null, null);
+            if (this._match(x.depth_texture_type)) return new bo(this._previous().toString(), null, null);
+            if (this._match(x.sampled_texture_type) || this._match(x.multisampled_texture_type)) {
                 let t = this._previous();
-                this._consume(T.tokens.less_than, "Expected '<' for sampler type.");
+                this._consume(x.tokens.less_than, "Expected '<' for sampler type.");
                 let r = this._type_decl();
-                return this._consume(T.tokens.greater_than, "Expected '>' for sampler type."), new Si(t.toString(), r, null)
+                return this._consume(x.tokens.greater_than, "Expected '>' for sampler type."), new bo(t.toString(), r, null)
             }
-            if (this._match(T.storage_texture_type)) {
+            if (this._match(x.storage_texture_type)) {
                 let t = this._previous();
-                this._consume(T.tokens.less_than, "Expected '<' for sampler type.");
-                let r = this._consume(T.texel_format, "Invalid texel format.").toString();
-                this._consume(T.tokens.comma, "Expected ',' after texel format.");
-                let i = this._consume(T.access_mode, "Expected access mode for storage texture type.").toString();
-                return this._consume(T.tokens.greater_than, "Expected '>' for sampler type."), new Si(t.toString(), r, i)
+                this._consume(x.tokens.less_than, "Expected '<' for sampler type.");
+                let r = this._consume(x.texel_format, "Invalid texel format.").toString();
+                this._consume(x.tokens.comma, "Expected ',' after texel format.");
+                let i = this._consume(x.access_mode, "Expected access mode for storage texture type.").toString();
+                return this._consume(x.tokens.greater_than, "Expected '>' for sampler type."), new bo(t.toString(), r, i)
             }
             return null
         }
         _attribute() {
             let t = [];
-            for (; this._match(T.tokens.attr);) {
-                let r = this._consume(T.attribute_name, "Expected attribute name"),
-                    i = new hc(r.toString(), null);
-                if (this._match(T.tokens.paren_left)) {
-                    if (i.value = this._consume(T.literal_or_ident, "Expected attribute value").toString(), this._check(T.tokens.comma)) {
+            for (; this._match(x.tokens.attr);) {
+                let r = this._consume(x.attribute_name, "Expected attribute name"),
+                    i = new dd(r.toString(), null);
+                if (this._match(x.tokens.paren_left)) {
+                    if (i.value = this._consume(x.literal_or_ident, "Expected attribute value").toString(), this._check(x.tokens.comma)) {
                         this._advance();
                         do {
-                            let s = this._consume(T.literal_or_ident, "Expected attribute value").toString();
-                            i.value instanceof Array || (i.value = [i.value]), i.value.push(s)
-                        } while (this._match(T.tokens.comma))
+                            let n = this._consume(x.literal_or_ident, "Expected attribute value").toString();
+                            i.value instanceof Array || (i.value = [i.value]), i.value.push(n)
+                        } while (this._match(x.tokens.comma))
                     }
-                    this._consume(T.tokens.paren_right, "Expected ')'")
+                    this._consume(x.tokens.paren_right, "Expected ')'")
                 }
                 t.push(i)
             }
-            for (; this._match(T.tokens.attr_left);) {
-                if (!this._check(T.tokens.attr_right))
+            for (; this._match(x.tokens.attr_left);) {
+                if (!this._check(x.tokens.attr_right))
                     do {
-                        let r = this._consume(T.attribute_name, "Expected attribute name"),
-                            i = new hc(r.toString(), null);
-                        if (this._match(T.tokens.paren_left)) {
-                            if (i.value = [this._consume(T.literal_or_ident, "Expected attribute value").toString()], this._check(T.tokens.comma)) {
+                        let r = this._consume(x.attribute_name, "Expected attribute name"),
+                            i = new dd(r.toString(), null);
+                        if (this._match(x.tokens.paren_left)) {
+                            if (i.value = [this._consume(x.literal_or_ident, "Expected attribute value").toString()], this._check(x.tokens.comma)) {
                                 this._advance();
                                 do {
-                                    let s = this._consume(T.literal_or_ident, "Expected attribute value").toString();
-                                    i.value.push(s)
-                                } while (this._match(T.tokens.comma))
+                                    let n = this._consume(x.literal_or_ident, "Expected attribute value").toString();
+                                    i.value.push(n)
+                                } while (this._match(x.tokens.comma))
                             }
-                            this._consume(T.tokens.paren_right, "Expected ')'")
+                            this._consume(x.tokens.paren_right, "Expected ')'")
                         }
                         t.push(i)
-                    } while (this._match(T.tokens.comma));
-                this._consume(T.tokens.attr_right, "Expected ']]' after attribute declarations")
+                    } while (this._match(x.tokens.comma));
+                this._consume(x.tokens.attr_right, "Expected ']]' after attribute declarations")
             }
             return t.length == 0 ? null : t
         }
     },
-    Wr = class {
+    Ts = class {
         constructor(t, r) {
             this.name = t, this.attributes = r, this.size = 0
         }
         get isArray() {
             return !1
         }
         get isStruct() {
             return !1
         }
         get isTemplate() {
             return !1
         }
     },
-    uc = class {
+    md = class {
         constructor(t, r, i) {
             this.name = t, this.type = r, this.attributes = i, this.offset = 0, this.size = 0
         }
         get isArray() {
             return this.type.isArray
         }
         get isStruct() {
@@ -7447,45 +7447,45 @@
         get count() {
             return this.type.isArray ? this.type.count : 0
         }
         get stride() {
             return this.type.isArray ? this.type.stride : this.size
         }
     },
-    cs = class extends Wr {
+    Ia = class extends Ts {
         constructor(t, r) {
             super(t, r), this.members = [], this.align = 0
         }
         get isStruct() {
             return !0
         }
     },
-    Ln = class extends Wr {
+    Ml = class extends Ts {
         constructor(t, r) {
             super(t, r), this.count = 0, this.stride = 0
         }
         get isArray() {
             return !0
         }
     },
-    dc = class extends Wr {
-        constructor(t, r, i, s) {
-            super(t, i), this.format = r, this.access = s
+    gd = class extends Ts {
+        constructor(t, r, i, n) {
+            super(t, i), this.format = r, this.access = n
         }
         get isTemplate() {
             return !0
         }
     },
-    Vr;
+    xs;
 (function(e) {
     e[e.Uniform = 0] = "Uniform", e[e.Storage = 1] = "Storage", e[e.Texture = 2] = "Texture", e[e.Sampler = 3] = "Sampler", e[e.StorageTexture = 4] = "StorageTexture"
-})(Vr || (Vr = {}));
-var ls = class {
-        constructor(t, r, i, s, n, o, a) {
-            this.name = t, this.type = r, this.group = i, this.binding = s, this.attributes = n, this.resourceType = o, this.access = a
+})(xs || (xs = {}));
+var Ra = class {
+        constructor(t, r, i, n, s, o, a) {
+            this.name = t, this.type = r, this.group = i, this.binding = n, this.attributes = s, this.resourceType = o, this.access = a
         }
         get isArray() {
             return this.type.isArray
         }
         get isStruct() {
             return this.type.isStruct
         }
@@ -7507,208 +7507,208 @@
         get count() {
             return this.type.isArray ? this.type.count : 0
         }
         get stride() {
             return this.type.isArray ? this.type.stride : this.size
         }
     },
-    su = class {
+    Yy = class {
         constructor(t, r) {
             this.name = t, this.type = r
         }
     },
-    hs = class {
+    Ma = class {
         constructor(t, r) {
             this.align = t, this.size = r
         }
     },
-    nu = class {
-        constructor(t, r, i, s) {
-            this.name = t, this.type = r, this.locationType = i, this.location = s, this.interpolation = null
+    qy = class {
+        constructor(t, r, i, n) {
+            this.name = t, this.type = r, this.locationType = i, this.location = n, this.interpolation = null
         }
     },
-    pc = class {
-        constructor(t, r, i, s) {
-            this.name = t, this.type = r, this.locationType = i, this.location = s
+    _d = class {
+        constructor(t, r, i, n) {
+            this.name = t, this.type = r, this.locationType = i, this.location = n
         }
     },
-    ou = class {
+    Zy = class {
         constructor(t, r = null) {
             this.stage = null, this.inputs = [], this.outputs = [], this.name = t, this.stage = r
         }
     },
-    au = class {
+    Ky = class {
         constructor() {
             this.vertex = [], this.fragment = [], this.compute = []
         }
     },
-    cu = class {
-        constructor(t, r, i, s) {
-            this.name = t, this.type = r, this.attributes = i, this.id = s
+    Gy = class {
+        constructor(t, r, i, n) {
+            this.name = t, this.type = r, this.attributes = i, this.id = n
         }
     },
-    vi = class e {
+    wo = class e {
         constructor(t) {
-            this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new au, this._types = new Map, t && this.update(t)
+            this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new Ky, this._types = new Map, t && this.update(t)
         }
         _isStorageTexture(t) {
             return t.name == "texture_storage_1d" || t.name == "texture_storage_2d" || t.name == "texture_storage_2d_array" || t.name == "texture_storage_3d"
         }
         update(t) {
-            let i = new iu().parse(t);
-            for (let s of i) {
-                if (s instanceof hr) {
-                    let n = this._getTypeInfo(s, null);
-                    n instanceof cs && this.structs.push(n);
+            let i = new Xy().parse(t);
+            for (let n of i) {
+                if (n instanceof bn) {
+                    let s = this._getTypeInfo(n, null);
+                    s instanceof Ia && this.structs.push(s);
                     continue
                 }
-                if (s instanceof ec) {
-                    this.aliases.push(this._getAliasInfo(s));
+                if (n instanceof nd) {
+                    this.aliases.push(this._getAliasInfo(n));
                     continue
                 }
-                if (s instanceof Ga) {
-                    let n = s,
-                        o = this._getAttributeNum(n.attributes, "id", 0),
-                        a = n.type != null ? this._getTypeInfo(n.type, n.attributes) : null;
-                    this.overrides.push(new cu(n.name, a, n.attributes, o));
+                if (n instanceof ed) {
+                    let s = n,
+                        o = this._getAttributeNum(s.attributes, "id", 0),
+                        a = s.type != null ? this._getTypeInfo(s.type, s.attributes) : null;
+                    this.overrides.push(new Gy(s.name, a, s.attributes, o));
                     continue
                 }
-                if (this._isUniformVar(s)) {
-                    let n = s,
-                        o = this._getAttributeNum(n.attributes, "group", 0),
-                        a = this._getAttributeNum(n.attributes, "binding", 0),
-                        c = this._getTypeInfo(n.type, n.attributes),
-                        l = new ls(n.name, c, o, a, n.attributes, Vr.Uniform, n.access);
+                if (this._isUniformVar(n)) {
+                    let s = n,
+                        o = this._getAttributeNum(s.attributes, "group", 0),
+                        a = this._getAttributeNum(s.attributes, "binding", 0),
+                        c = this._getTypeInfo(s.type, s.attributes),
+                        l = new Ra(s.name, c, o, a, s.attributes, xs.Uniform, s.access);
                     this.uniforms.push(l);
                     continue
                 }
-                if (this._isStorageVar(s)) {
-                    let n = s,
-                        o = this._getAttributeNum(n.attributes, "group", 0),
-                        a = this._getAttributeNum(n.attributes, "binding", 0),
-                        c = this._getTypeInfo(n.type, n.attributes),
+                if (this._isStorageVar(n)) {
+                    let s = n,
+                        o = this._getAttributeNum(s.attributes, "group", 0),
+                        a = this._getAttributeNum(s.attributes, "binding", 0),
+                        c = this._getTypeInfo(s.type, s.attributes),
                         l = this._isStorageTexture(c),
-                        h = new ls(n.name, c, o, a, n.attributes, l ? Vr.StorageTexture : Vr.Storage, n.access);
-                    this.storage.push(h);
+                        u = new Ra(s.name, c, o, a, s.attributes, l ? xs.StorageTexture : xs.Storage, s.access);
+                    this.storage.push(u);
                     continue
                 }
-                if (this._isTextureVar(s)) {
-                    let n = s,
-                        o = this._getAttributeNum(n.attributes, "group", 0),
-                        a = this._getAttributeNum(n.attributes, "binding", 0),
-                        c = this._getTypeInfo(n.type, n.attributes),
+                if (this._isTextureVar(n)) {
+                    let s = n,
+                        o = this._getAttributeNum(s.attributes, "group", 0),
+                        a = this._getAttributeNum(s.attributes, "binding", 0),
+                        c = this._getTypeInfo(s.type, s.attributes),
                         l = this._isStorageTexture(c),
-                        h = new ls(n.name, c, o, a, n.attributes, l ? Vr.StorageTexture : Vr.Texture, n.access);
-                    l ? this.storage.push(h) : this.textures.push(h);
+                        u = new Ra(s.name, c, o, a, s.attributes, l ? xs.StorageTexture : xs.Texture, s.access);
+                    l ? this.storage.push(u) : this.textures.push(u);
                     continue
                 }
-                if (this._isSamplerVar(s)) {
-                    let n = s,
-                        o = this._getAttributeNum(n.attributes, "group", 0),
-                        a = this._getAttributeNum(n.attributes, "binding", 0),
-                        c = this._getTypeInfo(n.type, n.attributes),
-                        l = new ls(n.name, c, o, a, n.attributes, Vr.Sampler, n.access);
+                if (this._isSamplerVar(n)) {
+                    let s = n,
+                        o = this._getAttributeNum(s.attributes, "group", 0),
+                        a = this._getAttributeNum(s.attributes, "binding", 0),
+                        c = this._getTypeInfo(s.type, s.attributes),
+                        l = new Ra(s.name, c, o, a, s.attributes, xs.Sampler, s.access);
                     this.samplers.push(l);
                     continue
                 }
-                if (s instanceof Qa) {
-                    let n = this._getAttribute(s, "vertex"),
-                        o = this._getAttribute(s, "fragment"),
-                        a = this._getAttribute(s, "compute"),
-                        c = n || o || a;
+                if (n instanceof td) {
+                    let s = this._getAttribute(n, "vertex"),
+                        o = this._getAttribute(n, "fragment"),
+                        a = this._getAttribute(n, "compute"),
+                        c = s || o || a;
                     if (c) {
-                        let l = new ou(s.name, c.name);
-                        l.inputs = this._getInputs(s.args), l.outputs = this._getOutputs(s.returnType), this.entry[c.name].push(l)
+                        let l = new Zy(n.name, c.name);
+                        l.inputs = this._getInputs(n.args), l.outputs = this._getOutputs(n.returnType), this.entry[c.name].push(l)
                     }
                     continue
                 }
             }
         }
         getBindGroups() {
             let t = [];
 
-            function r(i, s) {
-                i >= t.length && (t.length = i + 1), t[i] === void 0 && (t[i] = []), s >= t[i].length && (t[i].length = s + 1)
+            function r(i, n) {
+                i >= t.length && (t.length = i + 1), t[i] === void 0 && (t[i] = []), n >= t[i].length && (t[i].length = n + 1)
             }
             for (let i of this.uniforms) {
                 r(i.group, i.binding);
-                let s = t[i.group];
-                s[i.binding] = i
+                let n = t[i.group];
+                n[i.binding] = i
             }
             for (let i of this.storage) {
                 r(i.group, i.binding);
-                let s = t[i.group];
-                s[i.binding] = i
+                let n = t[i.group];
+                n[i.binding] = i
             }
             for (let i of this.textures) {
                 r(i.group, i.binding);
-                let s = t[i.group];
-                s[i.binding] = i
+                let n = t[i.group];
+                n[i.binding] = i
             }
             for (let i of this.samplers) {
                 r(i.group, i.binding);
-                let s = t[i.group];
-                s[i.binding] = i
+                let n = t[i.group];
+                n[i.binding] = i
             }
             return t
         }
         _getOutputs(t, r = void 0) {
-            if (r === void 0 && (r = []), t instanceof hr) this._getStructOutputs(t, r);
+            if (r === void 0 && (r = []), t instanceof bn) this._getStructOutputs(t, r);
             else {
                 let i = this._getOutputInfo(t);
                 i !== null && r.push(i)
             }
             return r
         }
         _getStructOutputs(t, r) {
             for (let i of t.members)
-                if (i.type instanceof hr) this._getStructOutputs(i.type, r);
+                if (i.type instanceof bn) this._getStructOutputs(i.type, r);
                 else {
-                    let s = this._getAttribute(i, "location") || this._getAttribute(i, "builtin");
-                    if (s !== null) {
-                        let n = this._getTypeInfo(i.type, i.type.attributes),
-                            o = this._parseInt(s.value),
-                            a = new pc(i.name, n, s.name, o);
+                    let n = this._getAttribute(i, "location") || this._getAttribute(i, "builtin");
+                    if (n !== null) {
+                        let s = this._getTypeInfo(i.type, i.type.attributes),
+                            o = this._parseInt(n.value),
+                            a = new _d(i.name, s, n.name, o);
                         r.push(a)
                     }
                 }
         }
         _getOutputInfo(t) {
             let r = this._getAttribute(t, "location") || this._getAttribute(t, "builtin");
             if (r !== null) {
                 let i = this._getTypeInfo(t, t.attributes),
-                    s = this._parseInt(r.value);
-                return new pc("", i, r.name, s)
+                    n = this._parseInt(r.value);
+                return new _d("", i, r.name, n)
             }
             return null
         }
         _getInputs(t, r = void 0) {
             r === void 0 && (r = []);
             for (let i of t)
-                if (i.type instanceof hr) this._getStructInputs(i.type, r);
+                if (i.type instanceof bn) this._getStructInputs(i.type, r);
                 else {
-                    let s = this._getInputInfo(i);
-                    s !== null && r.push(s)
+                    let n = this._getInputInfo(i);
+                    n !== null && r.push(n)
                 } return r
         }
         _getStructInputs(t, r) {
             for (let i of t.members)
-                if (i.type instanceof hr) this._getStructInputs(i.type, r);
+                if (i.type instanceof bn) this._getStructInputs(i.type, r);
                 else {
-                    let s = this._getInputInfo(i);
-                    s !== null && r.push(s)
+                    let n = this._getInputInfo(i);
+                    n !== null && r.push(n)
                 }
         }
         _getInputInfo(t) {
             let r = this._getAttribute(t, "location") || this._getAttribute(t, "builtin");
             if (r !== null) {
                 let i = this._getAttribute(t, "interpolation"),
-                    s = this._getTypeInfo(t.type, t.attributes),
-                    n = this._parseInt(r.value),
-                    o = new nu(t.name, s, r.name, n);
+                    n = this._getTypeInfo(t.type, t.attributes),
+                    s = this._parseInt(r.value),
+                    o = new qy(t.name, n, r.name, s);
                 return i !== null && (o.interpolation = this._parseString(i.value)), o
             }
             return null
         }
         _parseString(t) {
             return t instanceof Array && (t = t[0]), t
         }
@@ -7719,153 +7719,153 @@
         }
         _getAlias(t) {
             for (let r of this.aliases)
                 if (r.name == t) return r.type;
             return null
         }
         _getAliasInfo(t) {
-            return new su(t.name, this._getTypeInfo(t.type, null))
+            return new Yy(t.name, this._getTypeInfo(t.type, null))
         }
         _getTypeInfo(t, r) {
             if (this._types.has(t)) return this._types.get(t);
-            if (t instanceof ic) {
-                let s = t,
-                    n = this._getTypeInfo(s.format, s.attributes),
-                    o = new Ln(s.name, r);
-                return o.format = n, o.count = s.count, this._types.set(t, o), this._updateTypeInfo(o), o
+            if (t instanceof od) {
+                let n = t,
+                    s = this._getTypeInfo(n.format, n.attributes),
+                    o = new Ml(n.name, r);
+                return o.format = s, o.count = n.count, this._types.set(t, o), this._updateTypeInfo(o), o
             }
-            if (t instanceof hr) {
-                let s = t,
-                    n = new cs(s.name, r);
-                for (let o of s.members) {
+            if (t instanceof bn) {
+                let n = t,
+                    s = new Ia(n.name, r);
+                for (let o of n.members) {
                     let a = this._getTypeInfo(o.type, o.attributes);
-                    n.members.push(new uc(o.name, a, o.attributes))
+                    s.members.push(new md(o.name, a, o.attributes))
                 }
-                return this._types.set(t, n), this._updateTypeInfo(n), n
+                return this._types.set(t, s), this._updateTypeInfo(s), s
             }
-            if (t instanceof Si) {
-                let s = t,
-                    n = s.format instanceof ur,
-                    o = s.format ? n ? this._getTypeInfo(s.format, null) : new Wr(s.format, null) : null,
-                    a = new dc(s.name, o, r, s.access);
+            if (t instanceof bo) {
+                let n = t,
+                    s = n.format instanceof wn,
+                    o = n.format ? s ? this._getTypeInfo(n.format, null) : new Ts(n.format, null) : null,
+                    a = new gd(n.name, o, r, n.access);
                 return this._types.set(t, a), this._updateTypeInfo(a), a
             }
-            if (t instanceof rc) {
-                let s = t,
-                    n = s.format ? this._getTypeInfo(s.format, null) : null,
-                    o = new dc(s.name, n, r, s.access);
+            if (t instanceof sd) {
+                let n = t,
+                    s = n.format ? this._getTypeInfo(n.format, null) : null,
+                    o = new gd(n.name, s, r, n.access);
                 return this._types.set(t, o), this._updateTypeInfo(o), o
             }
-            let i = new Wr(t.name, r);
+            let i = new Ts(t.name, r);
             return this._types.set(t, i), this._updateTypeInfo(i), i
         }
         _updateTypeInfo(t) {
             var r, i;
-            let s = this._getTypeSize(t);
-            if (t.size = (r = s?.size) !== null && r !== void 0 ? r : 0, t instanceof Ln) {
-                let n = this._getTypeSize(t.format);
-                t.stride = (i = n?.size) !== null && i !== void 0 ? i : 0, this._updateTypeInfo(t.format)
+            let n = this._getTypeSize(t);
+            if (t.size = (r = n?.size) !== null && r !== void 0 ? r : 0, t instanceof Ml) {
+                let s = this._getTypeSize(t.format);
+                t.stride = (i = s?.size) !== null && i !== void 0 ? i : 0, this._updateTypeInfo(t.format)
             }
-            t instanceof cs && this._updateStructInfo(t)
+            t instanceof Ia && this._updateStructInfo(t)
         }
         _updateStructInfo(t) {
             var r;
             let i = 0,
-                s = 0,
                 n = 0,
+                s = 0,
                 o = 0;
             for (let a = 0, c = t.members.length; a < c; ++a) {
                 let l = t.members[a],
-                    h = this._getTypeSize(l);
-                if (!h) continue;
+                    u = this._getTypeSize(l);
+                if (!u) continue;
                 (r = this._getAlias(l.type.name)) !== null && r !== void 0 || l.type;
-                let f = h.align,
-                    u = h.size;
-                i = this._roundUp(f, i + s), s = u, n = i, o = Math.max(o, f), l.offset = i, l.size = u, this._updateTypeInfo(l.type)
+                let f = u.align,
+                    h = u.size;
+                i = this._roundUp(f, i + n), n = h, s = i, o = Math.max(o, f), l.offset = i, l.size = h, this._updateTypeInfo(l.type)
             }
-            t.size = this._roundUp(o, n + s), t.align = o
+            t.size = this._roundUp(o, s + n), t.align = o
         }
         _getTypeSize(t) {
             var r;
             if (t == null) return null;
             let i = this._getAttributeNum(t.attributes, "size", 0),
-                s = this._getAttributeNum(t.attributes, "align", 0);
-            if (t instanceof uc && (t = t.type), t instanceof Wr) {
-                let n = this._getAlias(t.name);
-                n !== null && (t = n)
+                n = this._getAttributeNum(t.attributes, "align", 0);
+            if (t instanceof md && (t = t.type), t instanceof Ts) {
+                let s = this._getAlias(t.name);
+                s !== null && (t = s)
             } {
-                let n = e._typeInfo[t.name];
-                if (n !== void 0) {
+                let s = e._typeInfo[t.name];
+                if (s !== void 0) {
                     let o = t.format === "f16" ? 2 : 1;
-                    return new hs(Math.max(s, n.align / o), Math.max(i, n.size / o))
+                    return new Ma(Math.max(n, s.align / o), Math.max(i, s.size / o))
                 }
             } {
-                let n = e._typeInfo[t.name.substring(0, t.name.length - 1)];
-                if (n) {
+                let s = e._typeInfo[t.name.substring(0, t.name.length - 1)];
+                if (s) {
                     let o = t.name[t.name.length - 1] === "h" ? 2 : 1;
-                    return new hs(Math.max(s, n.align / o), Math.max(i, n.size / o))
+                    return new Ma(Math.max(n, s.align / o), Math.max(i, s.size / o))
                 }
             }
-            if (t instanceof Ln) {
-                let n = t,
+            if (t instanceof Ml) {
+                let s = t,
                     o = 8,
                     a = 8,
-                    c = this._getTypeSize(n.format);
+                    c = this._getTypeSize(s.format);
                 c !== null && (a = c.size, o = c.align);
-                let l = n.count,
-                    h = this._getAttributeNum((r = t?.attributes) !== null && r !== void 0 ? r : null, "stride", this._roundUp(o, a));
-                return a = l * h, i && (a = i), new hs(Math.max(s, o), Math.max(i, a))
+                let l = s.count,
+                    u = this._getAttributeNum((r = t?.attributes) !== null && r !== void 0 ? r : null, "stride", this._roundUp(o, a));
+                return a = l * u, i && (a = i), new Ma(Math.max(n, o), Math.max(i, a))
             }
-            if (t instanceof cs) {
-                let n = 0,
+            if (t instanceof Ia) {
+                let s = 0,
                     o = 0,
                     a = 0,
                     c = 0,
                     l = 0;
-                for (let h of t.members) {
-                    let f = this._getTypeSize(h.type);
-                    f !== null && (n = Math.max(f.align, n), a = this._roundUp(f.align, a + c), c = f.size, l = a)
+                for (let u of t.members) {
+                    let f = this._getTypeSize(u.type);
+                    f !== null && (s = Math.max(f.align, s), a = this._roundUp(f.align, a + c), c = f.size, l = a)
                 }
-                return o = this._roundUp(n, l + c), new hs(Math.max(s, n), Math.max(i, o))
+                return o = this._roundUp(s, l + c), new Ma(Math.max(n, s), Math.max(i, o))
             }
             return null
         }
         _isUniformVar(t) {
-            return t instanceof zr && t.storage == "uniform"
+            return t instanceof ws && t.storage == "uniform"
         }
         _isStorageVar(t) {
-            return t instanceof zr && t.storage == "storage"
+            return t instanceof ws && t.storage == "storage"
         }
         _isTextureVar(t) {
-            return t instanceof zr && t.type !== null && e._textureTypes.indexOf(t.type.name) != -1
+            return t instanceof ws && t.type !== null && e._textureTypes.indexOf(t.type.name) != -1
         }
         _isSamplerVar(t) {
-            return t instanceof zr && t.type !== null && e._samplerTypes.indexOf(t.type.name) != -1
+            return t instanceof ws && t.type !== null && e._samplerTypes.indexOf(t.type.name) != -1
         }
         _getAttribute(t, r) {
             let i = t;
             if (!i || !i.attributes) return null;
-            let s = i.attributes;
-            for (let n of s)
-                if (n.name == r) return n;
+            let n = i.attributes;
+            for (let s of n)
+                if (s.name == r) return s;
             return null
         }
         _getAttributeNum(t, r, i) {
             if (t === null) return i;
-            for (let s of t)
-                if (s.name == r) {
-                    let n = s !== null && s.value !== null ? s.value : i;
-                    return n instanceof Array && (n = n[0]), typeof n == "number" ? n : typeof n == "string" ? parseInt(n) : i
+            for (let n of t)
+                if (n.name == r) {
+                    let s = n !== null && n.value !== null ? n.value : i;
+                    return s instanceof Array && (s = s[0]), typeof s == "number" ? s : typeof s == "string" ? parseInt(s) : i
                 } return i
         }
         _roundUp(t, r) {
             return Math.ceil(r / t) * t
         }
     };
-vi._typeInfo = {
+wo._typeInfo = {
     f16: {
         align: 2,
         size: 2
     },
     i32: {
         align: 4,
         size: 4
@@ -7927,74 +7927,74 @@
         size: 48
     },
     mat4x4: {
         align: 16,
         size: 64
     }
 };
-vi._textureTypes = T.any_texture_type.map(e => e.name);
-vi._samplerTypes = T.sampler_type.map(e => e.name);
+wo._textureTypes = x.any_texture_type.map(e => e.name);
+wo._samplerTypes = x.sampler_type.map(e => e.name);
 
-function lu(e) {
+function Jy(e) {
     let t = {
             attributes: [],
             bindings: []
         },
         r;
     try {
-        r = CA(e)
-    } catch (n) {
-        return O.error(n.message)(), t
+        r = FC(e)
+    } catch (s) {
+        return N.error(s.message)(), t
     }
-    for (let n of r.uniforms) {
+    for (let s of r.uniforms) {
         let o = [];
-        for (let a of n.type.members) o.push({
+        for (let a of s.type.members) o.push({
             name: a.name,
-            type: Pm(a.type)
+            type: Zv(a.type)
         });
         t.bindings.push({
             type: "uniform",
-            name: n.name,
-            location: n.binding,
-            group: n.group,
+            name: s.name,
+            location: s.binding,
+            group: s.group,
             members: o
         })
     }
     let i = r.entry.vertex[0],
-        s = i?.inputs.length || 0;
-    for (let n = 0; n < s; n++) {
-        let o = i.inputs[n];
+        n = i?.inputs.length || 0;
+    for (let s = 0; s < n; s++) {
+        let o = i.inputs[s];
         if (o.locationType === "location") {
-            let a = Pm(o.type);
+            let a = Zv(o.type);
             t.attributes.push({
                 name: o.name,
                 location: o.location,
                 type: a
             })
         }
     }
     return t
 }
 
-function Pm(e) {
+function Zv(e) {
     return e.format ? `${e.name}<${e.format.name}>` : e.name
 }
 
-function CA(e) {
+function FC(e) {
     try {
-        return new vi(e)
+        return new wo(e)
     } catch (t) {
         if (t instanceof Error) throw t;
         let r = "WGSL parse error";
         throw typeof t == "object" && t?.message && (r += `: ${t.message} `), typeof t == "object" && t?.token && (r += t.token.line || ""), new Error(r, {
             cause: t
         })
     }
 }
-var IA = `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
+var DC = `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
 const float TWO_PI = 6.2831854820251465;
 const float PI_2 = 1.5707963705062866;
 const float PI_16 = 0.1963495463132858;
 const float SIN_TABLE_0 = 0.19509032368659973;
 const float SIN_TABLE_1 = 0.3826834261417389;
 const float SIN_TABLE_2 = 0.5555702447891235;
 const float SIN_TABLE_3 = 0.7071067690849304;
@@ -8109,20 +8109,20 @@
 #ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
 return tan_taylor_fp32(a);
 #else
 return tan(a);
 #endif
 }
 `,
-    hu = {
+    Qy = {
         name: "fp32",
-        vs: IA
+        vs: DC
     };
-var OA = new Float32Array([0, 1, 1, 1]),
-    NA = `uniform pickingUniforms {
+var LC = new Float32Array([0, 1, 1, 1]),
+    kC = `uniform pickingUniforms {
 float isActive;
 float isAttribute;
 float isHighlightActive;
 float useFloatColors;
 vec3 highlightedObjectColor;
 vec4 highlightColor;
 } picking;
@@ -8167,15 +8167,15 @@
 }
 void picking_setPickingAttribute(vec3 value) {
 if (bool(picking.isAttribute)) {
 picking_vRGBcolor_Avalid.rgb = value;
 }
 }
 `,
-    FA = `uniform pickingUniforms {
+    UC = `uniform pickingUniforms {
 float isActive;
 float isAttribute;
 float isHighlightActive;
 float useFloatColors;
 vec3 highlightedObjectColor;
 vec4 highlightColor;
 } picking;
@@ -8205,125 +8205,125 @@
 return color;
 }
 vec4 picking_filterColor(vec4 color) {
 vec4 highlightColor = picking_filterHighlightColor(color);
 return picking_filterPickingColor(highlightColor);
 }
 `,
-    gc = {
+    yd = {
         name: "picking",
-        vs: NA,
-        fs: FA,
+        vs: kC,
+        fs: UC,
         uniformTypes: {
             isActive: "f32",
             isAttribute: "f32",
             isHighlightActive: "f32",
             useFloatColors: "f32",
             highlightedObjectColor: "vec3<f32>",
             highlightColor: "vec4<f32>"
         },
         defaultUniforms: {
             isActive: !1,
             isAttribute: !1,
             isHighlightActive: !1,
             useFloatColors: !0,
             highlightedObjectColor: new Float32Array([0, 0, 0]),
-            highlightColor: OA
+            highlightColor: LC
         },
-        getUniforms: DA
+        getUniforms: VC
     };
 
-function DA(e = {}, t) {
+function VC(e = {}, t) {
     let r = {};
     if (e.highlightedObjectColor !== void 0)
         if (e.highlightedObjectColor === null) r.isHighlightActive = !1;
         else {
             r.isHighlightActive = !0;
             let i = e.highlightedObjectColor.slice(0, 3);
             r.highlightedObjectColor = i
         } if (e.highlightColor) {
-        let i = Array.from(e.highlightColor, s => s / 255);
+        let i = Array.from(e.highlightColor, n => n / 255);
         Number.isFinite(i[3]) || (i[3] = 1), r.highlightColor = i
     }
     return e.isActive !== void 0 && (r.isActive = !!e.isActive, r.isAttribute = !!e.isAttribute), e.useFloatColors !== void 0 && (r.useFloatColors = !!e.useFloatColors), r
 }
-var PL = 1 / Math.PI * 180,
-    ML = 1 / 180 * Math.PI,
-    kA = {
+var aX = 1 / Math.PI * 180,
+    cX = 1 / 180 * Math.PI,
+    zC = {
         EPSILON: 1e-12,
         debug: !1,
         precision: 4,
         printTypes: !1,
         printDegrees: !1,
         printRowMajor: !0,
         _cartographicRadians: !1
     };
 globalThis.mathgl = globalThis.mathgl || {
     config: {
-        ...kA
+        ...zC
     }
 };
-var mt = globalThis.mathgl.config;
+var re = globalThis.mathgl.config;
 
-function fu(e, {
-    precision: t = mt.precision
+function t0(e, {
+    precision: t = re.precision
 } = {}) {
-    return e = LA(e), `${parseFloat(e.toPrecision(t))}`
+    return e = WC(e), `${parseFloat(e.toPrecision(t))}`
 }
 
-function Ae(e) {
+function Jr(e) {
     return Array.isArray(e) || ArrayBuffer.isView(e) && !(e instanceof DataView)
 }
 
-function ct(e, t, r) {
-    return UA(e, i => Math.max(t, Math.min(r, i)))
+function jt(e, t, r) {
+    return HC(e, i => Math.max(t, Math.min(r, i)))
 }
 
-function Ee(e, t, r) {
-    return Ae(e) ? e.map((i, s) => Ee(i, t[s], r)) : r * t + (1 - r) * e
+function Qr(e, t, r) {
+    return Jr(e) ? e.map((i, n) => Qr(i, t[n], r)) : r * t + (1 - r) * e
 }
 
-function Bt(e, t, r) {
-    let i = mt.EPSILON;
-    r && (mt.EPSILON = r);
+function Le(e, t, r) {
+    let i = re.EPSILON;
+    r && (re.EPSILON = r);
     try {
         if (e === t) return !0;
-        if (Ae(e) && Ae(t)) {
+        if (Jr(e) && Jr(t)) {
             if (e.length !== t.length) return !1;
-            for (let s = 0; s < e.length; ++s)
-                if (!Bt(e[s], t[s])) return !1;
+            for (let n = 0; n < e.length; ++n)
+                if (!Le(e[n], t[n])) return !1;
             return !0
         }
-        return e && e.equals ? e.equals(t) : t && t.equals ? t.equals(e) : typeof e == "number" && typeof t == "number" ? Math.abs(e - t) <= mt.EPSILON * Math.max(1, Math.abs(e), Math.abs(t)) : !1
+        return e && e.equals ? e.equals(t) : t && t.equals ? t.equals(e) : typeof e == "number" && typeof t == "number" ? Math.abs(e - t) <= re.EPSILON * Math.max(1, Math.abs(e), Math.abs(t)) : !1
     } finally {
-        mt.EPSILON = i
+        re.EPSILON = i
     }
 }
 
-function LA(e) {
-    return Math.round(e / mt.EPSILON) * mt.EPSILON
+function WC(e) {
+    return Math.round(e / re.EPSILON) * re.EPSILON
 }
 
-function BA(e) {
+function jC(e) {
     return e.clone ? e.clone() : new Array(e.length)
 }
 
-function UA(e, t, r) {
-    if (Ae(e)) {
+function HC(e, t, r) {
+    if (Jr(e)) {
         let i = e;
-        r = r || BA(i);
-        for (let s = 0; s < r.length && s < i.length; ++s) {
-            let n = typeof e == "number" ? e : e[s];
-            r[s] = t(n, s, r)
+        r = r || jC(i);
+        for (let n = 0; n < r.length && n < i.length; ++n) {
+            let s = typeof e == "number" ? e : e[n];
+            r[n] = t(s, n, r)
         }
         return r
     }
     return t(e)
 }
-var jr = class extends Array {
+var vs = class extends Array {
     clone() {
         return new this.constructor().copy(this)
     }
     fromArray(t, r = 0) {
         for (let i = 0; i < this.ELEMENTS; ++i) this[i] = t[i + r];
         return this.check()
     }
@@ -8334,52 +8334,52 @@
     toObject(t) {
         return t
     }
     from(t) {
         return Array.isArray(t) ? this.copy(t) : this.fromObject(t)
     }
     to(t) {
-        return t === this ? this : Ae(t) ? this.toArray(t) : this.toObject(t)
+        return t === this ? this : Jr(t) ? this.toArray(t) : this.toObject(t)
     }
     toTarget(t) {
         return t ? this.to(t) : this
     }
     toFloat32Array() {
         return new Float32Array(this)
     }
     toString() {
-        return this.formatString(mt)
+        return this.formatString(re)
     }
     formatString(t) {
         let r = "";
-        for (let i = 0; i < this.ELEMENTS; ++i) r += (i > 0 ? ", " : "") + fu(this[i], t);
+        for (let i = 0; i < this.ELEMENTS; ++i) r += (i > 0 ? ", " : "") + t0(this[i], t);
         return `${t.printTypes?this.constructor.name:""}[${r}]`
     }
     equals(t) {
         if (!t || this.length !== t.length) return !1;
         for (let r = 0; r < this.ELEMENTS; ++r)
-            if (!Bt(this[r], t[r])) return !1;
+            if (!Le(this[r], t[r])) return !1;
         return !0
     }
     exactEquals(t) {
         if (!t || this.length !== t.length) return !1;
         for (let r = 0; r < this.ELEMENTS; ++r)
             if (this[r] !== t[r]) return !1;
         return !0
     }
     negate() {
         for (let t = 0; t < this.ELEMENTS; ++t) this[t] = -this[t];
         return this.check()
     }
     lerp(t, r, i) {
         if (i === void 0) return this.lerp(this, t, r);
-        for (let s = 0; s < this.ELEMENTS; ++s) {
-            let n = t[s],
-                o = typeof r == "number" ? r : r[s];
-            this[s] = n + i * (o - n)
+        for (let n = 0; n < this.ELEMENTS; ++n) {
+            let s = t[n],
+                o = typeof r == "number" ? r : r[n];
+            this[n] = s + i * (o - s)
         }
         return this.check()
     }
     min(t) {
         for (let r = 0; r < this.ELEMENTS; ++r) this[r] = Math.min(t[r], this[r]);
         return this.check()
     }
@@ -8409,15 +8409,15 @@
         return this.check()
     }
     multiplyByScalar(t) {
         for (let r = 0; r < this.ELEMENTS; ++r) this[r] *= t;
         return this.check()
     }
     check() {
-        if (mt.debug && !this.validate()) throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
+        if (re.debug && !this.validate()) throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
         return this
     }
     validate() {
         let t = this.length === this.ELEMENTS;
         for (let r = 0; r < this.ELEMENTS; ++r) t = t && Number.isFinite(this[r]);
         return t
     }
@@ -8447,46 +8447,46 @@
         return this.check()
     }
     get elements() {
         return this
     }
 };
 
-function VA(e, t) {
+function $C(e, t) {
     if (e.length !== t) return !1;
     for (let r = 0; r < e.length; ++r)
         if (!Number.isFinite(e[r])) return !1;
     return !0
 }
 
-function st(e) {
+function Pt(e) {
     if (!Number.isFinite(e)) throw new Error(`Invalid number ${JSON.stringify(e)}`);
     return e
 }
 
-function Hr(e, t, r = "") {
-    if (mt.debug && !VA(e, t)) throw new Error(`math.gl: ${r} some fields set to invalid numbers'`);
+function Ss(e, t, r = "") {
+    if (re.debug && !$C(e, t)) throw new Error(`math.gl: ${r} some fields set to invalid numbers'`);
     return e
 }
 
-function Xe(e, t) {
+function Vi(e, t) {
     if (!e) throw new Error(`math.gl assertion ${t}`)
 }
-var us = class extends jr {
+var Ca = class extends vs {
     get x() {
         return this[0]
     }
     set x(t) {
-        this[0] = st(t)
+        this[0] = Pt(t)
     }
     get y() {
         return this[1]
     }
     set y(t) {
-        this[1] = st(t)
+        this[1] = Pt(t)
     }
     len() {
         return Math.sqrt(this.lengthSquared())
     }
     magnitude() {
         return this.len()
     }
@@ -8500,23 +8500,23 @@
     }
     distance(t) {
         return Math.sqrt(this.distanceSquared(t))
     }
     distanceSquared(t) {
         let r = 0;
         for (let i = 0; i < this.ELEMENTS; ++i) {
-            let s = this[i] - t[i];
-            r += s * s
+            let n = this[i] - t[i];
+            r += n * n
         }
-        return st(r)
+        return Pt(r)
     }
     dot(t) {
         let r = 0;
         for (let i = 0; i < this.ELEMENTS; ++i) r += this[i] * t[i];
-        return st(r)
+        return Pt(r)
     }
     normalize() {
         let t = this.magnitude();
         if (t !== 0)
             for (let r = 0; r < this.ELEMENTS; ++r) this[r] /= t;
         return this.check()
     }
@@ -8536,771 +8536,771 @@
     distanceTo(t) {
         return this.distance(t)
     }
     distanceToSquared(t) {
         return this.distanceSquared(t)
     }
     getComponent(t) {
-        return Xe(t >= 0 && t < this.ELEMENTS, "index is out of range"), st(this[t])
+        return Vi(t >= 0 && t < this.ELEMENTS, "index is out of range"), Pt(this[t])
     }
     setComponent(t, r) {
-        return Xe(t >= 0 && t < this.ELEMENTS, "index is out of range"), this[t] = r, this.check()
+        return Vi(t >= 0 && t < this.ELEMENTS, "index is out of range"), this[t] = r, this.check()
     }
     addVectors(t, r) {
         return this.copy(t).add(r)
     }
     subVectors(t, r) {
         return this.copy(t).subtract(r)
     }
     multiplyVectors(t, r) {
         return this.copy(t).multiply(r)
     }
     addScaledVector(t, r) {
         return this.add(new this.constructor(t).multiplyScalar(r))
     }
 };
-var Yt = {};
-Ji(Yt, {
-    add: () => XA,
-    angle: () => lE,
-    ceil: () => $A,
-    clone: () => zA,
-    copy: () => jA,
-    create: () => Mm,
-    cross: () => iE,
-    dist: () => yE,
-    distance: () => Nm,
-    div: () => _E,
-    divide: () => Om,
-    dot: () => rE,
-    equals: () => dE,
-    exactEquals: () => uE,
-    floor: () => YA,
-    forEach: () => bE,
-    fromValues: () => WA,
-    inverse: () => tE,
-    len: () => pE,
-    length: () => Dm,
-    lerp: () => sE,
-    max: () => ZA,
-    min: () => qA,
-    mul: () => mE,
-    multiply: () => Im,
-    negate: () => JA,
-    normalize: () => eE,
-    random: () => nE,
-    rotate: () => cE,
-    round: () => KA,
-    scale: () => QA,
-    scaleAndAdd: () => GA,
-    set: () => HA,
-    sqrDist: () => xE,
-    sqrLen: () => TE,
-    squaredDistance: () => Fm,
-    squaredLength: () => km,
-    str: () => fE,
-    sub: () => gE,
-    subtract: () => Cm,
-    transformMat2: () => oE,
-    transformMat2d: () => aE,
-    transformMat3: () => uu,
-    transformMat4: () => du,
-    zero: () => hE
+var Ge = {};
+Ze(Ge, {
+    add: () => KC,
+    angle: () => pO,
+    ceil: () => GC,
+    clone: () => XC,
+    copy: () => qC,
+    create: () => Kv,
+    cross: () => cO,
+    dist: () => vO,
+    distance: () => tS,
+    div: () => TO,
+    divide: () => Qv,
+    dot: () => aO,
+    equals: () => yO,
+    exactEquals: () => _O,
+    floor: () => JC,
+    forEach: () => EO,
+    fromValues: () => YC,
+    inverse: () => sO,
+    len: () => bO,
+    length: () => rS,
+    lerp: () => lO,
+    max: () => tO,
+    min: () => QC,
+    mul: () => wO,
+    multiply: () => Jv,
+    negate: () => nO,
+    normalize: () => oO,
+    random: () => uO,
+    rotate: () => dO,
+    round: () => eO,
+    scale: () => rO,
+    scaleAndAdd: () => iO,
+    set: () => ZC,
+    sqrDist: () => SO,
+    sqrLen: () => AO,
+    squaredDistance: () => eS,
+    squaredLength: () => iS,
+    str: () => gO,
+    sub: () => xO,
+    subtract: () => Gv,
+    transformMat2: () => fO,
+    transformMat2d: () => hO,
+    transformMat3: () => e0,
+    transformMat4: () => r0,
+    zero: () => mO
 });
-var nt = typeof Float32Array < "u" ? Float32Array : Array,
-    $e = Math.random;
+var Ft = typeof Float32Array < "u" ? Float32Array : Array,
+    zi = Math.random;
 
-function pe(e) {
+function Fr(e) {
     return e >= 0 ? Math.round(e) : e % .5 === 0 ? Math.floor(e) : Math.round(e)
 }
-var VL = Math.PI / 180;
+var bX = Math.PI / 180;
 
-function Mm() {
-    let e = new nt(2);
-    return nt != Float32Array && (e[0] = 0, e[1] = 0), e
+function Kv() {
+    let e = new Ft(2);
+    return Ft != Float32Array && (e[0] = 0, e[1] = 0), e
 }
 
-function zA(e) {
-    let t = new nt(2);
+function XC(e) {
+    let t = new Ft(2);
     return t[0] = e[0], t[1] = e[1], t
 }
 
-function WA(e, t) {
-    let r = new nt(2);
+function YC(e, t) {
+    let r = new Ft(2);
     return r[0] = e, r[1] = t, r
 }
 
-function jA(e, t) {
+function qC(e, t) {
     return e[0] = t[0], e[1] = t[1], e
 }
 
-function HA(e, t, r) {
+function ZC(e, t, r) {
     return e[0] = t, e[1] = r, e
 }
 
-function XA(e, t, r) {
+function KC(e, t, r) {
     return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e
 }
 
-function Cm(e, t, r) {
+function Gv(e, t, r) {
     return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e
 }
 
-function Im(e, t, r) {
+function Jv(e, t, r) {
     return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e
 }
 
-function Om(e, t, r) {
+function Qv(e, t, r) {
     return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e
 }
 
-function $A(e, t) {
+function GC(e, t) {
     return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e
 }
 
-function YA(e, t) {
+function JC(e, t) {
     return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e
 }
 
-function qA(e, t, r) {
+function QC(e, t, r) {
     return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e
 }
 
-function ZA(e, t, r) {
+function tO(e, t, r) {
     return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e
 }
 
-function KA(e, t) {
-    return e[0] = pe(t[0]), e[1] = pe(t[1]), e
+function eO(e, t) {
+    return e[0] = Fr(t[0]), e[1] = Fr(t[1]), e
 }
 
-function QA(e, t, r) {
+function rO(e, t, r) {
     return e[0] = t[0] * r, e[1] = t[1] * r, e
 }
 
-function GA(e, t, r, i) {
+function iO(e, t, r, i) {
     return e[0] = t[0] + r[0] * i, e[1] = t[1] + r[1] * i, e
 }
 
-function Nm(e, t) {
+function tS(e, t) {
     let r = t[0] - e[0],
         i = t[1] - e[1];
     return Math.sqrt(r * r + i * i)
 }
 
-function Fm(e, t) {
+function eS(e, t) {
     let r = t[0] - e[0],
         i = t[1] - e[1];
     return r * r + i * i
 }
 
-function Dm(e) {
+function rS(e) {
     let t = e[0],
         r = e[1];
     return Math.sqrt(t * t + r * r)
 }
 
-function km(e) {
+function iS(e) {
     let t = e[0],
         r = e[1];
     return t * t + r * r
 }
 
-function JA(e, t) {
+function nO(e, t) {
     return e[0] = -t[0], e[1] = -t[1], e
 }
 
-function tE(e, t) {
+function sO(e, t) {
     return e[0] = 1 / t[0], e[1] = 1 / t[1], e
 }
 
-function eE(e, t) {
+function oO(e, t) {
     let r = t[0],
         i = t[1],
-        s = r * r + i * i;
-    return s > 0 && (s = 1 / Math.sqrt(s)), e[0] = t[0] * s, e[1] = t[1] * s, e
+        n = r * r + i * i;
+    return n > 0 && (n = 1 / Math.sqrt(n)), e[0] = t[0] * n, e[1] = t[1] * n, e
 }
 
-function rE(e, t) {
+function aO(e, t) {
     return e[0] * t[0] + e[1] * t[1]
 }
 
-function iE(e, t, r) {
+function cO(e, t, r) {
     let i = t[0] * r[1] - t[1] * r[0];
     return e[0] = e[1] = 0, e[2] = i, e
 }
 
-function sE(e, t, r, i) {
-    let s = t[0],
-        n = t[1];
-    return e[0] = s + i * (r[0] - s), e[1] = n + i * (r[1] - n), e
+function lO(e, t, r, i) {
+    let n = t[0],
+        s = t[1];
+    return e[0] = n + i * (r[0] - n), e[1] = s + i * (r[1] - s), e
 }
 
-function nE(e, t) {
+function uO(e, t) {
     t = t === void 0 ? 1 : t;
-    let r = $e() * 2 * Math.PI;
+    let r = zi() * 2 * Math.PI;
     return e[0] = Math.cos(r) * t, e[1] = Math.sin(r) * t, e
 }
 
-function oE(e, t, r) {
+function fO(e, t, r) {
     let i = t[0],
-        s = t[1];
-    return e[0] = r[0] * i + r[2] * s, e[1] = r[1] * i + r[3] * s, e
+        n = t[1];
+    return e[0] = r[0] * i + r[2] * n, e[1] = r[1] * i + r[3] * n, e
 }
 
-function aE(e, t, r) {
+function hO(e, t, r) {
     let i = t[0],
-        s = t[1];
-    return e[0] = r[0] * i + r[2] * s + r[4], e[1] = r[1] * i + r[3] * s + r[5], e
+        n = t[1];
+    return e[0] = r[0] * i + r[2] * n + r[4], e[1] = r[1] * i + r[3] * n + r[5], e
 }
 
-function uu(e, t, r) {
+function e0(e, t, r) {
     let i = t[0],
-        s = t[1];
-    return e[0] = r[0] * i + r[3] * s + r[6], e[1] = r[1] * i + r[4] * s + r[7], e
+        n = t[1];
+    return e[0] = r[0] * i + r[3] * n + r[6], e[1] = r[1] * i + r[4] * n + r[7], e
 }
 
-function du(e, t, r) {
+function r0(e, t, r) {
     let i = t[0],
-        s = t[1];
-    return e[0] = r[0] * i + r[4] * s + r[12], e[1] = r[1] * i + r[5] * s + r[13], e
+        n = t[1];
+    return e[0] = r[0] * i + r[4] * n + r[12], e[1] = r[1] * i + r[5] * n + r[13], e
 }
 
-function cE(e, t, r, i) {
-    let s = t[0] - r[0],
-        n = t[1] - r[1],
+function dO(e, t, r, i) {
+    let n = t[0] - r[0],
+        s = t[1] - r[1],
         o = Math.sin(i),
         a = Math.cos(i);
-    return e[0] = s * a - n * o + r[0], e[1] = s * o + n * a + r[1], e
+    return e[0] = n * a - s * o + r[0], e[1] = n * o + s * a + r[1], e
 }
 
-function lE(e, t) {
+function pO(e, t) {
     let r = e[0],
         i = e[1],
-        s = t[0],
-        n = t[1],
-        o = Math.sqrt((r * r + i * i) * (s * s + n * n)),
-        a = o && (r * s + i * n) / o;
+        n = t[0],
+        s = t[1],
+        o = Math.sqrt((r * r + i * i) * (n * n + s * s)),
+        a = o && (r * n + i * s) / o;
     return Math.acos(Math.min(Math.max(a, -1), 1))
 }
 
-function hE(e) {
+function mO(e) {
     return e[0] = 0, e[1] = 0, e
 }
 
-function fE(e) {
+function gO(e) {
     return `vec2(${e[0]}, ${e[1]})`
 }
 
-function uE(e, t) {
+function _O(e, t) {
     return e[0] === t[0] && e[1] === t[1]
 }
 
-function dE(e, t) {
+function yO(e, t) {
     let r = e[0],
         i = e[1],
-        s = t[0],
-        n = t[1];
-    return Math.abs(r - s) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(i - n) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(n))
+        n = t[0],
+        s = t[1];
+    return Math.abs(r - n) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(n)) && Math.abs(i - s) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(s))
 }
-var pE = Dm,
-    gE = Cm,
-    mE = Im,
-    _E = Om,
-    yE = Nm,
-    xE = Fm,
-    TE = km,
-    bE = function() {
-        let e = Mm();
-        return function(t, r, i, s, n, o) {
+var bO = rS,
+    xO = Gv,
+    wO = Jv,
+    TO = Qv,
+    vO = tS,
+    SO = eS,
+    AO = iS,
+    EO = function() {
+        let e = Kv();
+        return function(t, r, i, n, s, o) {
             let a, c;
-            for (r || (r = 2), i || (i = 0), s ? c = Math.min(s * r + i, t.length) : c = t.length, a = i; a < c; a += r) e[0] = t[a], e[1] = t[a + 1], n(e, e, o), t[a] = e[0], t[a + 1] = e[1];
+            for (r || (r = 2), i || (i = 0), n ? c = Math.min(n * r + i, t.length) : c = t.length, a = i; a < c; a += r) e[0] = t[a], e[1] = t[a + 1], s(e, e, o), t[a] = e[0], t[a + 1] = e[1];
             return t
         }
     }();
 
-function Lm(e, t, r) {
+function nS(e, t, r) {
     let i = t[0],
-        s = t[1],
-        n = r[3] * i + r[7] * s || 1;
-    return e[0] = (r[0] * i + r[4] * s) / n, e[1] = (r[1] * i + r[5] * s) / n, e
+        n = t[1],
+        s = r[3] * i + r[7] * n || 1;
+    return e[0] = (r[0] * i + r[4] * n) / s, e[1] = (r[1] * i + r[5] * n) / s, e
 }
 
-function mc(e, t, r) {
+function bd(e, t, r) {
     let i = t[0],
-        s = t[1],
-        n = t[2],
-        o = r[3] * i + r[7] * s + r[11] * n || 1;
-    return e[0] = (r[0] * i + r[4] * s + r[8] * n) / o, e[1] = (r[1] * i + r[5] * s + r[9] * n) / o, e[2] = (r[2] * i + r[6] * s + r[10] * n) / o, e
+        n = t[1],
+        s = t[2],
+        o = r[3] * i + r[7] * n + r[11] * s || 1;
+    return e[0] = (r[0] * i + r[4] * n + r[8] * s) / o, e[1] = (r[1] * i + r[5] * n + r[9] * s) / o, e[2] = (r[2] * i + r[6] * n + r[10] * s) / o, e
 }
 
-function Bm(e, t, r) {
+function sS(e, t, r) {
     let i = t[0],
-        s = t[1];
-    return e[0] = r[0] * i + r[2] * s, e[1] = r[1] * i + r[3] * s, e[2] = t[2], e
+        n = t[1];
+    return e[0] = r[0] * i + r[2] * n, e[1] = r[1] * i + r[3] * n, e[2] = t[2], e
 }
 
-function Um(e, t, r) {
+function oS(e, t, r) {
     let i = t[0],
-        s = t[1];
-    return e[0] = r[0] * i + r[2] * s, e[1] = r[1] * i + r[3] * s, e[2] = t[2], e[3] = t[3], e
+        n = t[1];
+    return e[0] = r[0] * i + r[2] * n, e[1] = r[1] * i + r[3] * n, e[2] = t[2], e[3] = t[3], e
 }
 
-function _c(e, t, r) {
+function xd(e, t, r) {
     let i = t[0],
-        s = t[1],
-        n = t[2];
-    return e[0] = r[0] * i + r[3] * s + r[6] * n, e[1] = r[1] * i + r[4] * s + r[7] * n, e[2] = r[2] * i + r[5] * s + r[8] * n, e[3] = t[3], e
+        n = t[1],
+        s = t[2];
+    return e[0] = r[0] * i + r[3] * n + r[6] * s, e[1] = r[1] * i + r[4] * n + r[7] * s, e[2] = r[2] * i + r[5] * n + r[8] * s, e[3] = t[3], e
 }
-var qt = {};
-Ji(qt, {
-    add: () => wE,
-    angle: () => yu,
-    bezier: () => BE,
-    ceil: () => vE,
-    clone: () => AE,
-    copy: () => EE,
-    create: () => yc,
-    cross: () => Ri,
-    dist: () => YE,
-    distance: () => Hm,
-    div: () => $E,
-    divide: () => jm,
-    dot: () => Un,
-    equals: () => jE,
-    exactEquals: () => WE,
-    floor: () => RE,
-    forEach: () => KE,
-    fromValues: () => xc,
-    hermite: () => LE,
-    inverse: () => FE,
-    len: () => xu,
-    length: () => Vm,
-    lerp: () => DE,
-    max: () => ME,
-    min: () => PE,
-    mul: () => XE,
-    multiply: () => Wm,
-    negate: () => NE,
-    normalize: () => pu,
-    random: () => UE,
-    rotateX: () => gu,
-    rotateY: () => mu,
-    rotateZ: () => _u,
-    round: () => CE,
-    scale: () => IE,
-    scaleAndAdd: () => OE,
-    set: () => SE,
-    slerp: () => kE,
-    sqrDist: () => qE,
-    sqrLen: () => ZE,
-    squaredDistance: () => Xm,
-    squaredLength: () => $m,
-    str: () => zE,
-    sub: () => HE,
-    subtract: () => zm,
-    transformMat3: () => Vn,
-    transformMat4: () => Pi,
-    transformQuat: () => zn,
-    zero: () => VE
+var Je = {};
+Ze(Je, {
+    add: () => PO,
+    angle: () => a0,
+    bezier: () => jO,
+    ceil: () => CO,
+    clone: () => IO,
+    copy: () => RO,
+    create: () => wd,
+    cross: () => To,
+    dist: () => JO,
+    distance: () => fS,
+    div: () => GO,
+    divide: () => uS,
+    dot: () => Cl,
+    equals: () => qO,
+    exactEquals: () => YO,
+    floor: () => OO,
+    forEach: () => eN,
+    fromValues: () => Td,
+    hermite: () => WO,
+    inverse: () => UO,
+    len: () => c0,
+    length: () => aS,
+    lerp: () => VO,
+    max: () => BO,
+    min: () => NO,
+    mul: () => KO,
+    multiply: () => lS,
+    negate: () => kO,
+    normalize: () => i0,
+    random: () => HO,
+    rotateX: () => n0,
+    rotateY: () => s0,
+    rotateZ: () => o0,
+    round: () => FO,
+    scale: () => DO,
+    scaleAndAdd: () => LO,
+    set: () => MO,
+    slerp: () => zO,
+    sqrDist: () => QO,
+    sqrLen: () => tN,
+    squaredDistance: () => hS,
+    squaredLength: () => dS,
+    str: () => XO,
+    sub: () => ZO,
+    subtract: () => cS,
+    transformMat3: () => Ol,
+    transformMat4: () => vo,
+    transformQuat: () => Nl,
+    zero: () => $O
 });
 
-function yc() {
-    let e = new nt(3);
-    return nt != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e
+function wd() {
+    let e = new Ft(3);
+    return Ft != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e
 }
 
-function AE(e) {
-    let t = new nt(3);
+function IO(e) {
+    let t = new Ft(3);
     return t[0] = e[0], t[1] = e[1], t[2] = e[2], t
 }
 
-function Vm(e) {
+function aS(e) {
     let t = e[0],
         r = e[1],
         i = e[2];
     return Math.sqrt(t * t + r * r + i * i)
 }
 
-function xc(e, t, r) {
-    let i = new nt(3);
+function Td(e, t, r) {
+    let i = new Ft(3);
     return i[0] = e, i[1] = t, i[2] = r, i
 }
 
-function EE(e, t) {
+function RO(e, t) {
     return e[0] = t[0], e[1] = t[1], e[2] = t[2], e
 }
 
-function SE(e, t, r, i) {
+function MO(e, t, r, i) {
     return e[0] = t, e[1] = r, e[2] = i, e
 }
 
-function wE(e, t, r) {
+function PO(e, t, r) {
     return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e
 }
 
-function zm(e, t, r) {
+function cS(e, t, r) {
     return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e
 }
 
-function Wm(e, t, r) {
+function lS(e, t, r) {
     return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e
 }
 
-function jm(e, t, r) {
+function uS(e, t, r) {
     return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e
 }
 
-function vE(e, t) {
+function CO(e, t) {
     return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e
 }
 
-function RE(e, t) {
+function OO(e, t) {
     return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e
 }
 
-function PE(e, t, r) {
+function NO(e, t, r) {
     return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e
 }
 
-function ME(e, t, r) {
+function BO(e, t, r) {
     return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e
 }
 
-function CE(e, t) {
-    return e[0] = pe(t[0]), e[1] = pe(t[1]), e[2] = pe(t[2]), e
+function FO(e, t) {
+    return e[0] = Fr(t[0]), e[1] = Fr(t[1]), e[2] = Fr(t[2]), e
 }
 
-function IE(e, t, r) {
+function DO(e, t, r) {
     return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e
 }
 
-function OE(e, t, r, i) {
+function LO(e, t, r, i) {
     return e[0] = t[0] + r[0] * i, e[1] = t[1] + r[1] * i, e[2] = t[2] + r[2] * i, e
 }
 
-function Hm(e, t) {
+function fS(e, t) {
     let r = t[0] - e[0],
         i = t[1] - e[1],
-        s = t[2] - e[2];
-    return Math.sqrt(r * r + i * i + s * s)
+        n = t[2] - e[2];
+    return Math.sqrt(r * r + i * i + n * n)
 }
 
-function Xm(e, t) {
+function hS(e, t) {
     let r = t[0] - e[0],
         i = t[1] - e[1],
-        s = t[2] - e[2];
-    return r * r + i * i + s * s
+        n = t[2] - e[2];
+    return r * r + i * i + n * n
 }
 
-function $m(e) {
+function dS(e) {
     let t = e[0],
         r = e[1],
         i = e[2];
     return t * t + r * r + i * i
 }
 
-function NE(e, t) {
+function kO(e, t) {
     return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e
 }
 
-function FE(e, t) {
+function UO(e, t) {
     return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e
 }
 
-function pu(e, t) {
+function i0(e, t) {
     let r = t[0],
         i = t[1],
-        s = t[2],
-        n = r * r + i * i + s * s;
-    return n > 0 && (n = 1 / Math.sqrt(n)), e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e
+        n = t[2],
+        s = r * r + i * i + n * n;
+    return s > 0 && (s = 1 / Math.sqrt(s)), e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s, e
 }
 
-function Un(e, t) {
+function Cl(e, t) {
     return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]
 }
 
-function Ri(e, t, r) {
+function To(e, t, r) {
     let i = t[0],
-        s = t[1],
-        n = t[2],
+        n = t[1],
+        s = t[2],
         o = r[0],
         a = r[1],
         c = r[2];
-    return e[0] = s * c - n * a, e[1] = n * o - i * c, e[2] = i * a - s * o, e
+    return e[0] = n * c - s * a, e[1] = s * o - i * c, e[2] = i * a - n * o, e
 }
 
-function DE(e, t, r, i) {
-    let s = t[0],
-        n = t[1],
+function VO(e, t, r, i) {
+    let n = t[0],
+        s = t[1],
         o = t[2];
-    return e[0] = s + i * (r[0] - s), e[1] = n + i * (r[1] - n), e[2] = o + i * (r[2] - o), e
+    return e[0] = n + i * (r[0] - n), e[1] = s + i * (r[1] - s), e[2] = o + i * (r[2] - o), e
 }
 
-function kE(e, t, r, i) {
-    let s = Math.acos(Math.min(Math.max(Un(t, r), -1), 1)),
-        n = Math.sin(s),
-        o = Math.sin((1 - i) * s) / n,
-        a = Math.sin(i * s) / n;
+function zO(e, t, r, i) {
+    let n = Math.acos(Math.min(Math.max(Cl(t, r), -1), 1)),
+        s = Math.sin(n),
+        o = Math.sin((1 - i) * n) / s,
+        a = Math.sin(i * n) / s;
     return e[0] = o * t[0] + a * r[0], e[1] = o * t[1] + a * r[1], e[2] = o * t[2] + a * r[2], e
 }
 
-function LE(e, t, r, i, s, n) {
-    let o = n * n,
-        a = o * (2 * n - 3) + 1,
-        c = o * (n - 2) + n,
-        l = o * (n - 1),
-        h = o * (3 - 2 * n);
-    return e[0] = t[0] * a + r[0] * c + i[0] * l + s[0] * h, e[1] = t[1] * a + r[1] * c + i[1] * l + s[1] * h, e[2] = t[2] * a + r[2] * c + i[2] * l + s[2] * h, e
+function WO(e, t, r, i, n, s) {
+    let o = s * s,
+        a = o * (2 * s - 3) + 1,
+        c = o * (s - 2) + s,
+        l = o * (s - 1),
+        u = o * (3 - 2 * s);
+    return e[0] = t[0] * a + r[0] * c + i[0] * l + n[0] * u, e[1] = t[1] * a + r[1] * c + i[1] * l + n[1] * u, e[2] = t[2] * a + r[2] * c + i[2] * l + n[2] * u, e
 }
 
-function BE(e, t, r, i, s, n) {
-    let o = 1 - n,
+function jO(e, t, r, i, n, s) {
+    let o = 1 - s,
         a = o * o,
-        c = n * n,
+        c = s * s,
         l = a * o,
-        h = 3 * n * a,
+        u = 3 * s * a,
         f = 3 * c * o,
-        u = c * n;
-    return e[0] = t[0] * l + r[0] * h + i[0] * f + s[0] * u, e[1] = t[1] * l + r[1] * h + i[1] * f + s[1] * u, e[2] = t[2] * l + r[2] * h + i[2] * f + s[2] * u, e
+        h = c * s;
+    return e[0] = t[0] * l + r[0] * u + i[0] * f + n[0] * h, e[1] = t[1] * l + r[1] * u + i[1] * f + n[1] * h, e[2] = t[2] * l + r[2] * u + i[2] * f + n[2] * h, e
 }
 
-function UE(e, t) {
+function HO(e, t) {
     t = t === void 0 ? 1 : t;
-    let r = $e() * 2 * Math.PI,
-        i = $e() * 2 - 1,
-        s = Math.sqrt(1 - i * i) * t;
-    return e[0] = Math.cos(r) * s, e[1] = Math.sin(r) * s, e[2] = i * t, e
+    let r = zi() * 2 * Math.PI,
+        i = zi() * 2 - 1,
+        n = Math.sqrt(1 - i * i) * t;
+    return e[0] = Math.cos(r) * n, e[1] = Math.sin(r) * n, e[2] = i * t, e
 }
 
-function Pi(e, t, r) {
+function vo(e, t, r) {
     let i = t[0],
-        s = t[1],
-        n = t[2],
-        o = r[3] * i + r[7] * s + r[11] * n + r[15];
-    return o = o || 1, e[0] = (r[0] * i + r[4] * s + r[8] * n + r[12]) / o, e[1] = (r[1] * i + r[5] * s + r[9] * n + r[13]) / o, e[2] = (r[2] * i + r[6] * s + r[10] * n + r[14]) / o, e
+        n = t[1],
+        s = t[2],
+        o = r[3] * i + r[7] * n + r[11] * s + r[15];
+    return o = o || 1, e[0] = (r[0] * i + r[4] * n + r[8] * s + r[12]) / o, e[1] = (r[1] * i + r[5] * n + r[9] * s + r[13]) / o, e[2] = (r[2] * i + r[6] * n + r[10] * s + r[14]) / o, e
 }
 
-function Vn(e, t, r) {
+function Ol(e, t, r) {
     let i = t[0],
-        s = t[1],
-        n = t[2];
-    return e[0] = i * r[0] + s * r[3] + n * r[6], e[1] = i * r[1] + s * r[4] + n * r[7], e[2] = i * r[2] + s * r[5] + n * r[8], e
+        n = t[1],
+        s = t[2];
+    return e[0] = i * r[0] + n * r[3] + s * r[6], e[1] = i * r[1] + n * r[4] + s * r[7], e[2] = i * r[2] + n * r[5] + s * r[8], e
 }
 
-function zn(e, t, r) {
+function Nl(e, t, r) {
     let i = r[0],
-        s = r[1],
-        n = r[2],
+        n = r[1],
+        s = r[2],
         o = r[3],
         a = t[0],
         c = t[1],
         l = t[2],
-        h = s * l - n * c,
-        f = n * a - i * l,
-        u = i * c - s * a,
-        d = s * u - n * f,
-        m = n * h - i * u,
-        y = i * f - s * h,
-        x = o * 2;
-    return h *= x, f *= x, u *= x, d *= 2, m *= 2, y *= 2, e[0] = a + h + d, e[1] = c + f + m, e[2] = l + u + y, e
-}
-
-function gu(e, t, r, i) {
-    let s = [],
-        n = [];
-    return s[0] = t[0] - r[0], s[1] = t[1] - r[1], s[2] = t[2] - r[2], n[0] = s[0], n[1] = s[1] * Math.cos(i) - s[2] * Math.sin(i), n[2] = s[1] * Math.sin(i) + s[2] * Math.cos(i), e[0] = n[0] + r[0], e[1] = n[1] + r[1], e[2] = n[2] + r[2], e
-}
-
-function mu(e, t, r, i) {
-    let s = [],
-        n = [];
-    return s[0] = t[0] - r[0], s[1] = t[1] - r[1], s[2] = t[2] - r[2], n[0] = s[2] * Math.sin(i) + s[0] * Math.cos(i), n[1] = s[1], n[2] = s[2] * Math.cos(i) - s[0] * Math.sin(i), e[0] = n[0] + r[0], e[1] = n[1] + r[1], e[2] = n[2] + r[2], e
-}
-
-function _u(e, t, r, i) {
-    let s = [],
-        n = [];
-    return s[0] = t[0] - r[0], s[1] = t[1] - r[1], s[2] = t[2] - r[2], n[0] = s[0] * Math.cos(i) - s[1] * Math.sin(i), n[1] = s[0] * Math.sin(i) + s[1] * Math.cos(i), n[2] = s[2], e[0] = n[0] + r[0], e[1] = n[1] + r[1], e[2] = n[2] + r[2], e
+        u = n * l - s * c,
+        f = s * a - i * l,
+        h = i * c - n * a,
+        d = n * h - s * f,
+        p = s * u - i * h,
+        y = i * f - n * u,
+        b = o * 2;
+    return u *= b, f *= b, h *= b, d *= 2, p *= 2, y *= 2, e[0] = a + u + d, e[1] = c + f + p, e[2] = l + h + y, e
+}
+
+function n0(e, t, r, i) {
+    let n = [],
+        s = [];
+    return n[0] = t[0] - r[0], n[1] = t[1] - r[1], n[2] = t[2] - r[2], s[0] = n[0], s[1] = n[1] * Math.cos(i) - n[2] * Math.sin(i), s[2] = n[1] * Math.sin(i) + n[2] * Math.cos(i), e[0] = s[0] + r[0], e[1] = s[1] + r[1], e[2] = s[2] + r[2], e
+}
+
+function s0(e, t, r, i) {
+    let n = [],
+        s = [];
+    return n[0] = t[0] - r[0], n[1] = t[1] - r[1], n[2] = t[2] - r[2], s[0] = n[2] * Math.sin(i) + n[0] * Math.cos(i), s[1] = n[1], s[2] = n[2] * Math.cos(i) - n[0] * Math.sin(i), e[0] = s[0] + r[0], e[1] = s[1] + r[1], e[2] = s[2] + r[2], e
+}
+
+function o0(e, t, r, i) {
+    let n = [],
+        s = [];
+    return n[0] = t[0] - r[0], n[1] = t[1] - r[1], n[2] = t[2] - r[2], s[0] = n[0] * Math.cos(i) - n[1] * Math.sin(i), s[1] = n[0] * Math.sin(i) + n[1] * Math.cos(i), s[2] = n[2], e[0] = s[0] + r[0], e[1] = s[1] + r[1], e[2] = s[2] + r[2], e
 }
 
-function yu(e, t) {
+function a0(e, t) {
     let r = e[0],
         i = e[1],
-        s = e[2],
-        n = t[0],
+        n = e[2],
+        s = t[0],
         o = t[1],
         a = t[2],
-        c = Math.sqrt((r * r + i * i + s * s) * (n * n + o * o + a * a)),
-        l = c && Un(e, t) / c;
+        c = Math.sqrt((r * r + i * i + n * n) * (s * s + o * o + a * a)),
+        l = c && Cl(e, t) / c;
     return Math.acos(Math.min(Math.max(l, -1), 1))
 }
 
-function VE(e) {
+function $O(e) {
     return e[0] = 0, e[1] = 0, e[2] = 0, e
 }
 
-function zE(e) {
+function XO(e) {
     return `vec3(${e[0]}, ${e[1]}, ${e[2]})`
 }
 
-function WE(e, t) {
+function YO(e, t) {
     return e[0] === t[0] && e[1] === t[1] && e[2] === t[2]
 }
 
-function jE(e, t) {
+function qO(e, t) {
     let r = e[0],
         i = e[1],
-        s = e[2],
-        n = t[0],
+        n = e[2],
+        s = t[0],
         o = t[1],
         a = t[2];
-    return Math.abs(r - n) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(n)) && Math.abs(i - o) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(o)) && Math.abs(s - a) <= 1e-6 * Math.max(1, Math.abs(s), Math.abs(a))
+    return Math.abs(r - s) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(i - o) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(o)) && Math.abs(n - a) <= 1e-6 * Math.max(1, Math.abs(n), Math.abs(a))
 }
-var HE = zm,
-    XE = Wm,
-    $E = jm,
-    YE = Hm,
-    qE = Xm,
-    xu = Vm,
-    ZE = $m,
-    KE = function() {
-        let e = yc();
-        return function(t, r, i, s, n, o) {
+var ZO = cS,
+    KO = lS,
+    GO = uS,
+    JO = fS,
+    QO = hS,
+    c0 = aS,
+    tN = dS,
+    eN = function() {
+        let e = wd();
+        return function(t, r, i, n, s, o) {
             let a, c;
-            for (r || (r = 3), i || (i = 0), s ? c = Math.min(s * r + i, t.length) : c = t.length, a = i; a < c; a += r) e[0] = t[a], e[1] = t[a + 1], e[2] = t[a + 2], n(e, e, o), t[a] = e[0], t[a + 1] = e[1], t[a + 2] = e[2];
+            for (r || (r = 3), i || (i = 0), n ? c = Math.min(n * r + i, t.length) : c = t.length, a = i; a < c; a += r) e[0] = t[a], e[1] = t[a + 1], e[2] = t[a + 2], s(e, e, o), t[a] = e[0], t[a + 1] = e[1], t[a + 2] = e[2];
             return t
         }
     }();
-var Tu = [0, 0, 0],
-    Tc, U = class e extends us {
+var l0 = [0, 0, 0],
+    vd, z = class e extends Ca {
         static get ZERO() {
-            return Tc || (Tc = new e(0, 0, 0), Object.freeze(Tc)), Tc
+            return vd || (vd = new e(0, 0, 0), Object.freeze(vd)), vd
         }
         constructor(t = 0, r = 0, i = 0) {
-            super(-0, -0, -0), arguments.length === 1 && Ae(t) ? this.copy(t) : (mt.debug && (st(t), st(r), st(i)), this[0] = t, this[1] = r, this[2] = i)
+            super(-0, -0, -0), arguments.length === 1 && Jr(t) ? this.copy(t) : (re.debug && (Pt(t), Pt(r), Pt(i)), this[0] = t, this[1] = r, this[2] = i)
         }
         set(t, r, i) {
             return this[0] = t, this[1] = r, this[2] = i, this.check()
         }
         copy(t) {
             return this[0] = t[0], this[1] = t[1], this[2] = t[2], this.check()
         }
         fromObject(t) {
-            return mt.debug && (st(t.x), st(t.y), st(t.z)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this.check()
+            return re.debug && (Pt(t.x), Pt(t.y), Pt(t.z)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this.check()
         }
         toObject(t) {
             return t.x = this[0], t.y = this[1], t.z = this[2], t
         }
         get ELEMENTS() {
             return 3
         }
         get z() {
             return this[2]
         }
         set z(t) {
-            this[2] = st(t)
+            this[2] = Pt(t)
         }
         angle(t) {
-            return yu(this, t)
+            return a0(this, t)
         }
         cross(t) {
-            return Ri(this, this, t), this.check()
+            return To(this, this, t), this.check()
         }
         rotateX({
             radians: t,
-            origin: r = Tu
+            origin: r = l0
         }) {
-            return gu(this, this, r, t), this.check()
+            return n0(this, this, r, t), this.check()
         }
         rotateY({
             radians: t,
-            origin: r = Tu
+            origin: r = l0
         }) {
-            return mu(this, this, r, t), this.check()
+            return s0(this, this, r, t), this.check()
         }
         rotateZ({
             radians: t,
-            origin: r = Tu
+            origin: r = l0
         }) {
-            return _u(this, this, r, t), this.check()
+            return o0(this, this, r, t), this.check()
         }
         transform(t) {
             return this.transformAsPoint(t)
         }
         transformAsPoint(t) {
-            return Pi(this, this, t), this.check()
+            return vo(this, this, t), this.check()
         }
         transformAsVector(t) {
-            return mc(this, this, t), this.check()
+            return bd(this, this, t), this.check()
         }
         transformByMatrix3(t) {
-            return Vn(this, this, t), this.check()
+            return Ol(this, this, t), this.check()
         }
         transformByMatrix2(t) {
-            return Bm(this, this, t), this.check()
+            return sS(this, this, t), this.check()
         }
         transformByQuaternion(t) {
-            return zn(this, this, t), this.check()
+            return Nl(this, this, t), this.check()
         }
     };
-var bc, Ac = class e extends us {
+var Sd, Ad = class e extends Ca {
     static get ZERO() {
-        return bc || (bc = new e(0, 0, 0, 0), Object.freeze(bc)), bc
+        return Sd || (Sd = new e(0, 0, 0, 0), Object.freeze(Sd)), Sd
     }
-    constructor(t = 0, r = 0, i = 0, s = 0) {
-        super(-0, -0, -0, -0), Ae(t) && arguments.length === 1 ? this.copy(t) : (mt.debug && (st(t), st(r), st(i), st(s)), this[0] = t, this[1] = r, this[2] = i, this[3] = s)
+    constructor(t = 0, r = 0, i = 0, n = 0) {
+        super(-0, -0, -0, -0), Jr(t) && arguments.length === 1 ? this.copy(t) : (re.debug && (Pt(t), Pt(r), Pt(i), Pt(n)), this[0] = t, this[1] = r, this[2] = i, this[3] = n)
     }
-    set(t, r, i, s) {
-        return this[0] = t, this[1] = r, this[2] = i, this[3] = s, this.check()
+    set(t, r, i, n) {
+        return this[0] = t, this[1] = r, this[2] = i, this[3] = n, this.check()
     }
     copy(t) {
         return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this.check()
     }
     fromObject(t) {
-        return mt.debug && (st(t.x), st(t.y), st(t.z), st(t.w)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this[3] = t.w, this
+        return re.debug && (Pt(t.x), Pt(t.y), Pt(t.z), Pt(t.w)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this[3] = t.w, this
     }
     toObject(t) {
         return t.x = this[0], t.y = this[1], t.z = this[2], t.w = this[3], t
     }
     get ELEMENTS() {
         return 4
     }
     get z() {
         return this[2]
     }
     set z(t) {
-        this[2] = st(t)
+        this[2] = Pt(t)
     }
     get w() {
         return this[3]
     }
     set w(t) {
-        this[3] = st(t)
+        this[3] = Pt(t)
     }
     transform(t) {
-        return Pi(this, this, t), this.check()
+        return vo(this, this, t), this.check()
     }
     transformByMatrix3(t) {
-        return _c(this, this, t), this.check()
+        return xd(this, this, t), this.check()
     }
     transformByMatrix2(t) {
-        return Um(this, this, t), this.check()
+        return oS(this, this, t), this.check()
     }
     transformByQuaternion(t) {
-        return zn(this, this, t), this.check()
+        return Nl(this, this, t), this.check()
     }
     applyMatrix4(t) {
         return t.transform(this, this), this
     }
 };
-var ps = class extends jr {
+var Na = class extends vs {
     toString() {
         let t = "[";
-        if (mt.printRowMajor) {
+        if (re.printRowMajor) {
             t += "row-major:";
             for (let r = 0; r < this.RANK; ++r)
                 for (let i = 0; i < this.RANK; ++i) t += ` ${this[i*this.RANK+r]}`
         } else {
             t += "column-major:";
             for (let r = 0; r < this.ELEMENTS; ++r) t += ` ${this[r]}`
         }
@@ -9309,1349 +9309,1349 @@
     getElementIndex(t, r) {
         return r * this.RANK + t
     }
     getElement(t, r) {
         return this[r * this.RANK + t]
     }
     setElement(t, r, i) {
-        return this[r * this.RANK + t] = st(i), this
+        return this[r * this.RANK + t] = Pt(i), this
     }
     getColumn(t, r = new Array(this.RANK).fill(-0)) {
         let i = t * this.RANK;
-        for (let s = 0; s < this.RANK; ++s) r[s] = this[i + s];
+        for (let n = 0; n < this.RANK; ++n) r[n] = this[i + n];
         return r
     }
     setColumn(t, r) {
         let i = t * this.RANK;
-        for (let s = 0; s < this.RANK; ++s) this[i + s] = r[s];
+        for (let n = 0; n < this.RANK; ++n) this[i + n] = r[n];
         return this
     }
 };
 
-function Ym() {
-    let e = new nt(9);
-    return nt != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[0] = 1, e[4] = 1, e[8] = 1, e
+function pS() {
+    let e = new Ft(9);
+    return Ft != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[0] = 1, e[4] = 1, e[8] = 1, e
 }
 
-function qm(e, t) {
+function mS(e, t) {
     if (e === t) {
         let r = t[1],
             i = t[2],
-            s = t[5];
-        e[1] = t[3], e[2] = t[6], e[3] = r, e[5] = t[7], e[6] = i, e[7] = s
+            n = t[5];
+        e[1] = t[3], e[2] = t[6], e[3] = r, e[5] = t[7], e[6] = i, e[7] = n
     } else e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8];
     return e
 }
 
-function Zm(e, t) {
+function gS(e, t) {
     let r = t[0],
         i = t[1],
-        s = t[2],
-        n = t[3],
+        n = t[2],
+        s = t[3],
         o = t[4],
         a = t[5],
         c = t[6],
         l = t[7],
-        h = t[8],
-        f = h * o - a * l,
-        u = -h * n + a * c,
-        d = l * n - o * c,
-        m = r * f + i * u + s * d;
-    return m ? (m = 1 / m, e[0] = f * m, e[1] = (-h * i + s * l) * m, e[2] = (a * i - s * o) * m, e[3] = u * m, e[4] = (h * r - s * c) * m, e[5] = (-a * r + s * n) * m, e[6] = d * m, e[7] = (-l * r + i * c) * m, e[8] = (o * r - i * n) * m, e) : null
+        u = t[8],
+        f = u * o - a * l,
+        h = -u * s + a * c,
+        d = l * s - o * c,
+        p = r * f + i * h + n * d;
+    return p ? (p = 1 / p, e[0] = f * p, e[1] = (-u * i + n * l) * p, e[2] = (a * i - n * o) * p, e[3] = h * p, e[4] = (u * r - n * c) * p, e[5] = (-a * r + n * s) * p, e[6] = d * p, e[7] = (-l * r + i * c) * p, e[8] = (o * r - i * s) * p, e) : null
 }
 
-function Km(e) {
+function _S(e) {
     let t = e[0],
         r = e[1],
         i = e[2],
-        s = e[3],
-        n = e[4],
+        n = e[3],
+        s = e[4],
         o = e[5],
         a = e[6],
         c = e[7],
         l = e[8];
-    return t * (l * n - o * c) + r * (-l * s + o * a) + i * (c * s - n * a)
+    return t * (l * s - o * c) + r * (-l * n + o * a) + i * (c * n - s * a)
 }
 
-function bu(e, t, r) {
+function u0(e, t, r) {
     let i = t[0],
-        s = t[1],
-        n = t[2],
+        n = t[1],
+        s = t[2],
         o = t[3],
         a = t[4],
         c = t[5],
         l = t[6],
-        h = t[7],
+        u = t[7],
         f = t[8],
-        u = r[0],
+        h = r[0],
         d = r[1],
-        m = r[2],
+        p = r[2],
         y = r[3],
-        x = r[4],
-        A = r[5],
-        v = r[6],
-        E = r[7],
+        b = r[4],
+        T = r[5],
+        I = r[6],
+        S = r[7],
         R = r[8];
-    return e[0] = u * i + d * o + m * l, e[1] = u * s + d * a + m * h, e[2] = u * n + d * c + m * f, e[3] = y * i + x * o + A * l, e[4] = y * s + x * a + A * h, e[5] = y * n + x * c + A * f, e[6] = v * i + E * o + R * l, e[7] = v * s + E * a + R * h, e[8] = v * n + E * c + R * f, e
+    return e[0] = h * i + d * o + p * l, e[1] = h * n + d * a + p * u, e[2] = h * s + d * c + p * f, e[3] = y * i + b * o + T * l, e[4] = y * n + b * a + T * u, e[5] = y * s + b * c + T * f, e[6] = I * i + S * o + R * l, e[7] = I * n + S * a + R * u, e[8] = I * s + S * c + R * f, e
 }
 
-function Qm(e, t, r) {
+function yS(e, t, r) {
     let i = t[0],
-        s = t[1],
-        n = t[2],
+        n = t[1],
+        s = t[2],
         o = t[3],
         a = t[4],
         c = t[5],
         l = t[6],
-        h = t[7],
+        u = t[7],
         f = t[8],
-        u = r[0],
+        h = r[0],
         d = r[1];
-    return e[0] = i, e[1] = s, e[2] = n, e[3] = o, e[4] = a, e[5] = c, e[6] = u * i + d * o + l, e[7] = u * s + d * a + h, e[8] = u * n + d * c + f, e
+    return e[0] = i, e[1] = n, e[2] = s, e[3] = o, e[4] = a, e[5] = c, e[6] = h * i + d * o + l, e[7] = h * n + d * a + u, e[8] = h * s + d * c + f, e
 }
 
-function Gm(e, t, r) {
+function bS(e, t, r) {
     let i = t[0],
-        s = t[1],
-        n = t[2],
+        n = t[1],
+        s = t[2],
         o = t[3],
         a = t[4],
         c = t[5],
         l = t[6],
-        h = t[7],
+        u = t[7],
         f = t[8],
-        u = Math.sin(r),
+        h = Math.sin(r),
         d = Math.cos(r);
-    return e[0] = d * i + u * o, e[1] = d * s + u * a, e[2] = d * n + u * c, e[3] = d * o - u * i, e[4] = d * a - u * s, e[5] = d * c - u * n, e[6] = l, e[7] = h, e[8] = f, e
+    return e[0] = d * i + h * o, e[1] = d * n + h * a, e[2] = d * s + h * c, e[3] = d * o - h * i, e[4] = d * a - h * n, e[5] = d * c - h * s, e[6] = l, e[7] = u, e[8] = f, e
 }
 
-function Au(e, t, r) {
+function f0(e, t, r) {
     let i = r[0],
-        s = r[1];
-    return e[0] = i * t[0], e[1] = i * t[1], e[2] = i * t[2], e[3] = s * t[3], e[4] = s * t[4], e[5] = s * t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e
+        n = r[1];
+    return e[0] = i * t[0], e[1] = i * t[1], e[2] = i * t[2], e[3] = n * t[3], e[4] = n * t[4], e[5] = n * t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e
 }
 
-function Jm(e, t) {
+function xS(e, t) {
     let r = t[0],
         i = t[1],
-        s = t[2],
-        n = t[3],
+        n = t[2],
+        s = t[3],
         o = r + r,
         a = i + i,
-        c = s + s,
+        c = n + n,
         l = r * o,
-        h = i * o,
+        u = i * o,
         f = i * a,
-        u = s * o,
-        d = s * a,
-        m = s * c,
-        y = n * o,
-        x = n * a,
-        A = n * c;
-    return e[0] = 1 - f - m, e[3] = h - A, e[6] = u + x, e[1] = h + A, e[4] = 1 - l - m, e[7] = d - y, e[2] = u - x, e[5] = d + y, e[8] = 1 - l - f, e
+        h = n * o,
+        d = n * a,
+        p = n * c,
+        y = s * o,
+        b = s * a,
+        T = s * c;
+    return e[0] = 1 - f - p, e[3] = u - T, e[6] = h + b, e[1] = u + T, e[4] = 1 - l - p, e[7] = d - y, e[2] = h - b, e[5] = d + y, e[8] = 1 - l - f, e
 }
-var Eu;
+var h0;
 (function(e) {
     e[e.COL0ROW0 = 0] = "COL0ROW0", e[e.COL0ROW1 = 1] = "COL0ROW1", e[e.COL0ROW2 = 2] = "COL0ROW2", e[e.COL1ROW0 = 3] = "COL1ROW0", e[e.COL1ROW1 = 4] = "COL1ROW1", e[e.COL1ROW2 = 5] = "COL1ROW2", e[e.COL2ROW0 = 6] = "COL2ROW0", e[e.COL2ROW1 = 7] = "COL2ROW1", e[e.COL2ROW2 = 8] = "COL2ROW2"
-})(Eu || (Eu = {}));
-var QE = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]),
-    ft = class extends ps {
+})(h0 || (h0 = {}));
+var rN = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]),
+    qt = class extends Na {
         static get IDENTITY() {
-            return JE()
+            return nN()
         }
         static get ZERO() {
-            return GE()
+            return iN()
         }
         get ELEMENTS() {
             return 9
         }
         get RANK() {
             return 3
         }
         get INDICES() {
-            return Eu
+            return h0
         }
         constructor(t, ...r) {
             super(-0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(t) ? this.copy(t) : r.length > 0 ? this.copy([t, ...r]) : this.identity()
         }
         copy(t) {
             return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this[4] = t[4], this[5] = t[5], this[6] = t[6], this[7] = t[7], this[8] = t[8], this.check()
         }
         identity() {
-            return this.copy(QE)
+            return this.copy(rN)
         }
         fromObject(t) {
             return this.check()
         }
         fromQuaternion(t) {
-            return Jm(this, t), this.check()
+            return xS(this, t), this.check()
         }
-        set(t, r, i, s, n, o, a, c, l) {
-            return this[0] = t, this[1] = r, this[2] = i, this[3] = s, this[4] = n, this[5] = o, this[6] = a, this[7] = c, this[8] = l, this.check()
+        set(t, r, i, n, s, o, a, c, l) {
+            return this[0] = t, this[1] = r, this[2] = i, this[3] = n, this[4] = s, this[5] = o, this[6] = a, this[7] = c, this[8] = l, this.check()
         }
-        setRowMajor(t, r, i, s, n, o, a, c, l) {
-            return this[0] = t, this[1] = s, this[2] = a, this[3] = r, this[4] = n, this[5] = c, this[6] = i, this[7] = o, this[8] = l, this.check()
+        setRowMajor(t, r, i, n, s, o, a, c, l) {
+            return this[0] = t, this[1] = n, this[2] = a, this[3] = r, this[4] = s, this[5] = c, this[6] = i, this[7] = o, this[8] = l, this.check()
         }
         determinant() {
-            return Km(this)
+            return _S(this)
         }
         transpose() {
-            return qm(this, this), this.check()
+            return mS(this, this), this.check()
         }
         invert() {
-            return Zm(this, this), this.check()
+            return gS(this, this), this.check()
         }
         multiplyLeft(t) {
-            return bu(this, t, this), this.check()
+            return u0(this, t, this), this.check()
         }
         multiplyRight(t) {
-            return bu(this, this, t), this.check()
+            return u0(this, this, t), this.check()
         }
         rotate(t) {
-            return Gm(this, this, t), this.check()
+            return bS(this, this, t), this.check()
         }
         scale(t) {
-            return Array.isArray(t) ? Au(this, this, t) : Au(this, this, [t, t]), this.check()
+            return Array.isArray(t) ? f0(this, this, t) : f0(this, this, [t, t]), this.check()
         }
         translate(t) {
-            return Qm(this, this, t), this.check()
+            return yS(this, this, t), this.check()
         }
         transform(t, r) {
             let i;
             switch (t.length) {
                 case 2:
-                    i = uu(r || [-0, -0], t, this);
+                    i = e0(r || [-0, -0], t, this);
                     break;
                 case 3:
-                    i = Vn(r || [-0, -0, -0], t, this);
+                    i = Ol(r || [-0, -0, -0], t, this);
                     break;
                 case 4:
-                    i = _c(r || [-0, -0, -0, -0], t, this);
+                    i = xd(r || [-0, -0, -0, -0], t, this);
                     break;
                 default:
                     throw new Error("Illegal vector")
             }
-            return Hr(i, t.length), i
+            return Ss(i, t.length), i
         }
         transformVector(t, r) {
             return this.transform(t, r)
         }
         transformVector2(t, r) {
             return this.transform(t, r)
         }
         transformVector3(t, r) {
             return this.transform(t, r)
         }
     },
-    Ec, Sc = null;
+    Ed, Id = null;
 
-function GE() {
-    return Ec || (Ec = new ft([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Ec)), Ec
+function iN() {
+    return Ed || (Ed = new qt([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Ed)), Ed
 }
 
-function JE() {
-    return Sc || (Sc = new ft, Object.freeze(Sc)), Sc
+function nN() {
+    return Id || (Id = new qt, Object.freeze(Id)), Id
 }
-var _t = {};
-Ji(_t, {
-    add: () => SS,
-    adjoint: () => nS,
-    clone: () => eS,
-    copy: () => rS,
-    create: () => tS,
-    decompose: () => gS,
-    determinant: () => vu,
-    equals: () => PS,
-    exactEquals: () => RS,
-    frob: () => ES,
-    fromQuat: () => Nu,
-    fromQuat2: () => uS,
-    fromRotation: () => cS,
-    fromRotationTranslation: () => r_,
-    fromRotationTranslationScale: () => mS,
-    fromRotationTranslationScaleOrigin: () => _S,
-    fromScaling: () => aS,
-    fromTranslation: () => oS,
-    fromValues: () => iS,
-    fromXRotation: () => lS,
-    fromYRotation: () => hS,
-    fromZRotation: () => fS,
-    frustum: () => Fu,
-    getRotation: () => pS,
-    getScaling: () => i_,
-    getTranslation: () => dS,
-    identity: () => e_,
-    invert: () => wu,
-    lookAt: () => Lu,
-    mul: () => MS,
-    multiply: () => Wn,
-    multiplyScalar: () => wS,
-    multiplyScalarAndAdd: () => vS,
-    ortho: () => ku,
-    orthoNO: () => n_,
-    orthoZO: () => TS,
-    perspective: () => Du,
-    perspectiveFromFieldOfView: () => xS,
-    perspectiveNO: () => s_,
-    perspectiveZO: () => yS,
-    rotate: () => Mu,
-    rotateX: () => Cu,
-    rotateY: () => Iu,
-    rotateZ: () => Ou,
-    scale: () => Pu,
-    set: () => sS,
-    str: () => AS,
-    sub: () => CS,
-    subtract: () => o_,
-    targetTo: () => bS,
-    translate: () => Ru,
-    transpose: () => Su
+var ie = {};
+Ze(ie, {
+    add: () => MN,
+    adjoint: () => uN,
+    clone: () => oN,
+    copy: () => aN,
+    create: () => sN,
+    decompose: () => xN,
+    determinant: () => m0,
+    equals: () => NN,
+    exactEquals: () => ON,
+    frob: () => RN,
+    fromQuat: () => T0,
+    fromQuat2: () => _N,
+    fromRotation: () => dN,
+    fromRotationTranslation: () => vS,
+    fromRotationTranslationScale: () => wN,
+    fromRotationTranslationScaleOrigin: () => TN,
+    fromScaling: () => hN,
+    fromTranslation: () => fN,
+    fromValues: () => cN,
+    fromXRotation: () => pN,
+    fromYRotation: () => mN,
+    fromZRotation: () => gN,
+    frustum: () => v0,
+    getRotation: () => bN,
+    getScaling: () => SS,
+    getTranslation: () => yN,
+    identity: () => TS,
+    invert: () => p0,
+    lookAt: () => E0,
+    mul: () => BN,
+    multiply: () => Bl,
+    multiplyScalar: () => PN,
+    multiplyScalarAndAdd: () => CN,
+    ortho: () => A0,
+    orthoNO: () => ES,
+    orthoZO: () => AN,
+    perspective: () => S0,
+    perspectiveFromFieldOfView: () => SN,
+    perspectiveNO: () => AS,
+    perspectiveZO: () => vN,
+    rotate: () => y0,
+    rotateX: () => b0,
+    rotateY: () => x0,
+    rotateZ: () => w0,
+    scale: () => _0,
+    set: () => lN,
+    str: () => IN,
+    sub: () => FN,
+    subtract: () => IS,
+    targetTo: () => EN,
+    translate: () => g0,
+    transpose: () => d0
 });
 
-function tS() {
-    let e = new nt(16);
-    return nt != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0), e[0] = 1, e[5] = 1, e[10] = 1, e[15] = 1, e
+function sN() {
+    let e = new Ft(16);
+    return Ft != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0), e[0] = 1, e[5] = 1, e[10] = 1, e[15] = 1, e
 }
 
-function eS(e) {
-    let t = new nt(16);
+function oN(e) {
+    let t = new Ft(16);
     return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t
 }
 
-function rS(e, t) {
+function aN(e, t) {
     return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
 }
 
-function iS(e, t, r, i, s, n, o, a, c, l, h, f, u, d, m, y) {
-    let x = new nt(16);
-    return x[0] = e, x[1] = t, x[2] = r, x[3] = i, x[4] = s, x[5] = n, x[6] = o, x[7] = a, x[8] = c, x[9] = l, x[10] = h, x[11] = f, x[12] = u, x[13] = d, x[14] = m, x[15] = y, x
+function cN(e, t, r, i, n, s, o, a, c, l, u, f, h, d, p, y) {
+    let b = new Ft(16);
+    return b[0] = e, b[1] = t, b[2] = r, b[3] = i, b[4] = n, b[5] = s, b[6] = o, b[7] = a, b[8] = c, b[9] = l, b[10] = u, b[11] = f, b[12] = h, b[13] = d, b[14] = p, b[15] = y, b
 }
 
-function sS(e, t, r, i, s, n, o, a, c, l, h, f, u, d, m, y, x) {
-    return e[0] = t, e[1] = r, e[2] = i, e[3] = s, e[4] = n, e[5] = o, e[6] = a, e[7] = c, e[8] = l, e[9] = h, e[10] = f, e[11] = u, e[12] = d, e[13] = m, e[14] = y, e[15] = x, e
+function lN(e, t, r, i, n, s, o, a, c, l, u, f, h, d, p, y, b) {
+    return e[0] = t, e[1] = r, e[2] = i, e[3] = n, e[4] = s, e[5] = o, e[6] = a, e[7] = c, e[8] = l, e[9] = u, e[10] = f, e[11] = h, e[12] = d, e[13] = p, e[14] = y, e[15] = b, e
 }
 
-function e_(e) {
+function TS(e) {
     return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
 }
 
-function Su(e, t) {
+function d0(e, t) {
     if (e === t) {
         let r = t[1],
             i = t[2],
-            s = t[3],
-            n = t[6],
+            n = t[3],
+            s = t[6],
             o = t[7],
             a = t[11];
-        e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = r, e[6] = t[9], e[7] = t[13], e[8] = i, e[9] = n, e[11] = t[14], e[12] = s, e[13] = o, e[14] = a
+        e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = r, e[6] = t[9], e[7] = t[13], e[8] = i, e[9] = s, e[11] = t[14], e[12] = n, e[13] = o, e[14] = a
     } else e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];
     return e
 }
 
-function wu(e, t) {
+function p0(e, t) {
     let r = t[0],
         i = t[1],
-        s = t[2],
-        n = t[3],
+        n = t[2],
+        s = t[3],
         o = t[4],
         a = t[5],
         c = t[6],
         l = t[7],
-        h = t[8],
+        u = t[8],
         f = t[9],
-        u = t[10],
+        h = t[10],
         d = t[11],
-        m = t[12],
+        p = t[12],
         y = t[13],
-        x = t[14],
-        A = t[15],
-        v = r * a - i * o,
-        E = r * c - s * o,
-        R = r * l - n * o,
-        M = i * c - s * a,
-        C = i * l - n * a,
-        B = s * l - n * c,
-        L = h * y - f * m,
-        k = h * x - u * m,
-        N = h * A - d * m,
-        H = f * x - u * y,
-        $ = f * A - d * y,
-        X = u * A - d * x,
-        J = v * X - E * $ + R * H + M * N - C * k + B * L;
-    return J ? (J = 1 / J, e[0] = (a * X - c * $ + l * H) * J, e[1] = (s * $ - i * X - n * H) * J, e[2] = (y * B - x * C + A * M) * J, e[3] = (u * C - f * B - d * M) * J, e[4] = (c * N - o * X - l * k) * J, e[5] = (r * X - s * N + n * k) * J, e[6] = (x * R - m * B - A * E) * J, e[7] = (h * B - u * R + d * E) * J, e[8] = (o * $ - a * N + l * L) * J, e[9] = (i * N - r * $ - n * L) * J, e[10] = (m * C - y * R + A * v) * J, e[11] = (f * R - h * C - d * v) * J, e[12] = (a * k - o * H - c * L) * J, e[13] = (r * H - i * k + s * L) * J, e[14] = (y * E - m * M - x * v) * J, e[15] = (h * M - f * E + u * v) * J, e) : null
+        b = t[14],
+        T = t[15],
+        I = r * a - i * o,
+        S = r * c - n * o,
+        R = r * l - s * o,
+        P = i * c - n * a,
+        C = i * l - s * a,
+        V = n * l - s * c,
+        U = u * y - f * p,
+        k = u * b - h * p,
+        B = u * T - d * p,
+        K = f * b - h * y,
+        st = f * T - d * y,
+        G = h * T - d * b,
+        Tt = I * G - S * st + R * K + P * B - C * k + V * U;
+    return Tt ? (Tt = 1 / Tt, e[0] = (a * G - c * st + l * K) * Tt, e[1] = (n * st - i * G - s * K) * Tt, e[2] = (y * V - b * C + T * P) * Tt, e[3] = (h * C - f * V - d * P) * Tt, e[4] = (c * B - o * G - l * k) * Tt, e[5] = (r * G - n * B + s * k) * Tt, e[6] = (b * R - p * V - T * S) * Tt, e[7] = (u * V - h * R + d * S) * Tt, e[8] = (o * st - a * B + l * U) * Tt, e[9] = (i * B - r * st - s * U) * Tt, e[10] = (p * C - y * R + T * I) * Tt, e[11] = (f * R - u * C - d * I) * Tt, e[12] = (a * k - o * K - c * U) * Tt, e[13] = (r * K - i * k + n * U) * Tt, e[14] = (y * S - p * P - b * I) * Tt, e[15] = (u * P - f * S + h * I) * Tt, e) : null
 }
 
-function nS(e, t) {
+function uN(e, t) {
     let r = t[0],
         i = t[1],
-        s = t[2],
-        n = t[3],
+        n = t[2],
+        s = t[3],
         o = t[4],
         a = t[5],
         c = t[6],
         l = t[7],
-        h = t[8],
+        u = t[8],
         f = t[9],
-        u = t[10],
+        h = t[10],
         d = t[11],
-        m = t[12],
+        p = t[12],
         y = t[13],
-        x = t[14],
-        A = t[15],
-        v = r * a - i * o,
-        E = r * c - s * o,
-        R = r * l - n * o,
-        M = i * c - s * a,
-        C = i * l - n * a,
-        B = s * l - n * c,
-        L = h * y - f * m,
-        k = h * x - u * m,
-        N = h * A - d * m,
-        H = f * x - u * y,
-        $ = f * A - d * y,
-        X = u * A - d * x;
-    return e[0] = a * X - c * $ + l * H, e[1] = s * $ - i * X - n * H, e[2] = y * B - x * C + A * M, e[3] = u * C - f * B - d * M, e[4] = c * N - o * X - l * k, e[5] = r * X - s * N + n * k, e[6] = x * R - m * B - A * E, e[7] = h * B - u * R + d * E, e[8] = o * $ - a * N + l * L, e[9] = i * N - r * $ - n * L, e[10] = m * C - y * R + A * v, e[11] = f * R - h * C - d * v, e[12] = a * k - o * H - c * L, e[13] = r * H - i * k + s * L, e[14] = y * E - m * M - x * v, e[15] = h * M - f * E + u * v, e
+        b = t[14],
+        T = t[15],
+        I = r * a - i * o,
+        S = r * c - n * o,
+        R = r * l - s * o,
+        P = i * c - n * a,
+        C = i * l - s * a,
+        V = n * l - s * c,
+        U = u * y - f * p,
+        k = u * b - h * p,
+        B = u * T - d * p,
+        K = f * b - h * y,
+        st = f * T - d * y,
+        G = h * T - d * b;
+    return e[0] = a * G - c * st + l * K, e[1] = n * st - i * G - s * K, e[2] = y * V - b * C + T * P, e[3] = h * C - f * V - d * P, e[4] = c * B - o * G - l * k, e[5] = r * G - n * B + s * k, e[6] = b * R - p * V - T * S, e[7] = u * V - h * R + d * S, e[8] = o * st - a * B + l * U, e[9] = i * B - r * st - s * U, e[10] = p * C - y * R + T * I, e[11] = f * R - u * C - d * I, e[12] = a * k - o * K - c * U, e[13] = r * K - i * k + n * U, e[14] = y * S - p * P - b * I, e[15] = u * P - f * S + h * I, e
 }
 
-function vu(e) {
+function m0(e) {
     let t = e[0],
         r = e[1],
         i = e[2],
-        s = e[3],
-        n = e[4],
+        n = e[3],
+        s = e[4],
         o = e[5],
         a = e[6],
         c = e[7],
         l = e[8],
-        h = e[9],
+        u = e[9],
         f = e[10],
-        u = e[11],
+        h = e[11],
         d = e[12],
-        m = e[13],
+        p = e[13],
         y = e[14],
-        x = e[15],
-        A = t * o - r * n,
-        v = t * a - i * n,
-        E = r * a - i * o,
-        R = l * m - h * d,
-        M = l * y - f * d,
-        C = h * y - f * m,
-        B = t * C - r * M + i * R,
-        L = n * C - o * M + a * R,
-        k = l * E - h * v + f * A,
-        N = d * E - m * v + y * A;
-    return c * B - s * L + x * k - u * N
+        b = e[15],
+        T = t * o - r * s,
+        I = t * a - i * s,
+        S = r * a - i * o,
+        R = l * p - u * d,
+        P = l * y - f * d,
+        C = u * y - f * p,
+        V = t * C - r * P + i * R,
+        U = s * C - o * P + a * R,
+        k = l * S - u * I + f * T,
+        B = d * S - p * I + y * T;
+    return c * V - n * U + b * k - h * B
 }
 
-function Wn(e, t, r) {
+function Bl(e, t, r) {
     let i = t[0],
-        s = t[1],
-        n = t[2],
+        n = t[1],
+        s = t[2],
         o = t[3],
         a = t[4],
         c = t[5],
         l = t[6],
-        h = t[7],
+        u = t[7],
         f = t[8],
-        u = t[9],
+        h = t[9],
         d = t[10],
-        m = t[11],
+        p = t[11],
         y = t[12],
-        x = t[13],
-        A = t[14],
-        v = t[15],
-        E = r[0],
+        b = t[13],
+        T = t[14],
+        I = t[15],
+        S = r[0],
         R = r[1],
-        M = r[2],
+        P = r[2],
         C = r[3];
-    return e[0] = E * i + R * a + M * f + C * y, e[1] = E * s + R * c + M * u + C * x, e[2] = E * n + R * l + M * d + C * A, e[3] = E * o + R * h + M * m + C * v, E = r[4], R = r[5], M = r[6], C = r[7], e[4] = E * i + R * a + M * f + C * y, e[5] = E * s + R * c + M * u + C * x, e[6] = E * n + R * l + M * d + C * A, e[7] = E * o + R * h + M * m + C * v, E = r[8], R = r[9], M = r[10], C = r[11], e[8] = E * i + R * a + M * f + C * y, e[9] = E * s + R * c + M * u + C * x, e[10] = E * n + R * l + M * d + C * A, e[11] = E * o + R * h + M * m + C * v, E = r[12], R = r[13], M = r[14], C = r[15], e[12] = E * i + R * a + M * f + C * y, e[13] = E * s + R * c + M * u + C * x, e[14] = E * n + R * l + M * d + C * A, e[15] = E * o + R * h + M * m + C * v, e
+    return e[0] = S * i + R * a + P * f + C * y, e[1] = S * n + R * c + P * h + C * b, e[2] = S * s + R * l + P * d + C * T, e[3] = S * o + R * u + P * p + C * I, S = r[4], R = r[5], P = r[6], C = r[7], e[4] = S * i + R * a + P * f + C * y, e[5] = S * n + R * c + P * h + C * b, e[6] = S * s + R * l + P * d + C * T, e[7] = S * o + R * u + P * p + C * I, S = r[8], R = r[9], P = r[10], C = r[11], e[8] = S * i + R * a + P * f + C * y, e[9] = S * n + R * c + P * h + C * b, e[10] = S * s + R * l + P * d + C * T, e[11] = S * o + R * u + P * p + C * I, S = r[12], R = r[13], P = r[14], C = r[15], e[12] = S * i + R * a + P * f + C * y, e[13] = S * n + R * c + P * h + C * b, e[14] = S * s + R * l + P * d + C * T, e[15] = S * o + R * u + P * p + C * I, e
 }
 
-function Ru(e, t, r) {
+function g0(e, t, r) {
     let i = r[0],
-        s = r[1],
-        n = r[2],
-        o, a, c, l, h, f, u, d, m, y, x, A;
-    return t === e ? (e[12] = t[0] * i + t[4] * s + t[8] * n + t[12], e[13] = t[1] * i + t[5] * s + t[9] * n + t[13], e[14] = t[2] * i + t[6] * s + t[10] * n + t[14], e[15] = t[3] * i + t[7] * s + t[11] * n + t[15]) : (o = t[0], a = t[1], c = t[2], l = t[3], h = t[4], f = t[5], u = t[6], d = t[7], m = t[8], y = t[9], x = t[10], A = t[11], e[0] = o, e[1] = a, e[2] = c, e[3] = l, e[4] = h, e[5] = f, e[6] = u, e[7] = d, e[8] = m, e[9] = y, e[10] = x, e[11] = A, e[12] = o * i + h * s + m * n + t[12], e[13] = a * i + f * s + y * n + t[13], e[14] = c * i + u * s + x * n + t[14], e[15] = l * i + d * s + A * n + t[15]), e
+        n = r[1],
+        s = r[2],
+        o, a, c, l, u, f, h, d, p, y, b, T;
+    return t === e ? (e[12] = t[0] * i + t[4] * n + t[8] * s + t[12], e[13] = t[1] * i + t[5] * n + t[9] * s + t[13], e[14] = t[2] * i + t[6] * n + t[10] * s + t[14], e[15] = t[3] * i + t[7] * n + t[11] * s + t[15]) : (o = t[0], a = t[1], c = t[2], l = t[3], u = t[4], f = t[5], h = t[6], d = t[7], p = t[8], y = t[9], b = t[10], T = t[11], e[0] = o, e[1] = a, e[2] = c, e[3] = l, e[4] = u, e[5] = f, e[6] = h, e[7] = d, e[8] = p, e[9] = y, e[10] = b, e[11] = T, e[12] = o * i + u * n + p * s + t[12], e[13] = a * i + f * n + y * s + t[13], e[14] = c * i + h * n + b * s + t[14], e[15] = l * i + d * n + T * s + t[15]), e
 }
 
-function Pu(e, t, r) {
+function _0(e, t, r) {
     let i = r[0],
-        s = r[1],
-        n = r[2];
-    return e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i, e[3] = t[3] * i, e[4] = t[4] * s, e[5] = t[5] * s, e[6] = t[6] * s, e[7] = t[7] * s, e[8] = t[8] * n, e[9] = t[9] * n, e[10] = t[10] * n, e[11] = t[11] * n, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
+        n = r[1],
+        s = r[2];
+    return e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i, e[3] = t[3] * i, e[4] = t[4] * n, e[5] = t[5] * n, e[6] = t[6] * n, e[7] = t[7] * n, e[8] = t[8] * s, e[9] = t[9] * s, e[10] = t[10] * s, e[11] = t[11] * s, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e
 }
 
-function Mu(e, t, r, i) {
-    let s = i[0],
-        n = i[1],
+function y0(e, t, r, i) {
+    let n = i[0],
+        s = i[1],
         o = i[2],
-        a = Math.sqrt(s * s + n * n + o * o),
-        c, l, h, f, u, d, m, y, x, A, v, E, R, M, C, B, L, k, N, H, $, X, J, xt;
-    return a < 1e-6 ? null : (a = 1 / a, s *= a, n *= a, o *= a, l = Math.sin(r), c = Math.cos(r), h = 1 - c, f = t[0], u = t[1], d = t[2], m = t[3], y = t[4], x = t[5], A = t[6], v = t[7], E = t[8], R = t[9], M = t[10], C = t[11], B = s * s * h + c, L = n * s * h + o * l, k = o * s * h - n * l, N = s * n * h - o * l, H = n * n * h + c, $ = o * n * h + s * l, X = s * o * h + n * l, J = n * o * h - s * l, xt = o * o * h + c, e[0] = f * B + y * L + E * k, e[1] = u * B + x * L + R * k, e[2] = d * B + A * L + M * k, e[3] = m * B + v * L + C * k, e[4] = f * N + y * H + E * $, e[5] = u * N + x * H + R * $, e[6] = d * N + A * H + M * $, e[7] = m * N + v * H + C * $, e[8] = f * X + y * J + E * xt, e[9] = u * X + x * J + R * xt, e[10] = d * X + A * J + M * xt, e[11] = m * X + v * J + C * xt, t !== e && (e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e)
+        a = Math.sqrt(n * n + s * s + o * o),
+        c, l, u, f, h, d, p, y, b, T, I, S, R, P, C, V, U, k, B, K, st, G, Tt, oe;
+    return a < 1e-6 ? null : (a = 1 / a, n *= a, s *= a, o *= a, l = Math.sin(r), c = Math.cos(r), u = 1 - c, f = t[0], h = t[1], d = t[2], p = t[3], y = t[4], b = t[5], T = t[6], I = t[7], S = t[8], R = t[9], P = t[10], C = t[11], V = n * n * u + c, U = s * n * u + o * l, k = o * n * u - s * l, B = n * s * u - o * l, K = s * s * u + c, st = o * s * u + n * l, G = n * o * u + s * l, Tt = s * o * u - n * l, oe = o * o * u + c, e[0] = f * V + y * U + S * k, e[1] = h * V + b * U + R * k, e[2] = d * V + T * U + P * k, e[3] = p * V + I * U + C * k, e[4] = f * B + y * K + S * st, e[5] = h * B + b * K + R * st, e[6] = d * B + T * K + P * st, e[7] = p * B + I * K + C * st, e[8] = f * G + y * Tt + S * oe, e[9] = h * G + b * Tt + R * oe, e[10] = d * G + T * Tt + P * oe, e[11] = p * G + I * Tt + C * oe, t !== e && (e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e)
 }
 
-function Cu(e, t, r) {
+function b0(e, t, r) {
     let i = Math.sin(r),
-        s = Math.cos(r),
-        n = t[4],
+        n = Math.cos(r),
+        s = t[4],
         o = t[5],
         a = t[6],
         c = t[7],
         l = t[8],
-        h = t[9],
+        u = t[9],
         f = t[10],
-        u = t[11];
-    return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = n * s + l * i, e[5] = o * s + h * i, e[6] = a * s + f * i, e[7] = c * s + u * i, e[8] = l * s - n * i, e[9] = h * s - o * i, e[10] = f * s - a * i, e[11] = u * s - c * i, e
+        h = t[11];
+    return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = s * n + l * i, e[5] = o * n + u * i, e[6] = a * n + f * i, e[7] = c * n + h * i, e[8] = l * n - s * i, e[9] = u * n - o * i, e[10] = f * n - a * i, e[11] = h * n - c * i, e
 }
 
-function Iu(e, t, r) {
+function x0(e, t, r) {
     let i = Math.sin(r),
-        s = Math.cos(r),
-        n = t[0],
+        n = Math.cos(r),
+        s = t[0],
         o = t[1],
         a = t[2],
         c = t[3],
         l = t[8],
-        h = t[9],
+        u = t[9],
         f = t[10],
-        u = t[11];
-    return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = n * s - l * i, e[1] = o * s - h * i, e[2] = a * s - f * i, e[3] = c * s - u * i, e[8] = n * i + l * s, e[9] = o * i + h * s, e[10] = a * i + f * s, e[11] = c * i + u * s, e
+        h = t[11];
+    return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = s * n - l * i, e[1] = o * n - u * i, e[2] = a * n - f * i, e[3] = c * n - h * i, e[8] = s * i + l * n, e[9] = o * i + u * n, e[10] = a * i + f * n, e[11] = c * i + h * n, e
 }
 
-function Ou(e, t, r) {
+function w0(e, t, r) {
     let i = Math.sin(r),
-        s = Math.cos(r),
-        n = t[0],
+        n = Math.cos(r),
+        s = t[0],
         o = t[1],
         a = t[2],
         c = t[3],
         l = t[4],
-        h = t[5],
+        u = t[5],
         f = t[6],
-        u = t[7];
-    return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = n * s + l * i, e[1] = o * s + h * i, e[2] = a * s + f * i, e[3] = c * s + u * i, e[4] = l * s - n * i, e[5] = h * s - o * i, e[6] = f * s - a * i, e[7] = u * s - c * i, e
+        h = t[7];
+    return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = s * n + l * i, e[1] = o * n + u * i, e[2] = a * n + f * i, e[3] = c * n + h * i, e[4] = l * n - s * i, e[5] = u * n - o * i, e[6] = f * n - a * i, e[7] = h * n - c * i, e
 }
 
-function oS(e, t) {
+function fN(e, t) {
     return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = t[0], e[13] = t[1], e[14] = t[2], e[15] = 1, e
 }
 
-function aS(e, t) {
+function hN(e, t) {
     return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
 }
 
-function cS(e, t, r) {
+function dN(e, t, r) {
     let i = r[0],
-        s = r[1],
-        n = r[2],
-        o = Math.sqrt(i * i + s * s + n * n),
+        n = r[1],
+        s = r[2],
+        o = Math.sqrt(i * i + n * n + s * s),
         a, c, l;
-    return o < 1e-6 ? null : (o = 1 / o, i *= o, s *= o, n *= o, c = Math.sin(t), a = Math.cos(t), l = 1 - a, e[0] = i * i * l + a, e[1] = s * i * l + n * c, e[2] = n * i * l - s * c, e[3] = 0, e[4] = i * s * l - n * c, e[5] = s * s * l + a, e[6] = n * s * l + i * c, e[7] = 0, e[8] = i * n * l + s * c, e[9] = s * n * l - i * c, e[10] = n * n * l + a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e)
+    return o < 1e-6 ? null : (o = 1 / o, i *= o, n *= o, s *= o, c = Math.sin(t), a = Math.cos(t), l = 1 - a, e[0] = i * i * l + a, e[1] = n * i * l + s * c, e[2] = s * i * l - n * c, e[3] = 0, e[4] = i * n * l - s * c, e[5] = n * n * l + a, e[6] = s * n * l + i * c, e[7] = 0, e[8] = i * s * l + n * c, e[9] = n * s * l - i * c, e[10] = s * s * l + a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e)
 }
 
-function lS(e, t) {
+function pN(e, t) {
     let r = Math.sin(t),
         i = Math.cos(t);
     return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i, e[6] = r, e[7] = 0, e[8] = 0, e[9] = -r, e[10] = i, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
 }
 
-function hS(e, t) {
+function mN(e, t) {
     let r = Math.sin(t),
         i = Math.cos(t);
     return e[0] = i, e[1] = 0, e[2] = -r, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = r, e[9] = 0, e[10] = i, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
 }
 
-function fS(e, t) {
+function gN(e, t) {
     let r = Math.sin(t),
         i = Math.cos(t);
     return e[0] = i, e[1] = r, e[2] = 0, e[3] = 0, e[4] = -r, e[5] = i, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
 }
 
-function r_(e, t, r) {
+function vS(e, t, r) {
     let i = t[0],
-        s = t[1],
-        n = t[2],
+        n = t[1],
+        s = t[2],
         o = t[3],
         a = i + i,
-        c = s + s,
-        l = n + n,
-        h = i * a,
+        c = n + n,
+        l = s + s,
+        u = i * a,
         f = i * c,
-        u = i * l,
-        d = s * c,
-        m = s * l,
-        y = n * l,
-        x = o * a,
-        A = o * c,
-        v = o * l;
-    return e[0] = 1 - (d + y), e[1] = f + v, e[2] = u - A, e[3] = 0, e[4] = f - v, e[5] = 1 - (h + y), e[6] = m + x, e[7] = 0, e[8] = u + A, e[9] = m - x, e[10] = 1 - (h + d), e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e
+        h = i * l,
+        d = n * c,
+        p = n * l,
+        y = s * l,
+        b = o * a,
+        T = o * c,
+        I = o * l;
+    return e[0] = 1 - (d + y), e[1] = f + I, e[2] = h - T, e[3] = 0, e[4] = f - I, e[5] = 1 - (u + y), e[6] = p + b, e[7] = 0, e[8] = h + T, e[9] = p - b, e[10] = 1 - (u + d), e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e
 }
 
-function uS(e, t) {
-    let r = new nt(3),
+function _N(e, t) {
+    let r = new Ft(3),
         i = -t[0],
-        s = -t[1],
-        n = -t[2],
+        n = -t[1],
+        s = -t[2],
         o = t[3],
         a = t[4],
         c = t[5],
         l = t[6],
-        h = t[7],
-        f = i * i + s * s + n * n + o * o;
-    return f > 0 ? (r[0] = (a * o + h * i + c * n - l * s) * 2 / f, r[1] = (c * o + h * s + l * i - a * n) * 2 / f, r[2] = (l * o + h * n + a * s - c * i) * 2 / f) : (r[0] = (a * o + h * i + c * n - l * s) * 2, r[1] = (c * o + h * s + l * i - a * n) * 2, r[2] = (l * o + h * n + a * s - c * i) * 2), r_(e, t, r), e
+        u = t[7],
+        f = i * i + n * n + s * s + o * o;
+    return f > 0 ? (r[0] = (a * o + u * i + c * s - l * n) * 2 / f, r[1] = (c * o + u * n + l * i - a * s) * 2 / f, r[2] = (l * o + u * s + a * n - c * i) * 2 / f) : (r[0] = (a * o + u * i + c * s - l * n) * 2, r[1] = (c * o + u * n + l * i - a * s) * 2, r[2] = (l * o + u * s + a * n - c * i) * 2), vS(e, t, r), e
 }
 
-function dS(e, t) {
+function yN(e, t) {
     return e[0] = t[12], e[1] = t[13], e[2] = t[14], e
 }
 
-function i_(e, t) {
+function SS(e, t) {
     let r = t[0],
         i = t[1],
-        s = t[2],
-        n = t[4],
+        n = t[2],
+        s = t[4],
         o = t[5],
         a = t[6],
         c = t[8],
         l = t[9],
-        h = t[10];
-    return e[0] = Math.sqrt(r * r + i * i + s * s), e[1] = Math.sqrt(n * n + o * o + a * a), e[2] = Math.sqrt(c * c + l * l + h * h), e
+        u = t[10];
+    return e[0] = Math.sqrt(r * r + i * i + n * n), e[1] = Math.sqrt(s * s + o * o + a * a), e[2] = Math.sqrt(c * c + l * l + u * u), e
 }
 
-function pS(e, t) {
-    let r = new nt(3);
-    i_(r, t);
+function bN(e, t) {
+    let r = new Ft(3);
+    SS(r, t);
     let i = 1 / r[0],
-        s = 1 / r[1],
-        n = 1 / r[2],
+        n = 1 / r[1],
+        s = 1 / r[2],
         o = t[0] * i,
-        a = t[1] * s,
-        c = t[2] * n,
+        a = t[1] * n,
+        c = t[2] * s,
         l = t[4] * i,
-        h = t[5] * s,
-        f = t[6] * n,
-        u = t[8] * i,
-        d = t[9] * s,
-        m = t[10] * n,
-        y = o + h + m,
-        x = 0;
-    return y > 0 ? (x = Math.sqrt(y + 1) * 2, e[3] = .25 * x, e[0] = (f - d) / x, e[1] = (u - c) / x, e[2] = (a - l) / x) : o > h && o > m ? (x = Math.sqrt(1 + o - h - m) * 2, e[3] = (f - d) / x, e[0] = .25 * x, e[1] = (a + l) / x, e[2] = (u + c) / x) : h > m ? (x = Math.sqrt(1 + h - o - m) * 2, e[3] = (u - c) / x, e[0] = (a + l) / x, e[1] = .25 * x, e[2] = (f + d) / x) : (x = Math.sqrt(1 + m - o - h) * 2, e[3] = (a - l) / x, e[0] = (u + c) / x, e[1] = (f + d) / x, e[2] = .25 * x), e
+        u = t[5] * n,
+        f = t[6] * s,
+        h = t[8] * i,
+        d = t[9] * n,
+        p = t[10] * s,
+        y = o + u + p,
+        b = 0;
+    return y > 0 ? (b = Math.sqrt(y + 1) * 2, e[3] = .25 * b, e[0] = (f - d) / b, e[1] = (h - c) / b, e[2] = (a - l) / b) : o > u && o > p ? (b = Math.sqrt(1 + o - u - p) * 2, e[3] = (f - d) / b, e[0] = .25 * b, e[1] = (a + l) / b, e[2] = (h + c) / b) : u > p ? (b = Math.sqrt(1 + u - o - p) * 2, e[3] = (h - c) / b, e[0] = (a + l) / b, e[1] = .25 * b, e[2] = (f + d) / b) : (b = Math.sqrt(1 + p - o - u) * 2, e[3] = (a - l) / b, e[0] = (h + c) / b, e[1] = (f + d) / b, e[2] = .25 * b), e
 }
 
-function gS(e, t, r, i) {
+function xN(e, t, r, i) {
     t[0] = i[12], t[1] = i[13], t[2] = i[14];
-    let s = i[0],
-        n = i[1],
+    let n = i[0],
+        s = i[1],
         o = i[2],
         a = i[4],
         c = i[5],
         l = i[6],
-        h = i[8],
+        u = i[8],
         f = i[9],
-        u = i[10];
-    r[0] = Math.sqrt(s * s + n * n + o * o), r[1] = Math.sqrt(a * a + c * c + l * l), r[2] = Math.sqrt(h * h + f * f + u * u);
+        h = i[10];
+    r[0] = Math.sqrt(n * n + s * s + o * o), r[1] = Math.sqrt(a * a + c * c + l * l), r[2] = Math.sqrt(u * u + f * f + h * h);
     let d = 1 / r[0],
-        m = 1 / r[1],
+        p = 1 / r[1],
         y = 1 / r[2],
-        x = s * d,
-        A = n * m,
-        v = o * y,
-        E = a * d,
-        R = c * m,
-        M = l * y,
-        C = h * d,
-        B = f * m,
-        L = u * y,
-        k = x + R + L,
-        N = 0;
-    return k > 0 ? (N = Math.sqrt(k + 1) * 2, e[3] = .25 * N, e[0] = (M - B) / N, e[1] = (C - v) / N, e[2] = (A - E) / N) : x > R && x > L ? (N = Math.sqrt(1 + x - R - L) * 2, e[3] = (M - B) / N, e[0] = .25 * N, e[1] = (A + E) / N, e[2] = (C + v) / N) : R > L ? (N = Math.sqrt(1 + R - x - L) * 2, e[3] = (C - v) / N, e[0] = (A + E) / N, e[1] = .25 * N, e[2] = (M + B) / N) : (N = Math.sqrt(1 + L - x - R) * 2, e[3] = (A - E) / N, e[0] = (C + v) / N, e[1] = (M + B) / N, e[2] = .25 * N), e
+        b = n * d,
+        T = s * p,
+        I = o * y,
+        S = a * d,
+        R = c * p,
+        P = l * y,
+        C = u * d,
+        V = f * p,
+        U = h * y,
+        k = b + R + U,
+        B = 0;
+    return k > 0 ? (B = Math.sqrt(k + 1) * 2, e[3] = .25 * B, e[0] = (P - V) / B, e[1] = (C - I) / B, e[2] = (T - S) / B) : b > R && b > U ? (B = Math.sqrt(1 + b - R - U) * 2, e[3] = (P - V) / B, e[0] = .25 * B, e[1] = (T + S) / B, e[2] = (C + I) / B) : R > U ? (B = Math.sqrt(1 + R - b - U) * 2, e[3] = (C - I) / B, e[0] = (T + S) / B, e[1] = .25 * B, e[2] = (P + V) / B) : (B = Math.sqrt(1 + U - b - R) * 2, e[3] = (T - S) / B, e[0] = (C + I) / B, e[1] = (P + V) / B, e[2] = .25 * B), e
 }
 
-function mS(e, t, r, i) {
-    let s = t[0],
-        n = t[1],
+function wN(e, t, r, i) {
+    let n = t[0],
+        s = t[1],
         o = t[2],
         a = t[3],
-        c = s + s,
-        l = n + n,
-        h = o + o,
-        f = s * c,
-        u = s * l,
-        d = s * h,
-        m = n * l,
-        y = n * h,
-        x = o * h,
-        A = a * c,
-        v = a * l,
-        E = a * h,
+        c = n + n,
+        l = s + s,
+        u = o + o,
+        f = n * c,
+        h = n * l,
+        d = n * u,
+        p = s * l,
+        y = s * u,
+        b = o * u,
+        T = a * c,
+        I = a * l,
+        S = a * u,
         R = i[0],
-        M = i[1],
+        P = i[1],
         C = i[2];
-    return e[0] = (1 - (m + x)) * R, e[1] = (u + E) * R, e[2] = (d - v) * R, e[3] = 0, e[4] = (u - E) * M, e[5] = (1 - (f + x)) * M, e[6] = (y + A) * M, e[7] = 0, e[8] = (d + v) * C, e[9] = (y - A) * C, e[10] = (1 - (f + m)) * C, e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e
+    return e[0] = (1 - (p + b)) * R, e[1] = (h + S) * R, e[2] = (d - I) * R, e[3] = 0, e[4] = (h - S) * P, e[5] = (1 - (f + b)) * P, e[6] = (y + T) * P, e[7] = 0, e[8] = (d + I) * C, e[9] = (y - T) * C, e[10] = (1 - (f + p)) * C, e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e
 }
 
-function _S(e, t, r, i, s) {
-    let n = t[0],
+function TN(e, t, r, i, n) {
+    let s = t[0],
         o = t[1],
         a = t[2],
         c = t[3],
-        l = n + n,
-        h = o + o,
+        l = s + s,
+        u = o + o,
         f = a + a,
-        u = n * l,
-        d = n * h,
-        m = n * f,
-        y = o * h,
-        x = o * f,
-        A = a * f,
-        v = c * l,
-        E = c * h,
+        h = s * l,
+        d = s * u,
+        p = s * f,
+        y = o * u,
+        b = o * f,
+        T = a * f,
+        I = c * l,
+        S = c * u,
         R = c * f,
-        M = i[0],
+        P = i[0],
         C = i[1],
-        B = i[2],
-        L = s[0],
-        k = s[1],
-        N = s[2],
-        H = (1 - (y + A)) * M,
-        $ = (d + R) * M,
-        X = (m - E) * M,
-        J = (d - R) * C,
-        xt = (1 - (u + A)) * C,
-        ne = (x + v) * C,
-        It = (m + E) * B,
-        ci = (x - v) * B,
-        wr = (1 - (u + y)) * B;
-    return e[0] = H, e[1] = $, e[2] = X, e[3] = 0, e[4] = J, e[5] = xt, e[6] = ne, e[7] = 0, e[8] = It, e[9] = ci, e[10] = wr, e[11] = 0, e[12] = r[0] + L - (H * L + J * k + It * N), e[13] = r[1] + k - ($ * L + xt * k + ci * N), e[14] = r[2] + N - (X * L + ne * k + wr * N), e[15] = 1, e
+        V = i[2],
+        U = n[0],
+        k = n[1],
+        B = n[2],
+        K = (1 - (y + T)) * P,
+        st = (d + R) * P,
+        G = (p - S) * P,
+        Tt = (d - R) * C,
+        oe = (1 - (h + T)) * C,
+        Er = (b + I) * C,
+        Re = (p + S) * V,
+        ro = (b - I) * V,
+        os = (1 - (h + y)) * V;
+    return e[0] = K, e[1] = st, e[2] = G, e[3] = 0, e[4] = Tt, e[5] = oe, e[6] = Er, e[7] = 0, e[8] = Re, e[9] = ro, e[10] = os, e[11] = 0, e[12] = r[0] + U - (K * U + Tt * k + Re * B), e[13] = r[1] + k - (st * U + oe * k + ro * B), e[14] = r[2] + B - (G * U + Er * k + os * B), e[15] = 1, e
 }
 
-function Nu(e, t) {
+function T0(e, t) {
     let r = t[0],
         i = t[1],
-        s = t[2],
-        n = t[3],
+        n = t[2],
+        s = t[3],
         o = r + r,
         a = i + i,
-        c = s + s,
+        c = n + n,
         l = r * o,
-        h = i * o,
+        u = i * o,
         f = i * a,
-        u = s * o,
-        d = s * a,
-        m = s * c,
-        y = n * o,
-        x = n * a,
-        A = n * c;
-    return e[0] = 1 - f - m, e[1] = h + A, e[2] = u - x, e[3] = 0, e[4] = h - A, e[5] = 1 - l - m, e[6] = d + y, e[7] = 0, e[8] = u + x, e[9] = d - y, e[10] = 1 - l - f, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
+        h = n * o,
+        d = n * a,
+        p = n * c,
+        y = s * o,
+        b = s * a,
+        T = s * c;
+    return e[0] = 1 - f - p, e[1] = u + T, e[2] = h - b, e[3] = 0, e[4] = u - T, e[5] = 1 - l - p, e[6] = d + y, e[7] = 0, e[8] = h + b, e[9] = d - y, e[10] = 1 - l - f, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e
 }
 
-function Fu(e, t, r, i, s, n, o) {
+function v0(e, t, r, i, n, s, o) {
     let a = 1 / (r - t),
-        c = 1 / (s - i),
-        l = 1 / (n - o);
-    return e[0] = n * 2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = n * 2 * c, e[6] = 0, e[7] = 0, e[8] = (r + t) * a, e[9] = (s + i) * c, e[10] = (o + n) * l, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = o * n * 2 * l, e[15] = 0, e
+        c = 1 / (n - i),
+        l = 1 / (s - o);
+    return e[0] = s * 2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = s * 2 * c, e[6] = 0, e[7] = 0, e[8] = (r + t) * a, e[9] = (n + i) * c, e[10] = (o + s) * l, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = o * s * 2 * l, e[15] = 0, e
 }
 
-function s_(e, t, r, i, s) {
-    let n = 1 / Math.tan(t / 2);
-    if (e[0] = n / r, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = n, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, s != null && s !== 1 / 0) {
-        let o = 1 / (i - s);
-        e[10] = (s + i) * o, e[14] = 2 * s * i * o
+function AS(e, t, r, i, n) {
+    let s = 1 / Math.tan(t / 2);
+    if (e[0] = s / r, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = s, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, n != null && n !== 1 / 0) {
+        let o = 1 / (i - n);
+        e[10] = (n + i) * o, e[14] = 2 * n * i * o
     } else e[10] = -1, e[14] = -2 * i;
     return e
 }
-var Du = s_;
+var S0 = AS;
 
-function yS(e, t, r, i, s) {
-    let n = 1 / Math.tan(t / 2);
-    if (e[0] = n / r, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = n, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, s != null && s !== 1 / 0) {
-        let o = 1 / (i - s);
-        e[10] = s * o, e[14] = s * i * o
+function vN(e, t, r, i, n) {
+    let s = 1 / Math.tan(t / 2);
+    if (e[0] = s / r, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = s, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, n != null && n !== 1 / 0) {
+        let o = 1 / (i - n);
+        e[10] = n * o, e[14] = n * i * o
     } else e[10] = -1, e[14] = -i;
     return e
 }
 
-function xS(e, t, r, i) {
-    let s = Math.tan(t.upDegrees * Math.PI / 180),
-        n = Math.tan(t.downDegrees * Math.PI / 180),
+function SN(e, t, r, i) {
+    let n = Math.tan(t.upDegrees * Math.PI / 180),
+        s = Math.tan(t.downDegrees * Math.PI / 180),
         o = Math.tan(t.leftDegrees * Math.PI / 180),
         a = Math.tan(t.rightDegrees * Math.PI / 180),
         c = 2 / (o + a),
-        l = 2 / (s + n);
-    return e[0] = c, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = l, e[6] = 0, e[7] = 0, e[8] = -((o - a) * c * .5), e[9] = (s - n) * l * .5, e[10] = i / (r - i), e[11] = -1, e[12] = 0, e[13] = 0, e[14] = i * r / (r - i), e[15] = 0, e
+        l = 2 / (n + s);
+    return e[0] = c, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = l, e[6] = 0, e[7] = 0, e[8] = -((o - a) * c * .5), e[9] = (n - s) * l * .5, e[10] = i / (r - i), e[11] = -1, e[12] = 0, e[13] = 0, e[14] = i * r / (r - i), e[15] = 0, e
 }
 
-function n_(e, t, r, i, s, n, o) {
+function ES(e, t, r, i, n, s, o) {
     let a = 1 / (t - r),
-        c = 1 / (i - s),
-        l = 1 / (n - o);
-    return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * l, e[11] = 0, e[12] = (t + r) * a, e[13] = (s + i) * c, e[14] = (o + n) * l, e[15] = 1, e
+        c = 1 / (i - n),
+        l = 1 / (s - o);
+    return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * l, e[11] = 0, e[12] = (t + r) * a, e[13] = (n + i) * c, e[14] = (o + s) * l, e[15] = 1, e
 }
-var ku = n_;
+var A0 = ES;
 
-function TS(e, t, r, i, s, n, o) {
+function AN(e, t, r, i, n, s, o) {
     let a = 1 / (t - r),
-        c = 1 / (i - s),
-        l = 1 / (n - o);
-    return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = l, e[11] = 0, e[12] = (t + r) * a, e[13] = (s + i) * c, e[14] = n * l, e[15] = 1, e
+        c = 1 / (i - n),
+        l = 1 / (s - o);
+    return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = l, e[11] = 0, e[12] = (t + r) * a, e[13] = (n + i) * c, e[14] = s * l, e[15] = 1, e
 }
 
-function Lu(e, t, r, i) {
-    let s, n, o, a, c, l, h, f, u, d, m = t[0],
+function E0(e, t, r, i) {
+    let n, s, o, a, c, l, u, f, h, d, p = t[0],
         y = t[1],
-        x = t[2],
-        A = i[0],
-        v = i[1],
-        E = i[2],
+        b = t[2],
+        T = i[0],
+        I = i[1],
+        S = i[2],
         R = r[0],
-        M = r[1],
+        P = r[1],
         C = r[2];
-    return Math.abs(m - R) < 1e-6 && Math.abs(y - M) < 1e-6 && Math.abs(x - C) < 1e-6 ? e_(e) : (f = m - R, u = y - M, d = x - C, s = 1 / Math.sqrt(f * f + u * u + d * d), f *= s, u *= s, d *= s, n = v * d - E * u, o = E * f - A * d, a = A * u - v * f, s = Math.sqrt(n * n + o * o + a * a), s ? (s = 1 / s, n *= s, o *= s, a *= s) : (n = 0, o = 0, a = 0), c = u * a - d * o, l = d * n - f * a, h = f * o - u * n, s = Math.sqrt(c * c + l * l + h * h), s ? (s = 1 / s, c *= s, l *= s, h *= s) : (c = 0, l = 0, h = 0), e[0] = n, e[1] = c, e[2] = f, e[3] = 0, e[4] = o, e[5] = l, e[6] = u, e[7] = 0, e[8] = a, e[9] = h, e[10] = d, e[11] = 0, e[12] = -(n * m + o * y + a * x), e[13] = -(c * m + l * y + h * x), e[14] = -(f * m + u * y + d * x), e[15] = 1, e)
+    return Math.abs(p - R) < 1e-6 && Math.abs(y - P) < 1e-6 && Math.abs(b - C) < 1e-6 ? TS(e) : (f = p - R, h = y - P, d = b - C, n = 1 / Math.sqrt(f * f + h * h + d * d), f *= n, h *= n, d *= n, s = I * d - S * h, o = S * f - T * d, a = T * h - I * f, n = Math.sqrt(s * s + o * o + a * a), n ? (n = 1 / n, s *= n, o *= n, a *= n) : (s = 0, o = 0, a = 0), c = h * a - d * o, l = d * s - f * a, u = f * o - h * s, n = Math.sqrt(c * c + l * l + u * u), n ? (n = 1 / n, c *= n, l *= n, u *= n) : (c = 0, l = 0, u = 0), e[0] = s, e[1] = c, e[2] = f, e[3] = 0, e[4] = o, e[5] = l, e[6] = h, e[7] = 0, e[8] = a, e[9] = u, e[10] = d, e[11] = 0, e[12] = -(s * p + o * y + a * b), e[13] = -(c * p + l * y + u * b), e[14] = -(f * p + h * y + d * b), e[15] = 1, e)
 }
 
-function bS(e, t, r, i) {
-    let s = t[0],
-        n = t[1],
+function EN(e, t, r, i) {
+    let n = t[0],
+        s = t[1],
         o = t[2],
         a = i[0],
         c = i[1],
         l = i[2],
-        h = s - r[0],
-        f = n - r[1],
-        u = o - r[2],
-        d = h * h + f * f + u * u;
-    d > 0 && (d = 1 / Math.sqrt(d), h *= d, f *= d, u *= d);
-    let m = c * u - l * f,
-        y = l * h - a * u,
-        x = a * f - c * h;
-    return d = m * m + y * y + x * x, d > 0 && (d = 1 / Math.sqrt(d), m *= d, y *= d, x *= d), e[0] = m, e[1] = y, e[2] = x, e[3] = 0, e[4] = f * x - u * y, e[5] = u * m - h * x, e[6] = h * y - f * m, e[7] = 0, e[8] = h, e[9] = f, e[10] = u, e[11] = 0, e[12] = s, e[13] = n, e[14] = o, e[15] = 1, e
+        u = n - r[0],
+        f = s - r[1],
+        h = o - r[2],
+        d = u * u + f * f + h * h;
+    d > 0 && (d = 1 / Math.sqrt(d), u *= d, f *= d, h *= d);
+    let p = c * h - l * f,
+        y = l * u - a * h,
+        b = a * f - c * u;
+    return d = p * p + y * y + b * b, d > 0 && (d = 1 / Math.sqrt(d), p *= d, y *= d, b *= d), e[0] = p, e[1] = y, e[2] = b, e[3] = 0, e[4] = f * b - h * y, e[5] = h * p - u * b, e[6] = u * y - f * p, e[7] = 0, e[8] = u, e[9] = f, e[10] = h, e[11] = 0, e[12] = n, e[13] = s, e[14] = o, e[15] = 1, e
 }
 
-function AS(e) {
+function IN(e) {
     return `mat4(${e[0]}, ${e[1]}, ${e[2]}, ${e[3]}, ${e[4]}, ${e[5]}, ${e[6]}, ${e[7]}, ${e[8]}, ${e[9]}, ${e[10]}, ${e[11]}, ${e[12]}, ${e[13]}, ${e[14]}, ${e[15]})`
 }
 
-function ES(e) {
+function RN(e) {
     return Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2] + e[3] * e[3] + e[4] * e[4] + e[5] * e[5] + e[6] * e[6] + e[7] * e[7] + e[8] * e[8] + e[9] * e[9] + e[10] * e[10] + e[11] * e[11] + e[12] * e[12] + e[13] * e[13] + e[14] * e[14] + e[15] * e[15])
 }
 
-function SS(e, t, r) {
+function MN(e, t, r) {
     return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e[4] = t[4] + r[4], e[5] = t[5] + r[5], e[6] = t[6] + r[6], e[7] = t[7] + r[7], e[8] = t[8] + r[8], e[9] = t[9] + r[9], e[10] = t[10] + r[10], e[11] = t[11] + r[11], e[12] = t[12] + r[12], e[13] = t[13] + r[13], e[14] = t[14] + r[14], e[15] = t[15] + r[15], e
 }
 
-function o_(e, t, r) {
+function IS(e, t, r) {
     return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e[4] = t[4] - r[4], e[5] = t[5] - r[5], e[6] = t[6] - r[6], e[7] = t[7] - r[7], e[8] = t[8] - r[8], e[9] = t[9] - r[9], e[10] = t[10] - r[10], e[11] = t[11] - r[11], e[12] = t[12] - r[12], e[13] = t[13] - r[13], e[14] = t[14] - r[14], e[15] = t[15] - r[15], e
 }
 
-function wS(e, t, r) {
+function PN(e, t, r) {
     return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * r, e[9] = t[9] * r, e[10] = t[10] * r, e[11] = t[11] * r, e[12] = t[12] * r, e[13] = t[13] * r, e[14] = t[14] * r, e[15] = t[15] * r, e
 }
 
-function vS(e, t, r, i) {
+function CN(e, t, r, i) {
     return e[0] = t[0] + r[0] * i, e[1] = t[1] + r[1] * i, e[2] = t[2] + r[2] * i, e[3] = t[3] + r[3] * i, e[4] = t[4] + r[4] * i, e[5] = t[5] + r[5] * i, e[6] = t[6] + r[6] * i, e[7] = t[7] + r[7] * i, e[8] = t[8] + r[8] * i, e[9] = t[9] + r[9] * i, e[10] = t[10] + r[10] * i, e[11] = t[11] + r[11] * i, e[12] = t[12] + r[12] * i, e[13] = t[13] + r[13] * i, e[14] = t[14] + r[14] * i, e[15] = t[15] + r[15] * i, e
 }
 
-function RS(e, t) {
+function ON(e, t) {
     return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15]
 }
 
-function PS(e, t) {
+function NN(e, t) {
     let r = e[0],
         i = e[1],
-        s = e[2],
-        n = e[3],
+        n = e[2],
+        s = e[3],
         o = e[4],
         a = e[5],
         c = e[6],
         l = e[7],
-        h = e[8],
+        u = e[8],
         f = e[9],
-        u = e[10],
+        h = e[10],
         d = e[11],
-        m = e[12],
+        p = e[12],
         y = e[13],
-        x = e[14],
-        A = e[15],
-        v = t[0],
-        E = t[1],
+        b = e[14],
+        T = e[15],
+        I = t[0],
+        S = t[1],
         R = t[2],
-        M = t[3],
+        P = t[3],
         C = t[4],
-        B = t[5],
-        L = t[6],
+        V = t[5],
+        U = t[6],
         k = t[7],
-        N = t[8],
-        H = t[9],
-        $ = t[10],
-        X = t[11],
-        J = t[12],
-        xt = t[13],
-        ne = t[14],
-        It = t[15];
-    return Math.abs(r - v) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(v)) && Math.abs(i - E) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(E)) && Math.abs(s - R) <= 1e-6 * Math.max(1, Math.abs(s), Math.abs(R)) && Math.abs(n - M) <= 1e-6 * Math.max(1, Math.abs(n), Math.abs(M)) && Math.abs(o - C) <= 1e-6 * Math.max(1, Math.abs(o), Math.abs(C)) && Math.abs(a - B) <= 1e-6 * Math.max(1, Math.abs(a), Math.abs(B)) && Math.abs(c - L) <= 1e-6 * Math.max(1, Math.abs(c), Math.abs(L)) && Math.abs(l - k) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(k)) && Math.abs(h - N) <= 1e-6 * Math.max(1, Math.abs(h), Math.abs(N)) && Math.abs(f - H) <= 1e-6 * Math.max(1, Math.abs(f), Math.abs(H)) && Math.abs(u - $) <= 1e-6 * Math.max(1, Math.abs(u), Math.abs($)) && Math.abs(d - X) <= 1e-6 * Math.max(1, Math.abs(d), Math.abs(X)) && Math.abs(m - J) <= 1e-6 * Math.max(1, Math.abs(m), Math.abs(J)) && Math.abs(y - xt) <= 1e-6 * Math.max(1, Math.abs(y), Math.abs(xt)) && Math.abs(x - ne) <= 1e-6 * Math.max(1, Math.abs(x), Math.abs(ne)) && Math.abs(A - It) <= 1e-6 * Math.max(1, Math.abs(A), Math.abs(It))
-}
-var MS = Wn,
-    CS = o_;
-var Zt = {};
-Ji(Zt, {
-    add: () => Bu,
-    ceil: () => IS,
-    clone: () => c_,
-    copy: () => h_,
-    create: () => a_,
-    cross: () => US,
-    dist: () => YS,
-    distance: () => g_,
-    div: () => $S,
-    divide: () => p_,
-    dot: () => zu,
-    equals: () => jS,
-    exactEquals: () => __,
-    floor: () => OS,
-    forEach: () => QS,
-    fromValues: () => l_,
-    inverse: () => BS,
-    len: () => ZS,
-    length: () => wc,
-    lerp: () => Wu,
-    max: () => FS,
-    min: () => NS,
-    mul: () => XS,
-    multiply: () => d_,
-    negate: () => LS,
-    normalize: () => Vu,
-    random: () => VS,
-    round: () => DS,
-    scale: () => Uu,
-    scaleAndAdd: () => kS,
-    set: () => f_,
-    sqrDist: () => qS,
-    sqrLen: () => KS,
-    squaredDistance: () => m_,
-    squaredLength: () => vc,
-    str: () => WS,
-    sub: () => HS,
-    subtract: () => u_,
-    transformMat4: () => ju,
-    transformQuat: () => Hu,
-    zero: () => zS
+        B = t[8],
+        K = t[9],
+        st = t[10],
+        G = t[11],
+        Tt = t[12],
+        oe = t[13],
+        Er = t[14],
+        Re = t[15];
+    return Math.abs(r - I) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(I)) && Math.abs(i - S) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(S)) && Math.abs(n - R) <= 1e-6 * Math.max(1, Math.abs(n), Math.abs(R)) && Math.abs(s - P) <= 1e-6 * Math.max(1, Math.abs(s), Math.abs(P)) && Math.abs(o - C) <= 1e-6 * Math.max(1, Math.abs(o), Math.abs(C)) && Math.abs(a - V) <= 1e-6 * Math.max(1, Math.abs(a), Math.abs(V)) && Math.abs(c - U) <= 1e-6 * Math.max(1, Math.abs(c), Math.abs(U)) && Math.abs(l - k) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(k)) && Math.abs(u - B) <= 1e-6 * Math.max(1, Math.abs(u), Math.abs(B)) && Math.abs(f - K) <= 1e-6 * Math.max(1, Math.abs(f), Math.abs(K)) && Math.abs(h - st) <= 1e-6 * Math.max(1, Math.abs(h), Math.abs(st)) && Math.abs(d - G) <= 1e-6 * Math.max(1, Math.abs(d), Math.abs(G)) && Math.abs(p - Tt) <= 1e-6 * Math.max(1, Math.abs(p), Math.abs(Tt)) && Math.abs(y - oe) <= 1e-6 * Math.max(1, Math.abs(y), Math.abs(oe)) && Math.abs(b - Er) <= 1e-6 * Math.max(1, Math.abs(b), Math.abs(Er)) && Math.abs(T - Re) <= 1e-6 * Math.max(1, Math.abs(T), Math.abs(Re))
+}
+var BN = Bl,
+    FN = IS;
+var Qe = {};
+Ze(Qe, {
+    add: () => I0,
+    ceil: () => DN,
+    clone: () => MS,
+    copy: () => CS,
+    create: () => RS,
+    cross: () => HN,
+    dist: () => JN,
+    distance: () => DS,
+    div: () => GN,
+    divide: () => FS,
+    dot: () => P0,
+    equals: () => qN,
+    exactEquals: () => kS,
+    floor: () => LN,
+    forEach: () => rB,
+    fromValues: () => PS,
+    inverse: () => jN,
+    len: () => tB,
+    length: () => Rd,
+    lerp: () => C0,
+    max: () => UN,
+    min: () => kN,
+    mul: () => KN,
+    multiply: () => BS,
+    negate: () => WN,
+    normalize: () => M0,
+    random: () => $N,
+    round: () => VN,
+    scale: () => R0,
+    scaleAndAdd: () => zN,
+    set: () => OS,
+    sqrDist: () => QN,
+    sqrLen: () => eB,
+    squaredDistance: () => LS,
+    squaredLength: () => Md,
+    str: () => YN,
+    sub: () => ZN,
+    subtract: () => NS,
+    transformMat4: () => O0,
+    transformQuat: () => N0,
+    zero: () => XN
 });
 
-function a_() {
-    let e = new nt(4);
-    return nt != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0), e
+function RS() {
+    let e = new Ft(4);
+    return Ft != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0), e
 }
 
-function c_(e) {
-    let t = new nt(4);
+function MS(e) {
+    let t = new Ft(4);
     return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
 }
 
-function l_(e, t, r, i) {
-    let s = new nt(4);
-    return s[0] = e, s[1] = t, s[2] = r, s[3] = i, s
+function PS(e, t, r, i) {
+    let n = new Ft(4);
+    return n[0] = e, n[1] = t, n[2] = r, n[3] = i, n
 }
 
-function h_(e, t) {
+function CS(e, t) {
     return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e
 }
 
-function f_(e, t, r, i, s) {
-    return e[0] = t, e[1] = r, e[2] = i, e[3] = s, e
+function OS(e, t, r, i, n) {
+    return e[0] = t, e[1] = r, e[2] = i, e[3] = n, e
 }
 
-function Bu(e, t, r) {
+function I0(e, t, r) {
     return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e
 }
 
-function u_(e, t, r) {
+function NS(e, t, r) {
     return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e
 }
 
-function d_(e, t, r) {
+function BS(e, t, r) {
     return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e[3] = t[3] * r[3], e
 }
 
-function p_(e, t, r) {
+function FS(e, t, r) {
     return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e[3] = t[3] / r[3], e
 }
 
-function IS(e, t) {
+function DN(e, t) {
     return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e[3] = Math.ceil(t[3]), e
 }
 
-function OS(e, t) {
+function LN(e, t) {
     return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e[3] = Math.floor(t[3]), e
 }
 
-function NS(e, t, r) {
+function kN(e, t, r) {
     return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e[3] = Math.min(t[3], r[3]), e
 }
 
-function FS(e, t, r) {
+function UN(e, t, r) {
     return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e[3] = Math.max(t[3], r[3]), e
 }
 
-function DS(e, t) {
-    return e[0] = pe(t[0]), e[1] = pe(t[1]), e[2] = pe(t[2]), e[3] = pe(t[3]), e
+function VN(e, t) {
+    return e[0] = Fr(t[0]), e[1] = Fr(t[1]), e[2] = Fr(t[2]), e[3] = Fr(t[3]), e
 }
 
-function Uu(e, t, r) {
+function R0(e, t, r) {
     return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e
 }
 
-function kS(e, t, r, i) {
+function zN(e, t, r, i) {
     return e[0] = t[0] + r[0] * i, e[1] = t[1] + r[1] * i, e[2] = t[2] + r[2] * i, e[3] = t[3] + r[3] * i, e
 }
 
-function g_(e, t) {
+function DS(e, t) {
     let r = t[0] - e[0],
         i = t[1] - e[1],
-        s = t[2] - e[2],
-        n = t[3] - e[3];
-    return Math.sqrt(r * r + i * i + s * s + n * n)
+        n = t[2] - e[2],
+        s = t[3] - e[3];
+    return Math.sqrt(r * r + i * i + n * n + s * s)
 }
 
-function m_(e, t) {
+function LS(e, t) {
     let r = t[0] - e[0],
         i = t[1] - e[1],
-        s = t[2] - e[2],
-        n = t[3] - e[3];
-    return r * r + i * i + s * s + n * n
+        n = t[2] - e[2],
+        s = t[3] - e[3];
+    return r * r + i * i + n * n + s * s
 }
 
-function wc(e) {
+function Rd(e) {
     let t = e[0],
         r = e[1],
         i = e[2],
-        s = e[3];
-    return Math.sqrt(t * t + r * r + i * i + s * s)
+        n = e[3];
+    return Math.sqrt(t * t + r * r + i * i + n * n)
 }
 
-function vc(e) {
+function Md(e) {
     let t = e[0],
         r = e[1],
         i = e[2],
-        s = e[3];
-    return t * t + r * r + i * i + s * s
+        n = e[3];
+    return t * t + r * r + i * i + n * n
 }
 
-function LS(e, t) {
+function WN(e, t) {
     return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = -t[3], e
 }
 
-function BS(e, t) {
+function jN(e, t) {
     return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e[3] = 1 / t[3], e
 }
 
-function Vu(e, t) {
+function M0(e, t) {
     let r = t[0],
         i = t[1],
-        s = t[2],
-        n = t[3],
-        o = r * r + i * i + s * s + n * n;
-    return o > 0 && (o = 1 / Math.sqrt(o)), e[0] = r * o, e[1] = i * o, e[2] = s * o, e[3] = n * o, e
+        n = t[2],
+        s = t[3],
+        o = r * r + i * i + n * n + s * s;
+    return o > 0 && (o = 1 / Math.sqrt(o)), e[0] = r * o, e[1] = i * o, e[2] = n * o, e[3] = s * o, e
 }
 
-function zu(e, t) {
+function P0(e, t) {
     return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3]
 }
 
-function US(e, t, r, i) {
-    let s = r[0] * i[1] - r[1] * i[0],
-        n = r[0] * i[2] - r[2] * i[0],
+function HN(e, t, r, i) {
+    let n = r[0] * i[1] - r[1] * i[0],
+        s = r[0] * i[2] - r[2] * i[0],
         o = r[0] * i[3] - r[3] * i[0],
         a = r[1] * i[2] - r[2] * i[1],
         c = r[1] * i[3] - r[3] * i[1],
         l = r[2] * i[3] - r[3] * i[2],
-        h = t[0],
+        u = t[0],
         f = t[1],
-        u = t[2],
+        h = t[2],
         d = t[3];
-    return e[0] = f * l - u * c + d * a, e[1] = -(h * l) + u * o - d * n, e[2] = h * c - f * o + d * s, e[3] = -(h * a) + f * n - u * s, e
+    return e[0] = f * l - h * c + d * a, e[1] = -(u * l) + h * o - d * s, e[2] = u * c - f * o + d * n, e[3] = -(u * a) + f * s - h * n, e
 }
 
-function Wu(e, t, r, i) {
-    let s = t[0],
-        n = t[1],
+function C0(e, t, r, i) {
+    let n = t[0],
+        s = t[1],
         o = t[2],
         a = t[3];
-    return e[0] = s + i * (r[0] - s), e[1] = n + i * (r[1] - n), e[2] = o + i * (r[2] - o), e[3] = a + i * (r[3] - a), e
+    return e[0] = n + i * (r[0] - n), e[1] = s + i * (r[1] - s), e[2] = o + i * (r[2] - o), e[3] = a + i * (r[3] - a), e
 }
 
-function VS(e, t) {
+function $N(e, t) {
     t = t === void 0 ? 1 : t;
-    let r, i, s, n, o, a;
-    do r = $e() * 2 - 1, i = $e() * 2 - 1, o = r * r + i * i; while (o >= 1);
-    do s = $e() * 2 - 1, n = $e() * 2 - 1, a = s * s + n * n; while (a >= 1);
+    let r, i, n, s, o, a;
+    do r = zi() * 2 - 1, i = zi() * 2 - 1, o = r * r + i * i; while (o >= 1);
+    do n = zi() * 2 - 1, s = zi() * 2 - 1, a = n * n + s * s; while (a >= 1);
     let c = Math.sqrt((1 - o) / a);
-    return e[0] = t * r, e[1] = t * i, e[2] = t * s * c, e[3] = t * n * c, e
+    return e[0] = t * r, e[1] = t * i, e[2] = t * n * c, e[3] = t * s * c, e
 }
 
-function ju(e, t, r) {
+function O0(e, t, r) {
     let i = t[0],
-        s = t[1],
-        n = t[2],
+        n = t[1],
+        s = t[2],
         o = t[3];
-    return e[0] = r[0] * i + r[4] * s + r[8] * n + r[12] * o, e[1] = r[1] * i + r[5] * s + r[9] * n + r[13] * o, e[2] = r[2] * i + r[6] * s + r[10] * n + r[14] * o, e[3] = r[3] * i + r[7] * s + r[11] * n + r[15] * o, e
+    return e[0] = r[0] * i + r[4] * n + r[8] * s + r[12] * o, e[1] = r[1] * i + r[5] * n + r[9] * s + r[13] * o, e[2] = r[2] * i + r[6] * n + r[10] * s + r[14] * o, e[3] = r[3] * i + r[7] * n + r[11] * s + r[15] * o, e
 }
 
-function Hu(e, t, r) {
+function N0(e, t, r) {
     let i = t[0],
-        s = t[1],
-        n = t[2],
+        n = t[1],
+        s = t[2],
         o = r[0],
         a = r[1],
         c = r[2],
         l = r[3],
-        h = l * i + a * n - c * s,
-        f = l * s + c * i - o * n,
-        u = l * n + o * s - a * i,
-        d = -o * i - a * s - c * n;
-    return e[0] = h * l + d * -o + f * -c - u * -a, e[1] = f * l + d * -a + u * -o - h * -c, e[2] = u * l + d * -c + h * -a - f * -o, e[3] = t[3], e
+        u = l * i + a * s - c * n,
+        f = l * n + c * i - o * s,
+        h = l * s + o * n - a * i,
+        d = -o * i - a * n - c * s;
+    return e[0] = u * l + d * -o + f * -c - h * -a, e[1] = f * l + d * -a + h * -o - u * -c, e[2] = h * l + d * -c + u * -a - f * -o, e[3] = t[3], e
 }
 
-function zS(e) {
+function XN(e) {
     return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e
 }
 
-function WS(e) {
+function YN(e) {
     return `vec4(${e[0]}, ${e[1]}, ${e[2]}, ${e[3]})`
 }
 
-function __(e, t) {
+function kS(e, t) {
     return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3]
 }
 
-function jS(e, t) {
+function qN(e, t) {
     let r = e[0],
         i = e[1],
-        s = e[2],
-        n = e[3],
+        n = e[2],
+        s = e[3],
         o = t[0],
         a = t[1],
         c = t[2],
         l = t[3];
-    return Math.abs(r - o) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(i - a) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(a)) && Math.abs(s - c) <= 1e-6 * Math.max(1, Math.abs(s), Math.abs(c)) && Math.abs(n - l) <= 1e-6 * Math.max(1, Math.abs(n), Math.abs(l))
+    return Math.abs(r - o) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(i - a) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(a)) && Math.abs(n - c) <= 1e-6 * Math.max(1, Math.abs(n), Math.abs(c)) && Math.abs(s - l) <= 1e-6 * Math.max(1, Math.abs(s), Math.abs(l))
 }
-var HS = u_,
-    XS = d_,
-    $S = p_,
-    YS = g_,
-    qS = m_,
-    ZS = wc,
-    KS = vc,
-    QS = function() {
-        let e = a_();
-        return function(t, r, i, s, n, o) {
+var ZN = NS,
+    KN = BS,
+    GN = FS,
+    JN = DS,
+    QN = LS,
+    tB = Rd,
+    eB = Md,
+    rB = function() {
+        let e = RS();
+        return function(t, r, i, n, s, o) {
             let a, c;
-            for (r || (r = 4), i || (i = 0), s ? c = Math.min(s * r + i, t.length) : c = t.length, a = i; a < c; a += r) e[0] = t[a], e[1] = t[a + 1], e[2] = t[a + 2], e[3] = t[a + 3], n(e, e, o), t[a] = e[0], t[a + 1] = e[1], t[a + 2] = e[2], t[a + 3] = e[3];
+            for (r || (r = 4), i || (i = 0), n ? c = Math.min(n * r + i, t.length) : c = t.length, a = i; a < c; a += r) e[0] = t[a], e[1] = t[a + 1], e[2] = t[a + 2], e[3] = t[a + 3], s(e, e, o), t[a] = e[0], t[a + 1] = e[1], t[a + 2] = e[2], t[a + 3] = e[3];
             return t
         }
     }();
-var Yu;
+var D0;
 (function(e) {
     e[e.COL0ROW0 = 0] = "COL0ROW0", e[e.COL0ROW1 = 1] = "COL0ROW1", e[e.COL0ROW2 = 2] = "COL0ROW2", e[e.COL0ROW3 = 3] = "COL0ROW3", e[e.COL1ROW0 = 4] = "COL1ROW0", e[e.COL1ROW1 = 5] = "COL1ROW1", e[e.COL1ROW2 = 6] = "COL1ROW2", e[e.COL1ROW3 = 7] = "COL1ROW3", e[e.COL2ROW0 = 8] = "COL2ROW0", e[e.COL2ROW1 = 9] = "COL2ROW1", e[e.COL2ROW2 = 10] = "COL2ROW2", e[e.COL2ROW3 = 11] = "COL2ROW3", e[e.COL3ROW0 = 12] = "COL3ROW0", e[e.COL3ROW1 = 13] = "COL3ROW1", e[e.COL3ROW2 = 14] = "COL3ROW2", e[e.COL3ROW3 = 15] = "COL3ROW3"
-})(Yu || (Yu = {}));
-var GS = 45 * Math.PI / 180,
-    JS = 1,
-    Xu = .1,
-    $u = 500,
-    tw = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
-    ot = class extends ps {
+})(D0 || (D0 = {}));
+var iB = 45 * Math.PI / 180,
+    nB = 1,
+    B0 = .1,
+    F0 = 500,
+    sB = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
+    Dt = class extends Na {
         static get IDENTITY() {
-            return rw()
+            return aB()
         }
         static get ZERO() {
-            return ew()
+            return oB()
         }
         get ELEMENTS() {
             return 16
         }
         get RANK() {
             return 4
         }
         get INDICES() {
-            return Yu
+            return D0
         }
         constructor(t) {
             super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(t) ? this.copy(t) : this.identity()
         }
         copy(t) {
             return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this[4] = t[4], this[5] = t[5], this[6] = t[6], this[7] = t[7], this[8] = t[8], this[9] = t[9], this[10] = t[10], this[11] = t[11], this[12] = t[12], this[13] = t[13], this[14] = t[14], this[15] = t[15], this.check()
         }
-        set(t, r, i, s, n, o, a, c, l, h, f, u, d, m, y, x) {
-            return this[0] = t, this[1] = r, this[2] = i, this[3] = s, this[4] = n, this[5] = o, this[6] = a, this[7] = c, this[8] = l, this[9] = h, this[10] = f, this[11] = u, this[12] = d, this[13] = m, this[14] = y, this[15] = x, this.check()
+        set(t, r, i, n, s, o, a, c, l, u, f, h, d, p, y, b) {
+            return this[0] = t, this[1] = r, this[2] = i, this[3] = n, this[4] = s, this[5] = o, this[6] = a, this[7] = c, this[8] = l, this[9] = u, this[10] = f, this[11] = h, this[12] = d, this[13] = p, this[14] = y, this[15] = b, this.check()
         }
-        setRowMajor(t, r, i, s, n, o, a, c, l, h, f, u, d, m, y, x) {
-            return this[0] = t, this[1] = n, this[2] = l, this[3] = d, this[4] = r, this[5] = o, this[6] = h, this[7] = m, this[8] = i, this[9] = a, this[10] = f, this[11] = y, this[12] = s, this[13] = c, this[14] = u, this[15] = x, this.check()
+        setRowMajor(t, r, i, n, s, o, a, c, l, u, f, h, d, p, y, b) {
+            return this[0] = t, this[1] = s, this[2] = l, this[3] = d, this[4] = r, this[5] = o, this[6] = u, this[7] = p, this[8] = i, this[9] = a, this[10] = f, this[11] = y, this[12] = n, this[13] = c, this[14] = h, this[15] = b, this.check()
         }
         toRowMajor(t) {
             return t[0] = this[0], t[1] = this[4], t[2] = this[8], t[3] = this[12], t[4] = this[1], t[5] = this[5], t[6] = this[9], t[7] = this[13], t[8] = this[2], t[9] = this[6], t[10] = this[10], t[11] = this[14], t[12] = this[3], t[13] = this[7], t[14] = this[11], t[15] = this[15], t
         }
         identity() {
-            return this.copy(tw)
+            return this.copy(sB)
         }
         fromObject(t) {
             return this.check()
         }
         fromQuaternion(t) {
-            return Nu(this, t), this.check()
+            return T0(this, t), this.check()
         }
         frustum(t) {
             let {
                 left: r,
                 right: i,
-                bottom: s,
-                top: n,
-                near: o = Xu,
-                far: a = $u
+                bottom: n,
+                top: s,
+                near: o = B0,
+                far: a = F0
             } = t;
-            return a === 1 / 0 ? iw(this, r, i, s, n, o) : Fu(this, r, i, s, n, o, a), this.check()
+            return a === 1 / 0 ? cB(this, r, i, n, s, o) : v0(this, r, i, n, s, o, a), this.check()
         }
         lookAt(t) {
             let {
                 eye: r,
                 center: i = [0, 0, 0],
-                up: s = [0, 1, 0]
+                up: n = [0, 1, 0]
             } = t;
-            return Lu(this, r, i, s), this.check()
+            return E0(this, r, i, n), this.check()
         }
         ortho(t) {
             let {
                 left: r,
                 right: i,
-                bottom: s,
-                top: n,
-                near: o = Xu,
-                far: a = $u
+                bottom: n,
+                top: s,
+                near: o = B0,
+                far: a = F0
             } = t;
-            return ku(this, r, i, s, n, o, a), this.check()
+            return A0(this, r, i, n, s, o, a), this.check()
         }
         orthographic(t) {
             let {
-                fovy: r = GS,
-                aspect: i = JS,
-                focalDistance: s = 1,
-                near: n = Xu,
-                far: o = $u
+                fovy: r = iB,
+                aspect: i = nB,
+                focalDistance: n = 1,
+                near: s = B0,
+                far: o = F0
             } = t;
-            y_(r);
+            US(r);
             let a = r / 2,
-                c = s * Math.tan(a),
+                c = n * Math.tan(a),
                 l = c * i;
             return this.ortho({
                 left: -l,
                 right: l,
                 bottom: -c,
                 top: c,
-                near: n,
+                near: s,
                 far: o
             })
         }
         perspective(t) {
             let {
                 fovy: r = 45 * Math.PI / 180,
                 aspect: i = 1,
-                near: s = .1,
-                far: n = 500
+                near: n = .1,
+                far: s = 500
             } = t;
-            return y_(r), Du(this, r, i, s, n), this.check()
+            return US(r), S0(this, r, i, n, s), this.check()
         }
         determinant() {
-            return vu(this)
+            return m0(this)
         }
         getScale(t = [-0, -0, -0]) {
             return t[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), t[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), t[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), t
         }
         getTranslation(t = [-0, -0, -0]) {
             return t[0] = this[12], t[1] = this[13], t[2] = this[14], t
         }
         getRotation(t, r) {
             t = t || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], r = r || [-0, -0, -0];
             let i = this.getScale(r),
-                s = 1 / i[0],
-                n = 1 / i[1],
+                n = 1 / i[0],
+                s = 1 / i[1],
                 o = 1 / i[2];
-            return t[0] = this[0] * s, t[1] = this[1] * n, t[2] = this[2] * o, t[3] = 0, t[4] = this[4] * s, t[5] = this[5] * n, t[6] = this[6] * o, t[7] = 0, t[8] = this[8] * s, t[9] = this[9] * n, t[10] = this[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
+            return t[0] = this[0] * n, t[1] = this[1] * s, t[2] = this[2] * o, t[3] = 0, t[4] = this[4] * n, t[5] = this[5] * s, t[6] = this[6] * o, t[7] = 0, t[8] = this[8] * n, t[9] = this[9] * s, t[10] = this[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t
         }
         getRotationMatrix3(t, r) {
             t = t || [-0, -0, -0, -0, -0, -0, -0, -0, -0], r = r || [-0, -0, -0];
             let i = this.getScale(r),
-                s = 1 / i[0],
-                n = 1 / i[1],
+                n = 1 / i[0],
+                s = 1 / i[1],
                 o = 1 / i[2];
-            return t[0] = this[0] * s, t[1] = this[1] * n, t[2] = this[2] * o, t[3] = this[4] * s, t[4] = this[5] * n, t[5] = this[6] * o, t[6] = this[8] * s, t[7] = this[9] * n, t[8] = this[10] * o, t
+            return t[0] = this[0] * n, t[1] = this[1] * s, t[2] = this[2] * o, t[3] = this[4] * n, t[4] = this[5] * s, t[5] = this[6] * o, t[6] = this[8] * n, t[7] = this[9] * s, t[8] = this[10] * o, t
         }
         transpose() {
-            return Su(this, this), this.check()
+            return d0(this, this), this.check()
         }
         invert() {
-            return wu(this, this), this.check()
+            return p0(this, this), this.check()
         }
         multiplyLeft(t) {
-            return Wn(this, t, this), this.check()
+            return Bl(this, t, this), this.check()
         }
         multiplyRight(t) {
-            return Wn(this, this, t), this.check()
+            return Bl(this, this, t), this.check()
         }
         rotateX(t) {
-            return Cu(this, this, t), this.check()
+            return b0(this, this, t), this.check()
         }
         rotateY(t) {
-            return Iu(this, this, t), this.check()
+            return x0(this, this, t), this.check()
         }
         rotateZ(t) {
-            return Ou(this, this, t), this.check()
+            return w0(this, this, t), this.check()
         }
         rotateXYZ(t) {
             return this.rotateX(t[0]).rotateY(t[1]).rotateZ(t[2])
         }
         rotateAxis(t, r) {
-            return Mu(this, this, t, r), this.check()
+            return y0(this, this, t, r), this.check()
         }
         scale(t) {
-            return Pu(this, this, Array.isArray(t) ? t : [t, t, t]), this.check()
+            return _0(this, this, Array.isArray(t) ? t : [t, t, t]), this.check()
         }
         translate(t) {
-            return Ru(this, this, t), this.check()
+            return g0(this, this, t), this.check()
         }
         transform(t, r) {
-            return t.length === 4 ? (r = ju(r || [-0, -0, -0, -0], t, this), Hr(r, 4), r) : this.transformAsPoint(t, r)
+            return t.length === 4 ? (r = O0(r || [-0, -0, -0, -0], t, this), Ss(r, 4), r) : this.transformAsPoint(t, r)
         }
         transformAsPoint(t, r) {
             let {
                 length: i
-            } = t, s;
+            } = t, n;
             switch (i) {
                 case 2:
-                    s = du(r || [-0, -0], t, this);
+                    n = r0(r || [-0, -0], t, this);
                     break;
                 case 3:
-                    s = Pi(r || [-0, -0, -0], t, this);
+                    n = vo(r || [-0, -0, -0], t, this);
                     break;
                 default:
                     throw new Error("Illegal vector")
             }
-            return Hr(s, t.length), s
+            return Ss(n, t.length), n
         }
         transformAsVector(t, r) {
             let i;
             switch (t.length) {
                 case 2:
-                    i = Lm(r || [-0, -0], t, this);
+                    i = nS(r || [-0, -0], t, this);
                     break;
                 case 3:
-                    i = mc(r || [-0, -0, -0], t, this);
+                    i = bd(r || [-0, -0, -0], t, this);
                     break;
                 default:
                     throw new Error("Illegal vector")
             }
-            return Hr(i, t.length), i
+            return Ss(i, t.length), i
         }
         transformPoint(t, r) {
             return this.transformAsPoint(t, r)
         }
         transformVector(t, r) {
             return this.transformAsPoint(t, r)
         }
@@ -10661,364 +10661,364 @@
         makeRotationX(t) {
             return this.identity().rotateX(t)
         }
         makeTranslation(t, r, i) {
             return this.identity().translate([t, r, i])
         }
     },
-    Rc, Pc;
+    Pd, Cd;
 
-function ew() {
-    return Rc || (Rc = new ot([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Rc)), Rc
+function oB() {
+    return Pd || (Pd = new Dt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Pd)), Pd
 }
 
-function rw() {
-    return Pc || (Pc = new ot, Object.freeze(Pc)), Pc
+function aB() {
+    return Cd || (Cd = new Dt, Object.freeze(Cd)), Cd
 }
 
-function y_(e) {
+function US(e) {
     if (e > Math.PI * 2) throw Error("expected radians")
 }
 
-function iw(e, t, r, i, s, n) {
-    let o = 2 * n / (r - t),
-        a = 2 * n / (s - i),
+function cB(e, t, r, i, n, s) {
+    let o = 2 * s / (r - t),
+        a = 2 * s / (n - i),
         c = (r + t) / (r - t),
-        l = (s + i) / (s - i),
-        h = -1,
+        l = (n + i) / (n - i),
+        u = -1,
         f = -1,
-        u = -2 * n;
-    return e[0] = o, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = a, e[6] = 0, e[7] = 0, e[8] = c, e[9] = l, e[10] = h, e[11] = f, e[12] = 0, e[13] = 0, e[14] = u, e[15] = 0, e
+        h = -2 * s;
+    return e[0] = o, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = a, e[6] = 0, e[7] = 0, e[8] = c, e[9] = l, e[10] = u, e[11] = f, e[12] = 0, e[13] = 0, e[14] = h, e[15] = 0, e
 }
 
-function x_() {
-    let e = new nt(4);
-    return nt != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e[3] = 1, e
+function VS() {
+    let e = new Ft(4);
+    return Ft != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e[3] = 1, e
 }
 
-function T_(e) {
+function zS(e) {
     return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e
 }
 
-function qu(e, t, r) {
+function L0(e, t, r) {
     r = r * .5;
     let i = Math.sin(r);
     return e[0] = i * t[0], e[1] = i * t[1], e[2] = i * t[2], e[3] = Math.cos(r), e
 }
 
-function Zu(e, t, r) {
+function k0(e, t, r) {
     let i = t[0],
-        s = t[1],
-        n = t[2],
+        n = t[1],
+        s = t[2],
         o = t[3],
         a = r[0],
         c = r[1],
         l = r[2],
-        h = r[3];
-    return e[0] = i * h + o * a + s * l - n * c, e[1] = s * h + o * c + n * a - i * l, e[2] = n * h + o * l + i * c - s * a, e[3] = o * h - i * a - s * c - n * l, e
+        u = r[3];
+    return e[0] = i * u + o * a + n * l - s * c, e[1] = n * u + o * c + s * a - i * l, e[2] = s * u + o * l + i * c - n * a, e[3] = o * u - i * a - n * c - s * l, e
 }
 
-function b_(e, t, r) {
+function WS(e, t, r) {
     r *= .5;
     let i = t[0],
-        s = t[1],
-        n = t[2],
+        n = t[1],
+        s = t[2],
         o = t[3],
         a = Math.sin(r),
         c = Math.cos(r);
-    return e[0] = i * c + o * a, e[1] = s * c + n * a, e[2] = n * c - s * a, e[3] = o * c - i * a, e
+    return e[0] = i * c + o * a, e[1] = n * c + s * a, e[2] = s * c - n * a, e[3] = o * c - i * a, e
 }
 
-function A_(e, t, r) {
+function jS(e, t, r) {
     r *= .5;
     let i = t[0],
-        s = t[1],
-        n = t[2],
+        n = t[1],
+        s = t[2],
         o = t[3],
         a = Math.sin(r),
         c = Math.cos(r);
-    return e[0] = i * c - n * a, e[1] = s * c + o * a, e[2] = n * c + i * a, e[3] = o * c - s * a, e
+    return e[0] = i * c - s * a, e[1] = n * c + o * a, e[2] = s * c + i * a, e[3] = o * c - n * a, e
 }
 
-function E_(e, t, r) {
+function HS(e, t, r) {
     r *= .5;
     let i = t[0],
-        s = t[1],
-        n = t[2],
+        n = t[1],
+        s = t[2],
         o = t[3],
         a = Math.sin(r),
         c = Math.cos(r);
-    return e[0] = i * c + s * a, e[1] = s * c - i * a, e[2] = n * c + o * a, e[3] = o * c - n * a, e
+    return e[0] = i * c + n * a, e[1] = n * c - i * a, e[2] = s * c + o * a, e[3] = o * c - s * a, e
 }
 
-function S_(e, t) {
+function $S(e, t) {
     let r = t[0],
         i = t[1],
-        s = t[2];
-    return e[0] = r, e[1] = i, e[2] = s, e[3] = Math.sqrt(Math.abs(1 - r * r - i * i - s * s)), e
+        n = t[2];
+    return e[0] = r, e[1] = i, e[2] = n, e[3] = Math.sqrt(Math.abs(1 - r * r - i * i - n * n)), e
 }
 
-function jn(e, t, r, i) {
-    let s = t[0],
-        n = t[1],
+function Fl(e, t, r, i) {
+    let n = t[0],
+        s = t[1],
         o = t[2],
         a = t[3],
         c = r[0],
         l = r[1],
-        h = r[2],
+        u = r[2],
         f = r[3],
-        u, d, m, y, x;
-    return u = s * c + n * l + o * h + a * f, u < 0 && (u = -u, c = -c, l = -l, h = -h, f = -f), 1 - u > 1e-6 ? (d = Math.acos(u), x = Math.sin(d), m = Math.sin((1 - i) * d) / x, y = Math.sin(i * d) / x) : (m = 1 - i, y = i), e[0] = m * s + y * c, e[1] = m * n + y * l, e[2] = m * o + y * h, e[3] = m * a + y * f, e
+        h, d, p, y, b;
+    return h = n * c + s * l + o * u + a * f, h < 0 && (h = -h, c = -c, l = -l, u = -u, f = -f), 1 - h > 1e-6 ? (d = Math.acos(h), b = Math.sin(d), p = Math.sin((1 - i) * d) / b, y = Math.sin(i * d) / b) : (p = 1 - i, y = i), e[0] = p * n + y * c, e[1] = p * s + y * l, e[2] = p * o + y * u, e[3] = p * a + y * f, e
 }
 
-function w_(e, t) {
+function XS(e, t) {
     let r = t[0],
         i = t[1],
-        s = t[2],
-        n = t[3],
-        o = r * r + i * i + s * s + n * n,
+        n = t[2],
+        s = t[3],
+        o = r * r + i * i + n * n + s * s,
         a = o ? 1 / o : 0;
-    return e[0] = -r * a, e[1] = -i * a, e[2] = -s * a, e[3] = n * a, e
+    return e[0] = -r * a, e[1] = -i * a, e[2] = -n * a, e[3] = s * a, e
 }
 
-function v_(e, t) {
+function YS(e, t) {
     return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e
 }
 
-function Ku(e, t) {
+function U0(e, t) {
     let r = t[0] + t[4] + t[8],
         i;
     if (r > 0) i = Math.sqrt(r + 1), e[3] = .5 * i, i = .5 / i, e[0] = (t[5] - t[7]) * i, e[1] = (t[6] - t[2]) * i, e[2] = (t[1] - t[3]) * i;
     else {
-        let s = 0;
-        t[4] > t[0] && (s = 1), t[8] > t[s * 3 + s] && (s = 2);
-        let n = (s + 1) % 3,
-            o = (s + 2) % 3;
-        i = Math.sqrt(t[s * 3 + s] - t[n * 3 + n] - t[o * 3 + o] + 1), e[s] = .5 * i, i = .5 / i, e[3] = (t[n * 3 + o] - t[o * 3 + n]) * i, e[n] = (t[n * 3 + s] + t[s * 3 + n]) * i, e[o] = (t[o * 3 + s] + t[s * 3 + o]) * i
+        let n = 0;
+        t[4] > t[0] && (n = 1), t[8] > t[n * 3 + n] && (n = 2);
+        let s = (n + 1) % 3,
+            o = (n + 2) % 3;
+        i = Math.sqrt(t[n * 3 + n] - t[s * 3 + s] - t[o * 3 + o] + 1), e[n] = .5 * i, i = .5 / i, e[3] = (t[s * 3 + o] - t[o * 3 + s]) * i, e[s] = (t[s * 3 + n] + t[n * 3 + s]) * i, e[o] = (t[o * 3 + n] + t[n * 3 + o]) * i
     }
     return e
 }
-var R_ = Bu;
-var P_ = Uu,
-    M_ = zu,
-    C_ = Wu,
-    I_ = wc;
-var O_ = vc;
-var N_ = Vu;
-var F_ = function() {
-        let e = yc(),
-            t = xc(1, 0, 0),
-            r = xc(0, 1, 0);
-        return function(i, s, n) {
-            let o = Un(s, n);
-            return o < -.999999 ? (Ri(e, t, s), xu(e) < 1e-6 && Ri(e, r, s), pu(e, e), qu(i, e, Math.PI), i) : o > .999999 ? (i[0] = 0, i[1] = 0, i[2] = 0, i[3] = 1, i) : (Ri(e, s, n), i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = 1 + o, N_(i, i))
+var qS = I0;
+var ZS = R0,
+    KS = P0,
+    GS = C0,
+    JS = Rd;
+var QS = Md;
+var t1 = M0;
+var e1 = function() {
+        let e = wd(),
+            t = Td(1, 0, 0),
+            r = Td(0, 1, 0);
+        return function(i, n, s) {
+            let o = Cl(n, s);
+            return o < -.999999 ? (To(e, t, n), c0(e) < 1e-6 && To(e, r, n), i0(e, e), L0(i, e, Math.PI), i) : o > .999999 ? (i[0] = 0, i[1] = 0, i[2] = 0, i[3] = 1, i) : (To(e, n, s), i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = 1 + o, t1(i, i))
         }
     }(),
-    xB = function() {
-        let e = x_(),
-            t = x_();
-        return function(r, i, s, n, o, a) {
-            return jn(e, i, o, a), jn(t, s, n, a), jn(r, e, t, 2 * a * (1 - a)), r
+    JX = function() {
+        let e = VS(),
+            t = VS();
+        return function(r, i, n, s, o, a) {
+            return Fl(e, i, o, a), Fl(t, n, s, a), Fl(r, e, t, 2 * a * (1 - a)), r
         }
     }(),
-    TB = function() {
-        let e = Ym();
-        return function(t, r, i, s) {
-            return e[0] = i[0], e[3] = i[1], e[6] = i[2], e[1] = s[0], e[4] = s[1], e[7] = s[2], e[2] = -r[0], e[5] = -r[1], e[8] = -r[2], N_(t, Ku(t, e))
+    QX = function() {
+        let e = pS();
+        return function(t, r, i, n) {
+            return e[0] = i[0], e[3] = i[1], e[6] = i[2], e[1] = n[0], e[4] = n[1], e[7] = n[2], e[2] = -r[0], e[5] = -r[1], e[8] = -r[2], t1(t, U0(t, e))
         }
     }();
-var nw = [0, 0, 0, 1],
-    gs = class extends jr {
-        constructor(t = 0, r = 0, i = 0, s = 1) {
-            super(-0, -0, -0, -0), Array.isArray(t) && arguments.length === 1 ? this.copy(t) : this.set(t, r, i, s)
+var uB = [0, 0, 0, 1],
+    Ba = class extends vs {
+        constructor(t = 0, r = 0, i = 0, n = 1) {
+            super(-0, -0, -0, -0), Array.isArray(t) && arguments.length === 1 ? this.copy(t) : this.set(t, r, i, n)
         }
         copy(t) {
             return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this.check()
         }
-        set(t, r, i, s) {
-            return this[0] = t, this[1] = r, this[2] = i, this[3] = s, this.check()
+        set(t, r, i, n) {
+            return this[0] = t, this[1] = r, this[2] = i, this[3] = n, this.check()
         }
         fromObject(t) {
             return this[0] = t.x, this[1] = t.y, this[2] = t.z, this[3] = t.w, this.check()
         }
         fromMatrix3(t) {
-            return Ku(this, t), this.check()
+            return U0(this, t), this.check()
         }
         fromAxisRotation(t, r) {
-            return qu(this, t, r), this.check()
+            return L0(this, t, r), this.check()
         }
         identity() {
-            return T_(this), this.check()
+            return zS(this), this.check()
         }
         setAxisAngle(t, r) {
             return this.fromAxisRotation(t, r)
         }
         get ELEMENTS() {
             return 4
         }
         get x() {
             return this[0]
         }
         set x(t) {
-            this[0] = st(t)
+            this[0] = Pt(t)
         }
         get y() {
             return this[1]
         }
         set y(t) {
-            this[1] = st(t)
+            this[1] = Pt(t)
         }
         get z() {
             return this[2]
         }
         set z(t) {
-            this[2] = st(t)
+            this[2] = Pt(t)
         }
         get w() {
             return this[3]
         }
         set w(t) {
-            this[3] = st(t)
+            this[3] = Pt(t)
         }
         len() {
-            return I_(this)
+            return JS(this)
         }
         lengthSquared() {
-            return O_(this)
+            return QS(this)
         }
         dot(t) {
-            return M_(this, t)
+            return KS(this, t)
         }
         rotationTo(t, r) {
-            return F_(this, t, r), this.check()
+            return e1(this, t, r), this.check()
         }
         add(t) {
-            return R_(this, this, t), this.check()
+            return qS(this, this, t), this.check()
         }
         calculateW() {
-            return S_(this, this), this.check()
+            return $S(this, this), this.check()
         }
         conjugate() {
-            return v_(this, this), this.check()
+            return YS(this, this), this.check()
         }
         invert() {
-            return w_(this, this), this.check()
+            return XS(this, this), this.check()
         }
         lerp(t, r, i) {
-            return i === void 0 ? this.lerp(this, t, r) : (C_(this, t, r, i), this.check())
+            return i === void 0 ? this.lerp(this, t, r) : (GS(this, t, r, i), this.check())
         }
         multiplyRight(t) {
-            return Zu(this, this, t), this.check()
+            return k0(this, this, t), this.check()
         }
         multiplyLeft(t) {
-            return Zu(this, t, this), this.check()
+            return k0(this, t, this), this.check()
         }
         normalize() {
             let t = this.len(),
                 r = t > 0 ? 1 / t : 0;
             return this[0] = this[0] * r, this[1] = this[1] * r, this[2] = this[2] * r, this[3] = this[3] * r, t === 0 && (this[3] = 1), this.check()
         }
         rotateX(t) {
-            return b_(this, this, t), this.check()
+            return WS(this, this, t), this.check()
         }
         rotateY(t) {
-            return A_(this, this, t), this.check()
+            return jS(this, this, t), this.check()
         }
         rotateZ(t) {
-            return E_(this, this, t), this.check()
+            return HS(this, this, t), this.check()
         }
         scale(t) {
-            return P_(this, this, t), this.check()
+            return ZS(this, this, t), this.check()
         }
         slerp(t, r, i) {
-            let s, n, o;
+            let n, s, o;
             switch (arguments.length) {
                 case 1:
                     ({
-                        start: s = nw,
-                        target: n,
+                        start: n = uB,
+                        target: s,
                         ratio: o
                     } = t);
                     break;
                 case 2:
-                    s = this, n = t, o = r;
+                    n = this, s = t, o = r;
                     break;
                 default:
-                    s = t, n = r, o = i
+                    n = t, s = r, o = i
             }
-            return jn(this, s, n, o), this.check()
+            return Fl(this, n, s, o), this.check()
         }
-        transformVector4(t, r = new Ac) {
-            return Hu(r, t, this), Hr(r, 4)
+        transformVector4(t, r = new Ad) {
+            return N0(r, t, this), Ss(r, 4)
         }
         lengthSq() {
             return this.lengthSquared()
         }
         setFromAxisAngle(t, r) {
             return this.setAxisAngle(t, r)
         }
         premultiply(t) {
             return this.multiplyLeft(t)
         }
         multiply(t) {
             return this.multiplyRight(t)
         }
     };
-var Hn = {};
-Ji(Hn, {
-    EPSILON1: () => ow,
-    EPSILON10: () => gw,
-    EPSILON11: () => mw,
-    EPSILON12: () => _w,
-    EPSILON13: () => yw,
-    EPSILON14: () => xw,
-    EPSILON15: () => Tw,
-    EPSILON16: () => bw,
-    EPSILON17: () => Aw,
-    EPSILON18: () => Ew,
-    EPSILON19: () => Sw,
-    EPSILON2: () => aw,
-    EPSILON20: () => ww,
-    EPSILON3: () => cw,
-    EPSILON4: () => lw,
-    EPSILON5: () => hw,
-    EPSILON6: () => fw,
-    EPSILON7: () => uw,
-    EPSILON8: () => dw,
-    EPSILON9: () => pw,
-    PI_OVER_FOUR: () => Rw,
-    PI_OVER_SIX: () => Pw,
-    PI_OVER_TWO: () => vw,
-    TWO_PI: () => Mw
+var Dl = {};
+Ze(Dl, {
+    EPSILON1: () => fB,
+    EPSILON10: () => xB,
+    EPSILON11: () => wB,
+    EPSILON12: () => TB,
+    EPSILON13: () => vB,
+    EPSILON14: () => SB,
+    EPSILON15: () => AB,
+    EPSILON16: () => EB,
+    EPSILON17: () => IB,
+    EPSILON18: () => RB,
+    EPSILON19: () => MB,
+    EPSILON2: () => hB,
+    EPSILON20: () => PB,
+    EPSILON3: () => dB,
+    EPSILON4: () => pB,
+    EPSILON5: () => mB,
+    EPSILON6: () => gB,
+    EPSILON7: () => _B,
+    EPSILON8: () => yB,
+    EPSILON9: () => bB,
+    PI_OVER_FOUR: () => OB,
+    PI_OVER_SIX: () => NB,
+    PI_OVER_TWO: () => CB,
+    TWO_PI: () => BB
 });
-var ow = .1,
-    aw = .01,
-    cw = .001,
-    lw = 1e-4,
-    hw = 1e-5,
-    fw = 1e-6,
-    uw = 1e-7,
-    dw = 1e-8,
-    pw = 1e-9,
-    gw = 1e-10,
-    mw = 1e-11,
-    _w = 1e-12,
-    yw = 1e-13,
-    xw = 1e-14,
-    Tw = 1e-15,
-    bw = 1e-16,
-    Aw = 1e-17,
-    Ew = 1e-18,
-    Sw = 1e-19,
-    ww = 1e-20,
-    vw = Math.PI / 2,
-    Rw = Math.PI / 4,
-    Pw = Math.PI / 6,
-    Mw = Math.PI * 2;
-var Qu = `#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
+var fB = .1,
+    hB = .01,
+    dB = .001,
+    pB = 1e-4,
+    mB = 1e-5,
+    gB = 1e-6,
+    _B = 1e-7,
+    yB = 1e-8,
+    bB = 1e-9,
+    xB = 1e-10,
+    wB = 1e-11,
+    TB = 1e-12,
+    vB = 1e-13,
+    SB = 1e-14,
+    AB = 1e-15,
+    EB = 1e-16,
+    IB = 1e-17,
+    RB = 1e-18,
+    MB = 1e-19,
+    PB = 1e-20,
+    CB = Math.PI / 2,
+    OB = Math.PI / 4,
+    NB = Math.PI / 6,
+    BB = Math.PI * 2;
+var V0 = `#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
 struct AmbientLight {
 vec3 color;
 };
 struct PointLight {
 vec3 color;
 vec3 position;
 vec3 attenuation;
@@ -11036,47 +11036,47 @@
 float getPointLightAttenuation(PointLight pointLight, float distance) {
 return pointLight.attenuation.x
 + pointLight.attenuation.y * distance
 + pointLight.attenuation.z * distance * distance;
 }
 #endif
 `;
-var Cw = {
+var FB = {
     lightSources: {}
 };
 
-function Gu(e = {}) {
+function z0(e = {}) {
     let {
         color: t = [0, 0, 0],
         intensity: r = 1
     } = e;
     return t.map(i => i * r / 255)
 }
 
-function Iw({
+function DB({
     ambientLight: e,
     pointLights: t = [],
     directionalLights: r = []
 }) {
     let i = {};
-    return e ? i["lighting_uAmbientLight.color"] = Gu(e) : i["lighting_uAmbientLight.color"] = [0, 0, 0], t.forEach((s, n) => {
-        i[`lighting_uPointLight[${n}].color`] = Gu(s), i[`lighting_uPointLight[${n}].position`] = s.position, i[`lighting_uPointLight[${n}].attenuation`] = s.attenuation || [1, 0, 0]
-    }), i.lighting_uPointLightCount = t.length, r.forEach((s, n) => {
-        i[`lighting_uDirectionalLight[${n}].color`] = Gu(s), i[`lighting_uDirectionalLight[${n}].direction`] = s.direction
+    return e ? i["lighting_uAmbientLight.color"] = z0(e) : i["lighting_uAmbientLight.color"] = [0, 0, 0], t.forEach((n, s) => {
+        i[`lighting_uPointLight[${s}].color`] = z0(n), i[`lighting_uPointLight[${s}].position`] = n.position, i[`lighting_uPointLight[${s}].attenuation`] = n.attenuation || [1, 0, 0]
+    }), i.lighting_uPointLightCount = t.length, r.forEach((n, s) => {
+        i[`lighting_uDirectionalLight[${s}].color`] = z0(n), i[`lighting_uDirectionalLight[${s}].direction`] = n.direction
     }), i.lighting_uDirectionalLightCount = r.length, i
 }
 
-function D_(e = Cw) {
+function r1(e = FB) {
     if ("lightSources" in e) {
         let {
             ambientLight: t,
             pointLights: r,
             directionalLights: i
         } = e.lightSources || {};
-        return t || r && r.length > 0 || i && i.length > 0 ? Object.assign({}, Iw({
+        return t || r && r.length > 0 || i && i.length > 0 ? Object.assign({}, DB({
             ambientLight: t,
             pointLights: r,
             directionalLights: i
         }), {
             lighting_uEnabled: !0
         }) : {
             lighting_uEnabled: !1
@@ -11095,30 +11095,30 @@
                 t.directionalLights?.push(r);
                 break;
             case "point":
                 t.pointLights?.push(r);
                 break;
             default:
         }
-        return D_({
+        return r1({
             lightSources: t
         })
     }
     return {}
 }
-var k_ = {
+var i1 = {
     name: "lights",
-    vs: Qu,
-    fs: Qu,
-    getUniforms: D_,
+    vs: V0,
+    fs: V0,
+    getUniforms: r1,
     defines: {
         MAX_LIGHTS: 3
     }
 };
-var L_ = `uniform float lighting_uAmbient;
+var n1 = `uniform float lighting_uAmbient;
 uniform float lighting_uDiffuse;
 uniform float lighting_uShininess;
 uniform vec3  lighting_uSpecularColor;
 vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
 vec3 halfway_direction = normalize(light_direction + view_direction);
 float lambertian = dot(light_direction, normal_worldspace);
 float specular = 0.0;
@@ -11174,52 +11174,52 @@
 DirectionalLight directionalLight = lighting_uDirectionalLight[i];
 lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
 }
 }
 return lightColor;
 }
 `;
-var Ow = {};
+var LB = {};
 
-function Nw(e) {
+function kB(e) {
     let {
         ambient: t = .35,
         diffuse: r = .6,
         shininess: i = 32,
-        specularColor: s = [30, 30, 30]
+        specularColor: n = [30, 30, 30]
     } = e;
     return {
         lighting_uAmbient: t,
         lighting_uDiffuse: r,
         lighting_uShininess: i,
-        lighting_uSpecularColor: s.map(n => n / 255)
+        lighting_uSpecularColor: n.map(s => s / 255)
     }
 }
 
-function Fw(e = Ow) {
+function UB(e = LB) {
     if (!("material" in e)) return {};
     let {
         material: t
     } = e;
-    return t ? Nw(t) : {
+    return t ? kB(t) : {
         lighting_uEnabled: !1
     }
 }
-var ms = {
+var Fa = {
     name: "gouraud-lighting",
-    dependencies: [k_],
-    vs: L_,
+    dependencies: [i1],
+    vs: n1,
     defines: {
         LIGHTING_VERTEX: 1
     },
-    getUniforms: Fw
+    getUniforms: UB
 };
-var B_ = "#define SMOOTH_EDGE_RADIUS 0.5",
-    Dw = `
-${B_}
+var s1 = "#define SMOOTH_EDGE_RADIUS 0.5",
+    VB = `
+${s1}
 
 struct VertexGeometry {
   vec4 position;
   vec3 worldPosition;
   vec3 worldPositionAlt;
   vec3 normal;
   vec2 uv;
@@ -11229,71 +11229,71 @@
   vec3(0.0),
   vec3(0.0),
   vec3(0.0),
   vec2(0.0),
   vec3(0.0)
 );
 `,
-    kw = `
-${B_}
+    zB = `
+${s1}
 
 struct FragmentGeometry {
   vec2 uv;
 } geometry;
 
 float smoothedge(float edge, float x) {
   return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
 }
 `,
-    U_ = {
+    o1 = {
         name: "geometry",
-        vs: Dw,
-        fs: kw
+        vs: VB,
+        fs: zB
     };
-var K = {
+var gt = {
     DEFAULT: -1,
     LNGLAT: 1,
     METER_OFFSETS: 2,
     LNGLAT_OFFSETS: 3,
     CARTESIAN: 0
 };
-Object.defineProperty(K, "IDENTITY", {
-    get: () => (j.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
+Object.defineProperty(gt, "IDENTITY", {
+    get: () => (Z.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
 });
-var Nt = {
+var Pe = {
         WEB_MERCATOR: 1,
         GLOBE: 2,
         WEB_MERCATOR_AUTO_OFFSET: 4,
         IDENTITY: 0
     },
-    Kt = {
+    tr = {
         common: 0,
         meters: 1,
         pixels: 2
     },
-    Xn = {
+    Ll = {
         click: {
             handler: "onClick"
         },
         panstart: {
             handler: "onDragStart"
         },
         panmove: {
             handler: "onDrag"
         },
         panend: {
             handler: "onDragEnd"
         }
     };
-var Lw = Object.keys(K).map(e => `const int COORDINATE_SYSTEM_${e} = ${K[e]};`).join(""),
-    Bw = Object.keys(Nt).map(e => `const int PROJECTION_MODE_${e} = ${Nt[e]};`).join(""),
-    Uw = Object.keys(Kt).map(e => `const int UNIT_${e.toUpperCase()} = ${Kt[e]};`).join(""),
-    V_ = `${Lw}
-${Bw}
-${Uw}
+var WB = Object.keys(gt).map(e => `const int COORDINATE_SYSTEM_${e} = ${gt[e]};`).join(""),
+    jB = Object.keys(Pe).map(e => `const int PROJECTION_MODE_${e} = ${Pe[e]};`).join(""),
+    HB = Object.keys(tr).map(e => `const int UNIT_${e.toUpperCase()} = ${tr[e]};`).join(""),
+    a1 = `${WB}
+${jB}
+${HB}
 uniform int project_uCoordinateSystem;
 uniform int project_uProjectionMode;
 uniform float project_uScale;
 uniform bool project_uWrapLongitude;
 uniform vec3 project_uCommonUnitsPerMeter;
 uniform vec3 project_uCommonUnitsPerWorldUnit;
 uniform vec3 project_uCommonUnitsPerWorldUnit2;
@@ -11474,175 +11474,175 @@
 return pixels / project_uScale;
 }
 vec2 project_pixel_size(vec2 pixels) {
 return pixels / project_uScale;
 }
 `;
 
-function Vw(e, t) {
+function $B(e, t) {
     if (e === t) return !0;
     if (Array.isArray(e)) {
         let r = e.length;
         if (!t || t.length !== r) return !1;
         for (let i = 0; i < r; i++)
             if (e[i] !== t[i]) return !1;
         return !0
     }
     return !1
 }
 
-function Ye(e) {
+function Wi(e) {
     let t = {},
         r;
     return i => {
-        for (let s in i)
-            if (!Vw(i[s], t[s])) {
+        for (let n in i)
+            if (!$B(i[n], t[n])) {
                 r = e(i), t = i;
                 break
             } return r
     }
 }
-var z_ = [0, 0, 0, 0],
-    zw = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
-    W_ = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
-    Ww = [0, 0, 0],
-    j_ = [0, 0, 0],
-    jw = Ye(Xw);
+var c1 = [0, 0, 0, 0],
+    XB = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
+    l1 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
+    YB = [0, 0, 0],
+    u1 = [0, 0, 0],
+    qB = Wi(KB);
 
-function td(e, t, r = j_) {
+function j0(e, t, r = u1) {
     r.length < 3 && (r = [r[0], r[1], 0]);
     let i = r,
-        s, n = !0;
-    switch (t === K.LNGLAT_OFFSETS || t === K.METER_OFFSETS ? s = r : s = e.isGeospatial ? [Math.fround(e.longitude), Math.fround(e.latitude), 0] : null, e.projectionMode) {
-        case Nt.WEB_MERCATOR:
-            (t === K.LNGLAT || t === K.CARTESIAN) && (s = [0, 0, 0], n = !1);
+        n, s = !0;
+    switch (t === gt.LNGLAT_OFFSETS || t === gt.METER_OFFSETS ? n = r : n = e.isGeospatial ? [Math.fround(e.longitude), Math.fround(e.latitude), 0] : null, e.projectionMode) {
+        case Pe.WEB_MERCATOR:
+            (t === gt.LNGLAT || t === gt.CARTESIAN) && (n = [0, 0, 0], s = !1);
             break;
-        case Nt.WEB_MERCATOR_AUTO_OFFSET:
-            t === K.LNGLAT ? i = s : t === K.CARTESIAN && (i = [Math.fround(e.center[0]), Math.fround(e.center[1]), 0], s = e.unprojectPosition(i), i[0] -= r[0], i[1] -= r[1], i[2] -= r[2]);
+        case Pe.WEB_MERCATOR_AUTO_OFFSET:
+            t === gt.LNGLAT ? i = n : t === gt.CARTESIAN && (i = [Math.fround(e.center[0]), Math.fround(e.center[1]), 0], n = e.unprojectPosition(i), i[0] -= r[0], i[1] -= r[1], i[2] -= r[2]);
             break;
-        case Nt.IDENTITY:
+        case Pe.IDENTITY:
             i = e.position.map(Math.fround), i[2] = i[2] || 0;
             break;
-        case Nt.GLOBE:
-            n = !1, s = null;
+        case Pe.GLOBE:
+            s = !1, n = null;
             break;
         default:
-            n = !1
+            s = !1
     }
     return {
-        geospatialOrigin: s,
+        geospatialOrigin: n,
         shaderCoordinateOrigin: i,
-        offsetMode: n
+        offsetMode: s
     }
 }
 
-function Hw(e, t, r) {
+function ZB(e, t, r) {
     let {
         viewMatrixUncentered: i,
-        projectionMatrix: s
+        projectionMatrix: n
     } = e, {
-        viewMatrix: n,
+        viewMatrix: s,
         viewProjectionMatrix: o
-    } = e, a = z_, c = z_, l = e.cameraPosition, {
-        geospatialOrigin: h,
+    } = e, a = c1, c = c1, l = e.cameraPosition, {
+        geospatialOrigin: u,
         shaderCoordinateOrigin: f,
-        offsetMode: u
-    } = td(e, t, r);
-    return u && (c = e.projectPosition(h || f), l = [l[0] - c[0], l[1] - c[1], l[2] - c[2]], c[3] = 1, a = Zt.transformMat4([], c, o), n = i || n, o = _t.multiply([], s, n), o = _t.multiply([], o, zw)), {
-        viewMatrix: n,
+        offsetMode: h
+    } = j0(e, t, r);
+    return h && (c = e.projectPosition(u || f), l = [l[0] - c[0], l[1] - c[1], l[2] - c[2]], c[3] = 1, a = Qe.transformMat4([], c, o), s = i || s, o = ie.multiply([], n, s), o = ie.multiply([], o, XB)), {
+        viewMatrix: s,
         viewProjectionMatrix: o,
         projectionCenter: a,
         originCommon: c,
         cameraPosCommon: l,
         shaderCoordinateOrigin: f,
-        geospatialOrigin: h
+        geospatialOrigin: u
     }
 }
 
-function H_({
+function f1({
     viewport: e,
     devicePixelRatio: t = 1,
     modelMatrix: r = null,
-    coordinateSystem: i = K.DEFAULT,
-    coordinateOrigin: s = j_,
-    autoWrapLongitude: n = !1
+    coordinateSystem: i = gt.DEFAULT,
+    coordinateOrigin: n = u1,
+    autoWrapLongitude: s = !1
 }) {
-    i === K.DEFAULT && (i = e.isGeospatial ? K.LNGLAT : K.CARTESIAN);
-    let o = jw({
+    i === gt.DEFAULT && (i = e.isGeospatial ? gt.LNGLAT : gt.CARTESIAN);
+    let o = qB({
         viewport: e,
         devicePixelRatio: t,
         coordinateSystem: i,
-        coordinateOrigin: s
+        coordinateOrigin: n
     });
-    return o.project_uWrapLongitude = n, o.project_uModelMatrix = r || W_, o
+    return o.project_uWrapLongitude = s, o.project_uModelMatrix = r || l1, o
 }
 
-function Xw({
+function KB({
     viewport: e,
     devicePixelRatio: t,
     coordinateSystem: r,
     coordinateOrigin: i
 }) {
     let {
-        projectionCenter: s,
-        viewProjectionMatrix: n,
+        projectionCenter: n,
+        viewProjectionMatrix: s,
         originCommon: o,
         cameraPosCommon: a,
         shaderCoordinateOrigin: c,
         geospatialOrigin: l
-    } = Hw(e, r, i), h = e.getDistanceScales(), f = [e.width * t, e.height * t], u = Zt.transformMat4([], [0, 0, -e.focalDistance, 1], e.projectionMatrix)[3] || 1, d = {
+    } = ZB(e, r, i), u = e.getDistanceScales(), f = [e.width * t, e.height * t], h = Qe.transformMat4([], [0, 0, -e.focalDistance, 1], e.projectionMatrix)[3] || 1, d = {
         project_uCoordinateSystem: r,
         project_uProjectionMode: e.projectionMode,
         project_uCoordinateOrigin: c,
         project_uCommonOrigin: o.slice(0, 3),
-        project_uCenter: s,
+        project_uCenter: n,
         project_uPseudoMeters: !!e._pseudoMeters,
         project_uViewportSize: f,
         project_uDevicePixelRatio: t,
-        project_uFocalDistance: u,
-        project_uCommonUnitsPerMeter: h.unitsPerMeter,
-        project_uCommonUnitsPerWorldUnit: h.unitsPerMeter,
-        project_uCommonUnitsPerWorldUnit2: Ww,
+        project_uFocalDistance: h,
+        project_uCommonUnitsPerMeter: u.unitsPerMeter,
+        project_uCommonUnitsPerWorldUnit: u.unitsPerMeter,
+        project_uCommonUnitsPerWorldUnit2: YB,
         project_uScale: e.scale,
         project_uWrapLongitude: !1,
-        project_uViewProjectionMatrix: n,
-        project_uModelMatrix: W_,
+        project_uViewProjectionMatrix: s,
+        project_uModelMatrix: l1,
         project_uCameraPosition: a
     };
     if (l) {
-        let m = e.getDistanceScales(l);
+        let p = e.getDistanceScales(l);
         switch (r) {
-            case K.METER_OFFSETS:
-                d.project_uCommonUnitsPerWorldUnit = m.unitsPerMeter, d.project_uCommonUnitsPerWorldUnit2 = m.unitsPerMeter2;
+            case gt.METER_OFFSETS:
+                d.project_uCommonUnitsPerWorldUnit = p.unitsPerMeter, d.project_uCommonUnitsPerWorldUnit2 = p.unitsPerMeter2;
                 break;
-            case K.LNGLAT:
-            case K.LNGLAT_OFFSETS:
-                e._pseudoMeters || (d.project_uCommonUnitsPerMeter = m.unitsPerMeter), d.project_uCommonUnitsPerWorldUnit = m.unitsPerDegree, d.project_uCommonUnitsPerWorldUnit2 = m.unitsPerDegree2;
+            case gt.LNGLAT:
+            case gt.LNGLAT_OFFSETS:
+                e._pseudoMeters || (d.project_uCommonUnitsPerMeter = p.unitsPerMeter), d.project_uCommonUnitsPerWorldUnit = p.unitsPerDegree, d.project_uCommonUnitsPerWorldUnit2 = p.unitsPerDegree2;
                 break;
-            case K.CARTESIAN:
-                d.project_uCommonUnitsPerWorldUnit = [1, 1, m.unitsPerMeter[2]], d.project_uCommonUnitsPerWorldUnit2 = [0, 0, m.unitsPerMeter2[2]];
+            case gt.CARTESIAN:
+                d.project_uCommonUnitsPerWorldUnit = [1, 1, p.unitsPerMeter[2]], d.project_uCommonUnitsPerWorldUnit2 = [0, 0, p.unitsPerMeter2[2]];
                 break;
             default:
                 break
         }
     }
     return d
 }
-var $w = {};
+var GB = {};
 
-function Yw(e = $w) {
-    return "viewport" in e ? H_(e) : {}
+function JB(e = GB) {
+    return "viewport" in e ? f1(e) : {}
 }
-var Xr = {
+var As = {
     name: "project",
-    dependencies: [hu, U_],
-    vs: V_,
-    getUniforms: Yw
+    dependencies: [Qy, o1],
+    vs: a1,
+    getUniforms: JB
 };
-var qw = `
+var QB = `
 vec4 project_position_to_clipspace(
   vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
 ) {
   vec3 projectedPosition = project_position(position, position64Low);
   mat3 rotation;
   if (project_needs_rotation(projectedPosition, rotation)) {
     // offset is specified as ENU
@@ -11656,293 +11656,293 @@
 vec4 project_position_to_clipspace(
   vec3 position, vec3 position64Low, vec3 offset
 ) {
   vec4 commonPosition;
   return project_position_to_clipspace(position, position64Low, offset, commonPosition);
 }
 `,
-    Ut = {
+    ke = {
         name: "project32",
-        dependencies: [Xr],
-        vs: qw
+        dependencies: [As],
+        vs: QB
     };
 
-function ed() {
+function H0() {
     return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
 }
 
-function $r(e, t) {
-    let r = Zt.transformMat4([], t, e);
-    return Zt.scale(r, r, 1 / r[3]), r
+function Es(e, t) {
+    let r = Qe.transformMat4([], t, e);
+    return Qe.scale(r, r, 1 / r[3]), r
 }
 
-function rd(e, t) {
+function $0(e, t) {
     let r = e % t;
     return r < 0 ? t + r : r
 }
 
-function $n(e, t, r) {
+function kl(e, t, r) {
     return e < t ? t : e > r ? r : e
 }
 
-function Zw(e) {
+function tF(e) {
     return Math.log(e) * Math.LOG2E
 }
-var _s = Math.log2 || Zw;
+var Da = Math.log2 || tF;
 
-function Se(e, t) {
+function ti(e, t) {
     if (!e) throw new Error(t || "@math.gl/web-mercator: assertion failed.")
 }
-var we = Math.PI,
-    X_ = we / 4,
-    ge = we / 180,
-    id = 180 / we,
-    ys = 512,
-    Mc = 4003e4,
-    xs = 85.051129,
-    $_ = 1.5;
+var ei = Math.PI,
+    h1 = ei / 4,
+    Dr = ei / 180,
+    X0 = 180 / ei,
+    La = 512,
+    Od = 4003e4,
+    ka = 85.051129,
+    d1 = 1.5;
 
-function sd(e) {
-    return _s(e)
+function Y0(e) {
+    return Da(e)
 }
 
-function Vt(e) {
+function Ue(e) {
     let [t, r] = e;
-    Se(Number.isFinite(t)), Se(Number.isFinite(r) && r >= -90 && r <= 90, "invalid latitude");
-    let i = t * ge,
-        s = r * ge,
-        n = ys * (i + we) / (2 * we),
-        o = ys * (we + Math.log(Math.tan(X_ + s * .5))) / (2 * we);
-    return [n, o]
+    ti(Number.isFinite(t)), ti(Number.isFinite(r) && r >= -90 && r <= 90, "invalid latitude");
+    let i = t * Dr,
+        n = r * Dr,
+        s = La * (i + ei) / (2 * ei),
+        o = La * (ei + Math.log(Math.tan(h1 + n * .5))) / (2 * ei);
+    return [s, o]
 }
 
-function ie(e) {
-    let [t, r] = e, i = t / ys * (2 * we) - we, s = 2 * (Math.atan(Math.exp(r / ys * (2 * we) - we)) - X_);
-    return [i * id, s * id]
+function mr(e) {
+    let [t, r] = e, i = t / La * (2 * ei) - ei, n = 2 * (Math.atan(Math.exp(r / La * (2 * ei) - ei)) - h1);
+    return [i * X0, n * X0]
 }
 
-function nd(e) {
+function q0(e) {
     let {
         latitude: t
     } = e;
-    Se(Number.isFinite(t));
-    let r = Math.cos(t * ge);
-    return sd(Mc * r) - 9
+    ti(Number.isFinite(t));
+    let r = Math.cos(t * Dr);
+    return Y0(Od * r) - 9
 }
 
-function Yn(e) {
-    let t = Math.cos(e * ge);
-    return ys / Mc / t
+function Ul(e) {
+    let t = Math.cos(e * Dr);
+    return La / Od / t
 }
 
-function Ts(e) {
+function Ua(e) {
     let {
         latitude: t,
         longitude: r,
         highPrecision: i = !1
     } = e;
-    Se(Number.isFinite(t) && Number.isFinite(r));
-    let s = ys,
-        n = Math.cos(t * ge),
-        o = s / 360,
-        a = o / n,
-        c = s / Mc / n,
+    ti(Number.isFinite(t) && Number.isFinite(r));
+    let n = La,
+        s = Math.cos(t * Dr),
+        o = n / 360,
+        a = o / s,
+        c = n / Od / s,
         l = {
             unitsPerMeter: [c, c, c],
             metersPerUnit: [1 / c, 1 / c, 1 / c],
             unitsPerDegree: [o, a, c],
             degreesPerUnit: [1 / o, 1 / a, 1 / c]
         };
     if (i) {
-        let h = ge * Math.tan(t * ge) / n,
-            f = o * h / 2,
-            u = s / Mc * h,
-            d = u / a * c;
-        l.unitsPerDegree2 = [0, f, u], l.unitsPerMeter2 = [d, 0, d]
+        let u = Dr * Math.tan(t * Dr) / s,
+            f = o * u / 2,
+            h = n / Od * u,
+            d = h / a * c;
+        l.unitsPerDegree2 = [0, f, h], l.unitsPerMeter2 = [d, 0, d]
     }
     return l
 }
 
-function qn(e, t) {
-    let [r, i, s] = e, [n, o, a] = t, {
+function Vl(e, t) {
+    let [r, i, n] = e, [s, o, a] = t, {
         unitsPerMeter: c,
         unitsPerMeter2: l
-    } = Ts({
+    } = Ua({
         longitude: r,
         latitude: i,
         highPrecision: !0
-    }), h = Vt(e);
-    h[0] += n * (c[0] + l[0] * o), h[1] += o * (c[1] + l[1] * o);
-    let f = ie(h),
-        u = (s || 0) + (a || 0);
-    return Number.isFinite(s) || Number.isFinite(a) ? [f[0], f[1], u] : f
+    }), u = Ue(e);
+    u[0] += s * (c[0] + l[0] * o), u[1] += o * (c[1] + l[1] * o);
+    let f = mr(u),
+        h = (n || 0) + (a || 0);
+    return Number.isFinite(n) || Number.isFinite(a) ? [f[0], f[1], h] : f
 }
 
-function Cc(e) {
+function Nd(e) {
     let {
         height: t,
         pitch: r,
         bearing: i,
-        altitude: s,
-        scale: n,
+        altitude: n,
+        scale: s,
         center: o
-    } = e, a = ed();
-    _t.translate(a, a, [0, 0, -s]), _t.rotateX(a, a, -r * ge), _t.rotateZ(a, a, i * ge);
-    let c = n / t;
-    return _t.scale(a, a, [c, c, c]), o && _t.translate(a, a, qt.negate([], o)), a
+    } = e, a = H0();
+    ie.translate(a, a, [0, 0, -n]), ie.rotateX(a, a, -r * Dr), ie.rotateZ(a, a, i * Dr);
+    let c = s / t;
+    return ie.scale(a, a, [c, c, c]), o && ie.translate(a, a, Je.negate([], o)), a
 }
 
-function od(e) {
+function Z0(e) {
     let {
         width: t,
         height: r,
         altitude: i,
-        pitch: s = 0,
-        offset: n,
+        pitch: n = 0,
+        offset: s,
         center: o,
         scale: a,
         nearZMultiplier: c = 1,
         farZMultiplier: l = 1
     } = e, {
-        fovy: h = Mi($_)
+        fovy: u = So(d1)
     } = e;
-    i !== void 0 && (h = Mi(i));
-    let f = h * ge,
-        u = s * ge,
-        d = Zn(h),
-        m = d;
-    o && (m += o[2] * a / Math.cos(u) / r);
-    let y = f * (.5 + (n ? n[1] : 0) / r),
-        x = Math.sin(y) * m / Math.sin($n(Math.PI / 2 - u - y, .01, Math.PI - .01)),
-        A = Math.sin(u) * x + m,
-        v = m * 10,
-        E = Math.min(A * l, v);
+    i !== void 0 && (u = So(i));
+    let f = u * Dr,
+        h = n * Dr,
+        d = zl(u),
+        p = d;
+    o && (p += o[2] * a / Math.cos(h) / r);
+    let y = f * (.5 + (s ? s[1] : 0) / r),
+        b = Math.sin(y) * p / Math.sin(kl(Math.PI / 2 - h - y, .01, Math.PI - .01)),
+        T = Math.sin(h) * b + p,
+        I = p * 10,
+        S = Math.min(T * l, I);
     return {
         fov: f,
         aspect: t / r,
         focalDistance: d,
         near: c,
-        far: E
+        far: S
     }
 }
 
-function Mi(e) {
-    return 2 * Math.atan(.5 / e) * id
+function So(e) {
+    return 2 * Math.atan(.5 / e) * X0
 }
 
-function Zn(e) {
-    return .5 / Math.tan(.5 * e * ge)
+function zl(e) {
+    return .5 / Math.tan(.5 * e * Dr)
 }
 
-function bs(e, t) {
-    let [r, i, s = 0] = e;
-    return Se(Number.isFinite(r) && Number.isFinite(i) && Number.isFinite(s)), $r(t, [r, i, s, 1])
+function Va(e, t) {
+    let [r, i, n = 0] = e;
+    return ti(Number.isFinite(r) && Number.isFinite(i) && Number.isFinite(n)), Es(t, [r, i, n, 1])
 }
 
-function qe(e, t, r = 0) {
-    let [i, s, n] = e;
-    if (Se(Number.isFinite(i) && Number.isFinite(s), "invalid pixel coordinate"), Number.isFinite(n)) return $r(t, [i, s, n, 1]);
-    let o = $r(t, [i, s, 0, 1]),
-        a = $r(t, [i, s, 1, 1]),
+function ji(e, t, r = 0) {
+    let [i, n, s] = e;
+    if (ti(Number.isFinite(i) && Number.isFinite(n), "invalid pixel coordinate"), Number.isFinite(s)) return Es(t, [i, n, s, 1]);
+    let o = Es(t, [i, n, 0, 1]),
+        a = Es(t, [i, n, 1, 1]),
         c = o[2],
         l = a[2],
-        h = c === l ? 0 : ((r || 0) - c) / (l - c);
-    return Yt.lerp([], o, a, h)
+        u = c === l ? 0 : ((r || 0) - c) / (l - c);
+    return Ge.lerp([], o, a, u)
 }
 
-function Ic(e) {
+function Bd(e) {
     let {
         width: t,
         height: r,
         bounds: i,
-        minExtent: s = 0,
-        maxZoom: n = 24,
+        minExtent: n = 0,
+        maxZoom: s = 24,
         offset: o = [0, 0]
     } = e, [
         [a, c],
-        [l, h]
-    ] = i, f = Kw(e.padding), u = Vt([a, $n(h, -xs, xs)]), d = Vt([l, $n(c, -xs, xs)]), m = [Math.max(Math.abs(d[0] - u[0]), s), Math.max(Math.abs(d[1] - u[1]), s)], y = [t - f.left - f.right - Math.abs(o[0]) * 2, r - f.top - f.bottom - Math.abs(o[1]) * 2];
-    Se(y[0] > 0 && y[1] > 0);
-    let x = y[0] / m[0],
-        A = y[1] / m[1],
-        v = (f.right - f.left) / 2 / x,
-        E = (f.top - f.bottom) / 2 / A,
-        R = [(d[0] + u[0]) / 2 + v, (d[1] + u[1]) / 2 + E],
-        M = ie(R),
-        C = Math.min(n, _s(Math.abs(Math.min(x, A))));
-    return Se(Number.isFinite(C)), {
-        longitude: M[0],
-        latitude: M[1],
+        [l, u]
+    ] = i, f = eF(e.padding), h = Ue([a, kl(u, -ka, ka)]), d = Ue([l, kl(c, -ka, ka)]), p = [Math.max(Math.abs(d[0] - h[0]), n), Math.max(Math.abs(d[1] - h[1]), n)], y = [t - f.left - f.right - Math.abs(o[0]) * 2, r - f.top - f.bottom - Math.abs(o[1]) * 2];
+    ti(y[0] > 0 && y[1] > 0);
+    let b = y[0] / p[0],
+        T = y[1] / p[1],
+        I = (f.right - f.left) / 2 / b,
+        S = (f.top - f.bottom) / 2 / T,
+        R = [(d[0] + h[0]) / 2 + I, (d[1] + h[1]) / 2 + S],
+        P = mr(R),
+        C = Math.min(s, Da(Math.abs(Math.min(b, T))));
+    return ti(Number.isFinite(C)), {
+        longitude: P[0],
+        latitude: P[1],
         zoom: C
     }
 }
 
-function Kw(e = 0) {
+function eF(e = 0) {
     return typeof e == "number" ? {
         top: e,
         bottom: e,
         left: e,
         right: e
-    } : (Se(Number.isFinite(e.top) && Number.isFinite(e.bottom) && Number.isFinite(e.left) && Number.isFinite(e.right)), e)
+    } : (ti(Number.isFinite(e.top) && Number.isFinite(e.bottom) && Number.isFinite(e.left) && Number.isFinite(e.right)), e)
 }
-var Y_ = Math.PI / 180;
+var p1 = Math.PI / 180;
 
-function Oc(e, t = 0) {
+function Fd(e, t = 0) {
     let {
         width: r,
         height: i,
-        unproject: s
-    } = e, n = {
+        unproject: n
+    } = e, s = {
         targetZ: t
-    }, o = s([0, i], n), a = s([r, i], n), c, l, h = e.fovy ? .5 * e.fovy * Y_ : Math.atan(.5 / e.altitude), f = (90 - e.pitch) * Y_;
-    return h > f - .01 ? (c = q_(e, 0, t), l = q_(e, r, t)) : (c = s([0, 0], n), l = s([r, 0], n)), [o, a, l, c]
+    }, o = n([0, i], s), a = n([r, i], s), c, l, u = e.fovy ? .5 * e.fovy * p1 : Math.atan(.5 / e.altitude), f = (90 - e.pitch) * p1;
+    return u > f - .01 ? (c = m1(e, 0, t), l = m1(e, r, t)) : (c = n([0, 0], s), l = n([r, 0], s)), [o, a, l, c]
 }
 
-function q_(e, t, r) {
+function m1(e, t, r) {
     let {
         pixelUnprojectionMatrix: i
-    } = e, s = $r(i, [t, 0, 1, 1]), n = $r(i, [t, e.height, 1, 1]), a = (r * e.distanceScales.unitsPerMeter[2] - s[2]) / (n[2] - s[2]), c = Yt.lerp([], s, n, a), l = ie(c);
+    } = e, n = Es(i, [t, 0, 1, 1]), s = Es(i, [t, e.height, 1, 1]), a = (r * e.distanceScales.unitsPerMeter[2] - n[2]) / (s[2] - n[2]), c = Ge.lerp([], n, s, a), l = mr(c);
     return l.push(r), l
 }
-var K_ = 512;
+var _1 = 512;
 
-function ad(e) {
+function K0(e) {
     let {
         width: t,
         height: r,
         pitch: i = 0
     } = e, {
-        longitude: s,
-        latitude: n,
+        longitude: n,
+        latitude: s,
         zoom: o,
         bearing: a = 0
     } = e;
-    (s < -180 || s > 180) && (s = rd(s + 180, 360) - 180), (a < -180 || a > 180) && (a = rd(a + 180, 360) - 180);
-    let c = _s(r / K_);
-    if (o <= c) o = c, n = 0;
+    (n < -180 || n > 180) && (n = $0(n + 180, 360) - 180), (a < -180 || a > 180) && (a = $0(a + 180, 360) - 180);
+    let c = Da(r / _1);
+    if (o <= c) o = c, s = 0;
     else {
         let l = r / 2 / Math.pow(2, o),
-            h = ie([0, l])[1];
-        if (n < h) n = h;
+            u = mr([0, l])[1];
+        if (s < u) s = u;
         else {
-            let f = ie([0, K_ - l])[1];
-            n > f && (n = f)
+            let f = mr([0, _1 - l])[1];
+            s > f && (s = f)
         }
     }
     return {
         width: t,
         height: r,
-        longitude: s,
-        latitude: n,
+        longitude: n,
+        latitude: s,
         zoom: o,
         pitch: i,
         bearing: a
     }
 }
-var Jw = `
+var nF = `
 const int max_lights = 2;
 uniform mat4 shadow_uViewProjectionMatrices[max_lights];
 uniform vec4 shadow_uProjectCenters[max_lights];
 uniform bool shadow_uDrawShadowMap;
 uniform bool shadow_uUseShadowMap;
 uniform int shadow_uLightId;
 uniform float shadow_uLightCount;
@@ -11960,15 +11960,15 @@
         shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
       }
     }
   }
   return gl_Position;
 }
 `,
-    tv = `
+    sF = `
 const int max_lights = 2;
 uniform bool shadow_uDrawShadowMap;
 uniform bool shadow_uUseShadowMap;
 uniform sampler2D shadow_uShadowMap0;
 uniform sampler2D shadow_uShadowMap1;
 uniform vec4 shadow_uColor;
 uniform float shadow_uLightCount;
@@ -12005,118 +12005,118 @@
       mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),
       blendedAlpha
     );
   }
   return color;
 }
 `,
-    ev = Ye(ov),
-    rv = Ye(av),
-    iv = [0, 0, 0, 1],
-    sv = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
+    oF = Wi(fF),
+    aF = Wi(hF),
+    cF = [0, 0, 0, 1],
+    lF = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
 
-function nv(e, t) {
-    let [r, i, s] = e, n = qe([r, i, s], t);
-    return Number.isFinite(s) ? n : [n[0], n[1], 0]
+function uF(e, t) {
+    let [r, i, n] = e, s = ji([r, i, n], t);
+    return Number.isFinite(n) ? s : [s[0], s[1], 0]
 }
 
-function ov({
+function fF({
     viewport: e,
     center: t
 }) {
-    return new ot(e.viewProjectionMatrix).invert().transform(t)
+    return new Dt(e.viewProjectionMatrix).invert().transform(t)
 }
 
-function av({
+function hF({
     viewport: e,
     shadowMatrices: t
 }) {
     let r = [],
         i = e.pixelUnprojectionMatrix,
-        s = e.isGeospatial ? void 0 : 1,
-        n = [
-            [0, 0, s],
-            [e.width, 0, s],
-            [0, e.height, s],
-            [e.width, e.height, s],
+        n = e.isGeospatial ? void 0 : 1,
+        s = [
+            [0, 0, n],
+            [e.width, 0, n],
+            [0, e.height, n],
+            [e.width, e.height, n],
             [0, 0, -1],
             [e.width, 0, -1],
             [0, e.height, -1],
             [e.width, e.height, -1]
-        ].map(o => nv(o, i));
+        ].map(o => uF(o, i));
     for (let o of t) {
-        let a = o.clone().translate(new U(e.center).negate()),
-            c = n.map(h => a.transform(h)),
-            l = new ot().ortho({
-                left: Math.min(...c.map(h => h[0])),
-                right: Math.max(...c.map(h => h[0])),
-                bottom: Math.min(...c.map(h => h[1])),
-                top: Math.max(...c.map(h => h[1])),
-                near: Math.min(...c.map(h => -h[2])),
-                far: Math.max(...c.map(h => -h[2]))
+        let a = o.clone().translate(new z(e.center).negate()),
+            c = s.map(u => a.transform(u)),
+            l = new Dt().ortho({
+                left: Math.min(...c.map(u => u[0])),
+                right: Math.max(...c.map(u => u[0])),
+                bottom: Math.min(...c.map(u => u[1])),
+                top: Math.max(...c.map(u => u[1])),
+                near: Math.min(...c.map(u => -u[2])),
+                far: Math.max(...c.map(u => -u[2]))
             });
         r.push(l.multiplyRight(o))
     }
     return r
 }
 
-function cv(e, t) {
+function dF(e, t) {
     let {
         shadowEnabled: r = !0
     } = e;
     if (!r || !e.shadowMatrices || !e.shadowMatrices.length) return {
         shadow_uDrawShadowMap: !1,
         shadow_uUseShadowMap: !1,
         shadow_uShadowMap0: e.dummyShadowMap,
         shadow_uShadowMap1: e.dummyShadowMap
     };
     let i = {
             shadow_uDrawShadowMap: !!e.drawToShadowMap,
             shadow_uUseShadowMap: e.shadowMaps ? e.shadowMaps.length > 0 : !1,
-            shadow_uColor: e.shadowColor || iv,
+            shadow_uColor: e.shadowColor || cF,
             shadow_uLightId: e.shadowLightId || 0,
             shadow_uLightCount: e.shadowMatrices.length
         },
-        s = ev({
+        n = oF({
             viewport: e.viewport,
             center: t.project_uCenter
         }),
-        n = [],
-        o = rv({
+        s = [],
+        o = aF({
             shadowMatrices: e.shadowMatrices,
             viewport: e.viewport
         }).slice();
     for (let a = 0; a < e.shadowMatrices.length; a++) {
         let c = o[a],
-            l = c.clone().translate(new U(e.viewport.center).negate());
-        t.project_uCoordinateSystem === K.LNGLAT && t.project_uProjectionMode === Nt.WEB_MERCATOR ? (o[a] = l, n[a] = s) : (o[a] = c.clone().multiplyRight(sv), n[a] = l.transform(s))
+            l = c.clone().translate(new z(e.viewport.center).negate());
+        t.project_uCoordinateSystem === gt.LNGLAT && t.project_uProjectionMode === Pe.WEB_MERCATOR ? (o[a] = l, s[a] = n) : (o[a] = c.clone().multiplyRight(lF), s[a] = l.transform(n))
     }
-    for (let a = 0; a < o.length; a++) i[`shadow_uViewProjectionMatrices[${a}]`] = o[a], i[`shadow_uProjectCenters[${a}]`] = n[a];
+    for (let a = 0; a < o.length; a++) i[`shadow_uViewProjectionMatrices[${a}]`] = o[a], i[`shadow_uProjectCenters[${a}]`] = s[a];
     for (let a = 0; a < 2; a++) i[`shadow_uShadowMap${a}`] = e.shadowMaps && e.shadowMaps[a] || e.dummyShadowMap;
     return i
 }
-var Kn = {
+var Wl = {
     name: "shadow",
-    dependencies: [Xr],
-    vs: Jw,
-    fs: tv,
+    dependencies: [As],
+    vs: nF,
+    fs: sF,
     inject: {
         "vs:DECKGL_FILTER_GL_POSITION": `
     position = shadow_setVertexPosition(geometry.position);
     `,
         "fs:DECKGL_FILTER_COLOR": `
     color = shadow_filterShadowColor(color);
     `
     },
-    getUniforms: (e = {}, t = {}) => "viewport" in e && (e.drawToShadowMap || e.shadowMaps && e.shadowMaps.length > 0) ? cv(e, t) : {}
+    getUniforms: (e = {}, t = {}) => "viewport" in e && (e.drawToShadowMap || e.shadowMaps && e.shadowMaps.length > 0) ? dF(e, t) : {}
 };
-var zt = {
-    ...gc,
+var Ve = {
+    ...yd,
     defaultUniforms: {
-        ...gc.defaultUniforms,
+        ...yd.defaultUniforms,
         useFloatColors: !1
     },
     inject: {
         "vs:DECKGL_FILTER_GL_POSITION": `
     // for picking depth values
     picking_setPickingAttribute(position.z / position.w);
   `,
@@ -12131,60 +12131,60 @@
 
   // use picking color if rendering to picking FBO.
   color = picking_filterPickingColor(color);
     `
         }
     }
 };
-var lv = [Xr],
-    hv = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
+var pF = [As],
+    mF = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
 
-function cd() {
-    let e = xi.getDefaultShaderAssembler();
-    for (let t of lv) e.addDefaultModule(t);
-    for (let t of hv) e.addShaderHook(t);
+function G0() {
+    let e = po.getDefaultShaderAssembler();
+    for (let t of pF) e.addDefaultModule(t);
+    for (let t of mF) e.addShaderHook(t);
     return e
 }
-var fv = [255, 255, 255],
-    uv = 1,
-    dv = 0,
-    Qn = class {
+var gF = [255, 255, 255],
+    _F = 1,
+    yF = 0,
+    jl = class {
         constructor(t = {}) {
             this.type = "ambient";
             let {
-                color: r = fv
+                color: r = gF
             } = t, {
-                intensity: i = uv
+                intensity: i = _F
             } = t;
-            this.id = t.id || `ambient-${dv++}`, this.color = r, this.intensity = i
+            this.id = t.id || `ambient-${yF++}`, this.color = r, this.intensity = i
         }
     };
-var pv = [255, 255, 255],
-    gv = 1,
-    mv = [0, 0, -1],
-    _v = 0,
-    As = class {
+var bF = [255, 255, 255],
+    xF = 1,
+    wF = [0, 0, -1],
+    TF = 0,
+    za = class {
         constructor(t = {}) {
             this.type = "directional";
             let {
-                color: r = pv
+                color: r = bF
             } = t, {
-                intensity: i = gv
+                intensity: i = xF
             } = t, {
-                direction: s = mv
+                direction: n = wF
             } = t, {
-                _shadow: n = !1
+                _shadow: s = !1
             } = t;
-            this.id = t.id || `directional-${_v++}`, this.color = r, this.intensity = i, this.type = "directional", this.direction = new U(s).normalize().toArray(), this.shadow = n
+            this.id = t.id || `directional-${TF++}`, this.color = r, this.intensity = i, this.type = "directional", this.direction = new z(n).normalize().toArray(), this.shadow = s
         }
         getProjectedLight(t) {
             return this
         }
     };
-var Gn = class {
+var Hl = class {
     constructor(t, r = {
         id: "pass"
     }) {
         let {
             id: i
         } = r;
         this.id = i, this.device = t, this.props = {
@@ -12193,224 +12193,224 @@
     }
     setProps(t) {
         Object.assign(this.props, t)
     }
     render(t) {}
     cleanup() {}
 };
-var dr = class extends Gn {
+var Tn = class extends Hl {
     constructor() {
         super(...arguments), this._lastRenderIndex = -1
     }
     render(t) {
-        let [r, i] = this.device.canvasContext.getDrawingBufferSize(), s = t.clearCanvas ?? !0, n = t.clearColor ?? (s ? [0, 0, 0, 0] : !1), o = s ? 1 : !1, a = t.colorMask ?? 15, c = {
+        let [r, i] = this.device.canvasContext.getDrawingBufferSize(), n = t.clearCanvas ?? !0, s = t.clearColor ?? (n ? [0, 0, 0, 0] : !1), o = n ? 1 : !1, a = t.colorMask ?? 15, c = {
             viewport: [0, 0, r, i]
         };
         t.colorMask && (c.colorMask = a), t.scissorRect && (c.scissorRect = t.scissorRect);
         let l = this.device.beginRenderPass({
             framebuffer: t.target,
             parameters: c,
-            clearColor: n,
+            clearColor: s,
             clearDepth: o
         });
         try {
             return this._drawLayers(l, t)
         } finally {
             l.end()
         }
     }
     _drawLayers(t, r) {
         let {
             target: i,
-            moduleParameters: s,
-            viewports: n,
+            moduleParameters: n,
+            viewports: s,
             views: o,
             onViewportActive: a,
             clearStack: c = !0
         } = r;
         r.pass = r.pass || "unknown", c && (this._lastRenderIndex = -1);
         let l = [];
-        for (let h of n) {
-            let f = o && o[h.id];
-            a?.(h);
-            let u = this._getDrawLayerParams(h, r),
-                d = h.subViewports || [h];
-            for (let m of d) {
+        for (let u of s) {
+            let f = o && o[u.id];
+            a?.(u);
+            let h = this._getDrawLayerParams(u, r),
+                d = u.subViewports || [u];
+            for (let p of d) {
                 let y = this._drawLayersInViewport(t, {
                     target: i,
-                    moduleParameters: s,
-                    viewport: m,
+                    moduleParameters: n,
+                    viewport: p,
                     view: f,
                     pass: r.pass,
                     layers: r.layers
-                }, u);
+                }, h);
                 l.push(y)
             }
         }
         return l
     }
     _getDrawLayerParams(t, {
         layers: r,
         pass: i,
-        isPicking: s = !1,
-        layerFilter: n,
+        isPicking: n = !1,
+        layerFilter: s,
         cullRect: o,
         effects: a,
         moduleParameters: c
     }, l = !1) {
-        let h = [],
-            f = Q_(this._lastRenderIndex + 1),
-            u = {
+        let u = [],
+            f = y1(this._lastRenderIndex + 1),
+            h = {
                 layer: r[0],
                 viewport: t,
-                isPicking: s,
+                isPicking: n,
                 renderPass: i,
                 cullRect: o
             },
             d = {};
-        for (let m = 0; m < r.length; m++) {
-            let y = r[m],
-                x = this._shouldDrawLayer(y, u, n, d),
-                A = {
-                    shouldDrawLayer: x
+        for (let p = 0; p < r.length; p++) {
+            let y = r[p],
+                b = this._shouldDrawLayer(y, h, s, d),
+                T = {
+                    shouldDrawLayer: b
                 };
-            x && !l && (A.layerRenderIndex = f(y, x), A.moduleParameters = this._getModuleParameters(y, a, i, c), A.layerParameters = {
+            b && !l && (T.layerRenderIndex = f(y, b), T.moduleParameters = this._getModuleParameters(y, a, i, c), T.layerParameters = {
                 ...y.context.deck?.props.parameters,
-                ...this.getLayerParameters(y, m, t)
-            }), h[m] = A
+                ...this.getLayerParameters(y, p, t)
+            }), u[p] = T
         }
-        return h
+        return u
     }
     _drawLayersInViewport(t, {
         layers: r,
         moduleParameters: i,
-        pass: s,
-        target: n,
+        pass: n,
+        target: s,
         viewport: o,
         view: a
     }, c) {
-        let l = yv(this.device, {
+        let l = vF(this.device, {
             moduleParameters: i,
-            target: n,
+            target: s,
             viewport: o
         });
         if (a && a.props.clear) {
             let f = a.props.clear === !0 ? {
                 color: !0,
                 depth: !0
             } : a.props.clear;
             this.device.withParametersWebGL({
                 scissorTest: !0,
                 scissor: l
             }, () => this.device.clearWebGL(f))
         }
-        let h = {
+        let u = {
             totalCount: r.length,
             visibleCount: 0,
             compositeCount: 0,
             pickableCount: 0
         };
         t.setParameters({
             viewport: l
         });
         for (let f = 0; f < r.length; f++) {
-            let u = r[f],
+            let h = r[f],
                 {
                     shouldDrawLayer: d,
-                    layerRenderIndex: m,
+                    layerRenderIndex: p,
                     moduleParameters: y,
-                    layerParameters: x
+                    layerParameters: b
                 } = c[f];
-            if (d && u.props.pickable && h.pickableCount++, u.isComposite) h.compositeCount++;
+            if (d && h.props.pickable && u.pickableCount++, h.isComposite) u.compositeCount++;
             else if (d) {
-                h.visibleCount++, this._lastRenderIndex = Math.max(this._lastRenderIndex, m), y.viewport = o, u.context.renderPass = t;
+                u.visibleCount++, this._lastRenderIndex = Math.max(this._lastRenderIndex, p), y.viewport = o, h.context.renderPass = t;
                 try {
-                    u._drawLayer({
+                    h._drawLayer({
                         renderPass: t,
                         moduleParameters: y,
                         uniforms: {
-                            layerIndex: m
+                            layerIndex: p
                         },
-                        parameters: x
+                        parameters: b
                     })
-                } catch (A) {
-                    u.raiseError(A, `drawing ${u} to ${s}`)
+                } catch (T) {
+                    h.raiseError(T, `drawing ${h} to ${n}`)
                 }
             }
         }
-        return h
+        return u
     }
     shouldDrawLayer(t) {
         return !0
     }
     getModuleParameters(t, r) {
         return null
     }
     getLayerParameters(t, r, i) {
         return t.props.parameters
     }
-    _shouldDrawLayer(t, r, i, s) {
+    _shouldDrawLayer(t, r, i, n) {
         if (!(t.props.visible && this.shouldDrawLayer(t))) return !1;
         r.layer = t;
         let o = t.parent;
         for (; o;) {
             if (!o.props.visible || !o.filterSubLayer(r)) return !1;
             r.layer = o, o = o.parent
         }
         if (i) {
             let a = r.layer.id;
-            if (a in s || (s[a] = i(r)), !s[a]) return !1
+            if (a in n || (n[a] = i(r)), !n[a]) return !1
         }
         return t.activateViewport(r.viewport), !0
     }
-    _getModuleParameters(t, r, i, s) {
-        let n = this.device.canvasContext.cssToDeviceRatio(),
+    _getModuleParameters(t, r, i, n) {
+        let s = this.device.canvasContext.cssToDeviceRatio(),
             o = Object.assign(Object.create(t.internalState?.propsInTransition || t.props), {
                 autoWrapLongitude: t.wrapLongitude,
                 viewport: t.context.viewport,
                 mousePosition: t.context.mousePosition,
                 picking: {
                     isActive: 0
                 },
-                devicePixelRatio: n
+                devicePixelRatio: s
             });
         if (r)
             for (let a of r) Object.assign(o, a.getModuleParameters?.(t));
-        return Object.assign(o, this.getModuleParameters(t, r), s)
+        return Object.assign(o, this.getModuleParameters(t, r), n)
     }
 };
 
-function Q_(e = 0, t = {}) {
+function y1(e = 0, t = {}) {
     let r = {},
-        i = (s, n) => {
-            let o = s.props._offset,
-                a = s.id,
-                c = s.parent && s.parent.id,
+        i = (n, s) => {
+            let o = n.props._offset,
+                a = n.id,
+                c = n.parent && n.parent.id,
                 l;
-            if (c && !(c in t) && i(s.parent, !1), c in r) {
-                let h = r[c] = r[c] || Q_(t[c], t);
-                l = h(s, n), r[a] = h
+            if (c && !(c in t) && i(n.parent, !1), c in r) {
+                let u = r[c] = r[c] || y1(t[c], t);
+                l = u(n, s), r[a] = u
             } else Number.isFinite(o) ? (l = o + (t[c] || 0), r[a] = null) : l = e;
-            return n && l >= e && (e = l + 1), t[a] = l, l
+            return s && l >= e && (e = l + 1), t[a] = l, l
         };
     return i
 }
 
-function yv(e, {
+function vF(e, {
     moduleParameters: t,
     target: r,
     viewport: i
 }) {
-    let s = t && t.devicePixelRatio || e.canvasContext.cssToDeviceRatio(),
-        [, n] = e.canvasContext.getDrawingBufferSize(),
-        o = r ? r.height : n,
+    let n = t && t.devicePixelRatio || e.canvasContext.cssToDeviceRatio(),
+        [, s] = e.canvasContext.getDrawingBufferSize(),
+        o = r ? r.height : s,
         a = i;
-    return [a.x * s, o - (a.y + a.height) * s, a.width * s, a.height * s]
+    return [a.x * n, o - (a.y + a.height) * n, a.width * n, a.height * n]
 }
-var Jn = class extends dr {
+var $l = class extends Tn {
     constructor(t, r) {
         super(t, r), this.shadowMap = t.createTexture({
             width: 1,
             height: 1,
             sampler: {
                 minFilter: "linear",
                 magFilter: "linear",
@@ -12431,20 +12431,20 @@
             colorAttachments: [this.shadowMap],
             depthStencilAttachment: this.depthBuffer
         })
     }
     render(t) {
         let r = this.fbo,
             i = this.device.canvasContext.cssToDeviceRatio(),
-            s = t.viewports[0],
-            n = s.width * i,
-            o = s.height * i,
+            n = t.viewports[0],
+            s = n.width * i,
+            o = n.height * i,
             a = [1, 1, 1, 1];
-        (n !== r.width || o !== r.height) && r.resize({
-            width: n,
+        (s !== r.width || o !== r.height) && r.resize({
+            width: s,
             height: o
         }), super.render({
             ...t,
             clearColor: a,
             target: r,
             pass: "shadow"
         })
@@ -12465,39 +12465,39 @@
             drawToShadowMap: !0
         }
     }
     delete() {
         this.fbo && (this.fbo.destroy(), this.fbo = null), this.shadowMap && (this.shadowMap.destroy(), this.shadowMap = null), this.depthBuffer && (this.depthBuffer.destroy(), this.depthBuffer = null)
     }
 };
-var xv = {
+var SF = {
         color: [255, 255, 255],
         intensity: 1
     },
-    G_ = [{
+    b1 = [{
         color: [255, 255, 255],
         intensity: 1,
         direction: [-1, 3, -1]
     }, {
         color: [255, 255, 255],
         intensity: .9,
         direction: [1, -8, -2.5]
     }],
-    Tv = [0, 0, 0, 200 / 255],
-    Ci = class {
+    AF = [0, 0, 0, 200 / 255],
+    Ao = class {
         constructor(t = {}) {
-            this.id = "lighting-effect", this.shadowColor = Tv, this.shadow = !1, this.ambientLight = null, this.directionalLights = [], this.pointLights = [], this.shadowPasses = [], this.shadowMaps = [], this.dummyShadowMap = null, this.setProps(t)
+            this.id = "lighting-effect", this.shadowColor = AF, this.shadow = !1, this.ambientLight = null, this.directionalLights = [], this.pointLights = [], this.shadowPasses = [], this.shadowMaps = [], this.dummyShadowMap = null, this.setProps(t)
         }
         setup(t) {
             this.context = t;
             let {
                 device: r,
                 deck: i
             } = t;
-            this.shadow && !this.dummyShadowMap && (this._createShadowPasses(r), i._addDefaultShaderModule(Kn), this.dummyShadowMap = r.createTexture({
+            this.shadow && !this.dummyShadowMap && (this._createShadowPasses(r), i._addDefaultShaderModule(Wl), this.dummyShadowMap = r.createTexture({
                 width: 1,
                 height: 1
             }))
         }
         setProps(t) {
             this.ambientLight = null, this.directionalLights = [], this.pointLights = [];
             for (let r in t) {
@@ -12517,25 +12517,25 @@
             }
             this._applyDefaultLights(), this.shadow = this.directionalLights.some(r => r.shadow), this.context && this.setup(this.context), this.props = t
         }
         preRender({
             layers: t,
             layerFilter: r,
             viewports: i,
-            onViewportActive: s,
-            views: n
+            onViewportActive: n,
+            views: s
         }) {
             if (this.shadow) {
                 this.shadowMatrices = this._calculateMatrices();
                 for (let o = 0; o < this.shadowPasses.length; o++) this.shadowPasses[o].render({
                     layers: t,
                     layerFilter: r,
                     viewports: i,
-                    onViewportActive: s,
-                    views: n,
+                    onViewportActive: n,
+                    views: s,
                     moduleParameters: {
                         shadowLightId: o,
                         dummyShadowMap: this.dummyShadowMap,
                         shadowMatrices: this.shadowMatrices
                     }
                 })
             }
@@ -12555,586 +12555,586 @@
                 pointLights: this.pointLights.map(i => i.getProjectedLight({
                     layer: t
                 }))
             }, r
         }
         cleanup(t) {
             for (let r of this.shadowPasses) r.delete();
-            this.shadowPasses.length = 0, this.shadowMaps.length = 0, this.dummyShadowMap && (this.dummyShadowMap.destroy(), this.dummyShadowMap = null, t.deck._removeDefaultShaderModule(Kn))
+            this.shadowPasses.length = 0, this.shadowMaps.length = 0, this.dummyShadowMap && (this.dummyShadowMap.destroy(), this.dummyShadowMap = null, t.deck._removeDefaultShaderModule(Wl))
         }
         _calculateMatrices() {
             let t = [];
             for (let r of this.directionalLights) {
-                let i = new ot().lookAt({
-                    eye: new U(r.direction).negate()
+                let i = new Dt().lookAt({
+                    eye: new z(r.direction).negate()
                 });
                 t.push(i)
             }
             return t
         }
         _createShadowPasses(t) {
             for (let r = 0; r < this.directionalLights.length; r++) {
-                let i = new Jn(t);
+                let i = new $l(t);
                 this.shadowPasses[r] = i, this.shadowMaps[r] = i.shadowMap
             }
         }
         _applyDefaultLights() {
             let {
                 ambientLight: t,
                 pointLights: r,
                 directionalLights: i
             } = this;
-            !t && r.length === 0 && i.length === 0 && (this.ambientLight = new Qn(xv), this.directionalLights.push(new As(G_[0]), new As(G_[1])))
+            !t && r.length === 0 && i.length === 0 && (this.ambientLight = new jl(SF), this.directionalLights.push(new za(b1[0]), new za(b1[1])))
         }
     };
-var ld = class {
+var J0 = class {
         constructor(t = {}) {
             this._pool = [], this.opts = {
                 overAlloc: 2,
                 poolSize: 100
             }, this.setOptions(t)
         }
         setOptions(t) {
             Object.assign(this.opts, t)
         }
         allocate(t, r, {
             size: i = 1,
-            type: s,
-            padding: n = 0,
+            type: n,
+            padding: s = 0,
             copy: o = !1,
             initialize: a = !1,
             maxCount: c
         }) {
-            let l = s || t && t.constructor || Float32Array,
-                h = r * i + n;
+            let l = n || t && t.constructor || Float32Array,
+                u = r * i + s;
             if (ArrayBuffer.isView(t)) {
-                if (h <= t.length) return t;
-                if (h * t.BYTES_PER_ELEMENT <= t.buffer.byteLength) return new l(t.buffer, 0, h)
+                if (u <= t.length) return t;
+                if (u * t.BYTES_PER_ELEMENT <= t.buffer.byteLength) return new l(t.buffer, 0, u)
             }
             let f = 1 / 0;
-            c && (f = c * i + n);
-            let u = this._allocate(l, h, a, f);
-            return t && o ? u.set(t) : a || u.fill(0, 0, 4), this._release(t), u
+            c && (f = c * i + s);
+            let h = this._allocate(l, u, a, f);
+            return t && o ? h.set(t) : a || h.fill(0, 0, 4), this._release(t), h
         }
         release(t) {
             this._release(t)
         }
-        _allocate(t, r, i, s) {
-            let n = Math.max(Math.ceil(r * this.opts.overAlloc), 1);
-            n > s && (n = s);
+        _allocate(t, r, i, n) {
+            let s = Math.max(Math.ceil(r * this.opts.overAlloc), 1);
+            s > n && (s = n);
             let o = this._pool,
-                a = t.BYTES_PER_ELEMENT * n,
+                a = t.BYTES_PER_ELEMENT * s,
                 c = o.findIndex(l => l.byteLength >= a);
             if (c >= 0) {
-                let l = new t(o.splice(c, 1)[0], 0, n);
+                let l = new t(o.splice(c, 1)[0], 0, s);
                 return i && l.fill(0), l
             }
-            return new t(n)
+            return new t(s)
         }
         _release(t) {
             if (!ArrayBuffer.isView(t)) return;
             let r = this._pool,
                 {
                     buffer: i
                 } = t,
                 {
-                    byteLength: s
+                    byteLength: n
                 } = i,
-                n = r.findIndex(o => o.byteLength >= s);
-            n < 0 ? r.push(i) : (n > 0 || r.length < this.opts.poolSize) && r.splice(n, 0, i), r.length > this.opts.poolSize && r.shift()
+                s = r.findIndex(o => o.byteLength >= n);
+            s < 0 ? r.push(i) : (s > 0 || r.length < this.opts.poolSize) && r.splice(s, 0, i), r.length > this.opts.poolSize && r.shift()
         }
     },
-    ve = new ld;
+    ri = new J0;
 
-function Ss() {
+function ja() {
     return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
 }
 
-function t0(e, t) {
+function w1(e, t) {
     let r = e % t;
     return r < 0 ? t + r : r
 }
 
-function e0(e) {
+function T1(e) {
     return [e[12], e[13], e[14]]
 }
 
-function r0(e) {
+function v1(e) {
     return {
-        left: Es(e[3] + e[0], e[7] + e[4], e[11] + e[8], e[15] + e[12]),
-        right: Es(e[3] - e[0], e[7] - e[4], e[11] - e[8], e[15] - e[12]),
-        bottom: Es(e[3] + e[1], e[7] + e[5], e[11] + e[9], e[15] + e[13]),
-        top: Es(e[3] - e[1], e[7] - e[5], e[11] - e[9], e[15] - e[13]),
-        near: Es(e[3] + e[2], e[7] + e[6], e[11] + e[10], e[15] + e[14]),
-        far: Es(e[3] - e[2], e[7] - e[6], e[11] - e[10], e[15] - e[14])
+        left: Wa(e[3] + e[0], e[7] + e[4], e[11] + e[8], e[15] + e[12]),
+        right: Wa(e[3] - e[0], e[7] - e[4], e[11] - e[8], e[15] - e[12]),
+        bottom: Wa(e[3] + e[1], e[7] + e[5], e[11] + e[9], e[15] + e[13]),
+        top: Wa(e[3] - e[1], e[7] - e[5], e[11] - e[9], e[15] - e[13]),
+        near: Wa(e[3] + e[2], e[7] + e[6], e[11] + e[10], e[15] + e[14]),
+        far: Wa(e[3] - e[2], e[7] - e[6], e[11] - e[10], e[15] - e[14])
     }
 }
-var J_ = new U;
-
-function Es(e, t, r, i) {
-    J_.set(e, t, r);
-    let s = J_.len();
+var x1 = new z;
+
+function Wa(e, t, r, i) {
+    x1.set(e, t, r);
+    let n = x1.len();
     return {
-        distance: i / s,
-        normal: new U(-e / s, -t / s, -r / s)
+        distance: i / n,
+        normal: new z(-e / n, -t / n, -r / n)
     }
 }
 
-function i0(e) {
+function S1(e) {
     return e - Math.fround(e)
 }
-var to;
+var Xl;
 
-function Nc(e, t) {
+function Dd(e, t) {
     let {
         size: r = 1,
         startIndex: i = 0
-    } = t, s = t.endIndex !== void 0 ? t.endIndex : e.length, n = (s - i) / r;
-    to = ve.allocate(to, n, {
+    } = t, n = t.endIndex !== void 0 ? t.endIndex : e.length, s = (n - i) / r;
+    Xl = ri.allocate(Xl, s, {
         type: Float32Array,
         size: r * 2
     });
     let o = i,
         a = 0;
-    for (; o < s;) {
+    for (; o < n;) {
         for (let c = 0; c < r; c++) {
             let l = e[o++];
-            to[a + c] = l, to[a + c + r] = i0(l)
+            Xl[a + c] = l, Xl[a + c + r] = S1(l)
         }
         a += r * 2
     }
-    return to.subarray(0, n * r * 2)
+    return Xl.subarray(0, s * r * 2)
 }
 
-function s0(e) {
+function A1(e) {
     let t = null,
         r = !1;
     for (let i of e) i && (t ? (r || (t = [
         [t[0][0], t[0][1]],
         [t[1][0], t[1][1]]
     ], r = !0), t[0][0] = Math.min(t[0][0], i[0][0]), t[0][1] = Math.min(t[0][1], i[0][1]), t[1][0] = Math.max(t[1][0], i[1][0]), t[1][1] = Math.max(t[1][1], i[1][1])) : t = i);
     return t
 }
-var bv = Math.PI / 180,
-    Av = Ss(),
-    n0 = [0, 0, 0],
-    Ev = {
+var EF = Math.PI / 180,
+    IF = ja(),
+    E1 = [0, 0, 0],
+    RF = {
         unitsPerMeter: [1, 1, 1],
         metersPerUnit: [1, 1, 1]
     };
 
-function Sv({
+function MF({
     width: e,
     height: t,
     orthographic: r,
     fovyRadians: i,
-    focalDistance: s,
-    padding: n,
+    focalDistance: n,
+    padding: s,
     near: o,
     far: a
 }) {
     let c = e / t,
-        l = r ? new ot().orthographic({
+        l = r ? new Dt().orthographic({
             fovy: i,
             aspect: c,
-            focalDistance: s,
+            focalDistance: n,
             near: o,
             far: a
-        }) : new ot().perspective({
+        }) : new Dt().perspective({
             fovy: i,
             aspect: c,
             near: o,
             far: a
         });
-    if (n) {
+    if (s) {
         let {
-            left: h = 0,
+            left: u = 0,
             right: f = 0,
-            top: u = 0,
+            top: h = 0,
             bottom: d = 0
-        } = n, m = ct((h + e - f) / 2, 0, e) - e / 2, y = ct((u + t - d) / 2, 0, t) - t / 2;
-        l[8] -= m * 2 / e, l[9] += y * 2 / t
+        } = s, p = jt((u + e - f) / 2, 0, e) - e / 2, y = jt((h + t - d) / 2, 0, t) - t / 2;
+        l[8] -= p * 2 / e, l[9] += y * 2 / t
     }
     return l
 }
-var Fc = class Fc {
+var Ld = class Ld {
     constructor(t = {}) {
-        this._frustumPlanes = {}, this.id = t.id || this.constructor.displayName || "viewport", this.x = t.x || 0, this.y = t.y || 0, this.width = t.width || 1, this.height = t.height || 1, this.zoom = t.zoom || 0, this.padding = t.padding, this.distanceScales = t.distanceScales || Ev, this.focalDistance = t.focalDistance || 1, this.position = t.position || n0, this.modelMatrix = t.modelMatrix || null;
+        this._frustumPlanes = {}, this.id = t.id || this.constructor.displayName || "viewport", this.x = t.x || 0, this.y = t.y || 0, this.width = t.width || 1, this.height = t.height || 1, this.zoom = t.zoom || 0, this.padding = t.padding, this.distanceScales = t.distanceScales || RF, this.focalDistance = t.focalDistance || 1, this.position = t.position || E1, this.modelMatrix = t.modelMatrix || null;
         let {
             longitude: r,
             latitude: i
         } = t;
         this.isGeospatial = Number.isFinite(i) && Number.isFinite(r), this._initProps(t), this._initMatrices(t), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this)
     }
     get subViewports() {
         return null
     }
     get metersPerPixel() {
         return this.distanceScales.metersPerUnit[2] / this.scale
     }
     get projectionMode() {
-        return this.isGeospatial ? this.zoom < 12 ? Nt.WEB_MERCATOR : Nt.WEB_MERCATOR_AUTO_OFFSET : Nt.IDENTITY
+        return this.isGeospatial ? this.zoom < 12 ? Pe.WEB_MERCATOR : Pe.WEB_MERCATOR_AUTO_OFFSET : Pe.IDENTITY
     }
     equals(t) {
-        return t instanceof Fc ? this === t ? !0 : t.width === this.width && t.height === this.height && t.scale === this.scale && Bt(t.projectionMatrix, this.projectionMatrix) && Bt(t.viewMatrix, this.viewMatrix) : !1
+        return t instanceof Ld ? this === t ? !0 : t.width === this.width && t.height === this.height && t.scale === this.scale && Le(t.projectionMatrix, this.projectionMatrix) && Le(t.viewMatrix, this.viewMatrix) : !1
     }
     project(t, {
         topLeft: r = !0
     } = {}) {
         let i = this.projectPosition(t),
-            s = bs(i, this.pixelProjectionMatrix),
-            [n, o] = s,
+            n = Va(i, this.pixelProjectionMatrix),
+            [s, o] = n,
             a = r ? o : this.height - o;
-        return t.length === 2 ? [n, a] : [n, a, s[2]]
+        return t.length === 2 ? [s, a] : [s, a, n[2]]
     }
     unproject(t, {
         topLeft: r = !0,
         targetZ: i
     } = {}) {
-        let [s, n, o] = t, a = r ? n : this.height - n, c = i && i * this.distanceScales.unitsPerMeter[2], l = qe([s, a, o], this.pixelUnprojectionMatrix, c), [h, f, u] = this.unprojectPosition(l);
-        return Number.isFinite(o) ? [h, f, u] : Number.isFinite(i) ? [h, f, i] : [h, f]
+        let [n, s, o] = t, a = r ? s : this.height - s, c = i && i * this.distanceScales.unitsPerMeter[2], l = ji([n, a, o], this.pixelUnprojectionMatrix, c), [u, f, h] = this.unprojectPosition(l);
+        return Number.isFinite(o) ? [u, f, h] : Number.isFinite(i) ? [u, f, i] : [u, f]
     }
     projectPosition(t) {
-        let [r, i] = this.projectFlat(t), s = (t[2] || 0) * this.distanceScales.unitsPerMeter[2];
-        return [r, i, s]
+        let [r, i] = this.projectFlat(t), n = (t[2] || 0) * this.distanceScales.unitsPerMeter[2];
+        return [r, i, n]
     }
     unprojectPosition(t) {
-        let [r, i] = this.unprojectFlat(t), s = (t[2] || 0) * this.distanceScales.metersPerUnit[2];
-        return [r, i, s]
+        let [r, i] = this.unprojectFlat(t), n = (t[2] || 0) * this.distanceScales.metersPerUnit[2];
+        return [r, i, n]
     }
     projectFlat(t) {
         if (this.isGeospatial) {
-            let r = Vt(t);
-            return r[1] = ct(r[1], -318, 830), r
+            let r = Ue(t);
+            return r[1] = jt(r[1], -318, 830), r
         }
         return t
     }
     unprojectFlat(t) {
-        return this.isGeospatial ? ie(t) : t
+        return this.isGeospatial ? mr(t) : t
     }
     getBounds(t = {}) {
         let r = {
                 targetZ: t.z || 0
             },
             i = this.unproject([0, 0], r),
-            s = this.unproject([this.width, 0], r),
-            n = this.unproject([0, this.height], r),
+            n = this.unproject([this.width, 0], r),
+            s = this.unproject([0, this.height], r),
             o = this.unproject([this.width, this.height], r);
-        return [Math.min(i[0], s[0], n[0], o[0]), Math.min(i[1], s[1], n[1], o[1]), Math.max(i[0], s[0], n[0], o[0]), Math.max(i[1], s[1], n[1], o[1])]
+        return [Math.min(i[0], n[0], s[0], o[0]), Math.min(i[1], n[1], s[1], o[1]), Math.max(i[0], n[0], s[0], o[0]), Math.max(i[1], n[1], s[1], o[1])]
     }
     getDistanceScales(t) {
-        return t ? Ts({
+        return t ? Ua({
             longitude: t[0],
             latitude: t[1],
             highPrecision: !0
         }) : this.distanceScales
     }
     containsPixel({
         x: t,
         y: r,
         width: i = 1,
-        height: s = 1
+        height: n = 1
     }) {
-        return t < this.x + this.width && this.x < t + i && r < this.y + this.height && this.y < r + s
+        return t < this.x + this.width && this.x < t + i && r < this.y + this.height && this.y < r + n
     }
     getFrustumPlanes() {
-        return this._frustumPlanes.near ? this._frustumPlanes : (Object.assign(this._frustumPlanes, r0(this.viewProjectionMatrix)), this._frustumPlanes)
+        return this._frustumPlanes.near ? this._frustumPlanes : (Object.assign(this._frustumPlanes, v1(this.viewProjectionMatrix)), this._frustumPlanes)
     }
     panByPosition(t, r) {
         return null
     }
     _initProps(t) {
         let r = t.longitude,
             i = t.latitude;
-        this.isGeospatial && (Number.isFinite(t.zoom) || (this.zoom = nd({
+        this.isGeospatial && (Number.isFinite(t.zoom) || (this.zoom = q0({
             latitude: i
-        }) + Math.log2(this.focalDistance)), this.distanceScales = t.distanceScales || Ts({
+        }) + Math.log2(this.focalDistance)), this.distanceScales = t.distanceScales || Ua({
             latitude: i,
             longitude: r
         }));
-        let s = Math.pow(2, this.zoom);
-        this.scale = s;
+        let n = Math.pow(2, this.zoom);
+        this.scale = n;
         let {
-            position: n,
+            position: s,
             modelMatrix: o
-        } = t, a = n0;
-        if (n && (a = o ? new ot(o).transformAsVector(n, []) : n), this.isGeospatial) {
+        } = t, a = E1;
+        if (s && (a = o ? new Dt(o).transformAsVector(s, []) : s), this.isGeospatial) {
             let c = this.projectPosition([r, i, 0]);
-            this.center = new U(a).scale(this.distanceScales.unitsPerMeter).add(c)
+            this.center = new z(a).scale(this.distanceScales.unitsPerMeter).add(c)
         } else this.center = this.projectPosition(a)
     }
     _initMatrices(t) {
         let {
-            viewMatrix: r = Av,
+            viewMatrix: r = IF,
             projectionMatrix: i = null,
-            orthographic: s = !1,
-            fovyRadians: n,
+            orthographic: n = !1,
+            fovyRadians: s,
             fovy: o = 75,
             near: a = .1,
             far: c = 1e3,
             padding: l = null,
-            focalDistance: h = 1
+            focalDistance: u = 1
         } = t;
-        this.viewMatrixUncentered = r, this.viewMatrix = new ot().multiplyRight(r).translate(new U(this.center).negate()), this.projectionMatrix = i || Sv({
+        this.viewMatrixUncentered = r, this.viewMatrix = new Dt().multiplyRight(r).translate(new z(this.center).negate()), this.projectionMatrix = i || MF({
             width: this.width,
             height: this.height,
-            orthographic: s,
-            fovyRadians: n || o * bv,
-            focalDistance: h,
+            orthographic: n,
+            fovyRadians: s || o * EF,
+            focalDistance: u,
             padding: l,
             near: a,
             far: c
         });
-        let f = Ss();
-        _t.multiply(f, f, this.projectionMatrix), _t.multiply(f, f, this.viewMatrix), this.viewProjectionMatrix = f, this.viewMatrixInverse = _t.invert([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = e0(this.viewMatrixInverse);
-        let u = Ss(),
-            d = Ss();
-        _t.scale(u, u, [this.width / 2, -this.height / 2, 1]), _t.translate(u, u, [1, -1, 0]), _t.multiply(d, u, this.viewProjectionMatrix), this.pixelProjectionMatrix = d, this.pixelUnprojectionMatrix = _t.invert(Ss(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || j.warn("Pixel project matrix not invertible")()
+        let f = ja();
+        ie.multiply(f, f, this.projectionMatrix), ie.multiply(f, f, this.viewMatrix), this.viewProjectionMatrix = f, this.viewMatrixInverse = ie.invert([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = T1(this.viewMatrixInverse);
+        let h = ja(),
+            d = ja();
+        ie.scale(h, h, [this.width / 2, -this.height / 2, 1]), ie.translate(h, h, [1, -1, 0]), ie.multiply(d, h, this.viewProjectionMatrix), this.pixelProjectionMatrix = d, this.pixelUnprojectionMatrix = ie.invert(ja(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || Z.warn("Pixel project matrix not invertible")()
     }
 };
-Fc.displayName = "Viewport";
-var me = Fc;
-var eo = class eo extends me {
+Ld.displayName = "Viewport";
+var Lr = Ld;
+var Yl = class Yl extends Lr {
     constructor(t = {}) {
         let {
             latitude: r = 0,
             longitude: i = 0,
-            zoom: s = 0,
-            pitch: n = 0,
+            zoom: n = 0,
+            pitch: s = 0,
             bearing: o = 0,
             nearZMultiplier: a = .1,
             farZMultiplier: c = 1.01,
             nearZ: l,
-            farZ: h,
+            farZ: u,
             orthographic: f = !1,
-            projectionMatrix: u,
+            projectionMatrix: h,
             repeat: d = !1,
-            worldOffset: m = 0,
+            worldOffset: p = 0,
             position: y,
-            padding: x,
-            legacyMeterSizes: A = !1
+            padding: b,
+            legacyMeterSizes: T = !1
         } = t, {
-            width: v,
-            height: E,
+            width: I,
+            height: S,
             altitude: R = 1.5
-        } = t, M = Math.pow(2, s);
-        v = v || 1, E = E || 1;
-        let C, B = null;
-        if (u) R = u[5] / 2, C = Mi(R);
+        } = t, P = Math.pow(2, n);
+        I = I || 1, S = S || 1;
+        let C, V = null;
+        if (h) R = h[5] / 2, C = So(R);
         else {
-            t.fovy ? (C = t.fovy, R = Zn(C)) : C = Mi(R);
+            t.fovy ? (C = t.fovy, R = zl(C)) : C = So(R);
             let k;
-            if (x) {
+            if (b) {
                 let {
-                    top: N = 0,
-                    bottom: H = 0
-                } = x;
-                k = [0, ct((N + E - H) / 2, 0, E) - E / 2]
-            }
-            B = od({
-                width: v,
-                height: E,
-                scale: M,
-                center: y && [0, 0, y[2] * Yn(r)],
+                    top: B = 0,
+                    bottom: K = 0
+                } = b;
+                k = [0, jt((B + S - K) / 2, 0, S) - S / 2]
+            }
+            V = Z0({
+                width: I,
+                height: S,
+                scale: P,
+                center: y && [0, 0, y[2] * Ul(r)],
                 offset: k,
-                pitch: n,
+                pitch: s,
                 fovy: C,
                 nearZMultiplier: a,
                 farZMultiplier: c
-            }), Number.isFinite(l) && (B.near = l), Number.isFinite(h) && (B.far = h)
+            }), Number.isFinite(l) && (V.near = l), Number.isFinite(u) && (V.far = u)
         }
-        let L = Cc({
-            height: E,
-            pitch: n,
+        let U = Nd({
+            height: S,
+            pitch: s,
             bearing: o,
-            scale: M,
+            scale: P,
             altitude: R
         });
-        m && (L = new ot().translate([512 * m, 0, 0]).multiplyLeft(L)), super({
+        p && (U = new Dt().translate([512 * p, 0, 0]).multiplyLeft(U)), super({
             ...t,
-            width: v,
-            height: E,
-            viewMatrix: L,
+            width: I,
+            height: S,
+            viewMatrix: U,
             longitude: i,
             latitude: r,
-            zoom: s,
-            ...B,
+            zoom: n,
+            ...V,
             fovy: C,
             focalDistance: R
-        }), this.latitude = r, this.longitude = i, this.zoom = s, this.pitch = n, this.bearing = o, this.altitude = R, this.fovy = C, this.orthographic = f, this._subViewports = d ? [] : null, this._pseudoMeters = A, Object.freeze(this)
+        }), this.latitude = r, this.longitude = i, this.zoom = n, this.pitch = s, this.bearing = o, this.altitude = R, this.fovy = C, this.orthographic = f, this._subViewports = d ? [] : null, this._pseudoMeters = T, Object.freeze(this)
     }
     get subViewports() {
         if (this._subViewports && !this._subViewports.length) {
             let t = this.getBounds(),
                 r = Math.floor((t[0] + 180) / 360),
                 i = Math.ceil((t[2] - 180) / 360);
-            for (let s = r; s <= i; s++) {
-                let n = s ? new eo({
+            for (let n = r; n <= i; n++) {
+                let s = n ? new Yl({
                     ...this,
-                    worldOffset: s
+                    worldOffset: n
                 }) : this;
-                this._subViewports.push(n)
+                this._subViewports.push(s)
             }
         }
         return this._subViewports
     }
     projectPosition(t) {
         if (this._pseudoMeters) return super.projectPosition(t);
-        let [r, i] = this.projectFlat(t), s = (t[2] || 0) * Yn(t[1]);
-        return [r, i, s]
+        let [r, i] = this.projectFlat(t), n = (t[2] || 0) * Ul(t[1]);
+        return [r, i, n]
     }
     unprojectPosition(t) {
         if (this._pseudoMeters) return super.unprojectPosition(t);
-        let [r, i] = this.unprojectFlat(t), s = (t[2] || 0) / Yn(i);
-        return [r, i, s]
+        let [r, i] = this.unprojectFlat(t), n = (t[2] || 0) / Ul(i);
+        return [r, i, n]
     }
     addMetersToLngLat(t, r) {
-        return qn(t, r)
+        return Vl(t, r)
     }
     panByPosition(t, r) {
-        let i = qe(r, this.pixelUnprojectionMatrix),
-            s = this.projectFlat(t),
-            n = Yt.add([], s, Yt.negate([], i)),
-            o = Yt.add([], this.center, n),
+        let i = ji(r, this.pixelUnprojectionMatrix),
+            n = this.projectFlat(t),
+            s = Ge.add([], n, Ge.negate([], i)),
+            o = Ge.add([], this.center, s),
             [a, c] = this.unprojectFlat(o);
         return {
             longitude: a,
             latitude: c
         }
     }
     getBounds(t = {}) {
-        let r = Oc(this, t.z || 0);
+        let r = Fd(this, t.z || 0);
         return [Math.min(r[0][0], r[1][0], r[2][0], r[3][0]), Math.min(r[0][1], r[1][1], r[2][1], r[3][1]), Math.max(r[0][0], r[1][0], r[2][0], r[3][0]), Math.max(r[0][1], r[1][1], r[2][1], r[3][1])]
     }
     fitBounds(t, r = {}) {
         let {
             width: i,
-            height: s
+            height: n
         } = this, {
-            longitude: n,
+            longitude: s,
             latitude: o,
             zoom: a
-        } = Ic({
+        } = Bd({
             width: i,
-            height: s,
+            height: n,
             bounds: t,
             ...r
         });
-        return new eo({
+        return new Yl({
             width: i,
-            height: s,
-            longitude: n,
+            height: n,
+            longitude: s,
             latitude: o,
             zoom: a
         })
     }
 };
-eo.displayName = "WebMercatorViewport";
-var _e = eo;
-var o0 = [0, 0, 0];
+Yl.displayName = "WebMercatorViewport";
+var kr = Yl;
+var I1 = [0, 0, 0];
 
-function hd(e, t, r = !1) {
+function Q0(e, t, r = !1) {
     let i = t.projectPosition(e);
-    if (r && t instanceof _e) {
-        let [s, n, o = 0] = e, a = t.getDistanceScales([s, n]);
+    if (r && t instanceof kr) {
+        let [n, s, o = 0] = e, a = t.getDistanceScales([n, s]);
         i[2] = o * a.unitsPerMeter[2]
     }
     return i
 }
 
-function wv(e) {
+function PF(e) {
     let {
         viewport: t,
         modelMatrix: r,
         coordinateOrigin: i
     } = e, {
-        coordinateSystem: s,
-        fromCoordinateSystem: n,
+        coordinateSystem: n,
+        fromCoordinateSystem: s,
         fromCoordinateOrigin: o
     } = e;
-    return s === K.DEFAULT && (s = t.isGeospatial ? K.LNGLAT : K.CARTESIAN), n === void 0 && (n = s), o === void 0 && (o = i), {
+    return n === gt.DEFAULT && (n = t.isGeospatial ? gt.LNGLAT : gt.CARTESIAN), s === void 0 && (s = n), o === void 0 && (o = i), {
         viewport: t,
-        coordinateSystem: s,
+        coordinateSystem: n,
         coordinateOrigin: i,
         modelMatrix: r,
-        fromCoordinateSystem: n,
+        fromCoordinateSystem: s,
         fromCoordinateOrigin: o
     }
 }
 
-function fd(e, {
+function tb(e, {
     viewport: t,
     modelMatrix: r,
     coordinateSystem: i,
-    coordinateOrigin: s,
-    offsetMode: n
+    coordinateOrigin: n,
+    offsetMode: s
 }) {
     let [o, a, c = 0] = e;
-    switch (r && ([o, a, c] = Zt.transformMat4([], [o, a, c, 1], r)), i) {
-        case K.LNGLAT:
-            return hd([o, a, c], t, n);
-        case K.LNGLAT_OFFSETS:
-            return hd([o + s[0], a + s[1], c + (s[2] || 0)], t, n);
-        case K.METER_OFFSETS:
-            return hd(qn(s, [o, a, c]), t, n);
-        case K.CARTESIAN:
+    switch (r && ([o, a, c] = Qe.transformMat4([], [o, a, c, 1], r)), i) {
+        case gt.LNGLAT:
+            return Q0([o, a, c], t, s);
+        case gt.LNGLAT_OFFSETS:
+            return Q0([o + n[0], a + n[1], c + (n[2] || 0)], t, s);
+        case gt.METER_OFFSETS:
+            return Q0(Vl(n, [o, a, c]), t, s);
+        case gt.CARTESIAN:
         default:
-            return t.isGeospatial ? [o + s[0], a + s[1], c + s[2]] : t.projectPosition([o, a, c])
+            return t.isGeospatial ? [o + n[0], a + n[1], c + n[2]] : t.projectPosition([o, a, c])
     }
 }
 
-function a0(e, t) {
+function R1(e, t) {
     let {
         viewport: r,
         coordinateSystem: i,
-        coordinateOrigin: s,
-        modelMatrix: n,
+        coordinateOrigin: n,
+        modelMatrix: s,
         fromCoordinateSystem: o,
         fromCoordinateOrigin: a
-    } = wv(t), {
+    } = PF(t), {
         autoOffset: c = !0
     } = t, {
-        geospatialOrigin: l = o0,
-        shaderCoordinateOrigin: h = o0,
+        geospatialOrigin: l = I1,
+        shaderCoordinateOrigin: u = I1,
         offsetMode: f = !1
-    } = c ? td(r, i, s) : {}, u = fd(e, {
+    } = c ? j0(r, i, n) : {}, h = tb(e, {
         viewport: r,
-        modelMatrix: n,
+        modelMatrix: s,
         coordinateSystem: o,
         coordinateOrigin: a,
         offsetMode: f
     });
     if (f) {
-        let d = r.projectPosition(l || h);
-        qt.sub(u, u, d)
+        let d = r.projectPosition(l || u);
+        Je.sub(h, h, d)
     }
-    return u
+    return h
 }
-var vv = 1,
-    Rv = 1,
-    Ii = class {
+var CF = 1,
+    OF = 1,
+    Eo = class {
         constructor() {
-            p(this, "time", 0);
-            p(this, "channels", new Map);
-            p(this, "animations", new Map);
-            p(this, "playing", !1);
-            p(this, "lastEngineTime", -1)
+            m(this, "time", 0);
+            m(this, "channels", new Map);
+            m(this, "animations", new Map);
+            m(this, "playing", !1);
+            m(this, "lastEngineTime", -1)
         }
         addChannel(t) {
             let {
                 delay: r = 0,
                 duration: i = Number.POSITIVE_INFINITY,
-                rate: s = 1,
-                repeat: n = 1
-            } = t, o = vv++, a = {
+                rate: n = 1,
+                repeat: s = 1
+            } = t, o = CF++, a = {
                 time: 0,
                 delay: r,
                 duration: i,
-                rate: s,
-                repeat: n
+                rate: n,
+                repeat: s
             };
             return this._setChannelTime(a, this.time), this.channels.set(o, a), o
         }
         removeChannel(t) {
             this.channels.delete(t);
             for (let [r, i] of this.animations) i.channel === t && this.detachAnimation(r)
         }
@@ -13146,92 +13146,92 @@
             if (t === void 0) return this.time;
             let r = this.channels.get(t);
             return r === void 0 ? -1 : r.time
         }
         setTime(t) {
             this.time = Math.max(0, t);
             let r = this.channels.values();
-            for (let s of r) this._setChannelTime(s, this.time);
+            for (let n of r) this._setChannelTime(n, this.time);
             let i = this.animations.values();
-            for (let s of i) {
+            for (let n of i) {
                 let {
-                    animation: n,
+                    animation: s,
                     channel: o
-                } = s;
-                n.setTime(this.getTime(o))
+                } = n;
+                s.setTime(this.getTime(o))
             }
         }
         play() {
             this.playing = !0
         }
         pause() {
             this.playing = !1, this.lastEngineTime = -1
         }
         reset() {
             this.setTime(0)
         }
         attachAnimation(t, r) {
-            let i = Rv++;
+            let i = OF++;
             return this.animations.set(i, {
                 animation: t,
                 channel: r
             }), t.setTime(this.getTime(r)), i
         }
         detachAnimation(t) {
             this.animations.delete(t)
         }
         update(t) {
             this.playing && (this.lastEngineTime === -1 && (this.lastEngineTime = t), this.setTime(this.time + (t - this.lastEngineTime)), this.lastEngineTime = t)
         }
         _setChannelTime(t, r) {
             let i = r - t.delay,
-                s = t.duration * t.repeat;
-            i >= s ? t.time = t.duration * t.rate : (t.time = Math.max(0, i) % t.duration, t.time *= t.rate)
+                n = t.duration * t.repeat;
+            i >= n ? t.time = t.duration * t.rate : (t.time = Math.max(0, i) % t.duration, t.time *= t.rate)
         }
     };
-var Pv = 0,
-    Mv = {
+var NF = 0,
+    BF = {
         device: null,
         onAddHTML: () => "",
         onInitialize: async () => null,
         onRender: () => {},
         onFinalize: () => {},
         onError: e => console.error(e),
-        stats: fe.stats.get(`animation-loop-${Pv++}`),
+        stats: Or.stats.get(`animation-loop-${NF++}`),
         useDevicePixels: !0,
         autoResizeViewport: !1,
         autoResizeDrawingBuffer: !1
     },
-    ro = class {
+    ql = class {
         constructor(t) {
-            p(this, "device", null);
-            p(this, "canvas", null);
-            p(this, "props");
-            p(this, "animationProps", null);
-            p(this, "timeline", null);
-            p(this, "stats");
-            p(this, "cpuTime");
-            p(this, "gpuTime");
-            p(this, "frameRate");
-            p(this, "display");
-            p(this, "needsRedraw", "initialized");
-            p(this, "_initialized", !1);
-            p(this, "_running", !1);
-            p(this, "_animationFrameId", null);
-            p(this, "_nextFramePromise", null);
-            p(this, "_resolveNextFrame", null);
-            p(this, "_cpuStartTime", 0);
+            m(this, "device", null);
+            m(this, "canvas", null);
+            m(this, "props");
+            m(this, "animationProps", null);
+            m(this, "timeline", null);
+            m(this, "stats");
+            m(this, "cpuTime");
+            m(this, "gpuTime");
+            m(this, "frameRate");
+            m(this, "display");
+            m(this, "needsRedraw", "initialized");
+            m(this, "_initialized", !1);
+            m(this, "_running", !1);
+            m(this, "_animationFrameId", null);
+            m(this, "_nextFramePromise", null);
+            m(this, "_resolveNextFrame", null);
+            m(this, "_cpuStartTime", 0);
             if (this.props = {
-                    ...Mv,
+                    ...BF,
                     ...t
                 }, t = this.props, !t.device) throw new Error("No device provided");
             let {
                 useDevicePixels: r = !0
             } = this.props;
-            this.stats = t.stats || new Xt({
+            this.stats = t.stats || new Ke({
                 id: "animation-loop-stats"
             }), this.cpuTime = this.stats.get("CPU Time"), this.gpuTime = this.stats.get("GPU Time"), this.frameRate = this.stats.get("Frame Rate"), this.setProps({
                 autoResizeViewport: t.autoResizeViewport,
                 autoResizeDrawingBuffer: t.autoResizeDrawingBuffer,
                 useDevicePixels: r
             }), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this._onMousemove = this._onMousemove.bind(this), this._onMouseleave = this._onMouseleave.bind(this)
         }
@@ -13282,18 +13282,18 @@
         _initialize() {
             this._startEventHandling(), this._initializeAnimationProps(), this._updateAnimationProps(), this._resizeCanvasDrawingBuffer(), this._resizeViewport()
         }
         _setDisplay(t) {
             this.display && (this.display.destroy(), this.display.animationLoop = null), t && (t.animationLoop = this), this.display = t
         }
         _requestAnimationFrame() {
-            this._running && (this._animationFrameId = Rf(this._animationFrame.bind(this)))
+            this._running && (this._animationFrameId = gy(this._animationFrame.bind(this)))
         }
         _cancelAnimationFrame() {
-            this._animationFrameId !== null && (Pf(this._animationFrameId), this._animationFrameId = null)
+            this._animationFrameId !== null && (_y(this._animationFrameId), this._animationFrameId = null)
         }
         _animationFrame() {
             this._running && (this.redraw(), this._requestAnimationFrame())
         }
         _renderFrame(t) {
             if (this.display) {
                 this.display._renderFrame(t);
@@ -13356,16 +13356,16 @@
         }
         _getSizeAndAspect() {
             if (!this.device) return {
                 width: 1,
                 height: 1,
                 aspect: 1
             };
-            let [t, r] = this.device?.canvasContext?.getPixelSize() || [1, 1], i = 1, s = this.device?.canvasContext?.canvas;
-            return s && s.clientHeight ? i = s.clientWidth / s.clientHeight : t > 0 && r > 0 && (i = t / r), {
+            let [t, r] = this.device?.canvasContext?.getPixelSize() || [1, 1], i = 1, n = this.device?.canvasContext?.canvas;
+            return n && n.clientHeight ? i = n.clientWidth / n.clientHeight : t > 0 && r > 0 && (i = t / r), {
                 width: t,
                 height: r,
                 aspect: i
             }
         }
         _resizeViewport() {
             this.props.autoResizeViewport && this.device.gl && this.device.gl.viewport(0, 0, this.device.gl.drawingBufferWidth, this.device.gl.drawingBufferHeight)
@@ -13387,24 +13387,24 @@
         _onMousemove(t) {
             t instanceof MouseEvent && (this._getAnimationProps()._mousePosition = [t.offsetX, t.offsetY])
         }
         _onMouseleave(t) {
             this._getAnimationProps()._mousePosition = null
         }
     };
-var Dc = class {
+var kd = class {
     constructor(t) {
-        p(this, "id");
-        p(this, "userData", {});
-        p(this, "topology");
-        p(this, "bufferLayout", []);
-        p(this, "vertexCount");
-        p(this, "indices");
-        p(this, "attributes");
-        this.id = t.id || Lt("geometry"), this.topology = t.topology, this.indices = t.indices || null, this.attributes = t.attributes, this.vertexCount = t.vertexCount, this.bufferLayout = t.bufferLayout || [], this.indices && Q(this.indices.usage === it.INDEX)
+        m(this, "id");
+        m(this, "userData", {});
+        m(this, "topology");
+        m(this, "bufferLayout", []);
+        m(this, "vertexCount");
+        m(this, "indices");
+        m(this, "attributes");
+        this.id = t.id || De("geometry"), this.topology = t.topology, this.indices = t.indices || null, this.attributes = t.attributes, this.vertexCount = t.vertexCount, this.bufferLayout = t.bufferLayout || [], this.indices && _t(this.indices.usage === Mt.INDEX)
     }
     destroy() {
         this.indices?.destroy();
         for (let t of Object.values(this.attributes)) t.destroy()
     }
     getVertexCount() {
         return this.vertexCount
@@ -13416,45 +13416,45 @@
         return this.indices
     }
     _calculateVertexCount(t) {
         return t.byteLength / 12
     }
 };
 
-function c0(e, t) {
-    if (t instanceof Dc) return t;
-    let r = Cv(e, t),
+function M1(e, t) {
+    if (t instanceof kd) return t;
+    let r = FF(e, t),
         {
             attributes: i,
-            bufferLayout: s
-        } = Iv(e, t);
-    return new Dc({
+            bufferLayout: n
+        } = DF(e, t);
+    return new kd({
         topology: t.topology || "triangle-list",
-        bufferLayout: s,
+        bufferLayout: n,
         vertexCount: t.vertexCount,
         indices: r,
         attributes: i
     })
 }
 
-function Cv(e, t) {
+function FF(e, t) {
     if (!t.indices) return;
     let r = t.indices.value;
     return e.createBuffer({
-        usage: it.INDEX,
+        usage: Mt.INDEX,
         data: r
     })
 }
 
-function Iv(e, t) {
+function DF(e, t) {
     let r = [],
         i = {};
-    for (let [n, o] of Object.entries(t.attributes)) {
-        let a = n;
-        switch (n) {
+    for (let [s, o] of Object.entries(t.attributes)) {
+        let a = s;
+        switch (s) {
             case "POSITION":
                 a = "positions";
                 break;
             case "NORMAL":
                 a = "normals";
                 break;
             case "TEXCOORD_0":
@@ -13462,58 +13462,58 @@
                 break;
             case "COLOR_0":
                 a = "colors";
                 break
         }
         i[a] = e.createBuffer({
             data: o.value,
-            id: `${n}-buffer`
+            id: `${s}-buffer`
         });
         let {
             value: c,
             size: l,
-            normalized: h
+            normalized: u
         } = o;
         r.push({
             name: a,
-            format: Sf(c, l, h)
+            format: dy(c, l, u)
         })
     }
-    let s = t._calculateVertexCount(t.attributes, t.indices);
+    let n = t._calculateVertexCount(t.attributes, t.indices);
     return {
         attributes: i,
         bufferLayout: r,
-        vertexCount: s
+        vertexCount: n
     }
 }
-var kc = class {
+var Ud = class {
     constructor(t) {
-        p(this, "modules");
-        p(this, "moduleUniforms");
-        p(this, "moduleBindings");
-        p(this, "moduleUniformsChanged");
-        let r = _i(Object.values(t));
-        O.log(1, "Creating ShaderInputs with modules", r.map(i => i.name))(), this.modules = t, this.moduleUniforms = {}, this.moduleBindings = {};
-        for (let [i, s] of Object.entries(t)) {
-            let n = i;
-            this.moduleUniforms[n] = s.defaultUniforms || {}, this.moduleBindings[n] = {}
+        m(this, "modules");
+        m(this, "moduleUniforms");
+        m(this, "moduleBindings");
+        m(this, "moduleUniformsChanged");
+        let r = fo(Object.values(t));
+        N.log(1, "Creating ShaderInputs with modules", r.map(i => i.name))(), this.modules = t, this.moduleUniforms = {}, this.moduleBindings = {};
+        for (let [i, n] of Object.entries(t)) {
+            let s = i;
+            this.moduleUniforms[s] = n.defaultUniforms || {}, this.moduleBindings[s] = {}
         }
     }
     destroy() {}
     setProps(t) {
         for (let r of Object.keys(t)) {
             let i = r,
-                s = t[i],
-                n = this.modules[i];
-            if (!n) {
-                O.warn(`Module ${r} not found`)();
+                n = t[i],
+                s = this.modules[i];
+            if (!s) {
+                N.warn(`Module ${r} not found`)();
                 continue
             }
             let o = this.moduleUniforms[i],
-                a = n.getUniforms?.(s, this.moduleUniforms[i]) || s;
+                a = s.getUniforms?.(n, this.moduleUniforms[i]) || n;
             this.moduleUniforms[i] = {
                 ...o,
                 ...a
             }
         }
     }
     getModules() {
@@ -13526,248 +13526,248 @@
         let t = {};
         for (let r of Object.values(this.moduleBindings)) Object.assign(t, r);
         return t
     }
     getDebugTable() {
         let t = {};
         for (let [r, i] of Object.entries(this.moduleUniforms))
-            for (let [s, n] of Object.entries(i)) t[`${r}.${s}`] = {
-                type: this.modules[r].uniformTypes?.[s],
-                value: String(n)
+            for (let [n, s] of Object.entries(i)) t[`${r}.${n}`] = {
+                type: this.modules[r].uniformTypes?.[n],
+                value: String(s)
             };
         return t
     }
 };
-var Bc = class Bc {
+var zd = class zd {
     constructor(t) {
-        p(this, "device");
-        p(this, "_hashCounter", 0);
-        p(this, "_hashes", {});
-        p(this, "_renderPipelineCache", {});
-        p(this, "_computePipelineCache", {});
+        m(this, "device");
+        m(this, "_hashCounter", 0);
+        m(this, "_hashes", {});
+        m(this, "_renderPipelineCache", {});
+        m(this, "_computePipelineCache", {});
         this.device = t
     }
     static getDefaultPipelineFactory(t) {
-        return t._lumaData.defaultPipelineFactory = t._lumaData.defaultPipelineFactory || new Bc(t), t._lumaData.defaultPipelineFactory
+        return t._lumaData.defaultPipelineFactory = t._lumaData.defaultPipelineFactory || new zd(t), t._lumaData.defaultPipelineFactory
     }
     createRenderPipeline(t) {
         let r = {
-                ...He.defaultProps,
+                ...Ui.defaultProps,
                 ...t
             },
             i = this._hashRenderPipeline(r);
         if (!this._renderPipelineCache[i]) {
-            let s = this.device.createRenderPipeline({
+            let n = this.device.createRenderPipeline({
                 ...r,
                 id: r.id ? `${r.id}-cached` : void 0
             });
-            s.hash = i, this._renderPipelineCache[i] = {
-                pipeline: s,
+            n.hash = i, this._renderPipelineCache[i] = {
+                pipeline: n,
                 useCount: 0
             }
         }
         return this._renderPipelineCache[i].useCount++, this._renderPipelineCache[i].pipeline
     }
     createComputePipeline(t) {
         let r = {
-                ...as.defaultProps,
+                ...Ea.defaultProps,
                 ...t
             },
             i = this._hashComputePipeline(r);
         if (!this._computePipelineCache[i]) {
-            let s = this.device.createComputePipeline({
+            let n = this.device.createComputePipeline({
                 ...r,
                 id: r.id ? `${r.id}-cached` : void 0
             });
-            s.hash = i, this._computePipelineCache[i] = {
-                pipeline: s,
+            n.hash = i, this._computePipelineCache[i] = {
+                pipeline: n,
                 useCount: 0
             }
         }
         return this._computePipelineCache[i].useCount++, this._computePipelineCache[i].pipeline
     }
     release(t) {
         let r = t.hash,
-            i = t instanceof as ? this._computePipelineCache : this._renderPipelineCache;
+            i = t instanceof Ea ? this._computePipelineCache : this._renderPipelineCache;
         i[r].useCount--, i[r].useCount === 0 && (i[r].pipeline.destroy(), delete i[r])
     }
     _hashComputePipeline(t) {
         return `${this._getHash(t.shader.source)}`
     }
     _hashRenderPipeline(t) {
         let r = this._getHash(t.vs.source),
             i = t.fs ? this._getHash(t.fs.source) : 0,
-            s = "-",
-            n = this._getHash(JSON.stringify(t.bufferLayout));
+            n = "-",
+            s = this._getHash(JSON.stringify(t.bufferLayout));
         switch (this.device.type) {
             case "webgl":
-                return `${r}/${i}V${s}BL${n}`;
+                return `${r}/${i}V${n}BL${s}`;
             default:
                 let o = this._getHash(JSON.stringify(t.parameters));
-                return `${r}/${i}V${s}T${t.topology}P${o}BL${n}`
+                return `${r}/${i}V${n}T${t.topology}P${o}BL${s}`
         }
     }
     _getHash(t) {
         return this._hashes[t] === void 0 && (this._hashes[t] = this._hashCounter++), this._hashes[t]
     }
 };
-p(Bc, "defaultProps", {
-    ...He.defaultProps
+m(zd, "defaultProps", {
+    ...Ui.defaultProps
 });
-var Lc = Bc;
-var Vc = class Vc {
+var Vd = zd;
+var jd = class jd {
     constructor(t) {
-        p(this, "device");
-        p(this, "_cache", {});
+        m(this, "device");
+        m(this, "_cache", {});
         this.device = t
     }
     static getDefaultShaderFactory(t) {
         var r;
-        return (r = t._lumaData).defaultShaderFactory || (r.defaultShaderFactory = new Vc(t)), t._lumaData.defaultShaderFactory
+        return (r = t._lumaData).defaultShaderFactory || (r.defaultShaderFactory = new jd(t)), t._lumaData.defaultShaderFactory
     }
     createShader(t) {
         let r = this._hashShader(t),
             i = this._cache[r];
         if (!i) {
-            let s = this.device.createShader({
+            let n = this.device.createShader({
                 ...t,
                 id: t.id ? `${t.id}-cached` : void 0
             });
             this._cache[r] = i = {
-                shader: s,
+                shader: n,
                 useCount: 0
             }
         }
         return i.useCount++, i.shader
     }
     release(t) {
         let r = this._hashShader(t),
             i = this._cache[r];
         i && (i.useCount--, i.useCount === 0 && (delete this._cache[r], i.shader.destroy()))
     }
     _hashShader(t) {
         return `${t.stage}:${t.source}`
     }
 };
-p(Vc, "defaultProps", {
-    ...bi.defaultProps
+m(jd, "defaultProps", {
+    ...go.defaultProps
 });
-var Uc = Vc;
+var Wd = jd;
 
-function l0(e, t) {
+function P1(e, t) {
     let r = {},
         i = "Values";
     if (e.attributes.length === 0 && !e.varyings?.length) return {
         "No attributes or varyings": {
             [i]: "N/A"
         }
     };
-    for (let s of e.attributes)
-        if (s) {
-            let n = `${s.location} ${s.name}: ${s.type}`;
-            r[`in ${n}`] = {
-                [i]: s.stepMode || "vertex"
-            }
-        } for (let s of e.varyings || []) {
-        let n = `${s.location} ${s.name}`;
-        r[`out ${n}`] = {
-            [i]: JSON.stringify(s.accessor)
+    for (let n of e.attributes)
+        if (n) {
+            let s = `${n.location} ${n.name}: ${n.type}`;
+            r[`in ${s}`] = {
+                [i]: n.stepMode || "vertex"
+            }
+        } for (let n of e.varyings || []) {
+        let s = `${n.location} ${n.name}`;
+        r[`out ${s}`] = {
+            [i]: JSON.stringify(n.accessor)
         }
     }
     return r
 }
-var vt = null,
-    ud = null;
+var be = null,
+    eb = null;
 
-function h0(e, {
+function C1(e, {
     id: t,
     minimap: r,
     opaque: i,
-    top: s = "0",
-    left: n = "0",
+    top: n = "0",
+    left: s = "0",
     rgbaScale: o = 1
 }) {
-    vt || (vt = document.createElement("canvas"), vt.id = t, vt.title = t, vt.style.zIndex = "100", vt.style.position = "absolute", vt.style.top = s, vt.style.left = n, vt.style.border = "blue 1px solid", vt.style.transform = "scaleY(-1)", document.body.appendChild(vt), ud = vt.getContext("2d")), (vt.width !== e.width || vt.height !== e.height) && (vt.width = e.width / 2, vt.height = e.height / 2, vt.style.width = "400px", vt.style.height = "400px");
+    be || (be = document.createElement("canvas"), be.id = t, be.title = t, be.style.zIndex = "100", be.style.position = "absolute", be.style.top = n, be.style.left = s, be.style.border = "blue 1px solid", be.style.transform = "scaleY(-1)", document.body.appendChild(be), eb = be.getContext("2d")), (be.width !== e.width || be.height !== e.height) && (be.width = e.width / 2, be.height = e.height / 2, be.style.width = "400px", be.style.height = "400px");
     let a = e.device.readPixelsToArrayWebGL(e),
-        c = ud.createImageData(e.width, e.height),
+        c = eb.createImageData(e.width, e.height),
         l = 0;
-    for (let h = 0; h < a.length; h += 4) c.data[l + h + 0] = a[h + 0] * o, c.data[l + h + 1] = a[h + 1] * o, c.data[l + h + 2] = a[h + 2] * o, c.data[l + h + 3] = i ? 255 : a[h + 3] * o;
-    ud.putImageData(c, 0, 0)
+    for (let u = 0; u < a.length; u += 4) c.data[l + u + 0] = a[u + 0] * o, c.data[l + u + 1] = a[u + 1] * o, c.data[l + u + 2] = a[u + 2] * o, c.data[l + u + 3] = i ? 255 : a[u + 3] * o;
+    eb.putImageData(c, 0, 0)
 }
-var ws = 2,
-    Ov = 1e4,
-    zc = class zc {
+var Ha = 2,
+    LF = 1e4,
+    Hd = class Hd {
         constructor(t, r) {
-            p(this, "device");
-            p(this, "id");
-            p(this, "source");
-            p(this, "vs");
-            p(this, "fs");
-            p(this, "pipelineFactory");
-            p(this, "shaderFactory");
-            p(this, "userData", {});
-            p(this, "parameters");
-            p(this, "topology");
-            p(this, "bufferLayout");
-            p(this, "vertexCount");
-            p(this, "instanceCount", 0);
-            p(this, "indexBuffer", null);
-            p(this, "bufferAttributes", {});
-            p(this, "constantAttributes", {});
-            p(this, "bindings", {});
-            p(this, "uniforms", {});
-            p(this, "vertexArray");
-            p(this, "transformFeedback", null);
-            p(this, "pipeline");
-            p(this, "shaderInputs");
-            p(this, "_uniformStore");
-            p(this, "_attributeInfos", {});
-            p(this, "_gpuGeometry", null);
-            p(this, "_getModuleUniforms");
-            p(this, "props");
-            p(this, "_pipelineNeedsUpdate", "newly created");
-            p(this, "_needsRedraw", "initializing");
-            p(this, "_destroyed", !1);
-            p(this, "_lastDrawTimestamp", -1);
-            p(this, "_lastLogTime", 0);
-            p(this, "_logOpen", !1);
-            p(this, "_drawCount", 0);
+            m(this, "device");
+            m(this, "id");
+            m(this, "source");
+            m(this, "vs");
+            m(this, "fs");
+            m(this, "pipelineFactory");
+            m(this, "shaderFactory");
+            m(this, "userData", {});
+            m(this, "parameters");
+            m(this, "topology");
+            m(this, "bufferLayout");
+            m(this, "vertexCount");
+            m(this, "instanceCount", 0);
+            m(this, "indexBuffer", null);
+            m(this, "bufferAttributes", {});
+            m(this, "constantAttributes", {});
+            m(this, "bindings", {});
+            m(this, "uniforms", {});
+            m(this, "vertexArray");
+            m(this, "transformFeedback", null);
+            m(this, "pipeline");
+            m(this, "shaderInputs");
+            m(this, "_uniformStore");
+            m(this, "_attributeInfos", {});
+            m(this, "_gpuGeometry", null);
+            m(this, "_getModuleUniforms");
+            m(this, "props");
+            m(this, "_pipelineNeedsUpdate", "newly created");
+            m(this, "_needsRedraw", "initializing");
+            m(this, "_destroyed", !1);
+            m(this, "_lastDrawTimestamp", -1);
+            m(this, "_lastLogTime", 0);
+            m(this, "_logOpen", !1);
+            m(this, "_drawCount", 0);
             var a;
             this.props = {
-                ...zc.defaultProps,
+                ...Hd.defaultProps,
                 ...r
-            }, r = this.props, this.id = r.id || Lt("model"), this.device = t, Object.assign(this.userData, r.userData);
+            }, r = this.props, this.id = r.id || De("model"), this.device = t, Object.assign(this.userData, r.userData);
             let i = Object.fromEntries(this.props.modules?.map(c => [c.name, c]) || []);
-            this.setShaderInputs(r.shaderInputs || new kc(i));
-            let s = Nv(t),
-                n = (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];
+            this.setShaderInputs(r.shaderInputs || new Ud(i));
+            let n = kF(t),
+                s = (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];
             if (this.device.type === "webgpu" && this.props.source) {
-                (a = this.props).shaderLayout || (a.shaderLayout = lu(this.props.source));
+                (a = this.props).shaderLayout || (a.shaderLayout = Jy(this.props.source));
                 let {
                     source: c,
                     getUniforms: l
                 } = this.props.shaderAssembler.assembleShader({
-                    platformInfo: s,
+                    platformInfo: n,
                     ...this.props,
-                    modules: n
+                    modules: s
                 });
                 this.source = c, this._getModuleUniforms = l
             } else {
                 let {
                     vs: c,
                     fs: l,
-                    getUniforms: h
+                    getUniforms: u
                 } = this.props.shaderAssembler.assembleShaderPair({
-                    platformInfo: s,
+                    platformInfo: n,
                     ...this.props,
-                    modules: n
+                    modules: s
                 });
-                this.vs = c, this.fs = l, this._getModuleUniforms = h
+                this.vs = c, this.fs = l, this._getModuleUniforms = u
             }
-            this.vertexCount = this.props.vertexCount, this.instanceCount = this.props.instanceCount, this.topology = this.props.topology, this.bufferLayout = this.props.bufferLayout, this.parameters = this.props.parameters, r.geometry && this.setGeometry(r.geometry), this.pipelineFactory = r.pipelineFactory || Lc.getDefaultPipelineFactory(this.device), this.shaderFactory = r.shaderFactory || Uc.getDefaultShaderFactory(this.device), this.pipeline = this._updatePipeline(), this.vertexArray = t.createVertexArray({
+            this.vertexCount = this.props.vertexCount, this.instanceCount = this.props.instanceCount, this.topology = this.props.topology, this.bufferLayout = this.props.bufferLayout, this.parameters = this.props.parameters, r.geometry && this.setGeometry(r.geometry), this.pipelineFactory = r.pipelineFactory || Vd.getDefaultPipelineFactory(this.device), this.shaderFactory = r.shaderFactory || Wd.getDefaultShaderFactory(this.device), this.pipeline = this._updatePipeline(), this.vertexArray = t.createVertexArray({
                 renderPipeline: this.pipeline
             }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry), r.vertexCount && this.setVertexCount(r.vertexCount), r.instanceCount && this.setInstanceCount(r.instanceCount), r.indexBuffer && this.setIndexBuffer(r.indexBuffer), r.attributes && this.setAttributes(r.attributes), r.constantAttributes && this.setConstantAttributes(r.constantAttributes), r.bindings && this.setBindings(r.bindings), r.uniforms && this.setUniforms(r.uniforms), r.moduleSettings && this.updateModuleSettings(r.moduleSettings), r.transformFeedback && (this.transformFeedback = r.transformFeedback), Object.seal(this)
         }
         destroy() {
             this._destroyed || (this.pipelineFactory.release(this.pipeline), this.shaderFactory.release(this.pipeline.vs), this.pipeline.fs && this.shaderFactory.release(this.pipeline.fs), this._uniformStore.destroy(), this._gpuGeometry?.destroy(), this._destroyed = !0)
         }
         needsRedraw() {
@@ -13783,57 +13783,57 @@
         }
         draw(t) {
             this.predraw();
             let r;
             try {
                 this._logDrawCallStart(), this.pipeline = this._updatePipeline(), this.pipeline.setBindings(this.bindings, {
                     disableWarnings: this.props.disableWarnings
-                }), Br(this.uniforms) || this.pipeline.setUniformsWebGL(this.uniforms);
+                }), ys(this.uniforms) || this.pipeline.setUniformsWebGL(this.uniforms);
                 let {
                     indexBuffer: i
-                } = this.vertexArray, s = i ? i.byteLength / (i.indexType === "uint32" ? 4 : 2) : void 0;
+                } = this.vertexArray, n = i ? i.byteLength / (i.indexType === "uint32" ? 4 : 2) : void 0;
                 r = this.pipeline.draw({
                     renderPass: t,
                     vertexArray: this.vertexArray,
                     vertexCount: this.vertexCount,
                     instanceCount: this.instanceCount,
-                    indexCount: s,
+                    indexCount: n,
                     transformFeedback: this.transformFeedback || void 0,
                     parameters: this.parameters,
                     topology: this.topology
                 })
             } finally {
                 this._logDrawCallEnd()
             }
             return this._logFramebuffer(t), r ? (this._lastDrawTimestamp = this.device.timestamp, this._needsRedraw = !1) : this._needsRedraw = "waiting for resource initialization", r
         }
         setGeometry(t) {
             this._gpuGeometry?.destroy();
-            let r = t && c0(this.device, t);
-            r && (this.setTopology(r.topology || "triangle-list"), this.bufferLayout = f0(r.bufferLayout, this.bufferLayout), this.vertexArray && this._setGeometryAttributes(r)), this._gpuGeometry = r
+            let r = t && M1(this.device, t);
+            r && (this.setTopology(r.topology || "triangle-list"), this.bufferLayout = O1(r.bufferLayout, this.bufferLayout), this.vertexArray && this._setGeometryAttributes(r)), this._gpuGeometry = r
         }
         setTopology(t) {
             t !== this.topology && (this.topology = t, this._setPipelineNeedsUpdate("topology"))
         }
         setBufferLayout(t) {
-            this.bufferLayout = this._gpuGeometry ? f0(t, this._gpuGeometry.bufferLayout) : t, this._setPipelineNeedsUpdate("bufferLayout"), this.pipeline = this._updatePipeline(), this.vertexArray = this.device.createVertexArray({
+            this.bufferLayout = this._gpuGeometry ? O1(t, this._gpuGeometry.bufferLayout) : t, this._setPipelineNeedsUpdate("bufferLayout"), this.pipeline = this._updatePipeline(), this.vertexArray = this.device.createVertexArray({
                 renderPipeline: this.pipeline
             }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry)
         }
         setParameters(t) {
-            kn(t, this.parameters, 2) || (this.parameters = t, this._setPipelineNeedsUpdate("parameters"))
+            Rl(t, this.parameters, 2) || (this.parameters = t, this._setPipelineNeedsUpdate("parameters"))
         }
         setVertexCount(t) {
             this.vertexCount = t, this.setNeedsRedraw("vertexCount")
         }
         setInstanceCount(t) {
             this.instanceCount = t, this.setNeedsRedraw("instanceCount")
         }
         setShaderInputs(t) {
-            this.shaderInputs = t, this._uniformStore = new On(this.shaderInputs.modules);
+            this.shaderInputs = t, this._uniformStore = new Sl(this.shaderInputs.modules);
             for (let r of Object.keys(this.shaderInputs.modules)) {
                 let i = this._uniformStore.getManagedUniformBuffer(this.device, r);
                 this.bindings[`${r}Uniforms`] = i
             }
             this.setNeedsRedraw("shaderInputs")
         }
         updateShaderInputs() {
@@ -13845,118 +13845,118 @@
         setTransformFeedback(t) {
             this.transformFeedback = t, this.setNeedsRedraw("transformFeedback")
         }
         setIndexBuffer(t) {
             this.vertexArray.setIndexBuffer(t), this.setNeedsRedraw("indexBuffer")
         }
         setAttributes(t, r) {
-            t.indices && O.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
-            for (let [i, s] of Object.entries(t)) {
-                let n = this.bufferLayout.find(c => u0(c).includes(i));
-                if (!n) {
-                    O.warn(`Model(${this.id}): Missing layout for buffer "${i}".`)();
+            t.indices && N.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
+            for (let [i, n] of Object.entries(t)) {
+                let s = this.bufferLayout.find(c => N1(c).includes(i));
+                if (!s) {
+                    N.warn(`Model(${this.id}): Missing layout for buffer "${i}".`)();
                     continue
                 }
-                let o = u0(n),
+                let o = N1(s),
                     a = !1;
                 for (let c of o) {
                     let l = this._attributeInfos[c];
-                    l && (this.vertexArray.setBuffer(l.location, s), a = !0)
-                }!a && !(r?.disableWarnings ?? this.props.disableWarnings) && O.warn(`Model(${this.id}): Ignoring buffer "${s.id}" for unknown attribute "${i}"`)()
+                    l && (this.vertexArray.setBuffer(l.location, n), a = !0)
+                }!a && !(r?.disableWarnings ?? this.props.disableWarnings) && N.warn(`Model(${this.id}): Ignoring buffer "${n.id}" for unknown attribute "${i}"`)()
             }
             this.setNeedsRedraw("attributes")
         }
         setConstantAttributes(t, r) {
-            for (let [i, s] of Object.entries(t)) {
-                let n = this._attributeInfos[i];
-                n ? this.vertexArray.setConstantWebGL(n.location, s) : (r?.disableWarnings ?? this.props.disableWarnings) || O.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${i}"`)()
+            for (let [i, n] of Object.entries(t)) {
+                let s = this._attributeInfos[i];
+                s ? this.vertexArray.setConstantWebGL(s.location, n) : (r?.disableWarnings ?? this.props.disableWarnings) || N.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${i}"`)()
             }
             this.setNeedsRedraw("constants")
         }
         setUniforms(t) {
-            Br(t) || (this.pipeline.setUniformsWebGL(t), Object.assign(this.uniforms, t)), this.setNeedsRedraw("uniforms")
+            ys(t) || (this.pipeline.setUniformsWebGL(t), Object.assign(this.uniforms, t)), this.setNeedsRedraw("uniforms")
         }
         updateModuleSettings(t) {
             let {
                 bindings: r,
                 uniforms: i
-            } = Fn(this._getModuleUniforms(t));
+            } = El(this._getModuleUniforms(t));
             Object.assign(this.bindings, r), Object.assign(this.uniforms, i), this.setNeedsRedraw("moduleSettings")
         }
         _getBindingsUpdateTimestamp() {
             let t = 0;
-            for (let r of Object.values(this.bindings)) r instanceof Ti ? t = Math.max(t, r.texture.updateTimestamp) : r instanceof it || r instanceof Tt ? t = Math.max(t, r.updateTimestamp) : r instanceof Ai || (t = Math.max(t, r.buffer.updateTimestamp));
+            for (let r of Object.values(this.bindings)) r instanceof mo ? t = Math.max(t, r.texture.updateTimestamp) : r instanceof Mt || r instanceof ae ? t = Math.max(t, r.updateTimestamp) : r instanceof _o || (t = Math.max(t, r.buffer.updateTimestamp));
             return t
         }
         _setGeometryAttributes(t) {
             let r = {
                 ...t.attributes
             };
-            for (let [i] of Object.entries(r)) !this.pipeline.shaderLayout.attributes.find(s => s.name === i) && i !== "positions" && delete r[i];
+            for (let [i] of Object.entries(r)) !this.pipeline.shaderLayout.attributes.find(n => n.name === i) && i !== "positions" && delete r[i];
             this.vertexCount = t.vertexCount, this.setIndexBuffer(t.indices || null), this.setAttributes(t.attributes, {
                 disableWarnings: !0
             }), this.setAttributes(r, {
                 disableWarnings: this.props.disableWarnings
             }), this.setNeedsRedraw("geometry attributes")
         }
         _setPipelineNeedsUpdate(t) {
             this._pipelineNeedsUpdate || (this._pipelineNeedsUpdate = t), this.setNeedsRedraw(t)
         }
         _updatePipeline() {
             if (this._pipelineNeedsUpdate) {
                 let t = null,
                     r = null;
-                this.pipeline && (O.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(), t = this.pipeline.vs, r = this.pipeline.fs), this._pipelineNeedsUpdate = !1;
+                this.pipeline && (N.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(), t = this.pipeline.vs, r = this.pipeline.fs), this._pipelineNeedsUpdate = !1;
                 let i = this.shaderFactory.createShader({
                         id: `${this.id}-vertex`,
                         stage: "vertex",
                         source: this.source || this.vs,
                         debug: this.props.debugShaders
                     }),
-                    s = null;
-                this.source ? s = i : this.fs && (s = this.shaderFactory.createShader({
+                    n = null;
+                this.source ? n = i : this.fs && (n = this.shaderFactory.createShader({
                     id: `${this.id}-fragment`,
                     stage: "fragment",
                     source: this.source || this.fs,
                     debug: this.props.debugShaders
                 })), this.pipeline = this.pipelineFactory.createRenderPipeline({
                     ...this.props,
                     bufferLayout: this.bufferLayout,
                     topology: this.topology,
                     parameters: this.parameters,
                     vs: i,
-                    fs: s
-                }), this._attributeInfos = Wa(this.pipeline.shaderLayout, this.bufferLayout), t && this.shaderFactory.release(t), r && this.shaderFactory.release(r)
+                    fs: n
+                }), this._attributeInfos = $h(this.pipeline.shaderLayout, this.bufferLayout), t && this.shaderFactory.release(t), r && this.shaderFactory.release(r)
             }
             return this.pipeline
         }
         _logDrawCallStart() {
-            let t = O.level > 3 ? 0 : Ov;
-            O.level < 2 || Date.now() - this._lastLogTime < t || (this._lastLogTime = Date.now(), this._logOpen = !0, O.group(ws, `>>> DRAWING MODEL ${this.id}`, {
-                collapsed: O.level <= 2
+            let t = N.level > 3 ? 0 : LF;
+            N.level < 2 || Date.now() - this._lastLogTime < t || (this._lastLogTime = Date.now(), this._logOpen = !0, N.group(Ha, `>>> DRAWING MODEL ${this.id}`, {
+                collapsed: N.level <= 2
             })())
         }
         _logDrawCallEnd() {
             if (this._logOpen) {
-                let t = l0(this.pipeline.shaderLayout, this.id);
-                O.table(ws, t)();
+                let t = P1(this.pipeline.shaderLayout, this.id);
+                N.table(Ha, t)();
                 let r = this.shaderInputs.getDebugTable();
-                for (let [s, n] of Object.entries(this.uniforms)) r[s] = {
-                    value: n
+                for (let [n, s] of Object.entries(this.uniforms)) r[n] = {
+                    value: s
                 };
-                O.table(ws, r)();
+                N.table(Ha, r)();
                 let i = this._getAttributeDebugTable();
-                O.table(ws, this._attributeInfos)(), O.table(ws, i)(), O.groupEnd(ws)(), this._logOpen = !1
+                N.table(Ha, this._attributeInfos)(), N.table(Ha, i)(), N.groupEnd(Ha)(), this._logOpen = !1
             }
         }
         _logFramebuffer(t) {
-            let r = O.get("framebuffer");
+            let r = N.get("framebuffer");
             if (this._drawCount++, !r || this._drawCount++ > 3 && this._drawCount % 60) return;
             let i = t.props.framebuffer;
-            i && h0(i, {
+            i && C1(i, {
                 id: i.id,
                 minimap: !0
             })
         }
         _getAttributeDebugTable() {
             let t = {};
             for (let [r, i] of Object.entries(this._attributeInfos)) t[i.location] = {
@@ -13973,20 +13973,20 @@
                     type: r.indexType,
                     values: i.toString()
                 }
             }
             return t
         }
         _getBufferOrConstantValues(t, r) {
-            let i = Nn(r);
-            return (t instanceof it ? new i(t.debugData) : t).toString()
+            let i = Al(r);
+            return (t instanceof Mt ? new i(t.debugData) : t).toString()
         }
     };
-p(zc, "defaultProps", {
-    ...He.defaultProps,
+m(Hd, "defaultProps", {
+    ...Ui.defaultProps,
     source: null,
     vs: null,
     fs: null,
     id: "unnamed",
     handle: void 0,
     userData: {},
     defines: {},
@@ -13997,50 +13997,50 @@
     attributes: {},
     constantAttributes: {},
     varyings: [],
     shaderInputs: void 0,
     pipelineFactory: void 0,
     shaderFactory: void 0,
     transformFeedback: void 0,
-    shaderAssembler: xi.getDefaultShaderAssembler(),
+    shaderAssembler: po.getDefaultShaderAssembler(),
     debugShaders: void 0,
     disableWarnings: void 0
 });
-var bt = zc;
+var ce = Hd;
 
-function f0(e, t) {
+function O1(e, t) {
     let r = [...e];
     for (let i of t) {
-        let s = r.findIndex(n => n.name === i.name);
-        s < 0 ? r.push(i) : r[s] = i
+        let n = r.findIndex(s => s.name === i.name);
+        n < 0 ? r.push(i) : r[n] = i
     }
     return r
 }
 
-function Nv(e) {
+function kF(e) {
     return {
         type: e.type,
         shaderLanguage: e.info.shadingLanguage,
         shaderLanguageVersion: e.info.shadingLanguageVersion,
         gpu: e.info.gpu,
         features: e.features
     }
 }
 
-function u0(e) {
+function N1(e) {
     return e.attributes ? e.attributes?.map(t => t.attribute) : [e.name]
 }
-var Oi = class e {
-    constructor(t, r = bt.defaultProps) {
-        p(this, "device");
-        p(this, "model");
-        p(this, "transformFeedback");
-        Q(e.isSupported(t), "BufferTransform not yet implemented on WebGPU"), this.device = t, this.model = new bt(this.device, {
+var Io = class e {
+    constructor(t, r = ce.defaultProps) {
+        m(this, "device");
+        m(this, "model");
+        m(this, "transformFeedback");
+        _t(e.isSupported(t), "BufferTransform not yet implemented on WebGPU"), this.device = t, this.model = new ce(this.device, {
             id: r.id || "buffer-transform-model",
-            fs: r.fs || mf(),
+            fs: r.fs || sy(),
             topology: r.topology || "point-list",
             ...r
         }), this.transformFeedback = this.device.createTransformFeedback({
             layout: this.model.pipeline.shaderLayout,
             buffers: r.feedbackBuffers
         }), this.model.setTransformFeedback(this.transformFeedback), Object.seal(this)
     }
@@ -14061,47 +14061,47 @@
         console.warn("TextureTransform#update() not implemented")
     }
     getBuffer(t) {
         return this.transformFeedback.getBuffer(t)
     }
     readAsync(t) {
         let r = this.getBuffer(t);
-        if (r instanceof it) return r.readAsync();
+        if (r instanceof Mt) return r.readAsync();
         let {
             buffer: i,
-            byteOffset: s = 0,
-            byteLength: n = i.byteLength
+            byteOffset: n = 0,
+            byteLength: s = i.byteLength
         } = r;
-        return i.readAsync(s, n)
+        return i.readAsync(n, s)
     }
 };
-var Qt = class {
+var er = class {
     constructor(t) {
-        p(this, "id");
-        p(this, "topology");
-        p(this, "vertexCount");
-        p(this, "indices");
-        p(this, "attributes");
-        p(this, "userData", {});
+        m(this, "id");
+        m(this, "topology");
+        m(this, "vertexCount");
+        m(this, "indices");
+        m(this, "attributes");
+        m(this, "userData", {});
         let {
             attributes: r = {},
             indices: i = null,
-            vertexCount: s = null
+            vertexCount: n = null
         } = t;
-        this.id = t.id || Lt("geometry"), this.topology = t.topology, i && (this.indices = ArrayBuffer.isView(i) ? {
+        this.id = t.id || De("geometry"), this.topology = t.topology, i && (this.indices = ArrayBuffer.isView(i) ? {
             value: i,
             size: 1
         } : i), this.attributes = {};
-        for (let [n, o] of Object.entries(r)) {
+        for (let [s, o] of Object.entries(r)) {
             let a = ArrayBuffer.isView(o) ? {
                 value: o
             } : o;
-            Q(ArrayBuffer.isView(a.value), `${this._print(n)}: must be typed array or object with value as typed array`), (n === "POSITION" || n === "positions") && !a.size && (a.size = 3), n === "indices" ? (Q(!this.indices), this.indices = a) : this.attributes[n] = a
+            _t(ArrayBuffer.isView(a.value), `${this._print(s)}: must be typed array or object with value as typed array`), (s === "POSITION" || s === "positions") && !a.size && (a.size = 3), s === "indices" ? (_t(!this.indices), this.indices = a) : this.attributes[s] = a
         }
-        this.indices && this.indices.isIndexed !== void 0 && (this.indices = Object.assign({}, this.indices), delete this.indices.isIndexed), this.vertexCount = s || this._calculateVertexCount(this.attributes, this.indices)
+        this.indices && this.indices.isIndexed !== void 0 && (this.indices = Object.assign({}, this.indices), delete this.indices.isIndexed), this.vertexCount = n || this._calculateVertexCount(this.attributes, this.indices)
     }
     getVertexCount() {
         return this.vertexCount
     }
     getAttributes() {
         return this.indices ? {
             indices: this.indices,
@@ -14113,81 +14113,81 @@
     }
     _setAttributes(t, r) {
         return this
     }
     _calculateVertexCount(t, r) {
         if (r) return r.value.length;
         let i = 1 / 0;
-        for (let s of Object.values(t)) {
+        for (let n of Object.values(t)) {
             let {
-                value: n,
+                value: s,
                 size: o,
                 constant: a
-            } = s;
-            !a && n && o >= 1 && (i = Math.min(i, n.length / o))
+            } = n;
+            !a && s && o >= 1 && (i = Math.min(i, s.length / o))
         }
-        return Q(Number.isFinite(i)), i
+        return _t(Number.isFinite(i)), i
     }
 };
-var Fv = {
+var UF = {
         blendColorOperation: "add",
         blendColorSrcFactor: "one",
         blendColorDstFactor: "zero",
         blendAlphaOperation: "add",
         blendAlphaSrcFactor: "constant-alpha",
         blendAlphaDstFactor: "zero"
     },
-    Ni = class extends dr {
+    Ro = class extends Tn {
         constructor() {
             super(...arguments), this._colorEncoderState = null
         }
         render(t) {
             return "pickingFBO" in t ? this._drawPickingBuffer(t) : super.render(t)
         }
         _drawPickingBuffer({
             layers: t,
             layerFilter: r,
             views: i,
-            viewports: s,
-            onViewportActive: n,
+            viewports: n,
+            onViewportActive: s,
             pickingFBO: o,
             deviceRect: {
                 x: a,
                 y: c,
                 width: l,
-                height: h
+                height: u
             },
             cullRect: f,
-            effects: u,
+            effects: h,
             pass: d = "picking",
-            pickZ: m,
+            pickZ: p,
             moduleParameters: y
         }) {
-            this.pickZ = m;
-            let x = this._resetColorEncoder(m),
-                A = [a, c, l, h],
-                v = super.render({
+            this.pickZ = p;
+            let b = this._resetColorEncoder(p),
+                T = [a, c, l, u],
+                I = super.render({
                     target: o,
                     layers: t,
                     layerFilter: r,
                     views: i,
-                    viewports: s,
-                    onViewportActive: n,
+                    viewports: n,
+                    onViewportActive: s,
                     cullRect: f,
-                    effects: u?.filter(R => R.useInPicking),
+                    effects: h?.filter(R => R.useInPicking),
                     pass: d,
                     isPicking: !0,
                     moduleParameters: y,
                     clearColor: [0, 0, 0, 0],
                     colorMask: 15,
-                    scissorRect: A
+                    scissorRect: T
                 });
             return this._colorEncoderState = null, {
-                decodePickingColor: x && kv.bind(null, x),
-                stats: v
+                decodePickingColor: b && zF.bind(null, b),
+                stats: I
             }
         }
         shouldDrawLayer(t) {
             let {
                 pickable: r,
                 operation: i
             } = t.props;
@@ -14199,96 +14199,96 @@
                     isActive: 1,
                     isAttribute: this.pickZ
                 },
                 lightSources: {}
             }
         }
         getLayerParameters(t, r, i) {
-            let s = {
+            let n = {
                     depthMask: !0,
                     depthTest: !0,
                     depthRange: [0, 1],
                     ...t.props.parameters
                 },
                 {
-                    pickable: n,
+                    pickable: s,
                     operation: o
                 } = t.props;
-            return !this._colorEncoderState || o.includes("terrain") ? s.blend = !1 : n && o.includes("draw") && (Object.assign(s, Fv), s.blend = !0, s.blendColor = Dv(this._colorEncoderState, t, i)), s
+            return !this._colorEncoderState || o.includes("terrain") ? n.blend = !1 : s && o.includes("draw") && (Object.assign(n, UF), n.blend = !0, n.blendColor = VF(this._colorEncoderState, t, i)), n
         }
         _resetColorEncoder(t) {
             return this._colorEncoderState = t ? null : {
                 byLayer: new Map,
                 byAlpha: []
             }, this._colorEncoderState
         }
     };
 
-function Dv(e, t, r) {
+function VF(e, t, r) {
     let {
         byLayer: i,
-        byAlpha: s
-    } = e, n, o = i.get(t);
-    return o ? (o.viewports.push(r), n = o.a) : (n = i.size + 1, n <= 255 ? (o = {
-        a: n,
+        byAlpha: n
+    } = e, s, o = i.get(t);
+    return o ? (o.viewports.push(r), s = o.a) : (s = i.size + 1, s <= 255 ? (o = {
+        a: s,
         layer: t,
         viewports: [r]
-    }, i.set(t, o), s[n] = o) : (j.warn("Too many pickable layers, only picking the first 255")(), n = 0)), [0, 0, 0, n / 255]
+    }, i.set(t, o), n[s] = o) : (Z.warn("Too many pickable layers, only picking the first 255")(), s = 0)), [0, 0, 0, s / 255]
 }
 
-function kv(e, t) {
+function zF(e, t) {
     let r = e.byAlpha[t[3]];
     return r && {
         pickedLayer: r.layer,
         pickedViewports: r.viewports,
         pickedObjectIndex: r.layer.decodePickingColor(t)
     }
 }
-var Yr = {
+var Is = {
         NO_STATE: "Awaiting state",
         MATCHED: "Matched. State transferred from previous layer",
         INITIALIZED: "Initialized",
         AWAITING_GC: "Discarded. Awaiting garbage collection",
         AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
         FINALIZED: "Finalized! Awaiting garbage collection"
     },
-    vs = Symbol.for("component"),
-    ye = Symbol.for("propTypes"),
-    Wc = Symbol.for("deprecatedProps"),
-    pr = Symbol.for("asyncPropDefaults"),
-    Ze = Symbol.for("asyncPropOriginal"),
-    Re = Symbol.for("asyncPropResolved");
+    $a = Symbol.for("component"),
+    Ur = Symbol.for("propTypes"),
+    $d = Symbol.for("deprecatedProps"),
+    vn = Symbol.for("asyncPropDefaults"),
+    Hi = Symbol.for("asyncPropOriginal"),
+    ii = Symbol.for("asyncPropResolved");
 
-function gr(e, t = () => !0) {
-    return Array.isArray(e) ? d0(e, t, []) : t(e) ? [e] : []
+function Sn(e, t = () => !0) {
+    return Array.isArray(e) ? B1(e, t, []) : t(e) ? [e] : []
 }
 
-function d0(e, t, r) {
+function B1(e, t, r) {
     let i = -1;
     for (; ++i < e.length;) {
-        let s = e[i];
-        Array.isArray(s) ? d0(s, t, r) : t(s) && r.push(s)
+        let n = e[i];
+        Array.isArray(n) ? B1(n, t, r) : t(n) && r.push(n)
     }
     return r
 }
 
-function dd({
+function rb({
     target: e,
     source: t,
     start: r = 0,
     count: i = 1
 }) {
-    let s = t.length,
-        n = i * s,
+    let n = t.length,
+        s = i * n,
         o = 0;
-    for (let a = r; o < s; o++) e[a++] = t[o];
-    for (; o < n;) o < n - o ? (e.copyWithin(r + o, r, r + o), o *= 2) : (e.copyWithin(r + o, r, r + n - o), o = n);
+    for (let a = r; o < n; o++) e[a++] = t[o];
+    for (; o < s;) o < s - o ? (e.copyWithin(r + o, r, r + o), o *= 2) : (e.copyWithin(r + o, r, r + s - o), o = s);
     return e
 }
-var io = class {
+var Zl = class {
     constructor(t, r, i) {
         this._loadCount = 0, this._subscribers = new Set, this.id = t, this.context = i, this.setData(r)
     }
     subscribe(t) {
         this._subscribers.add(t)
     }
     unsubscribe(t) {
@@ -14301,151 +14301,151 @@
     getData() {
         return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData())
     }
     setData(t, r) {
         if (t === this._data && !r) return;
         this._data = t;
         let i = ++this._loadCount,
-            s = t;
-        typeof t == "string" && (s = kr(t)), s instanceof Promise ? (this.isLoaded = !1, this._loader = s.then(n => {
-            this._loadCount === i && (this.isLoaded = !0, this._error = void 0, this._content = n)
-        }).catch(n => {
-            this._loadCount === i && (this.isLoaded = !0, this._error = n || !0)
+            n = t;
+        typeof t == "string" && (n = va(t)), n instanceof Promise ? (this.isLoaded = !1, this._loader = n.then(s => {
+            this._loadCount === i && (this.isLoaded = !0, this._error = void 0, this._content = s)
+        }).catch(s => {
+            this._loadCount === i && (this.isLoaded = !0, this._error = s || !0)
         })) : (this.isLoaded = !0, this._error = void 0, this._content = t);
-        for (let n of this._subscribers) n.onChange(this.getData())
+        for (let s of this._subscribers) s.onChange(this.getData())
     }
 };
-var so = class {
+var Kl = class {
     constructor(t) {
         this.protocol = t.protocol || "resource://", this._context = {
             device: t.device,
             gl: t.device?.gl,
             resourceManager: this
         }, this._resources = {}, this._consumers = {}, this._pruneRequest = null
     }
     contains(t) {
         return t.startsWith(this.protocol) ? !0 : t in this._resources
     }
     add({
         resourceId: t,
         data: r,
         forceUpdate: i = !1,
-        persistent: s = !0
+        persistent: n = !0
     }) {
-        let n = this._resources[t];
-        n ? n.setData(r, i) : (n = new io(t, r, this._context), this._resources[t] = n), n.persistent = s
+        let s = this._resources[t];
+        s ? s.setData(r, i) : (s = new Zl(t, r, this._context), this._resources[t] = s), s.persistent = n
     }
     remove(t) {
         let r = this._resources[t];
         r && (r.delete(), delete this._resources[t])
     }
     unsubscribe({
         consumerId: t
     }) {
         let r = this._consumers[t];
         if (r) {
             for (let i in r) {
-                let s = r[i],
-                    n = this._resources[s.resourceId];
-                n && n.unsubscribe(s)
+                let n = r[i],
+                    s = this._resources[n.resourceId];
+                s && s.unsubscribe(n)
             }
             delete this._consumers[t], this.prune()
         }
     }
     subscribe({
         resourceId: t,
         onChange: r,
         consumerId: i,
-        requestId: s = "default"
+        requestId: n = "default"
     }) {
         let {
-            _resources: n,
+            _resources: s,
             protocol: o
         } = this;
-        t.startsWith(o) && (t = t.replace(o, ""), n[t] || this.add({
+        t.startsWith(o) && (t = t.replace(o, ""), s[t] || this.add({
             resourceId: t,
             data: null,
             persistent: !1
         }));
-        let a = n[t];
-        if (this._track(i, s, a, r), a) return a.getData()
+        let a = s[t];
+        if (this._track(i, n, a, r), a) return a.getData()
     }
     prune() {
         this._pruneRequest || (this._pruneRequest = setTimeout(() => this._prune(), 0))
     }
     finalize() {
         for (let t in this._resources) this._resources[t].delete()
     }
-    _track(t, r, i, s) {
-        let n = this._consumers,
-            o = n[t] = n[t] || {},
+    _track(t, r, i, n) {
+        let s = this._consumers,
+            o = s[t] = s[t] || {},
             a = o[r],
             c = a && a.resourceId && this._resources[a.resourceId];
-        c && (c.unsubscribe(a), this.prune()), i && (a ? (a.onChange = s, a.resourceId = i.id) : a = {
-            onChange: s,
+        c && (c.unsubscribe(a), this.prune()), i && (a ? (a.onChange = n, a.resourceId = i.id) : a = {
+            onChange: n,
             resourceId: i.id
         }, o[r] = a, i.subscribe(a))
     }
     _prune() {
         this._pruneRequest = null;
         for (let t of Object.keys(this._resources)) {
             let r = this._resources[t];
             !r.persistent && !r.inUse() && (r.delete(), delete this._resources[t])
         }
     }
 };
-var Lv = "layerManager.setLayers",
-    Bv = "layerManager.activateViewport",
-    Rs = class {
+var WF = "layerManager.setLayers",
+    jF = "layerManager.activateViewport",
+    Xa = class {
         constructor(t, r) {
             this._lastRenderedLayers = [], this._needsRedraw = !1, this._needsUpdate = !1, this._nextLayers = null, this._debug = !1, this._defaultShaderModulesChanged = !1, this.activateViewport = a => {
-                pt(Bv, this, a), a && (this.context.viewport = a)
+                Qt(jF, this, a), a && (this.context.viewport = a)
             };
             let {
                 deck: i,
-                stats: s,
-                viewport: n,
+                stats: n,
+                viewport: s,
                 timeline: o
             } = r || {};
-            this.layers = [], this.resourceManager = new so({
+            this.layers = [], this.resourceManager = new Kl({
                 device: t,
                 protocol: "deck://"
             }), this.context = {
                 mousePosition: null,
                 userData: {},
                 layerManager: this,
                 device: t,
                 gl: t?.gl,
                 deck: i,
-                shaderAssembler: cd(),
+                shaderAssembler: G0(),
                 defaultShaderModules: [],
                 renderPass: void 0,
-                stats: s || new Xt({
+                stats: n || new Ke({
                     id: "deck.gl"
                 }),
-                viewport: n || new me({
+                viewport: s || new Lr({
                     id: "DEFAULT-INITIAL-VIEWPORT"
                 }),
-                timeline: o || new Ii,
+                timeline: o || new Eo,
                 resourceManager: this.resourceManager,
                 onError: void 0
             }, Object.seal(this)
         }
         finalize() {
             this.resourceManager.finalize();
             for (let t of this.layers) this._finalizeLayer(t)
         }
         needsRedraw(t = {
             clearRedrawFlags: !1
         }) {
             let r = this._needsRedraw;
             t.clearRedrawFlags && (this._needsRedraw = !1);
             for (let i of this.layers) {
-                let s = i.getNeedsRedraw(t);
-                r = r || s
+                let n = i.getNeedsRedraw(t);
+                r = r || n
             }
             return r
         }
         needsUpdate() {
             return this._nextLayers && this._nextLayers !== this._lastRenderedLayers ? "layers changed" : this._defaultShaderModulesChanged ? "shader modules changed" : this._needsUpdate
         }
         setNeedsRedraw(t) {
@@ -14459,17 +14459,17 @@
         } = {}) {
             return t ? this.layers.filter(r => t.find(i => r.id.indexOf(i) === 0)) : this.layers
         }
         setProps(t) {
             "debug" in t && (this._debug = t.debug), "userData" in t && (this.context.userData = t.userData), "layers" in t && (this._nextLayers = t.layers), "onError" in t && (this.context.onError = t.onError)
         }
         setLayers(t, r) {
-            pt(Lv, this, r, t), this._lastRenderedLayers = t;
-            let i = gr(t, Boolean);
-            for (let s of i) s.context = this.context;
+            Qt(WF, this, r, t), this._lastRenderedLayers = t;
+            let i = Sn(t, Boolean);
+            for (let n of i) n.context = this.context;
             this._updateLayers(this.layers, i)
         }
         updateLayers() {
             let t = this.needsUpdate();
             t && (this.setNeedsRedraw(`updating layers: ${t}`), this.setLayers(this._nextLayers || this._lastRenderedLayers, t)), this._nextLayers = null
         }
         addDefaultShaderModule(t) {
@@ -14477,106 +14477,106 @@
                 defaultShaderModules: r
             } = this.context;
             r.find(i => i.name === t.name) || (r.push(t), this._defaultShaderModulesChanged = !0)
         }
         removeDefaultShaderModule(t) {
             let {
                 defaultShaderModules: r
-            } = this.context, i = r.findIndex(s => s.name === t.name);
+            } = this.context, i = r.findIndex(n => n.name === t.name);
             i >= 0 && (r.splice(i, 1), this._defaultShaderModulesChanged = !0)
         }
         _handleError(t, r, i) {
             i.raiseError(r, `${t} of ${i}`)
         }
         _updateLayers(t, r) {
             let i = {};
-            for (let o of t) i[o.id] ? j.warn(`Multiple old layers with same id ${o.id}`)() : i[o.id] = o;
+            for (let o of t) i[o.id] ? Z.warn(`Multiple old layers with same id ${o.id}`)() : i[o.id] = o;
             if (this._defaultShaderModulesChanged) {
                 for (let o of t) o.setNeedsUpdate(), o.setChangeFlags({
                     extensionsChanged: !0
                 });
                 this._defaultShaderModulesChanged = !1
             }
-            let s = [];
-            this._updateSublayersRecursively(r, i, s), this._finalizeOldLayers(i);
-            let n = !1;
-            for (let o of s)
+            let n = [];
+            this._updateSublayersRecursively(r, i, n), this._finalizeOldLayers(i);
+            let s = !1;
+            for (let o of n)
                 if (o.hasUniformTransition()) {
-                    n = `Uniform transition in ${o}`;
+                    s = `Uniform transition in ${o}`;
                     break
-                } this._needsUpdate = n, this.layers = s
+                } this._needsUpdate = s, this.layers = n
         }
         _updateSublayersRecursively(t, r, i) {
-            for (let s of t) {
-                s.context = this.context;
-                let n = r[s.id];
-                n === null && j.warn(`Multiple new layers with same id ${s.id}`)(), r[s.id] = null;
+            for (let n of t) {
+                n.context = this.context;
+                let s = r[n.id];
+                s === null && Z.warn(`Multiple new layers with same id ${n.id}`)(), r[n.id] = null;
                 let o = null;
                 try {
-                    this._debug && n !== s && s.validateProps(), n ? (this._transferLayerState(n, s), this._updateLayer(s)) : this._initializeLayer(s), i.push(s), o = s.isComposite ? s.getSubLayers() : null
+                    this._debug && s !== n && n.validateProps(), s ? (this._transferLayerState(s, n), this._updateLayer(n)) : this._initializeLayer(n), i.push(n), o = n.isComposite ? n.getSubLayers() : null
                 } catch (a) {
-                    this._handleError("matching", a, s)
+                    this._handleError("matching", a, n)
                 }
                 o && this._updateSublayersRecursively(o, r, i)
             }
         }
         _finalizeOldLayers(t) {
             for (let r in t) {
                 let i = t[r];
                 i && this._finalizeLayer(i)
             }
         }
         _initializeLayer(t) {
             try {
-                t._initialize(), t.lifecycle = Yr.INITIALIZED
+                t._initialize(), t.lifecycle = Is.INITIALIZED
             } catch (r) {
                 this._handleError("initialization", r, t)
             }
         }
         _transferLayerState(t, r) {
-            r._transferState(t), r.lifecycle = Yr.MATCHED, r !== t && (t.lifecycle = Yr.AWAITING_GC)
+            r._transferState(t), r.lifecycle = Is.MATCHED, r !== t && (t.lifecycle = Is.AWAITING_GC)
         }
         _updateLayer(t) {
             try {
                 t._update()
             } catch (r) {
                 this._handleError("update", r, t)
             }
         }
         _finalizeLayer(t) {
-            this._needsRedraw = this._needsRedraw || `finalized ${t}`, t.lifecycle = Yr.AWAITING_FINALIZATION;
+            this._needsRedraw = this._needsRedraw || `finalized ${t}`, t.lifecycle = Is.AWAITING_FINALIZATION;
             try {
-                t._finalize(), t.lifecycle = Yr.FINALIZED
+                t._finalize(), t.lifecycle = Is.FINALIZED
             } catch (r) {
                 this._handleError("finalization", r, t)
             }
         }
     };
 
-function Ct(e, t, r) {
+function Se(e, t, r) {
     if (e === t) return !0;
     if (!r || !e || !t) return !1;
     if (Array.isArray(e)) {
         if (!Array.isArray(t) || e.length !== t.length) return !1;
         for (let i = 0; i < e.length; i++)
-            if (!Ct(e[i], t[i], r - 1)) return !1;
+            if (!Se(e[i], t[i], r - 1)) return !1;
         return !0
     }
     if (Array.isArray(t)) return !1;
     if (typeof e == "object" && typeof t == "object") {
         let i = Object.keys(e),
-            s = Object.keys(t);
-        if (i.length !== s.length) return !1;
-        for (let n of i)
-            if (!t.hasOwnProperty(n) || !Ct(e[n], t[n], r - 1)) return !1;
+            n = Object.keys(t);
+        if (i.length !== n.length) return !1;
+        for (let s of i)
+            if (!t.hasOwnProperty(s) || !Se(e[s], t[s], r - 1)) return !1;
         return !0
     }
     return !1
 }
-var no = class {
+var Gl = class {
     constructor(t) {
         this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = t.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = !1, this._needsRedraw = "First render", this._needsUpdate = "Initialize", this._eventManager = t.eventManager, this._eventCallbacks = {
             onViewStateChange: t.onViewStateChange,
             onInteractionStateChange: t.onInteractionStateChange
         }, Object.seal(this), this.setProps(t)
     }
     finalize() {
@@ -14619,21 +14619,21 @@
         return r ? r.filterViewState(i) : i
     }
     getViewport(t) {
         return this._viewportMap[t]
     }
     unproject(t, r) {
         let i = this.getViewports(),
-            s = {
+            n = {
                 x: t[0],
                 y: t[1]
             };
-        for (let n = i.length - 1; n >= 0; --n) {
-            let o = i[n];
-            if (o.containsPixel(s)) {
+        for (let s = i.length - 1; s >= 0; --s) {
+            let o = i[s];
+            if (o.containsPixel(n)) {
                 let a = t.slice();
                 return a[0] -= o.x, a[1] -= o.y, o.unproject(a, r)
             }
         }
         return null
     }
     setProps(t) {
@@ -14642,151 +14642,151 @@
     _update() {
         this._isUpdating = !0, this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._isUpdating = !1
     }
     _setSize(t, r) {
         (t !== this.width || r !== this.height) && (this.width = t, this.height = r, this.setNeedsUpdate("Size changed"))
     }
     _setViews(t) {
-        t = gr(t, Boolean), this._diffViews(t, this.views) && this.setNeedsUpdate("views changed"), this.views = t
+        t = Sn(t, Boolean), this._diffViews(t, this.views) && this.setNeedsUpdate("views changed"), this.views = t
     }
     _setViewState(t) {
-        t ? (!Ct(t, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = t) : j.warn("missing `viewState` or `initialViewState`")()
+        t ? (!Se(t, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = t) : Z.warn("missing `viewState` or `initialViewState`")()
     }
     _onViewStateChange(t, r) {
         this._eventCallbacks.onViewStateChange && this._eventCallbacks.onViewStateChange({
             ...r,
             viewId: t
         })
     }
     _createController(t, r) {
         let i = r.type;
         return new i({
             timeline: this.timeline,
             eventManager: this._eventManager,
             onViewStateChange: this._onViewStateChange.bind(this, r.id),
             onStateChange: this._eventCallbacks.onInteractionStateChange,
-            makeViewport: n => this.getView(t.id)?.makeViewport({
-                viewState: n,
+            makeViewport: s => this.getView(t.id)?.makeViewport({
+                viewState: s,
                 width: this.width,
                 height: this.height
             })
         })
     }
-    _updateController(t, r, i, s) {
-        let n = t.controller;
-        if (n && i) {
+    _updateController(t, r, i, n) {
+        let s = t.controller;
+        if (s && i) {
             let o = {
                 ...r,
-                ...n,
+                ...s,
                 id: t.id,
                 x: i.x,
                 y: i.y,
                 width: i.width,
                 height: i.height
             };
-            return (!s || s.constructor !== n.type) && (s = this._createController(t, o)), s && s.setProps(o), s
+            return (!n || n.constructor !== s.type) && (n = this._createController(t, o)), n && n.setProps(o), n
         }
         return null
     }
     _rebuildViewports() {
         let {
             views: t
         } = this, r = this.controllers;
         this._viewports = [], this.controllers = {};
         let i = !1;
-        for (let s = t.length; s--;) {
-            let n = t[s],
-                o = this.getViewState(n),
-                a = n.makeViewport({
+        for (let n = t.length; n--;) {
+            let s = t[n],
+                o = this.getViewState(s),
+                a = s.makeViewport({
                     viewState: o,
                     width: this.width,
                     height: this.height
                 }),
-                c = r[n.id],
-                l = !!n.controller;
-            l && !c && (i = !0), (i || !l) && c && (c.finalize(), c = null), this.controllers[n.id] = this._updateController(n, o, a, c), a && this._viewports.unshift(a)
-        }
-        for (let s in r) {
-            let n = r[s];
-            n && !this.controllers[s] && n.finalize()
+                c = r[s.id],
+                l = !!s.controller;
+            l && !c && (i = !0), (i || !l) && c && (c.finalize(), c = null), this.controllers[s.id] = this._updateController(s, o, a, c), a && this._viewports.unshift(a)
+        }
+        for (let n in r) {
+            let s = r[n];
+            s && !this.controllers[n] && s.finalize()
         }
         this._buildViewportMap()
     }
     _buildViewportMap() {
         this._viewportMap = {}, this._viewports.forEach(t => {
             t.id && (this._viewportMap[t.id] = this._viewportMap[t.id] || t)
         })
     }
     _diffViews(t, r) {
-        return t.length !== r.length ? !0 : t.some((i, s) => !t[s].equals(r[s]))
+        return t.length !== r.length ? !0 : t.some((i, n) => !t[n].equals(r[n]))
     }
 };
-var Uv = /([0-9]+\.?[0-9]*)(%|px)/;
+var HF = /([0-9]+\.?[0-9]*)(%|px)/;
 
-function mr(e) {
+function An(e) {
     switch (typeof e) {
         case "number":
             return {
                 position: e, relative: !1
             };
         case "string":
-            let t = Uv.exec(e);
+            let t = HF.exec(e);
             if (t && t.length >= 3) {
                 let r = t[2] === "%",
                     i = parseFloat(t[1]);
                 return {
                     position: r ? i / 100 : i,
                     relative: r
                 }
             }
         default:
             throw new Error(`Could not parse position string ${e}`)
     }
 }
 
-function _r(e, t) {
+function En(e, t) {
     return e.relative ? Math.round(e.position * t) : e.position
 }
-var qr = class {
+var Rs = class {
     constructor(t = {}) {
         let {
             id: r,
             x: i = 0,
-            y: s = 0,
-            width: n = "100%",
+            y: n = 0,
+            width: s = "100%",
             height: o = "100%",
             padding: a = null
         } = t;
         this.id = r || this.constructor.displayName || "view", this.props = {
             ...t,
             id: this.id
-        }, this._x = mr(i), this._y = mr(s), this._width = mr(n), this._height = mr(o), this._padding = a && {
-            left: mr(a.left || 0),
-            right: mr(a.right || 0),
-            top: mr(a.top || 0),
-            bottom: mr(a.bottom || 0)
+        }, this._x = An(i), this._y = An(n), this._width = An(s), this._height = An(o), this._padding = a && {
+            left: An(a.left || 0),
+            right: An(a.right || 0),
+            top: An(a.top || 0),
+            bottom: An(a.bottom || 0)
         }, this.equals = this.equals.bind(this), Object.seal(this)
     }
     equals(t) {
-        return this === t ? !0 : this.ViewportType === t.ViewportType && Ct(this.props, t.props, 2)
+        return this === t ? !0 : this.ViewportType === t.ViewportType && Se(this.props, t.props, 2)
     }
     makeViewport({
         width: t,
         height: r,
         viewState: i
     }) {
         i = this.filterViewState(i);
-        let s = this.getDimensions({
+        let n = this.getDimensions({
             width: t,
             height: r
         });
-        return !s.height || !s.width ? null : new this.ViewportType({
+        return !n.height || !n.width ? null : new this.ViewportType({
             ...i,
             ...this.props,
-            ...s
+            ...n
         })
     }
     getViewStateId() {
         let {
             viewState: t
         } = this.props;
         return typeof t == "string" ? t : t?.id || this.id
@@ -14803,39 +14803,39 @@
         return t
     }
     getDimensions({
         width: t,
         height: r
     }) {
         let i = {
-            x: _r(this._x, t),
-            y: _r(this._y, r),
-            width: _r(this._width, t),
-            height: _r(this._height, r)
+            x: En(this._x, t),
+            y: En(this._y, r),
+            width: En(this._width, t),
+            height: En(this._height, r)
         };
         return this._padding && (i.padding = {
-            left: _r(this._padding.left, t),
-            top: _r(this._padding.top, r),
-            right: _r(this._padding.right, t),
-            bottom: _r(this._padding.bottom, r)
+            left: En(this._padding.left, t),
+            top: En(this._padding.top, r),
+            right: En(this._padding.right, t),
+            bottom: En(this._padding.bottom, r)
         }), i
     }
     get controller() {
         let t = this.props.controller;
         return t ? t === !0 ? {
             type: this.ControllerType
         } : typeof t == "function" ? {
             type: t
         } : {
             type: this.ControllerType,
             ...t
         } : null
     }
 };
-var Pe = class {
+var ni = class {
     constructor(t) {
         this._inProgress = !1, this._handle = null, this.time = 0, this.settings = {
             duration: 0
         }, this._timeline = t
     }
     get inProgress() {
         return this._inProgress
@@ -14861,67 +14861,67 @@
                 duration: r.duration
             })
         }
         return this.time = this._timeline.getTime(this._handle), this._onUpdate(), this.settings.onUpdate?.(this), this._timeline.isFinished(this._handle) && this.end(), !0
     }
     _onUpdate() {}
 };
-var p0 = () => {},
-    jc = {
+var F1 = () => {},
+    Xd = {
         BREAK: 1,
         SNAP_TO_END: 2,
         IGNORE: 3
     },
-    Vv = e => e,
-    zv = jc.BREAK,
-    oo = class {
+    $F = e => e,
+    XF = Xd.BREAK,
+    Jl = class {
         constructor(t) {
             this._onTransitionUpdate = r => {
                 let {
                     time: i,
                     settings: {
-                        interpolator: s,
-                        startProps: n,
+                        interpolator: n,
+                        startProps: s,
                         endProps: o,
                         duration: a,
                         easing: c
                     }
-                } = r, l = c(i / a), h = s.interpolateProps(n, o, l);
+                } = r, l = c(i / a), u = n.interpolateProps(s, o, l);
                 this.propsInTransition = this.getControllerState({
                     ...this.props,
-                    ...h
+                    ...u
                 }).getViewportProps(), this.onViewStateChange({
                     viewState: this.propsInTransition,
                     oldViewState: this.props
                 })
-            }, this.getControllerState = t.getControllerState, this.propsInTransition = null, this.transition = new Pe(t.timeline), this.onViewStateChange = t.onViewStateChange || p0, this.onStateChange = t.onStateChange || p0
+            }, this.getControllerState = t.getControllerState, this.propsInTransition = null, this.transition = new ni(t.timeline), this.onViewStateChange = t.onViewStateChange || F1, this.onStateChange = t.onStateChange || F1
         }
         finalize() {
             this.transition.cancel()
         }
         getViewportInTransition() {
             return this.propsInTransition
         }
         processViewStateChange(t) {
             let r = !1,
                 i = this.props;
             if (this.props = t, !i || this._shouldIgnoreViewportChange(i, t)) return !1;
             if (this._isTransitionEnabled(t)) {
-                let s = i;
+                let n = i;
                 if (this.transition.inProgress) {
                     let {
-                        interruption: n,
+                        interruption: s,
                         endProps: o
                     } = this.transition.settings;
-                    s = {
+                    n = {
                         ...i,
-                        ...n === jc.SNAP_TO_END ? o : this.propsInTransition || i
+                        ...s === Xd.SNAP_TO_END ? o : this.propsInTransition || i
                     }
                 }
-                this._triggerTransition(s, t), r = !0
+                this._triggerTransition(n, t), r = !0
             } else this.transition.cancel();
             return r
         }
         updateTransition() {
             this.transition.update()
         }
         _isTransitionEnabled(t) {
@@ -14931,29 +14931,29 @@
             } = t;
             return (r > 0 || r === "auto") && !!i
         }
         _isUpdateDueToCurrentTransition(t) {
             return this.transition.inProgress && this.propsInTransition ? this.transition.settings.interpolator.arePropsEqual(t, this.propsInTransition) : !1
         }
         _shouldIgnoreViewportChange(t, r) {
-            return this.transition.inProgress ? this.transition.settings.interruption === jc.IGNORE || this._isUpdateDueToCurrentTransition(r) : this._isTransitionEnabled(r) ? r.transitionInterpolator.arePropsEqual(t, r) : !0
+            return this.transition.inProgress ? this.transition.settings.interruption === Xd.IGNORE || this._isUpdateDueToCurrentTransition(r) : this._isTransitionEnabled(r) ? r.transitionInterpolator.arePropsEqual(t, r) : !0
         }
         _triggerTransition(t, r) {
             let i = this.getControllerState(t),
-                s = this.getControllerState(r).shortestPathFrom(i),
-                n = r.transitionInterpolator,
-                o = n.getDuration ? n.getDuration(t, r) : r.transitionDuration;
+                n = this.getControllerState(r).shortestPathFrom(i),
+                s = r.transitionInterpolator,
+                o = s.getDuration ? s.getDuration(t, r) : r.transitionDuration;
             if (o === 0) return;
-            let a = n.initializeProps(t, s);
+            let a = s.initializeProps(t, n);
             this.propsInTransition = {};
             let c = {
                 duration: o,
-                easing: r.transitionEasing || Vv,
-                interpolator: n,
-                interruption: r.transitionInterruption || zv,
+                easing: r.transitionEasing || $F,
+                interpolator: s,
+                interruption: r.transitionInterruption || XF,
                 startProps: a.start,
                 endProps: a.end,
                 onStart: r.onTransitionStart,
                 onUpdate: this._onTransitionUpdate,
                 onInterrupt: this._onTransitionEnd(r.onTransitionInterrupt),
                 onEnd: this._onTransitionEnd(r.onTransitionEnd)
             };
@@ -14969,115 +14969,115 @@
                     isPanning: !1,
                     isRotating: !1
                 }), t?.(r)
             }
         }
     };
 
-function lt(e, t) {
+function Ht(e, t) {
     if (!e) throw new Error(t || "deck.gl: assertion failed.")
 }
-var Ps = class {
+var Ya = class {
     constructor(t) {
         let {
             compare: r,
             extract: i,
-            required: s
+            required: n
         } = t;
-        this._propsToCompare = r, this._propsToExtract = i || r, this._requiredProps = s
+        this._propsToCompare = r, this._propsToExtract = i || r, this._requiredProps = n
     }
     arePropsEqual(t, r) {
         for (let i of this._propsToCompare)
-            if (!(i in t) || !(i in r) || !Bt(t[i], r[i])) return !1;
+            if (!(i in t) || !(i in r) || !Le(t[i], r[i])) return !1;
         return !0
     }
     initializeProps(t, r) {
         let i = {},
-            s = {};
-        for (let n of this._propsToExtract)(n in t || n in r) && (i[n] = t[n], s[n] = r[n]);
-        return this._checkRequiredProps(i), this._checkRequiredProps(s), {
+            n = {};
+        for (let s of this._propsToExtract)(s in t || s in r) && (i[s] = t[s], n[s] = r[s]);
+        return this._checkRequiredProps(i), this._checkRequiredProps(n), {
             start: i,
-            end: s
+            end: n
         }
     }
     getDuration(t, r) {
         return r.transitionDuration
     }
     _checkRequiredProps(t) {
         this._requiredProps && this._requiredProps.forEach(r => {
             let i = t[r];
-            lt(Number.isFinite(i) || Array.isArray(i), `${r} is required for transition`)
+            Ht(Number.isFinite(i) || Array.isArray(i), `${r} is required for transition`)
         })
     }
 };
-var Wv = ["longitude", "latitude", "zoom", "bearing", "pitch"],
-    jv = ["longitude", "latitude", "zoom"],
-    Ke = class extends Ps {
+var YF = ["longitude", "latitude", "zoom", "bearing", "pitch"],
+    qF = ["longitude", "latitude", "zoom"],
+    $i = class extends Ya {
         constructor(t = {}) {
             let r = Array.isArray(t) ? t : t.transitionProps,
                 i = Array.isArray(t) ? {} : t;
             i.transitionProps = Array.isArray(r) ? {
                 compare: r,
                 required: r
             } : r || {
-                compare: Wv,
-                required: jv
+                compare: YF,
+                required: qF
             }, super(i.transitionProps), this.opts = i
         }
         initializeProps(t, r) {
             let i = super.initializeProps(t, r),
                 {
-                    makeViewport: s,
-                    around: n
+                    makeViewport: n,
+                    around: s
                 } = this.opts;
-            if (s && n) {
-                let o = s(t),
-                    a = s(r),
-                    c = o.unproject(n);
-                i.start.around = n, Object.assign(i.end, {
+            if (n && s) {
+                let o = n(t),
+                    a = n(r),
+                    c = o.unproject(s);
+                i.start.around = s, Object.assign(i.end, {
                     around: a.project(c),
                     aroundPosition: c,
                     width: r.width,
                     height: r.height
                 })
             }
             return i
         }
         interpolateProps(t, r, i) {
-            let s = {};
-            for (let n of this._propsToExtract) s[n] = Ee(t[n] || 0, r[n] || 0, i);
+            let n = {};
+            for (let s of this._propsToExtract) n[s] = Qr(t[s] || 0, r[s] || 0, i);
             if (r.aroundPosition && this.opts.makeViewport) {
-                let n = this.opts.makeViewport({
+                let s = this.opts.makeViewport({
                     ...r,
-                    ...s
+                    ...n
                 });
-                Object.assign(s, n.panByPosition(r.aroundPosition, Ee(t.around, r.around, i)))
+                Object.assign(n, s.panByPosition(r.aroundPosition, Qr(t.around, r.around, i)))
             }
-            return s
+            return n
         }
     };
-var Zr = {
+var Ms = {
         transitionDuration: 0
     },
-    Hv = 300,
-    Hc = e => 1 - (1 - e) * (1 - e),
-    Ms = {
+    ZF = 300,
+    Yd = e => 1 - (1 - e) * (1 - e),
+    qa = {
         WHEEL: ["wheel"],
         PAN: ["panstart", "panmove", "panend"],
         PINCH: ["pinchstart", "pinchmove", "pinchend"],
         TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
         DOUBLE_TAP: ["doubletap"],
         KEYBOARD: ["keydown"]
     },
-    Fi = {},
-    Kr = class {
+    Mo = {},
+    Ps = class {
         constructor(t) {
             this.state = {}, this._events = {}, this._interactionState = {
                 isDragging: !1
-            }, this._customEvents = [], this._eventStartBlocked = null, this._panMove = !1, this.invertPan = !1, this.dragMode = "rotate", this.inertia = 0, this.scrollZoom = !0, this.dragPan = !0, this.dragRotate = !0, this.doubleClickZoom = !0, this.touchZoom = !0, this.touchRotate = !1, this.keyboard = !0, this.transitionManager = new oo({
+            }, this._customEvents = [], this._eventStartBlocked = null, this._panMove = !1, this.invertPan = !1, this.dragMode = "rotate", this.inertia = 0, this.scrollZoom = !0, this.dragPan = !0, this.dragRotate = !0, this.doubleClickZoom = !0, this.touchZoom = !0, this.touchRotate = !1, this.keyboard = !0, this.transitionManager = new Jl({
                 ...t,
                 getControllerState: r => new this.ControllerState(r),
                 onViewStateChange: this._onTransition.bind(this),
                 onStateChange: this._setInteractionState.bind(this)
             }), this.handleEvent = this.handleEvent.bind(this), this.eventManager = t.eventManager, this.onViewStateChange = t.onViewStateChange || (() => {}), this.onStateChange = t.onStateChange || (() => {}), this.makeViewport = t.makeViewport
         }
         set events(t) {
@@ -15127,26 +15127,26 @@
             }), this._controllerState
         }
         getCenter(t) {
             let {
                 x: r,
                 y: i
             } = this.props, {
-                offsetCenter: s
+                offsetCenter: n
             } = t;
-            return [s.x - r, s.y - i]
+            return [n.x - r, n.y - i]
         }
         isPointInBounds(t, r) {
             let {
                 width: i,
-                height: s
+                height: n
             } = this.props;
             if (r && r.handled) return !1;
-            let n = t[0] >= 0 && t[0] <= i && t[1] >= 0 && t[1] <= s;
-            return n && r && r.stopPropagation(), n
+            let s = t[0] >= 0 && t[0] <= i && t[1] >= 0 && t[1] <= n;
+            return s && r && r.stopPropagation(), s
         }
         isFunctionKeyPressed(t) {
             let {
                 srcEvent: r
             } = t;
             return !!(r.metaKey || r.altKey || r.ctrlKey || r.shiftKey)
         }
@@ -15160,44 +15160,44 @@
             this._eventStartBlocked = r
         }
         setProps(t) {
             t.dragMode && (this.dragMode = t.dragMode), this.props = t, "transitionInterpolator" in t || (t.transitionInterpolator = this._getTransitionProps().transitionInterpolator), this.transitionManager.processViewStateChange(t);
             let {
                 inertia: r
             } = t;
-            this.inertia = Number.isFinite(r) ? r : r === !0 ? Hv : 0;
+            this.inertia = Number.isFinite(r) ? r : r === !0 ? ZF : 0;
             let {
                 scrollZoom: i = !0,
-                dragPan: s = !0,
-                dragRotate: n = !0,
+                dragPan: n = !0,
+                dragRotate: s = !0,
                 doubleClickZoom: o = !0,
                 touchZoom: a = !0,
                 touchRotate: c = !1,
                 keyboard: l = !0
-            } = t, h = !!this.onViewStateChange;
-            this.toggleEvents(Ms.WHEEL, h && i), this.toggleEvents(Ms.PAN, h), this.toggleEvents(Ms.PINCH, h && (a || c)), this.toggleEvents(Ms.TRIPLE_PAN, h && c), this.toggleEvents(Ms.DOUBLE_TAP, h && o), this.toggleEvents(Ms.KEYBOARD, h && l), this.scrollZoom = i, this.dragPan = s, this.dragRotate = n, this.doubleClickZoom = o, this.touchZoom = a, this.touchRotate = c, this.keyboard = l
+            } = t, u = !!this.onViewStateChange;
+            this.toggleEvents(qa.WHEEL, u && i), this.toggleEvents(qa.PAN, u), this.toggleEvents(qa.PINCH, u && (a || c)), this.toggleEvents(qa.TRIPLE_PAN, u && c), this.toggleEvents(qa.DOUBLE_TAP, u && o), this.toggleEvents(qa.KEYBOARD, u && l), this.scrollZoom = i, this.dragPan = n, this.dragRotate = s, this.doubleClickZoom = o, this.touchZoom = a, this.touchRotate = c, this.keyboard = l
         }
         updateTransition() {
             this.transitionManager.updateTransition()
         }
         toggleEvents(t, r) {
             this.eventManager && t.forEach(i => {
                 this._events[i] !== r && (this._events[i] = r, r ? this.eventManager.on(i, this.handleEvent) : this.eventManager.off(i, this.handleEvent))
             })
         }
         updateViewport(t, r = null, i = {}) {
-            let s = {
+            let n = {
                     ...t.getViewportProps(),
                     ...r
                 },
-                n = this.controllerState !== t;
-            if (this.state = t.getState(), this._setInteractionState(i), n) {
+                s = this.controllerState !== t;
+            if (this.state = t.getState(), this._setInteractionState(i), s) {
                 let o = this.controllerState && this.controllerState.getViewportProps();
                 this.onViewStateChange && this.onViewStateChange({
-                    viewState: s,
+                    viewState: n,
                     interactionState: this._interactionState,
                     oldViewState: o
                 })
             }
         }
         _onTransition(t) {
             this.onViewStateChange({
@@ -15209,18 +15209,18 @@
             Object.assign(this._interactionState, t), this.onStateChange(this._interactionState)
         }
         _onPanStart(t) {
             let r = this.getCenter(t);
             if (!this.isPointInBounds(r, t)) return !1;
             let i = this.isFunctionKeyPressed(t) || t.rightButton || !1;
             (this.invertPan || this.dragMode === "pan") && (i = !i);
-            let s = this.controllerState[i ? "panStart" : "rotateStart"]({
+            let n = this.controllerState[i ? "panStart" : "rotateStart"]({
                 pos: r
             });
-            return this._panMove = i, this.updateViewport(s, Zr, {
+            return this._panMove = i, this.updateViewport(n, Ms, {
                 isDragging: !0
             }), !0
         }
         _onPan(t) {
             return this.isDragging() ? this._panMove ? this._onPanMove(t) : this._onPanRotate(t) : !1
         }
         _onPanEnd(t) {
@@ -15228,33 +15228,33 @@
         }
         _onPanMove(t) {
             if (!this.dragPan) return !1;
             let r = this.getCenter(t),
                 i = this.controllerState.pan({
                     pos: r
                 });
-            return this.updateViewport(i, Zr, {
+            return this.updateViewport(i, Ms, {
                 isDragging: !0,
                 isPanning: !0
             }), !0
         }
         _onPanMoveEnd(t) {
             let {
                 inertia: r
             } = this;
             if (this.dragPan && r && t.velocity) {
                 let i = this.getCenter(t),
-                    s = [i[0] + t.velocityX * r / 2, i[1] + t.velocityY * r / 2],
-                    n = this.controllerState.pan({
-                        pos: s
+                    n = [i[0] + t.velocityX * r / 2, i[1] + t.velocityY * r / 2],
+                    s = this.controllerState.pan({
+                        pos: n
                     }).panEnd();
-                this.updateViewport(n, {
+                this.updateViewport(s, {
                     ...this._getTransitionProps(),
                     transitionDuration: r,
-                    transitionEasing: Hc
+                    transitionEasing: Yd
                 }, {
                     isDragging: !1,
                     isPanning: !0
                 })
             } else {
                 let i = this.controllerState.panEnd();
                 this.updateViewport(i, null, {
@@ -15266,33 +15266,33 @@
         }
         _onPanRotate(t) {
             if (!this.dragRotate) return !1;
             let r = this.getCenter(t),
                 i = this.controllerState.rotate({
                     pos: r
                 });
-            return this.updateViewport(i, Zr, {
+            return this.updateViewport(i, Ms, {
                 isDragging: !0,
                 isRotating: !0
             }), !0
         }
         _onPanRotateEnd(t) {
             let {
                 inertia: r
             } = this;
             if (this.dragRotate && r && t.velocity) {
                 let i = this.getCenter(t),
-                    s = [i[0] + t.velocityX * r / 2, i[1] + t.velocityY * r / 2],
-                    n = this.controllerState.rotate({
-                        pos: s
+                    n = [i[0] + t.velocityX * r / 2, i[1] + t.velocityY * r / 2],
+                    s = this.controllerState.rotate({
+                        pos: n
                     }).rotateEnd();
-                this.updateViewport(n, {
+                this.updateViewport(s, {
                     ...this._getTransitionProps(),
                     transitionDuration: r,
-                    transitionEasing: Hc
+                    transitionEasing: Yd
                 }, {
                     isDragging: !1,
                     isRotating: !0
                 })
             } else {
                 let i = this.controllerState.rotateEnd();
                 this.updateViewport(i, null, {
@@ -15305,70 +15305,70 @@
         _onWheel(t) {
             if (!this.scrollZoom) return !1;
             let r = this.getCenter(t);
             if (!this.isPointInBounds(r, t)) return !1;
             t.srcEvent.preventDefault();
             let {
                 speed: i = .01,
-                smooth: s = !1
+                smooth: n = !1
             } = this.scrollZoom === !0 ? {} : this.scrollZoom, {
-                delta: n
-            } = t, o = 2 / (1 + Math.exp(-Math.abs(n * i)));
-            n < 0 && o !== 0 && (o = 1 / o);
+                delta: s
+            } = t, o = 2 / (1 + Math.exp(-Math.abs(s * i)));
+            s < 0 && o !== 0 && (o = 1 / o);
             let a = this.controllerState.zoom({
                 pos: r,
                 scale: o
             });
             return this.updateViewport(a, {
                 ...this._getTransitionProps({
                     around: r
                 }),
-                transitionDuration: s ? 250 : 1
+                transitionDuration: n ? 250 : 1
             }, {
                 isZooming: !0,
                 isPanning: !0
             }), !0
         }
         _onTriplePanStart(t) {
             let r = this.getCenter(t);
             if (!this.isPointInBounds(r, t)) return !1;
             let i = this.controllerState.rotateStart({
                 pos: r
             });
-            return this.updateViewport(i, Zr, {
+            return this.updateViewport(i, Ms, {
                 isDragging: !0
             }), !0
         }
         _onTriplePan(t) {
             if (!this.touchRotate || !this.isDragging()) return !1;
             let r = this.getCenter(t);
             r[0] -= t.deltaX;
             let i = this.controllerState.rotate({
                 pos: r
             });
-            return this.updateViewport(i, Zr, {
+            return this.updateViewport(i, Ms, {
                 isDragging: !0,
                 isRotating: !0
             }), !0
         }
         _onTriplePanEnd(t) {
             if (!this.isDragging()) return !1;
             let {
                 inertia: r
             } = this;
             if (this.touchRotate && r && t.velocityY) {
                 let i = this.getCenter(t),
-                    s = [i[0], i[1] += t.velocityY * r / 2],
-                    n = this.controllerState.rotate({
-                        pos: s
+                    n = [i[0], i[1] += t.velocityY * r / 2],
+                    s = this.controllerState.rotate({
+                        pos: n
                     });
-                this.updateViewport(n, {
+                this.updateViewport(s, {
                     ...this._getTransitionProps(),
                     transitionDuration: r,
-                    transitionEasing: Hc
+                    transitionEasing: Yd
                 }, {
                     isDragging: !1,
                     isRotating: !0
                 }), this.blockEvents(r)
             } else {
                 let i = this.controllerState.rotateEnd();
                 this.updateViewport(i, null, {
@@ -15382,209 +15382,209 @@
             let r = this.getCenter(t);
             if (!this.isPointInBounds(r, t)) return !1;
             let i = this.controllerState.zoomStart({
                 pos: r
             }).rotateStart({
                 pos: r
             });
-            return Fi._startPinchRotation = t.rotation, Fi._lastPinchEvent = t, this.updateViewport(i, Zr, {
+            return Mo._startPinchRotation = t.rotation, Mo._lastPinchEvent = t, this.updateViewport(i, Ms, {
                 isDragging: !0
             }), !0
         }
         _onPinch(t) {
             if (!this.touchZoom && !this.touchRotate || !this.isDragging()) return !1;
             let r = this.controllerState;
             if (this.touchZoom) {
                 let {
                     scale: i
-                } = t, s = this.getCenter(t);
+                } = t, n = this.getCenter(t);
                 r = r.zoom({
-                    pos: s,
+                    pos: n,
                     scale: i
                 })
             }
             if (this.touchRotate) {
                 let {
                     rotation: i
                 } = t;
                 r = r.rotate({
-                    deltaAngleX: Fi._startPinchRotation - i
+                    deltaAngleX: Mo._startPinchRotation - i
                 })
             }
-            return this.updateViewport(r, Zr, {
+            return this.updateViewport(r, Ms, {
                 isDragging: !0,
                 isPanning: this.touchZoom,
                 isZooming: this.touchZoom,
                 isRotating: this.touchRotate
-            }), Fi._lastPinchEvent = t, !0
+            }), Mo._lastPinchEvent = t, !0
         }
         _onPinchEnd(t) {
             if (!this.isDragging()) return !1;
             let {
                 inertia: r
             } = this, {
                 _lastPinchEvent: i
-            } = Fi;
+            } = Mo;
             if (this.touchZoom && r && i && t.scale !== i.scale) {
-                let s = this.getCenter(t),
-                    n = this.controllerState.rotateEnd(),
+                let n = this.getCenter(t),
+                    s = this.controllerState.rotateEnd(),
                     o = Math.log2(t.scale),
                     a = (o - Math.log2(i.scale)) / (t.deltaTime - i.deltaTime),
                     c = Math.pow(2, o + a * r / 2);
-                n = n.zoom({
-                    pos: s,
+                s = s.zoom({
+                    pos: n,
                     scale: c
-                }).zoomEnd(), this.updateViewport(n, {
+                }).zoomEnd(), this.updateViewport(s, {
                     ...this._getTransitionProps({
-                        around: s
+                        around: n
                     }),
                     transitionDuration: r,
-                    transitionEasing: Hc
+                    transitionEasing: Yd
                 }, {
                     isDragging: !1,
                     isPanning: this.touchZoom,
                     isZooming: this.touchZoom,
                     isRotating: !1
                 }), this.blockEvents(r)
             } else {
-                let s = this.controllerState.zoomEnd().rotateEnd();
-                this.updateViewport(s, null, {
+                let n = this.controllerState.zoomEnd().rotateEnd();
+                this.updateViewport(n, null, {
                     isDragging: !1,
                     isPanning: !1,
                     isZooming: !1,
                     isRotating: !1
                 })
             }
-            return Fi._startPinchRotation = null, Fi._lastPinchEvent = null, !0
+            return Mo._startPinchRotation = null, Mo._lastPinchEvent = null, !0
         }
         _onDoubleTap(t) {
             if (!this.doubleClickZoom) return !1;
             let r = this.getCenter(t);
             if (!this.isPointInBounds(r, t)) return !1;
             let i = this.isFunctionKeyPressed(t),
-                s = this.controllerState.zoom({
+                n = this.controllerState.zoom({
                     pos: r,
                     scale: i ? .5 : 2
                 });
-            return this.updateViewport(s, this._getTransitionProps({
+            return this.updateViewport(n, this._getTransitionProps({
                 around: r
             }), {
                 isZooming: !0,
                 isPanning: !0
             }), this.blockEvents(100), !0
         }
         _onKeyDown(t) {
             if (!this.keyboard) return !1;
             let r = this.isFunctionKeyPressed(t),
                 {
                     zoomSpeed: i,
-                    moveSpeed: s,
-                    rotateSpeedX: n,
+                    moveSpeed: n,
+                    rotateSpeedX: s,
                     rotateSpeedY: o
                 } = this.keyboard === !0 ? {} : this.keyboard,
                 {
                     controllerState: a
                 } = this,
                 c, l = {};
             switch (t.srcEvent.code) {
                 case "Minus":
                     c = r ? a.zoomOut(i).zoomOut(i) : a.zoomOut(i), l.isZooming = !0;
                     break;
                 case "Equal":
                     c = r ? a.zoomIn(i).zoomIn(i) : a.zoomIn(i), l.isZooming = !0;
                     break;
                 case "ArrowLeft":
-                    r ? (c = a.rotateLeft(n), l.isRotating = !0) : (c = a.moveLeft(s), l.isPanning = !0);
+                    r ? (c = a.rotateLeft(s), l.isRotating = !0) : (c = a.moveLeft(n), l.isPanning = !0);
                     break;
                 case "ArrowRight":
-                    r ? (c = a.rotateRight(n), l.isRotating = !0) : (c = a.moveRight(s), l.isPanning = !0);
+                    r ? (c = a.rotateRight(s), l.isRotating = !0) : (c = a.moveRight(n), l.isPanning = !0);
                     break;
                 case "ArrowUp":
-                    r ? (c = a.rotateUp(o), l.isRotating = !0) : (c = a.moveUp(s), l.isPanning = !0);
+                    r ? (c = a.rotateUp(o), l.isRotating = !0) : (c = a.moveUp(n), l.isPanning = !0);
                     break;
                 case "ArrowDown":
-                    r ? (c = a.rotateDown(o), l.isRotating = !0) : (c = a.moveDown(s), l.isPanning = !0);
+                    r ? (c = a.rotateDown(o), l.isRotating = !0) : (c = a.moveDown(n), l.isPanning = !0);
                     break;
                 default:
                     return !1
             }
             return this.updateViewport(c, this._getTransitionProps(), l), !0
         }
         _getTransitionProps(t) {
             let {
                 transition: r
             } = this;
-            return !r || !r.transitionInterpolator ? Zr : t ? {
+            return !r || !r.transitionInterpolator ? Ms : t ? {
                 ...r,
-                transitionInterpolator: new Ke({
+                transitionInterpolator: new $i({
                     ...t,
                     ...r.transitionInterpolator.opts,
                     makeViewport: this.controllerState.makeViewport
                 })
             } : r
         }
     };
-var Di = class {
+var Po = class {
     constructor(t, r) {
         this._viewportProps = this.applyConstraints(t), this._state = r
     }
     getViewportProps() {
         return this._viewportProps
     }
     getState() {
         return this._state
     }
 };
-var g0 = 5,
-    Xv = 1.2,
-    pd = class extends Di {
+var D1 = 5,
+    KF = 1.2,
+    ib = class extends Po {
         constructor(t) {
             let {
                 width: r,
                 height: i,
-                latitude: s,
-                longitude: n,
+                latitude: n,
+                longitude: s,
                 zoom: o,
                 bearing: a = 0,
                 pitch: c = 0,
                 altitude: l = 1.5,
-                position: h = [0, 0, 0],
+                position: u = [0, 0, 0],
                 maxZoom: f = 20,
-                minZoom: u = 0,
+                minZoom: h = 0,
                 maxPitch: d = 60,
-                minPitch: m = 0,
+                minPitch: p = 0,
                 startPanLngLat: y,
-                startZoomLngLat: x,
-                startRotatePos: A,
-                startBearing: v,
-                startPitch: E,
+                startZoomLngLat: b,
+                startRotatePos: T,
+                startBearing: I,
+                startPitch: S,
                 startZoom: R,
-                normalize: M = !0
+                normalize: P = !0
             } = t;
-            lt(Number.isFinite(n)), lt(Number.isFinite(s)), lt(Number.isFinite(o)), super({
+            Ht(Number.isFinite(s)), Ht(Number.isFinite(n)), Ht(Number.isFinite(o)), super({
                 width: r,
                 height: i,
-                latitude: s,
-                longitude: n,
+                latitude: n,
+                longitude: s,
                 zoom: o,
                 bearing: a,
                 pitch: c,
                 altitude: l,
                 maxZoom: f,
-                minZoom: u,
+                minZoom: h,
                 maxPitch: d,
-                minPitch: m,
-                normalize: M,
-                position: h
+                minPitch: p,
+                normalize: P,
+                position: u
             }, {
                 startPanLngLat: y,
-                startZoomLngLat: x,
-                startRotatePos: A,
-                startBearing: v,
-                startPitch: E,
+                startZoomLngLat: b,
+                startRotatePos: T,
+                startBearing: I,
+                startPitch: S,
                 startZoom: R
             }), this.makeViewport = t.makeViewport
         }
         panStart({
             pos: t
         }) {
             return this._getUpdatedState({
@@ -15593,16 +15593,16 @@
         }
         pan({
             pos: t,
             startPos: r
         }) {
             let i = this.getState().startPanLngLat || this._unproject(r);
             if (!i) return this;
-            let n = this.makeViewport(this.getViewportProps()).panByPosition(i, t);
-            return this._getUpdatedState(n)
+            let s = this.makeViewport(this.getViewportProps()).panByPosition(i, t);
+            return this._getUpdatedState(s)
         }
         panEnd() {
             return this._getUpdatedState({
                 startPanLngLat: null
             })
         }
         rotateStart({
@@ -15616,22 +15616,22 @@
         }
         rotate({
             pos: t,
             deltaAngleX: r = 0,
             deltaAngleY: i = 0
         }) {
             let {
-                startRotatePos: s,
-                startBearing: n,
+                startRotatePos: n,
+                startBearing: s,
                 startPitch: o
             } = this.getState();
-            if (!s || n === void 0 || o === void 0) return this;
+            if (!n || s === void 0 || o === void 0) return this;
             let a;
-            return t ? a = this._getNewRotation(t, s, o, n) : a = {
-                bearing: n + r,
+            return t ? a = this._getNewRotation(t, n, o, s) : a = {
+                bearing: s + r,
                 pitch: o + i
             }, this._getUpdatedState(a)
         }
         rotateEnd() {
             return this._getUpdatedState({
                 startBearing: null,
                 startPitch: null
@@ -15647,30 +15647,30 @@
         }
         zoom({
             pos: t,
             startPos: r,
             scale: i
         }) {
             let {
-                startZoom: s,
-                startZoomLngLat: n
+                startZoom: n,
+                startZoomLngLat: s
             } = this.getState();
-            if (n || (s = this.getViewportProps().zoom, n = this._unproject(r) || this._unproject(t)), !n) return this;
+            if (s || (n = this.getViewportProps().zoom, s = this._unproject(r) || this._unproject(t)), !s) return this;
             let {
                 maxZoom: o,
                 minZoom: a
-            } = this.getViewportProps(), c = s + Math.log2(i);
-            c = ct(c, a, o);
+            } = this.getViewportProps(), c = n + Math.log2(i);
+            c = jt(c, a, o);
             let l = this.makeViewport({
                 ...this.getViewportProps(),
                 zoom: c
             });
             return this._getUpdatedState({
                 zoom: c,
-                ...l.panByPosition(n, t)
+                ...l.panByPosition(s, t)
             })
         }
         zoomEnd() {
             return this._getUpdatedState({
                 startZoomLngLat: null,
                 startZoom: null
             })
@@ -15715,36 +15715,36 @@
         }
         shortestPathFrom(t) {
             let r = t.getViewportProps(),
                 i = {
                     ...this.getViewportProps()
                 },
                 {
-                    bearing: s,
-                    longitude: n
+                    bearing: n,
+                    longitude: s
                 } = i;
-            return Math.abs(s - r.bearing) > 180 && (i.bearing = s < 0 ? s + 360 : s - 360), Math.abs(n - r.longitude) > 180 && (i.longitude = n < 0 ? n + 360 : n - 360), i
+            return Math.abs(n - r.bearing) > 180 && (i.bearing = n < 0 ? n + 360 : n - 360), Math.abs(s - r.longitude) > 180 && (i.longitude = s < 0 ? s + 360 : s - 360), i
         }
         applyConstraints(t) {
             let {
                 maxZoom: r,
                 minZoom: i,
-                zoom: s
+                zoom: n
             } = t;
-            t.zoom = ct(s, i, r);
+            t.zoom = jt(n, i, r);
             let {
-                maxPitch: n,
+                maxPitch: s,
                 minPitch: o,
                 pitch: a
             } = t;
-            t.pitch = ct(a, o, n);
+            t.pitch = jt(a, o, s);
             let {
                 normalize: c = !0
             } = t;
-            return c && Object.assign(t, ad(t)), t
+            return c && Object.assign(t, K0(t)), t
         }
         _zoomFromCenter(t) {
             let {
                 width: r,
                 height: i
             } = this.getViewportProps();
             return this.zoom({
@@ -15770,41 +15770,41 @@
                 ...t
             })
         }
         _unproject(t) {
             let r = this.makeViewport(this.getViewportProps());
             return t && r.unproject(t)
         }
-        _getNewRotation(t, r, i, s) {
-            let n = t[0] - r[0],
+        _getNewRotation(t, r, i, n) {
+            let s = t[0] - r[0],
                 o = t[1] - r[1],
                 a = t[1],
                 c = r[1],
                 {
                     width: l,
-                    height: h
+                    height: u
                 } = this.getViewportProps(),
-                f = n / l,
-                u = 0;
-            o > 0 ? Math.abs(h - c) > g0 && (u = o / (c - h) * Xv) : o < 0 && c > g0 && (u = 1 - a / c), u = ct(u, -1, 1);
+                f = s / l,
+                h = 0;
+            o > 0 ? Math.abs(u - c) > D1 && (h = o / (c - u) * KF) : o < 0 && c > D1 && (h = 1 - a / c), h = jt(h, -1, 1);
             let {
                 minPitch: d,
-                maxPitch: m
-            } = this.getViewportProps(), y = s + 180 * f, x = i;
-            return u > 0 ? x = i + u * (m - i) : u < 0 && (x = i - u * (d - i)), {
-                pitch: x,
+                maxPitch: p
+            } = this.getViewportProps(), y = n + 180 * f, b = i;
+            return h > 0 ? b = i + h * (p - i) : h < 0 && (b = i - h * (d - i)), {
+                pitch: b,
                 bearing: y
             }
         }
     },
-    Cs = class extends Kr {
+    Za = class extends Ps {
         constructor() {
-            super(...arguments), this.ControllerState = pd, this.transition = {
+            super(...arguments), this.ControllerState = ib, this.transition = {
                 transitionDuration: 300,
-                transitionInterpolator: new Ke({
+                transitionInterpolator: new $i({
                     transitionProps: {
                         compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
                         required: ["longitude", "latitude", "zoom"]
                     }
                 })
             }, this.dragMode = "pan"
         }
@@ -15814,103 +15814,103 @@
             super.setProps(t), (!r || r.height !== t.height) && this.updateViewport(new this.ControllerState({
                 makeViewport: this.makeViewport,
                 ...t,
                 ...this.state
             }))
         }
     };
-var gd = class gd extends qr {
+var nb = class nb extends Rs {
     get ViewportType() {
-        return _e
+        return kr
     }
     get ControllerType() {
-        return Cs
+        return Za
     }
 };
-gd.displayName = "MapView";
-var Is = gd;
-var $v = new Ci;
+nb.displayName = "MapView";
+var Ka = nb;
+var GF = new Ao;
 
-function Yv(e, t) {
+function JF(e, t) {
     let r = e.order ?? 1 / 0,
         i = t.order ?? 1 / 0;
     return r - i
 }
-var ao = class {
+var Ql = class {
     constructor(t) {
         this._resolvedEffects = [], this._defaultEffects = [], this.effects = [], this._context = t, this._needsRedraw = "Initial render", this._setEffects([])
     }
     addDefaultEffect(t) {
         let r = this._defaultEffects;
         if (!r.find(i => i.id === t.id)) {
-            let i = r.findIndex(s => Yv(s, t) > 0);
+            let i = r.findIndex(n => JF(n, t) > 0);
             i < 0 ? r.push(t) : r.splice(i, 0, t), t.setup(this._context), this._setEffects(this.effects)
         }
     }
     setProps(t) {
-        "effects" in t && (Ct(t.effects, this.effects, 1) || this._setEffects(t.effects))
+        "effects" in t && (Se(t.effects, this.effects, 1) || this._setEffects(t.effects))
     }
     needsRedraw(t = {
         clearRedrawFlags: !1
     }) {
         let r = this._needsRedraw;
         return t.clearRedrawFlags && (this._needsRedraw = !1), r
     }
     getEffects() {
         return this._resolvedEffects
     }
     _setEffects(t) {
         let r = {};
-        for (let s of this.effects) r[s.id] = s;
+        for (let n of this.effects) r[n.id] = n;
         let i = [];
-        for (let s of t) {
-            let n = r[s.id],
-                o = s;
-            n && n !== s ? n.setProps ? (n.setProps(s.props), o = n) : n.cleanup(this._context) : n || s.setup(this._context), i.push(o), delete r[s.id]
+        for (let n of t) {
+            let s = r[n.id],
+                o = n;
+            s && s !== n ? s.setProps ? (s.setProps(n.props), o = s) : s.cleanup(this._context) : s || n.setup(this._context), i.push(o), delete r[n.id]
         }
-        for (let s in r) r[s].cleanup(this._context);
-        this.effects = i, this._resolvedEffects = i.concat(this._defaultEffects), t.some(s => s instanceof Ci) || this._resolvedEffects.push($v), this._needsRedraw = "effects changed"
+        for (let n in r) r[n].cleanup(this._context);
+        this.effects = i, this._resolvedEffects = i.concat(this._defaultEffects), t.some(n => n instanceof Ao) || this._resolvedEffects.push(GF), this._needsRedraw = "effects changed"
     }
     finalize() {
         for (let t of this._resolvedEffects) t.cleanup(this._context);
         this.effects.length = 0, this._resolvedEffects.length = 0, this._defaultEffects.length = 0
     }
 };
-var co = class extends dr {
+var tu = class extends Tn {
     shouldDrawLayer(t) {
         let {
             operation: r
         } = t.props;
         return r.includes("draw") || r.includes("terrain")
     }
 };
-var qv = "deckRenderer.renderLayers",
-    Os = class {
+var QF = "deckRenderer.renderLayers",
+    Ga = class {
         constructor(t) {
-            this.device = t, this.gl = t.gl, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new co(t), this.pickLayersPass = new Ni(t), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null
+            this.device = t, this.gl = t.gl, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new tu(t), this.pickLayersPass = new Ro(t), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null
         }
         setProps(t) {
             this.layerFilter !== t.layerFilter && (this.layerFilter = t.layerFilter, this._needsRedraw = "layerFilter changed"), this.drawPickingColors !== t.drawPickingColors && (this.drawPickingColors = t.drawPickingColors, this._needsRedraw = "drawPickingColors changed")
         }
         renderLayers(t) {
             if (!t.viewports.length) return;
             let r = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass,
                 i = {
                     layerFilter: this.layerFilter,
                     isPicking: this.drawPickingColors,
                     ...t
                 };
             i.effects && this._preRender(i.effects, i);
-            let s = this.lastPostProcessEffect ? this.renderBuffers[0] : i.target;
+            let n = this.lastPostProcessEffect ? this.renderBuffers[0] : i.target;
             this.lastPostProcessEffect && (i.clearColor = [0, 0, 0, 0], i.clearCanvas = !0);
-            let n = r.render({
+            let s = r.render({
                 ...i,
-                target: s
+                target: n
             });
-            i.effects && this._postRender(i.effects, i), this.renderCount++, pt(qv, this, n, t)
+            i.effects && this._postRender(i.effects, i), this.renderCount++, Qt(QF, this, s, t)
         }
         needsRedraw(t = {
             clearRedrawFlags: !1
         }) {
             let r = this._needsRedraw;
             return t.clearRedrawFlags && (this._needsRedraw = !1), r
         }
@@ -15927,189 +15927,189 @@
             this.lastPostProcessEffect && this._resizeRenderBuffers()
         }
         _resizeRenderBuffers() {
             let {
                 renderBuffers: t
             } = this, r = this.device.canvasContext.getDrawingBufferSize();
             t.length === 0 && [0, 1].map(i => {
-                let s = this.device.createTexture({
+                let n = this.device.createTexture({
                     sampler: {
                         minFilter: "linear",
                         magFilter: "linear"
                     }
                 });
                 t.push(this.device.createFramebuffer({
                     id: `deck-renderbuffer-${i}`,
-                    colorAttachments: [s]
+                    colorAttachments: [n]
                 }))
             });
             for (let i of t) i.resize(r)
         }
         _postRender(t, r) {
             let {
                 renderBuffers: i
-            } = this, s = {
+            } = this, n = {
                 ...r,
                 inputBuffer: i[0],
                 swapBuffer: i[1]
             };
-            for (let n of t)
-                if (n.postRender) {
-                    s.target = n.id === this.lastPostProcessEffect ? r.target : void 0;
-                    let o = n.postRender(s);
-                    s.inputBuffer = o, s.swapBuffer = o === i[0] ? i[1] : i[0]
+            for (let s of t)
+                if (s.postRender) {
+                    n.target = s.id === this.lastPostProcessEffect ? r.target : void 0;
+                    let o = s.postRender(n);
+                    n.inputBuffer = o, n.swapBuffer = o === i[0] ? i[1] : i[0]
                 }
         }
     };
-var Zv = {
+var tD = {
     pickedColor: null,
     pickedObjectIndex: -1
 };
 
-function m0({
+function L1({
     pickedColors: e,
     decodePickingColor: t,
     deviceX: r,
     deviceY: i,
-    deviceRadius: s,
-    deviceRect: n
+    deviceRadius: n,
+    deviceRect: s
 }) {
     let {
         x: o,
         y: a,
         width: c,
         height: l
-    } = n, h = s * s, f = -1, u = 0;
+    } = s, u = n * n, f = -1, h = 0;
     for (let d = 0; d < l; d++) {
-        let m = d + a - i,
-            y = m * m;
-        if (y > h) u += 4 * c;
+        let p = d + a - i,
+            y = p * p;
+        if (y > u) h += 4 * c;
         else
-            for (let x = 0; x < c; x++) {
-                if (e[u + 3] - 1 >= 0) {
-                    let v = x + o - r,
-                        E = v * v + y;
-                    E <= h && (h = E, f = u)
+            for (let b = 0; b < c; b++) {
+                if (e[h + 3] - 1 >= 0) {
+                    let I = b + o - r,
+                        S = I * I + y;
+                    S <= u && (u = S, f = h)
                 }
-                u += 4
+                h += 4
             }
     }
     if (f >= 0) {
         let d = e.slice(f, f + 4),
-            m = t(d);
-        if (m) {
+            p = t(d);
+        if (p) {
             let y = Math.floor(f / 4 / c),
-                x = f / 4 - y * c;
+                b = f / 4 - y * c;
             return {
-                ...m,
+                ...p,
                 pickedColor: d,
-                pickedX: o + x,
+                pickedX: o + b,
                 pickedY: a + y
             }
         }
-        j.error("Picked non-existent layer. Is picking buffer corrupt?")()
+        Z.error("Picked non-existent layer. Is picking buffer corrupt?")()
     }
-    return Zv
+    return tD
 }
 
-function _0({
+function k1({
     pickedColors: e,
     decodePickingColor: t
 }) {
     let r = new Map;
     if (e) {
         for (let i = 0; i < e.length; i += 4)
             if (e[i + 3] - 1 >= 0) {
-                let n = e.slice(i, i + 4),
-                    o = n.join(",");
+                let s = e.slice(i, i + 4),
+                    o = s.join(",");
                 if (!r.has(o)) {
-                    let a = t(n);
+                    let a = t(s);
                     a ? r.set(o, {
                         ...a,
-                        color: n
-                    }) : j.error("Picked non-existent layer. Is picking buffer corrupt?")()
+                        color: s
+                    }) : Z.error("Picked non-existent layer. Is picking buffer corrupt?")()
                 }
             }
     }
     return Array.from(r.values())
 }
 
-function md({
+function sb({
     pickInfo: e,
     viewports: t,
     pixelRatio: r,
     x: i,
-    y: s,
-    z: n
+    y: n,
+    z: s
 }) {
     let o = t[0];
-    t.length > 1 && (o = Kv(e?.pickedViewports || t, {
+    t.length > 1 && (o = eD(e?.pickedViewports || t, {
         x: i,
-        y: s
+        y: n
     }));
     let a;
     if (o) {
-        let c = [i - o.x, s - o.y];
-        n !== void 0 && (c[2] = n), a = o.unproject(c)
+        let c = [i - o.x, n - o.y];
+        s !== void 0 && (c[2] = s), a = o.unproject(c)
     }
     return {
         color: null,
         layer: null,
         viewport: o,
         index: -1,
         picked: !1,
         x: i,
-        y: s,
-        pixel: [i, s],
+        y: n,
+        pixel: [i, n],
         coordinate: a,
         devicePixel: e && "pickedX" in e ? [e.pickedX, e.pickedY] : void 0,
         pixelRatio: r
     }
 }
 
-function y0(e) {
+function U1(e) {
     let {
         pickInfo: t,
         lastPickedInfo: r,
         mode: i,
-        layers: s
+        layers: n
     } = e, {
-        pickedColor: n,
+        pickedColor: s,
         pickedLayer: o,
         pickedObjectIndex: a
     } = t, c = o ? [o] : [];
     if (i === "hover") {
         let f = r.index,
-            u = r.layerId,
+            h = r.layerId,
             d = o ? o.props.id : null;
-        if (d !== u || a !== f) {
-            if (d !== u) {
-                let m = s.find(y => y.props.id === u);
-                m && c.unshift(m)
+        if (d !== h || a !== f) {
+            if (d !== h) {
+                let p = n.find(y => y.props.id === h);
+                p && c.unshift(p)
             }
             r.layerId = d, r.index = a, r.info = null
         }
     }
-    let l = md(e),
-        h = new Map;
-    return h.set(null, l), c.forEach(f => {
-        let u = {
+    let l = sb(e),
+        u = new Map;
+    return u.set(null, l), c.forEach(f => {
+        let h = {
             ...l
         };
-        f === o && (u.color = n, u.index = a, u.picked = !0), u = _d({
+        f === o && (h.color = s, h.index = a, h.picked = !0), h = ob({
             layer: f,
-            info: u,
+            info: h,
             mode: i
         });
-        let d = u.layer;
-        f === o && i === "hover" && (r.info = u), h.set(d.id, u), i === "hover" && d.updateAutoHighlight(u)
-    }), h
+        let d = h.layer;
+        f === o && i === "hover" && (r.info = h), u.set(d.id, h), i === "hover" && d.updateAutoHighlight(h)
+    }), u
 }
 
-function _d({
+function ob({
     layer: e,
     info: t,
     mode: r
 }) {
     for (; e && t;) {
         let i = t.layer || null;
         t.sourceLayer = i, t.layer = e, t = e.getPickingInfo({
@@ -16117,24 +16117,24 @@
             mode: r,
             sourceLayer: i
         }), e = e.parent
     }
     return t
 }
 
-function Kv(e, t) {
+function eD(e, t) {
     for (let r = e.length - 1; r >= 0; r--) {
         let i = e[r];
         if (i.containsPixel(t)) return i
     }
     return e[0]
 }
-var lo = class {
+var eu = class {
     constructor(t) {
-        this._pickable = !0, this.device = t, this.pickLayersPass = new Ni(t), this.lastPickedInfo = {
+        this._pickable = !0, this.device = t, this.pickLayersPass = new Ro(t), this.lastPickedInfo = {
             index: -1,
             layerId: null,
             info: null
         }
     }
     setProps(t) {
         "layerFilter" in t && (this.layerFilter = t.layerFilter), "_pickable" in t && (this._pickable = t._pickable)
@@ -16148,28 +16148,28 @@
     pickObjects(t) {
         return this._pickVisibleObjects(t)
     }
     getLastPickedObject({
         x: t,
         y: r,
         layers: i,
-        viewports: s
-    }, n = this.lastPickedInfo.info) {
-        let o = n && n.layer && n.layer.id,
-            a = n && n.viewport && n.viewport.id,
-            c = o ? i.find(u => u.id === o) : null,
-            l = a && s.find(u => u.id === a) || s[0],
-            h = l && l.unproject([t - l.x, r - l.y]);
+        viewports: n
+    }, s = this.lastPickedInfo.info) {
+        let o = s && s.layer && s.layer.id,
+            a = s && s.viewport && s.viewport.id,
+            c = o ? i.find(h => h.id === o) : null,
+            l = a && n.find(h => h.id === a) || n[0],
+            u = l && l.unproject([t - l.x, r - l.y]);
         return {
-            ...n,
+            ...s,
             ...{
                 x: t,
                 y: r,
                 viewport: l,
-                coordinate: h,
+                coordinate: u,
                 layer: c
             }
         }
     }
     _resizeBuffer() {
         if (!this.pickingFBO && (this.pickingFBO = this.device.createFramebuffer({
                 colorAttachments: ["rgba8unorm"],
@@ -16195,259 +16195,259 @@
         let r = t.filter(i => this.pickLayersPass.shouldDrawLayer(i) && !i.isComposite);
         return r.length ? r : null
     }
     _pickClosestObject({
         layers: t,
         views: r,
         viewports: i,
-        x: s,
-        y: n,
+        x: n,
+        y: s,
         radius: o = 0,
         depth: a = 1,
         mode: c = "query",
         unproject3D: l,
-        onViewportActive: h,
+        onViewportActive: u,
         effects: f
     }) {
-        let u = this.device.canvasContext.cssToDeviceRatio(),
+        let h = this.device.canvasContext.cssToDeviceRatio(),
             d = this._getPickable(t);
         if (!d || i.length === 0) return {
             result: [],
-            emptyInfo: md({
+            emptyInfo: sb({
                 viewports: i,
-                x: s,
-                y: n,
-                pixelRatio: u
+                x: n,
+                y: s,
+                pixelRatio: h
             })
         };
         this._resizeBuffer();
-        let m = this.device.canvasContext.cssToDevicePixels([s, n], !0),
-            y = [m.x + Math.floor(m.width / 2), m.y + Math.floor(m.height / 2)],
-            x = Math.round(o * u),
+        let p = this.device.canvasContext.cssToDevicePixels([n, s], !0),
+            y = [p.x + Math.floor(p.width / 2), p.y + Math.floor(p.height / 2)],
+            b = Math.round(o * h),
             {
-                width: A,
-                height: v
+                width: T,
+                height: I
             } = this.pickingFBO,
-            E = this._getPickingRect({
+            S = this._getPickingRect({
                 deviceX: y[0],
                 deviceY: y[1],
-                deviceRadius: x,
-                deviceWidth: A,
-                deviceHeight: v
+                deviceRadius: b,
+                deviceWidth: T,
+                deviceHeight: I
             }),
             R = {
-                x: s - o,
-                y: n - o,
+                x: n - o,
+                y: s - o,
                 width: o * 2 + 1,
                 height: o * 2 + 1
             },
-            M, C = [],
-            B = new Set;
-        for (let L = 0; L < a; L++) {
+            P, C = [],
+            V = new Set;
+        for (let U = 0; U < a; U++) {
             let k;
-            if (E) {
-                let H = this._drawAndSample({
+            if (S) {
+                let K = this._drawAndSample({
                     layers: d,
                     views: r,
                     viewports: i,
-                    onViewportActive: h,
-                    deviceRect: E,
+                    onViewportActive: u,
+                    deviceRect: S,
                     cullRect: R,
                     effects: f,
                     pass: `picking:${c}`
                 });
-                k = m0({
-                    ...H,
+                k = L1({
+                    ...K,
                     deviceX: y[0],
                     deviceY: y[1],
-                    deviceRadius: x,
-                    deviceRect: E
+                    deviceRadius: b,
+                    deviceRect: S
                 })
             } else k = {
                 pickedColor: null,
                 pickedObjectIndex: -1
             };
-            let N;
+            let B;
             if (k.pickedLayer && l && this.depthFBO) {
                 let {
-                    pickedColors: H
+                    pickedColors: K
                 } = this._drawAndSample({
                     layers: [k.pickedLayer],
                     views: r,
                     viewports: i,
-                    onViewportActive: h,
+                    onViewportActive: u,
                     deviceRect: {
                         x: k.pickedX,
                         y: k.pickedY,
                         width: 1,
                         height: 1
                     },
                     cullRect: R,
                     effects: f,
                     pass: `picking:${c}:z`
                 }, !0);
-                H[3] && (N = H[0])
+                K[3] && (B = K[0])
             }
-            k.pickedLayer && L + 1 < a && (B.add(k.pickedLayer), k.pickedLayer.disablePickingIndex(k.pickedObjectIndex)), M = y0({
+            k.pickedLayer && U + 1 < a && (V.add(k.pickedLayer), k.pickedLayer.disablePickingIndex(k.pickedObjectIndex)), P = U1({
                 pickInfo: k,
                 lastPickedInfo: this.lastPickedInfo,
                 mode: c,
                 layers: d,
                 viewports: i,
-                x: s,
-                y: n,
-                z: N,
-                pixelRatio: u
+                x: n,
+                y: s,
+                z: B,
+                pixelRatio: h
             });
-            for (let H of M.values()) H.layer && C.push(H);
+            for (let K of P.values()) K.layer && C.push(K);
             if (!k.pickedColor) break
         }
-        for (let L of B) L.restorePickingColors();
+        for (let U of V) U.restorePickingColors();
         return {
             result: C,
-            emptyInfo: M.get(null)
+            emptyInfo: P.get(null)
         }
     }
     _pickVisibleObjects({
         layers: t,
         views: r,
         viewports: i,
-        x: s,
-        y: n,
+        x: n,
+        y: s,
         width: o = 1,
         height: a = 1,
         mode: c = "query",
         maxObjects: l = null,
-        onViewportActive: h,
+        onViewportActive: u,
         effects: f
     }) {
-        let u = this._getPickable(t);
-        if (!u || i.length === 0) return [];
+        let h = this._getPickable(t);
+        if (!h || i.length === 0) return [];
         this._resizeBuffer();
         let d = this.device.canvasContext.cssToDeviceRatio(),
-            m = this.device.canvasContext.cssToDevicePixels([s, n], !0),
-            y = m.x,
-            x = m.y + m.height,
-            A = this.device.canvasContext.cssToDevicePixels([s + o, n + a], !0),
-            v = A.x + A.width,
-            E = A.y,
+            p = this.device.canvasContext.cssToDevicePixels([n, s], !0),
+            y = p.x,
+            b = p.y + p.height,
+            T = this.device.canvasContext.cssToDevicePixels([n + o, s + a], !0),
+            I = T.x + T.width,
+            S = T.y,
             R = {
                 x: y,
-                y: E,
-                width: v - y,
-                height: x - E
+                y: S,
+                width: I - y,
+                height: b - S
             },
-            M = this._drawAndSample({
-                layers: u,
+            P = this._drawAndSample({
+                layers: h,
                 views: r,
                 viewports: i,
-                onViewportActive: h,
+                onViewportActive: u,
                 deviceRect: R,
                 cullRect: {
-                    x: s,
-                    y: n,
+                    x: n,
+                    y: s,
                     width: o,
                     height: a
                 },
                 effects: f,
                 pass: `picking:${c}`
             }),
-            C = _0(M),
-            B = new Map,
-            L = [],
+            C = k1(P),
+            V = new Map,
+            U = [],
             k = Number.isFinite(l);
-        for (let N = 0; N < C.length && !(k && L.length >= l); N++) {
-            let H = C[N],
-                $ = {
-                    color: H.pickedColor,
+        for (let B = 0; B < C.length && !(k && U.length >= l); B++) {
+            let K = C[B],
+                st = {
+                    color: K.pickedColor,
                     layer: null,
-                    index: H.pickedObjectIndex,
+                    index: K.pickedObjectIndex,
                     picked: !0,
-                    x: s,
-                    y: n,
+                    x: n,
+                    y: s,
                     pixelRatio: d
                 };
-            $ = _d({
-                layer: H.pickedLayer,
-                info: $,
+            st = ob({
+                layer: K.pickedLayer,
+                info: st,
                 mode: c
             });
-            let X = $.layer.id;
-            B.has(X) || B.set(X, new Set);
-            let J = B.get(X),
-                xt = $.object ?? $.index;
-            J.has(xt) || (J.add(xt), L.push($))
+            let G = st.layer.id;
+            V.has(G) || V.set(G, new Set);
+            let Tt = V.get(G),
+                oe = st.object ?? st.index;
+            Tt.has(oe) || (Tt.add(oe), U.push(st))
         }
-        return L
+        return U
     }
     _drawAndSample({
         layers: t,
         views: r,
         viewports: i,
-        onViewportActive: s,
-        deviceRect: n,
+        onViewportActive: n,
+        deviceRect: s,
         cullRect: o,
         effects: a,
         pass: c
     }, l = !1) {
-        let h = l ? this.depthFBO : this.pickingFBO,
+        let u = l ? this.depthFBO : this.pickingFBO,
             f = {
                 layers: t,
                 layerFilter: this.layerFilter,
                 views: r,
                 viewports: i,
-                onViewportActive: s,
-                pickingFBO: h,
-                deviceRect: n,
+                onViewportActive: n,
+                pickingFBO: u,
+                deviceRect: s,
                 cullRect: o,
                 effects: a,
                 pass: c,
                 pickZ: l,
                 preRenderStats: {}
             };
-        for (let v of a) v.useInPicking && (f.preRenderStats[v.id] = v.preRender(f));
+        for (let I of a) I.useInPicking && (f.preRenderStats[I.id] = I.preRender(f));
         let {
-            decodePickingColor: u
+            decodePickingColor: h
         } = this.pickLayersPass.render(f), {
             x: d,
-            y: m,
+            y: p,
             width: y,
-            height: x
-        } = n, A = new(l ? Float32Array : Uint8Array)(y * x * 4);
-        return this.device.readPixelsToArrayWebGL(h, {
+            height: b
+        } = s, T = new(l ? Float32Array : Uint8Array)(y * b * 4);
+        return this.device.readPixelsToArrayWebGL(u, {
             sourceX: d,
-            sourceY: m,
+            sourceY: p,
             sourceWidth: y,
-            sourceHeight: x,
-            target: A
+            sourceHeight: b,
+            target: T
         }), {
-            pickedColors: A,
-            decodePickingColor: u
+            pickedColors: T,
+            decodePickingColor: h
         }
     }
     _getPickingRect({
         deviceX: t,
         deviceY: r,
         deviceRadius: i,
-        deviceWidth: s,
-        deviceHeight: n
+        deviceWidth: n,
+        deviceHeight: s
     }) {
         let o = Math.max(0, t - i),
             a = Math.max(0, r - i),
-            c = Math.min(s, t + i + 1) - o,
-            l = Math.min(n, r + i + 1) - a;
+            c = Math.min(n, t + i + 1) - o,
+            l = Math.min(s, r + i + 1) - a;
         return c <= 0 || l <= 0 ? null : {
             x: o,
             y: a,
             width: c,
             height: l
         }
     }
 };
-var Qv = {
+var rD = {
         "top-left": {
             top: 0,
             left: 0
         },
         "top-right": {
             top: 0,
             right: 0
@@ -16463,28 +16463,28 @@
         fill: {
             top: 0,
             left: 0,
             bottom: 0,
             right: 0
         }
     },
-    Gv = "top-left",
-    x0 = "__root",
-    Xc = class {
+    iD = "top-left",
+    V1 = "__root",
+    qd = class {
         constructor({
             deck: t,
             parentElement: r
         }) {
             this.defaultWidgets = [], this.widgets = [], this.resolvedWidgets = [], this.containers = {}, this.lastViewports = {}, this.deck = t, this.parentElement = r
         }
         getWidgets() {
             return this.resolvedWidgets
         }
         setProps(t) {
-            t.widgets && !Ct(t.widgets, this.widgets, 1) && this._setWidgets(t.widgets)
+            t.widgets && !Se(t.widgets, this.widgets, 1) && this._setWidgets(t.widgets)
         }
         finalize() {
             for (let t of this.getWidgets()) this._remove(t);
             this.defaultWidgets.length = 0, this.resolvedWidgets.length = 0;
             for (let t in this.containers) this.containers[t].remove()
         }
         addDefault(t) {
@@ -16492,155 +16492,155 @@
         }
         _setWidgets(t) {
             let r = {};
             for (let i of this.resolvedWidgets) r[i.id] = i;
             this.resolvedWidgets.length = 0;
             for (let i of this.defaultWidgets) r[i.id] = null, this.resolvedWidgets.push(i);
             for (let i of t) {
-                let s = r[i.id];
-                s ? s.viewId !== i.viewId || s.placement !== i.placement ? (this._remove(s), this._add(i)) : i !== s && (s.setProps(i.props), i = s) : this._add(i), r[i.id] = null, this.resolvedWidgets.push(i)
+                let n = r[i.id];
+                n ? n.viewId !== i.viewId || n.placement !== i.placement ? (this._remove(n), this._add(i)) : i !== n && (n.setProps(i.props), i = n) : this._add(i), r[i.id] = null, this.resolvedWidgets.push(i)
             }
             for (let i in r) {
-                let s = r[i];
-                s && this._remove(s)
+                let n = r[i];
+                n && this._remove(n)
             }
             this.widgets = t
         }
         _add(t) {
             let {
                 viewId: r = null,
-                placement: i = Gv
-            } = t, s = t.onAdd({
+                placement: i = iD
+            } = t, n = t.onAdd({
                 deck: this.deck,
                 viewId: r
             });
-            s && this._getContainer(r, i).append(s), t._element = s
+            n && this._getContainer(r, i).append(n), t._element = n
         }
         _remove(t) {
             t.onRemove(), t._element && t._element.remove(), t._element = void 0
         }
         _getContainer(t, r) {
-            let i = t || x0,
-                s = this.containers[i];
-            s || (s = document.createElement("div"), s.style.pointerEvents = "none", s.style.position = "absolute", s.style.overflow = "hidden", this.parentElement?.append(s), this.containers[i] = s);
-            let n = s.querySelector(`.${r}`);
-            return n || (n = document.createElement("div"), n.className = r, n.style.position = "absolute", Object.assign(n.style, Qv[r]), s.append(n)), n
+            let i = t || V1,
+                n = this.containers[i];
+            n || (n = document.createElement("div"), n.style.pointerEvents = "none", n.style.position = "absolute", n.style.overflow = "hidden", this.parentElement?.append(n), this.containers[i] = n);
+            let s = n.querySelector(`.${r}`);
+            return s || (s = document.createElement("div"), s.className = r, s.style.position = "absolute", Object.assign(s.style, rD[r]), n.append(s)), s
         }
         _updateContainers() {
             let t = this.deck.width,
                 r = this.deck.height;
             for (let i in this.containers) {
-                let s = this.lastViewports[i] || null,
-                    n = i === x0 || s,
+                let n = this.lastViewports[i] || null,
+                    s = i === V1 || n,
                     o = this.containers[i];
-                n ? (o.style.display = "block", o.style.left = `${s?s.x:0}px`, o.style.top = `${s?s.y:0}px`, o.style.width = `${s?s.width:t}px`, o.style.height = `${s?s.height:r}px`) : o.style.display = "none"
+                s ? (o.style.display = "block", o.style.left = `${n?n.x:0}px`, o.style.top = `${n?n.y:0}px`, o.style.width = `${n?n.width:t}px`, o.style.height = `${n?n.height:r}px`) : o.style.display = "none"
             }
         }
         onRedraw({
             viewports: t,
             layers: r
         }) {
-            let i = t.reduce((n, o) => (n[o.id] = o, n), {}),
+            let i = t.reduce((s, o) => (s[o.id] = o, s), {}),
                 {
-                    lastViewports: s
+                    lastViewports: n
                 } = this;
-            for (let n of this.getWidgets()) {
+            for (let s of this.getWidgets()) {
                 let {
                     viewId: o
-                } = n;
+                } = s;
                 if (o) {
                     let a = i[o];
-                    a && (n.onViewportChange && !a.equals(s[o]) && n.onViewportChange(a), n.onRedraw?.({
+                    a && (s.onViewportChange && !a.equals(n[o]) && s.onViewportChange(a), s.onRedraw?.({
                         viewports: [a],
                         layers: r
                     }))
                 } else {
-                    if (n.onViewportChange)
-                        for (let a of t) a.equals(s[a.id]) || n.onViewportChange(a);
-                    n.onRedraw?.({
+                    if (s.onViewportChange)
+                        for (let a of t) a.equals(n[a.id]) || s.onViewportChange(a);
+                    s.onRedraw?.({
                         viewports: t,
                         layers: r
                     })
                 }
             }
             this.lastViewports = i, this._updateContainers()
         }
         onHover(t, r) {
             for (let i of this.getWidgets()) {
                 let {
-                    viewId: s
+                    viewId: n
                 } = i;
-                (!s || s === t.viewport?.id) && i.onHover?.(t, r)
+                (!n || n === t.viewport?.id) && i.onHover?.(t, r)
             }
         }
         onEvent(t, r) {
-            let i = Xn[r.type];
+            let i = Ll[r.type];
             if (i)
-                for (let s of this.getWidgets()) {
+                for (let n of this.getWidgets()) {
                     let {
-                        viewId: n
-                    } = s;
-                    (!n || n === t.viewport?.id) && s[i.handler]?.(t, r)
+                        viewId: s
+                    } = n;
+                    (!s || s === t.viewport?.id) && n[i.handler]?.(t, r)
                 }
         }
     };
-var Jv = {
+var nD = {
         zIndex: "1",
         position: "absolute",
         pointerEvents: "none",
         color: "#a0a7b4",
         backgroundColor: "#29323c",
         padding: "10px",
         top: "0",
         left: "0",
         display: "none"
     },
-    ho = class {
+    ru = class {
         constructor() {
             this.id = "default-tooltip", this.placement = "fill", this.props = {}, this.isVisible = !1
         }
         onAdd({
             deck: t
         }) {
             let r = document.createElement("div");
-            return r.className = "deck-tooltip", Object.assign(r.style, Jv), this.deck = t, this.element = r, r
+            return r.className = "deck-tooltip", Object.assign(r.style, nD), this.deck = t, this.element = r, r
         }
         onRemove() {
             this.deck = void 0, this.element = void 0
         }
         setProps() {}
         onViewportChange(t) {
             this.isVisible && t.id === this.lastViewport?.id && t !== this.lastViewport && this.setTooltip(null)
         }
         onHover(t) {
             let {
                 deck: r
             } = this, i = r && r.props.getTooltip;
             if (!i) return;
-            let s = i(t);
-            this.lastViewport = t.viewport, this.setTooltip(s, t.x, t.y)
+            let n = i(t);
+            this.lastViewport = t.viewport, this.setTooltip(n, t.x, t.y)
         }
         setTooltip(t, r, i) {
-            let s = this.element;
-            if (s) {
-                if (typeof t == "string") s.innerText = t;
-                else if (t) t.text && (s.innerText = t.text), t.html && (s.innerHTML = t.html), t.className && (s.className = t.className);
+            let n = this.element;
+            if (n) {
+                if (typeof t == "string") n.innerText = t;
+                else if (t) t.text && (n.innerText = t.text), t.html && (n.innerHTML = t.html), t.className && (n.className = t.className);
                 else {
-                    this.isVisible = !1, s.style.display = "none";
+                    this.isVisible = !1, n.style.display = "none";
                     return
                 }
-                this.isVisible = !0, s.style.display = "block", s.style.transform = `translate(${r}px, ${i}px)`, t && typeof t == "object" && "style" in t && Object.assign(s.style, t.style)
+                this.isVisible = !0, n.style.display = "block", n.style.transform = `translate(${r}px, ${i}px)`, t && typeof t == "object" && "style" in t && Object.assign(n.style, t.style)
             }
         }
     };
-var Qr;
+var Cs;
 (function(e) {
     e[e.DEPTH_BUFFER_BIT = 256] = "DEPTH_BUFFER_BIT", e[e.STENCIL_BUFFER_BIT = 1024] = "STENCIL_BUFFER_BIT", e[e.COLOR_BUFFER_BIT = 16384] = "COLOR_BUFFER_BIT", e[e.POINTS = 0] = "POINTS", e[e.LINES = 1] = "LINES", e[e.LINE_LOOP = 2] = "LINE_LOOP", e[e.LINE_STRIP = 3] = "LINE_STRIP", e[e.TRIANGLES = 4] = "TRIANGLES", e[e.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", e[e.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", e[e.ZERO = 0] = "ZERO", e[e.ONE = 1] = "ONE", e[e.SRC_COLOR = 768] = "SRC_COLOR", e[e.ONE_MINUS_SRC_COLOR = 769] = "ONE_MINUS_SRC_COLOR", e[e.SRC_ALPHA = 770] = "SRC_ALPHA", e[e.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", e[e.DST_ALPHA = 772] = "DST_ALPHA", e[e.ONE_MINUS_DST_ALPHA = 773] = "ONE_MINUS_DST_ALPHA", e[e.DST_COLOR = 774] = "DST_COLOR", e[e.ONE_MINUS_DST_COLOR = 775] = "ONE_MINUS_DST_COLOR", e[e.SRC_ALPHA_SATURATE = 776] = "SRC_ALPHA_SATURATE", e[e.CONSTANT_COLOR = 32769] = "CONSTANT_COLOR", e[e.ONE_MINUS_CONSTANT_COLOR = 32770] = "ONE_MINUS_CONSTANT_COLOR", e[e.CONSTANT_ALPHA = 32771] = "CONSTANT_ALPHA", e[e.ONE_MINUS_CONSTANT_ALPHA = 32772] = "ONE_MINUS_CONSTANT_ALPHA", e[e.FUNC_ADD = 32774] = "FUNC_ADD", e[e.FUNC_SUBTRACT = 32778] = "FUNC_SUBTRACT", e[e.FUNC_REVERSE_SUBTRACT = 32779] = "FUNC_REVERSE_SUBTRACT", e[e.BLEND_EQUATION = 32777] = "BLEND_EQUATION", e[e.BLEND_EQUATION_RGB = 32777] = "BLEND_EQUATION_RGB", e[e.BLEND_EQUATION_ALPHA = 34877] = "BLEND_EQUATION_ALPHA", e[e.BLEND_DST_RGB = 32968] = "BLEND_DST_RGB", e[e.BLEND_SRC_RGB = 32969] = "BLEND_SRC_RGB", e[e.BLEND_DST_ALPHA = 32970] = "BLEND_DST_ALPHA", e[e.BLEND_SRC_ALPHA = 32971] = "BLEND_SRC_ALPHA", e[e.BLEND_COLOR = 32773] = "BLEND_COLOR", e[e.ARRAY_BUFFER_BINDING = 34964] = "ARRAY_BUFFER_BINDING", e[e.ELEMENT_ARRAY_BUFFER_BINDING = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING", e[e.LINE_WIDTH = 2849] = "LINE_WIDTH", e[e.ALIASED_POINT_SIZE_RANGE = 33901] = "ALIASED_POINT_SIZE_RANGE", e[e.ALIASED_LINE_WIDTH_RANGE = 33902] = "ALIASED_LINE_WIDTH_RANGE", e[e.CULL_FACE_MODE = 2885] = "CULL_FACE_MODE", e[e.FRONT_FACE = 2886] = "FRONT_FACE", e[e.DEPTH_RANGE = 2928] = "DEPTH_RANGE", e[e.DEPTH_WRITEMASK = 2930] = "DEPTH_WRITEMASK", e[e.DEPTH_CLEAR_VALUE = 2931] = "DEPTH_CLEAR_VALUE", e[e.DEPTH_FUNC = 2932] = "DEPTH_FUNC", e[e.STENCIL_CLEAR_VALUE = 2961] = "STENCIL_CLEAR_VALUE", e[e.STENCIL_FUNC = 2962] = "STENCIL_FUNC", e[e.STENCIL_FAIL = 2964] = "STENCIL_FAIL", e[e.STENCIL_PASS_DEPTH_FAIL = 2965] = "STENCIL_PASS_DEPTH_FAIL", e[e.STENCIL_PASS_DEPTH_PASS = 2966] = "STENCIL_PASS_DEPTH_PASS", e[e.STENCIL_REF = 2967] = "STENCIL_REF", e[e.STENCIL_VALUE_MASK = 2963] = "STENCIL_VALUE_MASK", e[e.STENCIL_WRITEMASK = 2968] = "STENCIL_WRITEMASK", e[e.STENCIL_BACK_FUNC = 34816] = "STENCIL_BACK_FUNC", e[e.STENCIL_BACK_FAIL = 34817] = "STENCIL_BACK_FAIL", e[e.STENCIL_BACK_PASS_DEPTH_FAIL = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL", e[e.STENCIL_BACK_PASS_DEPTH_PASS = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS", e[e.STENCIL_BACK_REF = 36003] = "STENCIL_BACK_REF", e[e.STENCIL_BACK_VALUE_MASK = 36004] = "STENCIL_BACK_VALUE_MASK", e[e.STENCIL_BACK_WRITEMASK = 36005] = "STENCIL_BACK_WRITEMASK", e[e.VIEWPORT = 2978] = "VIEWPORT", e[e.SCISSOR_BOX = 3088] = "SCISSOR_BOX", e[e.COLOR_CLEAR_VALUE = 3106] = "COLOR_CLEAR_VALUE", e[e.COLOR_WRITEMASK = 3107] = "COLOR_WRITEMASK", e[e.UNPACK_ALIGNMENT = 3317] = "UNPACK_ALIGNMENT", e[e.PACK_ALIGNMENT = 3333] = "PACK_ALIGNMENT", e[e.MAX_TEXTURE_SIZE = 3379] = "MAX_TEXTURE_SIZE", e[e.MAX_VIEWPORT_DIMS = 3386] = "MAX_VIEWPORT_DIMS", e[e.SUBPIXEL_BITS = 3408] = "SUBPIXEL_BITS", e[e.RED_BITS = 3410] = "RED_BITS", e[e.GREEN_BITS = 3411] = "GREEN_BITS", e[e.BLUE_BITS = 3412] = "BLUE_BITS", e[e.ALPHA_BITS = 3413] = "ALPHA_BITS", e[e.DEPTH_BITS = 3414] = "DEPTH_BITS", e[e.STENCIL_BITS = 3415] = "STENCIL_BITS", e[e.POLYGON_OFFSET_UNITS = 10752] = "POLYGON_OFFSET_UNITS", e[e.POLYGON_OFFSET_FACTOR = 32824] = "POLYGON_OFFSET_FACTOR", e[e.TEXTURE_BINDING_2D = 32873] = "TEXTURE_BINDING_2D", e[e.SAMPLE_BUFFERS = 32936] = "SAMPLE_BUFFERS", e[e.SAMPLES = 32937] = "SAMPLES", e[e.SAMPLE_COVERAGE_VALUE = 32938] = "SAMPLE_COVERAGE_VALUE", e[e.SAMPLE_COVERAGE_INVERT = 32939] = "SAMPLE_COVERAGE_INVERT", e[e.COMPRESSED_TEXTURE_FORMATS = 34467] = "COMPRESSED_TEXTURE_FORMATS", e[e.VENDOR = 7936] = "VENDOR", e[e.RENDERER = 7937] = "RENDERER", e[e.VERSION = 7938] = "VERSION", e[e.IMPLEMENTATION_COLOR_READ_TYPE = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE", e[e.IMPLEMENTATION_COLOR_READ_FORMAT = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT", e[e.BROWSER_DEFAULT_WEBGL = 37444] = "BROWSER_DEFAULT_WEBGL", e[e.STATIC_DRAW = 35044] = "STATIC_DRAW", e[e.STREAM_DRAW = 35040] = "STREAM_DRAW", e[e.DYNAMIC_DRAW = 35048] = "DYNAMIC_DRAW", e[e.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", e[e.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", e[e.BUFFER_SIZE = 34660] = "BUFFER_SIZE", e[e.BUFFER_USAGE = 34661] = "BUFFER_USAGE", e[e.CURRENT_VERTEX_ATTRIB = 34342] = "CURRENT_VERTEX_ATTRIB", e[e.VERTEX_ATTRIB_ARRAY_ENABLED = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED", e[e.VERTEX_ATTRIB_ARRAY_SIZE = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE", e[e.VERTEX_ATTRIB_ARRAY_STRIDE = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE", e[e.VERTEX_ATTRIB_ARRAY_TYPE = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE", e[e.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED", e[e.VERTEX_ATTRIB_ARRAY_POINTER = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER", e[e.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", e[e.CULL_FACE = 2884] = "CULL_FACE", e[e.FRONT = 1028] = "FRONT", e[e.BACK = 1029] = "BACK", e[e.FRONT_AND_BACK = 1032] = "FRONT_AND_BACK", e[e.BLEND = 3042] = "BLEND", e[e.DEPTH_TEST = 2929] = "DEPTH_TEST", e[e.DITHER = 3024] = "DITHER", e[e.POLYGON_OFFSET_FILL = 32823] = "POLYGON_OFFSET_FILL", e[e.SAMPLE_ALPHA_TO_COVERAGE = 32926] = "SAMPLE_ALPHA_TO_COVERAGE", e[e.SAMPLE_COVERAGE = 32928] = "SAMPLE_COVERAGE", e[e.SCISSOR_TEST = 3089] = "SCISSOR_TEST", e[e.STENCIL_TEST = 2960] = "STENCIL_TEST", e[e.NO_ERROR = 0] = "NO_ERROR", e[e.INVALID_ENUM = 1280] = "INVALID_ENUM", e[e.INVALID_VALUE = 1281] = "INVALID_VALUE", e[e.INVALID_OPERATION = 1282] = "INVALID_OPERATION", e[e.OUT_OF_MEMORY = 1285] = "OUT_OF_MEMORY", e[e.CONTEXT_LOST_WEBGL = 37442] = "CONTEXT_LOST_WEBGL", e[e.CW = 2304] = "CW", e[e.CCW = 2305] = "CCW", e[e.DONT_CARE = 4352] = "DONT_CARE", e[e.FASTEST = 4353] = "FASTEST", e[e.NICEST = 4354] = "NICEST", e[e.GENERATE_MIPMAP_HINT = 33170] = "GENERATE_MIPMAP_HINT", e[e.BYTE = 5120] = "BYTE", e[e.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", e[e.SHORT = 5122] = "SHORT", e[e.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", e[e.INT = 5124] = "INT", e[e.UNSIGNED_INT = 5125] = "UNSIGNED_INT", e[e.FLOAT = 5126] = "FLOAT", e[e.DOUBLE = 5130] = "DOUBLE", e[e.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", e[e.ALPHA = 6406] = "ALPHA", e[e.RGB = 6407] = "RGB", e[e.RGBA = 6408] = "RGBA", e[e.LUMINANCE = 6409] = "LUMINANCE", e[e.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", e[e.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", e[e.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", e[e.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", e[e.FRAGMENT_SHADER = 35632] = "FRAGMENT_SHADER", e[e.VERTEX_SHADER = 35633] = "VERTEX_SHADER", e[e.COMPILE_STATUS = 35713] = "COMPILE_STATUS", e[e.DELETE_STATUS = 35712] = "DELETE_STATUS", e[e.LINK_STATUS = 35714] = "LINK_STATUS", e[e.VALIDATE_STATUS = 35715] = "VALIDATE_STATUS", e[e.ATTACHED_SHADERS = 35717] = "ATTACHED_SHADERS", e[e.ACTIVE_ATTRIBUTES = 35721] = "ACTIVE_ATTRIBUTES", e[e.ACTIVE_UNIFORMS = 35718] = "ACTIVE_UNIFORMS", e[e.MAX_VERTEX_ATTRIBS = 34921] = "MAX_VERTEX_ATTRIBS", e[e.MAX_VERTEX_UNIFORM_VECTORS = 36347] = "MAX_VERTEX_UNIFORM_VECTORS", e[e.MAX_VARYING_VECTORS = 36348] = "MAX_VARYING_VECTORS", e[e.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS", e[e.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS", e[e.MAX_TEXTURE_IMAGE_UNITS = 34930] = "MAX_TEXTURE_IMAGE_UNITS", e[e.MAX_FRAGMENT_UNIFORM_VECTORS = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS", e[e.SHADER_TYPE = 35663] = "SHADER_TYPE", e[e.SHADING_LANGUAGE_VERSION = 35724] = "SHADING_LANGUAGE_VERSION", e[e.CURRENT_PROGRAM = 35725] = "CURRENT_PROGRAM", e[e.NEVER = 512] = "NEVER", e[e.LESS = 513] = "LESS", e[e.EQUAL = 514] = "EQUAL", e[e.LEQUAL = 515] = "LEQUAL", e[e.GREATER = 516] = "GREATER", e[e.NOTEQUAL = 517] = "NOTEQUAL", e[e.GEQUAL = 518] = "GEQUAL", e[e.ALWAYS = 519] = "ALWAYS", e[e.KEEP = 7680] = "KEEP", e[e.REPLACE = 7681] = "REPLACE", e[e.INCR = 7682] = "INCR", e[e.DECR = 7683] = "DECR", e[e.INVERT = 5386] = "INVERT", e[e.INCR_WRAP = 34055] = "INCR_WRAP", e[e.DECR_WRAP = 34056] = "DECR_WRAP", e[e.NEAREST = 9728] = "NEAREST", e[e.LINEAR = 9729] = "LINEAR", e[e.NEAREST_MIPMAP_NEAREST = 9984] = "NEAREST_MIPMAP_NEAREST", e[e.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", e[e.NEAREST_MIPMAP_LINEAR = 9986] = "NEAREST_MIPMAP_LINEAR", e[e.LINEAR_MIPMAP_LINEAR = 9987] = "LINEAR_MIPMAP_LINEAR", e[e.TEXTURE_MAG_FILTER = 10240] = "TEXTURE_MAG_FILTER", e[e.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", e[e.TEXTURE_WRAP_S = 10242] = "TEXTURE_WRAP_S", e[e.TEXTURE_WRAP_T = 10243] = "TEXTURE_WRAP_T", e[e.TEXTURE_2D = 3553] = "TEXTURE_2D", e[e.TEXTURE = 5890] = "TEXTURE", e[e.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", e[e.TEXTURE_BINDING_CUBE_MAP = 34068] = "TEXTURE_BINDING_CUBE_MAP", e[e.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", e[e.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", e[e.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", e[e.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", e[e.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", e[e.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", e[e.MAX_CUBE_MAP_TEXTURE_SIZE = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE", e[e.TEXTURE0 = 33984] = "TEXTURE0", e[e.ACTIVE_TEXTURE = 34016] = "ACTIVE_TEXTURE", e[e.REPEAT = 10497] = "REPEAT", e[e.CLAMP_TO_EDGE = 33071] = "CLAMP_TO_EDGE", e[e.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", e[e.TEXTURE_WIDTH = 4096] = "TEXTURE_WIDTH", e[e.TEXTURE_HEIGHT = 4097] = "TEXTURE_HEIGHT", e[e.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", e[e.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", e[e.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", e[e.INT_VEC2 = 35667] = "INT_VEC2", e[e.INT_VEC3 = 35668] = "INT_VEC3", e[e.INT_VEC4 = 35669] = "INT_VEC4", e[e.BOOL = 35670] = "BOOL", e[e.BOOL_VEC2 = 35671] = "BOOL_VEC2", e[e.BOOL_VEC3 = 35672] = "BOOL_VEC3", e[e.BOOL_VEC4 = 35673] = "BOOL_VEC4", e[e.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", e[e.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", e[e.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", e[e.SAMPLER_2D = 35678] = "SAMPLER_2D", e[e.SAMPLER_CUBE = 35680] = "SAMPLER_CUBE", e[e.LOW_FLOAT = 36336] = "LOW_FLOAT", e[e.MEDIUM_FLOAT = 36337] = "MEDIUM_FLOAT", e[e.HIGH_FLOAT = 36338] = "HIGH_FLOAT", e[e.LOW_INT = 36339] = "LOW_INT", e[e.MEDIUM_INT = 36340] = "MEDIUM_INT", e[e.HIGH_INT = 36341] = "HIGH_INT", e[e.FRAMEBUFFER = 36160] = "FRAMEBUFFER", e[e.RENDERBUFFER = 36161] = "RENDERBUFFER", e[e.RGBA4 = 32854] = "RGBA4", e[e.RGB5_A1 = 32855] = "RGB5_A1", e[e.RGB565 = 36194] = "RGB565", e[e.DEPTH_COMPONENT16 = 33189] = "DEPTH_COMPONENT16", e[e.STENCIL_INDEX = 6401] = "STENCIL_INDEX", e[e.STENCIL_INDEX8 = 36168] = "STENCIL_INDEX8", e[e.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", e[e.RENDERBUFFER_WIDTH = 36162] = "RENDERBUFFER_WIDTH", e[e.RENDERBUFFER_HEIGHT = 36163] = "RENDERBUFFER_HEIGHT", e[e.RENDERBUFFER_INTERNAL_FORMAT = 36164] = "RENDERBUFFER_INTERNAL_FORMAT", e[e.RENDERBUFFER_RED_SIZE = 36176] = "RENDERBUFFER_RED_SIZE", e[e.RENDERBUFFER_GREEN_SIZE = 36177] = "RENDERBUFFER_GREEN_SIZE", e[e.RENDERBUFFER_BLUE_SIZE = 36178] = "RENDERBUFFER_BLUE_SIZE", e[e.RENDERBUFFER_ALPHA_SIZE = 36179] = "RENDERBUFFER_ALPHA_SIZE", e[e.RENDERBUFFER_DEPTH_SIZE = 36180] = "RENDERBUFFER_DEPTH_SIZE", e[e.RENDERBUFFER_STENCIL_SIZE = 36181] = "RENDERBUFFER_STENCIL_SIZE", e[e.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", e[e.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", e[e.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", e[e.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", e[e.COLOR_ATTACHMENT0 = 36064] = "COLOR_ATTACHMENT0", e[e.DEPTH_ATTACHMENT = 36096] = "DEPTH_ATTACHMENT", e[e.STENCIL_ATTACHMENT = 36128] = "STENCIL_ATTACHMENT", e[e.DEPTH_STENCIL_ATTACHMENT = 33306] = "DEPTH_STENCIL_ATTACHMENT", e[e.NONE = 0] = "NONE", e[e.FRAMEBUFFER_COMPLETE = 36053] = "FRAMEBUFFER_COMPLETE", e[e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", e[e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", e[e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", e[e.FRAMEBUFFER_UNSUPPORTED = 36061] = "FRAMEBUFFER_UNSUPPORTED", e[e.FRAMEBUFFER_BINDING = 36006] = "FRAMEBUFFER_BINDING", e[e.RENDERBUFFER_BINDING = 36007] = "RENDERBUFFER_BINDING", e[e.READ_FRAMEBUFFER = 36008] = "READ_FRAMEBUFFER", e[e.DRAW_FRAMEBUFFER = 36009] = "DRAW_FRAMEBUFFER", e[e.MAX_RENDERBUFFER_SIZE = 34024] = "MAX_RENDERBUFFER_SIZE", e[e.INVALID_FRAMEBUFFER_OPERATION = 1286] = "INVALID_FRAMEBUFFER_OPERATION", e[e.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL", e[e.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL", e[e.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL", e[e.READ_BUFFER = 3074] = "READ_BUFFER", e[e.UNPACK_ROW_LENGTH = 3314] = "UNPACK_ROW_LENGTH", e[e.UNPACK_SKIP_ROWS = 3315] = "UNPACK_SKIP_ROWS", e[e.UNPACK_SKIP_PIXELS = 3316] = "UNPACK_SKIP_PIXELS", e[e.PACK_ROW_LENGTH = 3330] = "PACK_ROW_LENGTH", e[e.PACK_SKIP_ROWS = 3331] = "PACK_SKIP_ROWS", e[e.PACK_SKIP_PIXELS = 3332] = "PACK_SKIP_PIXELS", e[e.TEXTURE_BINDING_3D = 32874] = "TEXTURE_BINDING_3D", e[e.UNPACK_SKIP_IMAGES = 32877] = "UNPACK_SKIP_IMAGES", e[e.UNPACK_IMAGE_HEIGHT = 32878] = "UNPACK_IMAGE_HEIGHT", e[e.MAX_3D_TEXTURE_SIZE = 32883] = "MAX_3D_TEXTURE_SIZE", e[e.MAX_ELEMENTS_VERTICES = 33e3] = "MAX_ELEMENTS_VERTICES", e[e.MAX_ELEMENTS_INDICES = 33001] = "MAX_ELEMENTS_INDICES", e[e.MAX_TEXTURE_LOD_BIAS = 34045] = "MAX_TEXTURE_LOD_BIAS", e[e.MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS", e[e.MAX_VERTEX_UNIFORM_COMPONENTS = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS", e[e.MAX_ARRAY_TEXTURE_LAYERS = 35071] = "MAX_ARRAY_TEXTURE_LAYERS", e[e.MIN_PROGRAM_TEXEL_OFFSET = 35076] = "MIN_PROGRAM_TEXEL_OFFSET", e[e.MAX_PROGRAM_TEXEL_OFFSET = 35077] = "MAX_PROGRAM_TEXEL_OFFSET", e[e.MAX_VARYING_COMPONENTS = 35659] = "MAX_VARYING_COMPONENTS", e[e.FRAGMENT_SHADER_DERIVATIVE_HINT = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT", e[e.RASTERIZER_DISCARD = 35977] = "RASTERIZER_DISCARD", e[e.VERTEX_ARRAY_BINDING = 34229] = "VERTEX_ARRAY_BINDING", e[e.MAX_VERTEX_OUTPUT_COMPONENTS = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS", e[e.MAX_FRAGMENT_INPUT_COMPONENTS = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS", e[e.MAX_SERVER_WAIT_TIMEOUT = 37137] = "MAX_SERVER_WAIT_TIMEOUT", e[e.MAX_ELEMENT_INDEX = 36203] = "MAX_ELEMENT_INDEX", e[e.RED = 6403] = "RED", e[e.RGB8 = 32849] = "RGB8", e[e.RGBA8 = 32856] = "RGBA8", e[e.RGB10_A2 = 32857] = "RGB10_A2", e[e.TEXTURE_3D = 32879] = "TEXTURE_3D", e[e.TEXTURE_WRAP_R = 32882] = "TEXTURE_WRAP_R", e[e.TEXTURE_MIN_LOD = 33082] = "TEXTURE_MIN_LOD", e[e.TEXTURE_MAX_LOD = 33083] = "TEXTURE_MAX_LOD", e[e.TEXTURE_BASE_LEVEL = 33084] = "TEXTURE_BASE_LEVEL", e[e.TEXTURE_MAX_LEVEL = 33085] = "TEXTURE_MAX_LEVEL", e[e.TEXTURE_COMPARE_MODE = 34892] = "TEXTURE_COMPARE_MODE", e[e.TEXTURE_COMPARE_FUNC = 34893] = "TEXTURE_COMPARE_FUNC", e[e.SRGB = 35904] = "SRGB", e[e.SRGB8 = 35905] = "SRGB8", e[e.SRGB8_ALPHA8 = 35907] = "SRGB8_ALPHA8", e[e.COMPARE_REF_TO_TEXTURE = 34894] = "COMPARE_REF_TO_TEXTURE", e[e.RGBA32F = 34836] = "RGBA32F", e[e.RGB32F = 34837] = "RGB32F", e[e.RGBA16F = 34842] = "RGBA16F", e[e.RGB16F = 34843] = "RGB16F", e[e.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", e[e.TEXTURE_BINDING_2D_ARRAY = 35869] = "TEXTURE_BINDING_2D_ARRAY", e[e.R11F_G11F_B10F = 35898] = "R11F_G11F_B10F", e[e.RGB9_E5 = 35901] = "RGB9_E5", e[e.RGBA32UI = 36208] = "RGBA32UI", e[e.RGB32UI = 36209] = "RGB32UI", e[e.RGBA16UI = 36214] = "RGBA16UI", e[e.RGB16UI = 36215] = "RGB16UI", e[e.RGBA8UI = 36220] = "RGBA8UI", e[e.RGB8UI = 36221] = "RGB8UI", e[e.RGBA32I = 36226] = "RGBA32I", e[e.RGB32I = 36227] = "RGB32I", e[e.RGBA16I = 36232] = "RGBA16I", e[e.RGB16I = 36233] = "RGB16I", e[e.RGBA8I = 36238] = "RGBA8I", e[e.RGB8I = 36239] = "RGB8I", e[e.RED_INTEGER = 36244] = "RED_INTEGER", e[e.RGB_INTEGER = 36248] = "RGB_INTEGER", e[e.RGBA_INTEGER = 36249] = "RGBA_INTEGER", e[e.R8 = 33321] = "R8", e[e.RG8 = 33323] = "RG8", e[e.R16F = 33325] = "R16F", e[e.R32F = 33326] = "R32F", e[e.RG16F = 33327] = "RG16F", e[e.RG32F = 33328] = "RG32F", e[e.R8I = 33329] = "R8I", e[e.R8UI = 33330] = "R8UI", e[e.R16I = 33331] = "R16I", e[e.R16UI = 33332] = "R16UI", e[e.R32I = 33333] = "R32I", e[e.R32UI = 33334] = "R32UI", e[e.RG8I = 33335] = "RG8I", e[e.RG8UI = 33336] = "RG8UI", e[e.RG16I = 33337] = "RG16I", e[e.RG16UI = 33338] = "RG16UI", e[e.RG32I = 33339] = "RG32I", e[e.RG32UI = 33340] = "RG32UI", e[e.R8_SNORM = 36756] = "R8_SNORM", e[e.RG8_SNORM = 36757] = "RG8_SNORM", e[e.RGB8_SNORM = 36758] = "RGB8_SNORM", e[e.RGBA8_SNORM = 36759] = "RGBA8_SNORM", e[e.RGB10_A2UI = 36975] = "RGB10_A2UI", e[e.TEXTURE_IMMUTABLE_FORMAT = 37167] = "TEXTURE_IMMUTABLE_FORMAT", e[e.TEXTURE_IMMUTABLE_LEVELS = 33503] = "TEXTURE_IMMUTABLE_LEVELS", e[e.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", e[e.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", e[e.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", e[e.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", e[e.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", e[e.HALF_FLOAT = 5131] = "HALF_FLOAT", e[e.RG = 33319] = "RG", e[e.RG_INTEGER = 33320] = "RG_INTEGER", e[e.INT_2_10_10_10_REV = 36255] = "INT_2_10_10_10_REV", e[e.CURRENT_QUERY = 34917] = "CURRENT_QUERY", e[e.QUERY_RESULT = 34918] = "QUERY_RESULT", e[e.QUERY_RESULT_AVAILABLE = 34919] = "QUERY_RESULT_AVAILABLE", e[e.ANY_SAMPLES_PASSED = 35887] = "ANY_SAMPLES_PASSED", e[e.ANY_SAMPLES_PASSED_CONSERVATIVE = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE", e[e.MAX_DRAW_BUFFERS = 34852] = "MAX_DRAW_BUFFERS", e[e.DRAW_BUFFER0 = 34853] = "DRAW_BUFFER0", e[e.DRAW_BUFFER1 = 34854] = "DRAW_BUFFER1", e[e.DRAW_BUFFER2 = 34855] = "DRAW_BUFFER2", e[e.DRAW_BUFFER3 = 34856] = "DRAW_BUFFER3", e[e.DRAW_BUFFER4 = 34857] = "DRAW_BUFFER4", e[e.DRAW_BUFFER5 = 34858] = "DRAW_BUFFER5", e[e.DRAW_BUFFER6 = 34859] = "DRAW_BUFFER6", e[e.DRAW_BUFFER7 = 34860] = "DRAW_BUFFER7", e[e.DRAW_BUFFER8 = 34861] = "DRAW_BUFFER8", e[e.DRAW_BUFFER9 = 34862] = "DRAW_BUFFER9", e[e.DRAW_BUFFER10 = 34863] = "DRAW_BUFFER10", e[e.DRAW_BUFFER11 = 34864] = "DRAW_BUFFER11", e[e.DRAW_BUFFER12 = 34865] = "DRAW_BUFFER12", e[e.DRAW_BUFFER13 = 34866] = "DRAW_BUFFER13", e[e.DRAW_BUFFER14 = 34867] = "DRAW_BUFFER14", e[e.DRAW_BUFFER15 = 34868] = "DRAW_BUFFER15", e[e.MAX_COLOR_ATTACHMENTS = 36063] = "MAX_COLOR_ATTACHMENTS", e[e.COLOR_ATTACHMENT1 = 36065] = "COLOR_ATTACHMENT1", e[e.COLOR_ATTACHMENT2 = 36066] = "COLOR_ATTACHMENT2", e[e.COLOR_ATTACHMENT3 = 36067] = "COLOR_ATTACHMENT3", e[e.COLOR_ATTACHMENT4 = 36068] = "COLOR_ATTACHMENT4", e[e.COLOR_ATTACHMENT5 = 36069] = "COLOR_ATTACHMENT5", e[e.COLOR_ATTACHMENT6 = 36070] = "COLOR_ATTACHMENT6", e[e.COLOR_ATTACHMENT7 = 36071] = "COLOR_ATTACHMENT7", e[e.COLOR_ATTACHMENT8 = 36072] = "COLOR_ATTACHMENT8", e[e.COLOR_ATTACHMENT9 = 36073] = "COLOR_ATTACHMENT9", e[e.COLOR_ATTACHMENT10 = 36074] = "COLOR_ATTACHMENT10", e[e.COLOR_ATTACHMENT11 = 36075] = "COLOR_ATTACHMENT11", e[e.COLOR_ATTACHMENT12 = 36076] = "COLOR_ATTACHMENT12", e[e.COLOR_ATTACHMENT13 = 36077] = "COLOR_ATTACHMENT13", e[e.COLOR_ATTACHMENT14 = 36078] = "COLOR_ATTACHMENT14", e[e.COLOR_ATTACHMENT15 = 36079] = "COLOR_ATTACHMENT15", e[e.SAMPLER_3D = 35679] = "SAMPLER_3D", e[e.SAMPLER_2D_SHADOW = 35682] = "SAMPLER_2D_SHADOW", e[e.SAMPLER_2D_ARRAY = 36289] = "SAMPLER_2D_ARRAY", e[e.SAMPLER_2D_ARRAY_SHADOW = 36292] = "SAMPLER_2D_ARRAY_SHADOW", e[e.SAMPLER_CUBE_SHADOW = 36293] = "SAMPLER_CUBE_SHADOW", e[e.INT_SAMPLER_2D = 36298] = "INT_SAMPLER_2D", e[e.INT_SAMPLER_3D = 36299] = "INT_SAMPLER_3D", e[e.INT_SAMPLER_CUBE = 36300] = "INT_SAMPLER_CUBE", e[e.INT_SAMPLER_2D_ARRAY = 36303] = "INT_SAMPLER_2D_ARRAY", e[e.UNSIGNED_INT_SAMPLER_2D = 36306] = "UNSIGNED_INT_SAMPLER_2D", e[e.UNSIGNED_INT_SAMPLER_3D = 36307] = "UNSIGNED_INT_SAMPLER_3D", e[e.UNSIGNED_INT_SAMPLER_CUBE = 36308] = "UNSIGNED_INT_SAMPLER_CUBE", e[e.UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY", e[e.MAX_SAMPLES = 36183] = "MAX_SAMPLES", e[e.SAMPLER_BINDING = 35097] = "SAMPLER_BINDING", e[e.PIXEL_PACK_BUFFER = 35051] = "PIXEL_PACK_BUFFER", e[e.PIXEL_UNPACK_BUFFER = 35052] = "PIXEL_UNPACK_BUFFER", e[e.PIXEL_PACK_BUFFER_BINDING = 35053] = "PIXEL_PACK_BUFFER_BINDING", e[e.PIXEL_UNPACK_BUFFER_BINDING = 35055] = "PIXEL_UNPACK_BUFFER_BINDING", e[e.COPY_READ_BUFFER = 36662] = "COPY_READ_BUFFER", e[e.COPY_WRITE_BUFFER = 36663] = "COPY_WRITE_BUFFER", e[e.COPY_READ_BUFFER_BINDING = 36662] = "COPY_READ_BUFFER_BINDING", e[e.COPY_WRITE_BUFFER_BINDING = 36663] = "COPY_WRITE_BUFFER_BINDING", e[e.FLOAT_MAT2x3 = 35685] = "FLOAT_MAT2x3", e[e.FLOAT_MAT2x4 = 35686] = "FLOAT_MAT2x4", e[e.FLOAT_MAT3x2 = 35687] = "FLOAT_MAT3x2", e[e.FLOAT_MAT3x4 = 35688] = "FLOAT_MAT3x4", e[e.FLOAT_MAT4x2 = 35689] = "FLOAT_MAT4x2", e[e.FLOAT_MAT4x3 = 35690] = "FLOAT_MAT4x3", e[e.UNSIGNED_INT_VEC2 = 36294] = "UNSIGNED_INT_VEC2", e[e.UNSIGNED_INT_VEC3 = 36295] = "UNSIGNED_INT_VEC3", e[e.UNSIGNED_INT_VEC4 = 36296] = "UNSIGNED_INT_VEC4", e[e.UNSIGNED_NORMALIZED = 35863] = "UNSIGNED_NORMALIZED", e[e.SIGNED_NORMALIZED = 36764] = "SIGNED_NORMALIZED", e[e.VERTEX_ATTRIB_ARRAY_INTEGER = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER", e[e.VERTEX_ATTRIB_ARRAY_DIVISOR = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR", e[e.TRANSFORM_FEEDBACK_BUFFER_MODE = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE", e[e.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", e[e.TRANSFORM_FEEDBACK_VARYINGS = 35971] = "TRANSFORM_FEEDBACK_VARYINGS", e[e.TRANSFORM_FEEDBACK_BUFFER_START = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START", e[e.TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE", e[e.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", e[e.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", e[e.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", e[e.INTERLEAVED_ATTRIBS = 35980] = "INTERLEAVED_ATTRIBS", e[e.SEPARATE_ATTRIBS = 35981] = "SEPARATE_ATTRIBS", e[e.TRANSFORM_FEEDBACK_BUFFER = 35982] = "TRANSFORM_FEEDBACK_BUFFER", e[e.TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING", e[e.TRANSFORM_FEEDBACK = 36386] = "TRANSFORM_FEEDBACK", e[e.TRANSFORM_FEEDBACK_PAUSED = 36387] = "TRANSFORM_FEEDBACK_PAUSED", e[e.TRANSFORM_FEEDBACK_ACTIVE = 36388] = "TRANSFORM_FEEDBACK_ACTIVE", e[e.TRANSFORM_FEEDBACK_BINDING = 36389] = "TRANSFORM_FEEDBACK_BINDING", e[e.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", e[e.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", e[e.FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE", e[e.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", e[e.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", e[e.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", e[e.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", e[e.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", e[e.FRAMEBUFFER_DEFAULT = 33304] = "FRAMEBUFFER_DEFAULT", e[e.DEPTH24_STENCIL8 = 35056] = "DEPTH24_STENCIL8", e[e.DRAW_FRAMEBUFFER_BINDING = 36006] = "DRAW_FRAMEBUFFER_BINDING", e[e.READ_FRAMEBUFFER_BINDING = 36010] = "READ_FRAMEBUFFER_BINDING", e[e.RENDERBUFFER_SAMPLES = 36011] = "RENDERBUFFER_SAMPLES", e[e.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", e[e.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", e[e.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", e[e.UNIFORM_BUFFER_BINDING = 35368] = "UNIFORM_BUFFER_BINDING", e[e.UNIFORM_BUFFER_START = 35369] = "UNIFORM_BUFFER_START", e[e.UNIFORM_BUFFER_SIZE = 35370] = "UNIFORM_BUFFER_SIZE", e[e.MAX_VERTEX_UNIFORM_BLOCKS = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS", e[e.MAX_FRAGMENT_UNIFORM_BLOCKS = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS", e[e.MAX_COMBINED_UNIFORM_BLOCKS = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS", e[e.MAX_UNIFORM_BUFFER_BINDINGS = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS", e[e.MAX_UNIFORM_BLOCK_SIZE = 35376] = "MAX_UNIFORM_BLOCK_SIZE", e[e.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", e[e.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", e[e.UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT", e[e.ACTIVE_UNIFORM_BLOCKS = 35382] = "ACTIVE_UNIFORM_BLOCKS", e[e.UNIFORM_TYPE = 35383] = "UNIFORM_TYPE", e[e.UNIFORM_SIZE = 35384] = "UNIFORM_SIZE", e[e.UNIFORM_BLOCK_INDEX = 35386] = "UNIFORM_BLOCK_INDEX", e[e.UNIFORM_OFFSET = 35387] = "UNIFORM_OFFSET", e[e.UNIFORM_ARRAY_STRIDE = 35388] = "UNIFORM_ARRAY_STRIDE", e[e.UNIFORM_MATRIX_STRIDE = 35389] = "UNIFORM_MATRIX_STRIDE", e[e.UNIFORM_IS_ROW_MAJOR = 35390] = "UNIFORM_IS_ROW_MAJOR", e[e.UNIFORM_BLOCK_BINDING = 35391] = "UNIFORM_BLOCK_BINDING", e[e.UNIFORM_BLOCK_DATA_SIZE = 35392] = "UNIFORM_BLOCK_DATA_SIZE", e[e.UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS", e[e.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", e[e.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", e[e.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", e[e.OBJECT_TYPE = 37138] = "OBJECT_TYPE", e[e.SYNC_CONDITION = 37139] = "SYNC_CONDITION", e[e.SYNC_STATUS = 37140] = "SYNC_STATUS", e[e.SYNC_FLAGS = 37141] = "SYNC_FLAGS", e[e.SYNC_FENCE = 37142] = "SYNC_FENCE", e[e.SYNC_GPU_COMMANDS_COMPLETE = 37143] = "SYNC_GPU_COMMANDS_COMPLETE", e[e.UNSIGNALED = 37144] = "UNSIGNALED", e[e.SIGNALED = 37145] = "SIGNALED", e[e.ALREADY_SIGNALED = 37146] = "ALREADY_SIGNALED", e[e.TIMEOUT_EXPIRED = 37147] = "TIMEOUT_EXPIRED", e[e.CONDITION_SATISFIED = 37148] = "CONDITION_SATISFIED", e[e.WAIT_FAILED = 37149] = "WAIT_FAILED", e[e.SYNC_FLUSH_COMMANDS_BIT = 1] = "SYNC_FLUSH_COMMANDS_BIT", e[e.COLOR = 6144] = "COLOR", e[e.DEPTH = 6145] = "DEPTH", e[e.STENCIL = 6146] = "STENCIL", e[e.MIN = 32775] = "MIN", e[e.MAX = 32776] = "MAX", e[e.DEPTH_COMPONENT24 = 33190] = "DEPTH_COMPONENT24", e[e.STREAM_READ = 35041] = "STREAM_READ", e[e.STREAM_COPY = 35042] = "STREAM_COPY", e[e.STATIC_READ = 35045] = "STATIC_READ", e[e.STATIC_COPY = 35046] = "STATIC_COPY", e[e.DYNAMIC_READ = 35049] = "DYNAMIC_READ", e[e.DYNAMIC_COPY = 35050] = "DYNAMIC_COPY", e[e.DEPTH_COMPONENT32F = 36012] = "DEPTH_COMPONENT32F", e[e.DEPTH32F_STENCIL8 = 36013] = "DEPTH32F_STENCIL8", e[e.INVALID_INDEX = 4294967295] = "INVALID_INDEX", e[e.TIMEOUT_IGNORED = -1] = "TIMEOUT_IGNORED", e[e.MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL", e[e.UNMASKED_VENDOR_WEBGL = 37445] = "UNMASKED_VENDOR_WEBGL", e[e.UNMASKED_RENDERER_WEBGL = 37446] = "UNMASKED_RENDERER_WEBGL", e[e.MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT", e[e.TEXTURE_MAX_ANISOTROPY_EXT = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT", e[e.R16_EXT = 33322] = "R16_EXT", e[e.RG16_EXT = 33324] = "RG16_EXT", e[e.RGB16_EXT = 32852] = "RGB16_EXT", e[e.RGBA16_EXT = 32859] = "RGBA16_EXT", e[e.R16_SNORM_EXT = 36760] = "R16_SNORM_EXT", e[e.RG16_SNORM_EXT = 36761] = "RG16_SNORM_EXT", e[e.RGB16_SNORM_EXT = 36762] = "RGB16_SNORM_EXT", e[e.RGBA16_SNORM_EXT = 36763] = "RGBA16_SNORM_EXT", e[e.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", e[e.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", e[e.COMPRESSED_RED_RGTC1_EXT = 36283] = "COMPRESSED_RED_RGTC1_EXT", e[e.COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT", e[e.COMPRESSED_RED_GREEN_RGTC2_EXT = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT", e[e.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", e[e.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT", e[e.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT", e[e.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT", e[e.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT", e[e.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", e[e.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", e[e.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", e[e.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", e[e.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", e[e.COMPRESSED_RGBA8_ETC2_EAC = 37493] = "COMPRESSED_RGBA8_ETC2_EAC", e[e.COMPRESSED_SRGB8_ETC2 = 37494] = "COMPRESSED_SRGB8_ETC2", e[e.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", e[e.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", e[e.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", e[e.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", e[e.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", e[e.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", e[e.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR", e[e.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR", e[e.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR", e[e.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR", e[e.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR", e[e.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR", e[e.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR", e[e.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR", e[e.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR", e[e.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR", e[e.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR", e[e.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR", e[e.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", e[e.QUERY_COUNTER_BITS_EXT = 34916] = "QUERY_COUNTER_BITS_EXT", e[e.CURRENT_QUERY_EXT = 34917] = "CURRENT_QUERY_EXT", e[e.QUERY_RESULT_EXT = 34918] = "QUERY_RESULT_EXT", e[e.QUERY_RESULT_AVAILABLE_EXT = 34919] = "QUERY_RESULT_AVAILABLE_EXT", e[e.TIME_ELAPSED_EXT = 35007] = "TIME_ELAPSED_EXT", e[e.TIMESTAMP_EXT = 36392] = "TIMESTAMP_EXT", e[e.GPU_DISJOINT_EXT = 36795] = "GPU_DISJOINT_EXT", e[e.COMPLETION_STATUS_KHR = 37297] = "COMPLETION_STATUS_KHR", e[e.DEPTH_CLAMP_EXT = 34383] = "DEPTH_CLAMP_EXT", e[e.FIRST_VERTEX_CONVENTION_WEBGL = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL", e[e.LAST_VERTEX_CONVENTION_WEBGL = 36430] = "LAST_VERTEX_CONVENTION_WEBGL", e[e.PROVOKING_VERTEX_WEBL = 36431] = "PROVOKING_VERTEX_WEBL", e[e.POLYGON_MODE_WEBGL = 2880] = "POLYGON_MODE_WEBGL", e[e.POLYGON_OFFSET_LINE_WEBGL = 10754] = "POLYGON_OFFSET_LINE_WEBGL", e[e.LINE_WEBGL = 6913] = "LINE_WEBGL", e[e.FILL_WEBGL = 6914] = "FILL_WEBGL", e[e.MAX_CLIP_DISTANCES_WEBGL = 3378] = "MAX_CLIP_DISTANCES_WEBGL", e[e.MAX_CULL_DISTANCES_WEBGL = 33529] = "MAX_CULL_DISTANCES_WEBGL", e[e.MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL", e[e.CLIP_DISTANCE0_WEBGL = 12288] = "CLIP_DISTANCE0_WEBGL", e[e.CLIP_DISTANCE1_WEBGL = 12289] = "CLIP_DISTANCE1_WEBGL", e[e.CLIP_DISTANCE2_WEBGL = 12290] = "CLIP_DISTANCE2_WEBGL", e[e.CLIP_DISTANCE3_WEBGL = 12291] = "CLIP_DISTANCE3_WEBGL", e[e.CLIP_DISTANCE4_WEBGL = 12292] = "CLIP_DISTANCE4_WEBGL", e[e.CLIP_DISTANCE5_WEBGL = 12293] = "CLIP_DISTANCE5_WEBGL", e[e.CLIP_DISTANCE6_WEBGL = 12294] = "CLIP_DISTANCE6_WEBGL", e[e.CLIP_DISTANCE7_WEBGL = 12295] = "CLIP_DISTANCE7_WEBGL", e[e.POLYGON_OFFSET_CLAMP_EXT = 36379] = "POLYGON_OFFSET_CLAMP_EXT", e[e.LOWER_LEFT_EXT = 36001] = "LOWER_LEFT_EXT", e[e.UPPER_LEFT_EXT = 36002] = "UPPER_LEFT_EXT", e[e.NEGATIVE_ONE_TO_ONE_EXT = 37726] = "NEGATIVE_ONE_TO_ONE_EXT", e[e.ZERO_TO_ONE_EXT = 37727] = "ZERO_TO_ONE_EXT", e[e.CLIP_ORIGIN_EXT = 37724] = "CLIP_ORIGIN_EXT", e[e.CLIP_DEPTH_MODE_EXT = 37725] = "CLIP_DEPTH_MODE_EXT", e[e.SRC1_COLOR_WEBGL = 35065] = "SRC1_COLOR_WEBGL", e[e.SRC1_ALPHA_WEBGL = 34185] = "SRC1_ALPHA_WEBGL", e[e.ONE_MINUS_SRC1_COLOR_WEBGL = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL", e[e.ONE_MINUS_SRC1_ALPHA_WEBGL = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL", e[e.MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL", e[e.MIRROR_CLAMP_TO_EDGE_EXT = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT"
-})(Qr || (Qr = {}));
-var uo = {
+})(Cs || (Cs = {}));
+var nu = {
         3042: !1,
         32773: new Float32Array([0, 0, 0, 0]),
         32777: 32774,
         34877: 32774,
         32969: 1,
         32968: 0,
         32971: 1,
@@ -16707,80 +16707,80 @@
         3331: 0,
         3314: 0,
         32878: 0,
         3316: 0,
         3315: 0,
         32877: 0
     },
-    At = (e, t, r) => t ? e.enable(r) : e.disable(r),
-    T0 = (e, t, r) => e.hint(r, t),
-    se = (e, t, r) => e.pixelStorei(r, t),
-    b0 = (e, t, r) => {
+    le = (e, t, r) => t ? e.enable(r) : e.disable(r),
+    z1 = (e, t, r) => e.hint(r, t),
+    gr = (e, t, r) => e.pixelStorei(r, t),
+    W1 = (e, t, r) => {
         let i = r === 36006 ? 36009 : 36008;
         return e.bindFramebuffer(i, t)
     },
-    fo = (e, t, r) => {
-        let s = {
+    iu = (e, t, r) => {
+        let n = {
             34964: 34962,
             36662: 36662,
             36663: 36663,
             35053: 35051,
             35055: 35052
         } [r];
-        e.bindBuffer(s, t)
+        e.bindBuffer(n, t)
     };
 
-function yd(e) {
+function ab(e) {
     return Array.isArray(e) || ArrayBuffer.isView(e) && !(e instanceof DataView)
 }
-var A0 = {
-    3042: At,
+var j1 = {
+    3042: le,
     32773: (e, t) => e.blendColor(...t),
     32777: "blendEquation",
     34877: "blendEquation",
     32969: "blendFunc",
     32968: "blendFunc",
     32971: "blendFunc",
     32970: "blendFunc",
     3106: (e, t) => e.clearColor(...t),
     3107: (e, t) => e.colorMask(...t),
-    2884: At,
+    2884: le,
     2885: (e, t) => e.cullFace(t),
-    2929: At,
+    2929: le,
     2931: (e, t) => e.clearDepth(t),
     2932: (e, t) => e.depthFunc(t),
     2928: (e, t) => e.depthRange(...t),
     2930: (e, t) => e.depthMask(t),
-    3024: At,
-    35723: T0,
+    3024: le,
+    35723: z1,
     35725: (e, t) => e.useProgram(t),
     36007: (e, t) => e.bindRenderbuffer(36161, t),
     36389: (e, t) => e.bindTransformFeedback?.(36386, t),
     34229: (e, t) => e.bindVertexArray(t),
-    36006: b0,
-    36010: b0,
-    34964: fo,
-    36662: fo,
-    36663: fo,
-    35053: fo,
-    35055: fo,
+    36006: W1,
+    36010: W1,
+    34964: iu,
+    36662: iu,
+    36663: iu,
+    35053: iu,
+    35055: iu,
     2886: (e, t) => e.frontFace(t),
-    33170: T0,
+    33170: z1,
     2849: (e, t) => e.lineWidth(t),
-    32823: At,
+    32823: le,
     32824: "polygonOffset",
     10752: "polygonOffset",
-    35977: At,
-    32926: At,
-    32928: At,
+    35977: le,
+    32926: le,
+    32928: le,
     32938: "sampleCoverage",
     32939: "sampleCoverage",
-    3089: At,
+    3089: le,
     3088: (e, t) => e.scissor(...t),
-    2960: At,
+    2960: le,
     2961: (e, t) => e.clearStencil(t),
     2968: (e, t) => e.stencilMaskSeparate(1028, t),
     36005: (e, t) => e.stencilMaskSeparate(1029, t),
     2962: "stencilFuncFront",
     2967: "stencilFuncFront",
     2963: "stencilFuncFront",
     34816: "stencilFuncBack",
@@ -16789,37 +16789,37 @@
     2964: "stencilOpFront",
     2965: "stencilOpFront",
     2966: "stencilOpFront",
     34817: "stencilOpBack",
     34818: "stencilOpBack",
     34819: "stencilOpBack",
     2978: (e, t) => e.viewport(...t),
-    34383: At,
-    10754: At,
-    12288: At,
-    12289: At,
-    12290: At,
-    12291: At,
-    12292: At,
-    12293: At,
-    12294: At,
-    12295: At,
-    3333: se,
-    3317: se,
-    37440: se,
-    37441: se,
-    37443: se,
-    3330: se,
-    3332: se,
-    3331: se,
-    3314: se,
-    32878: se,
-    3316: se,
-    3315: se,
-    32877: se,
+    34383: le,
+    10754: le,
+    12288: le,
+    12289: le,
+    12290: le,
+    12291: le,
+    12292: le,
+    12293: le,
+    12294: le,
+    12295: le,
+    3333: gr,
+    3317: gr,
+    37440: gr,
+    37441: gr,
+    37443: gr,
+    3330: gr,
+    3332: gr,
+    3331: gr,
+    3314: gr,
+    32878: gr,
+    3316: gr,
+    3315: gr,
+    32877: gr,
     framebuffer: (e, t) => {
         let r = t && "handle" in t ? t.handle : t;
         return e.bindFramebuffer(36160, r)
     },
     blend: (e, t) => t ? e.enable(3042) : e.disable(3042),
     blendColor: (e, t) => e.blendColor(...t),
     blendEquation: (e, t) => {
@@ -16850,45 +16850,45 @@
     polygonOffsetFill: (e, t) => t ? e.enable(32823) : e.disable(32823),
     polygonOffset: (e, t) => e.polygonOffset(...t),
     sampleCoverage: (e, t) => e.sampleCoverage(...t),
     scissorTest: (e, t) => t ? e.enable(3089) : e.disable(3089),
     scissor: (e, t) => e.scissor(...t),
     stencilTest: (e, t) => t ? e.enable(2960) : e.disable(2960),
     stencilMask: (e, t) => {
-        t = yd(t) ? t : [t, t];
+        t = ab(t) ? t : [t, t];
         let [r, i] = t;
         e.stencilMaskSeparate(1028, r), e.stencilMaskSeparate(1029, i)
     },
     stencilFunc: (e, t) => {
-        t = yd(t) && t.length === 3 ? [...t, ...t] : t;
-        let [r, i, s, n, o, a] = t;
-        e.stencilFuncSeparate(1028, r, i, s), e.stencilFuncSeparate(1029, n, o, a)
+        t = ab(t) && t.length === 3 ? [...t, ...t] : t;
+        let [r, i, n, s, o, a] = t;
+        e.stencilFuncSeparate(1028, r, i, n), e.stencilFuncSeparate(1029, s, o, a)
     },
     stencilOp: (e, t) => {
-        t = yd(t) && t.length === 3 ? [...t, ...t] : t;
-        let [r, i, s, n, o, a] = t;
-        e.stencilOpSeparate(1028, r, i, s), e.stencilOpSeparate(1029, n, o, a)
+        t = ab(t) && t.length === 3 ? [...t, ...t] : t;
+        let [r, i, n, s, o, a] = t;
+        e.stencilOpSeparate(1028, r, i, n), e.stencilOpSeparate(1029, s, o, a)
     },
     viewport: (e, t) => e.viewport(...t)
 };
 
-function gt(e, t, r) {
+function te(e, t, r) {
     return t[e] !== void 0 ? t[e] : r[e]
 }
-var E0 = {
-        blendEquation: (e, t, r) => e.blendEquationSeparate(gt(32777, t, r), gt(34877, t, r)),
-        blendFunc: (e, t, r) => e.blendFuncSeparate(gt(32969, t, r), gt(32968, t, r), gt(32971, t, r), gt(32970, t, r)),
-        polygonOffset: (e, t, r) => e.polygonOffset(gt(32824, t, r), gt(10752, t, r)),
-        sampleCoverage: (e, t, r) => e.sampleCoverage(gt(32938, t, r), gt(32939, t, r)),
-        stencilFuncFront: (e, t, r) => e.stencilFuncSeparate(1028, gt(2962, t, r), gt(2967, t, r), gt(2963, t, r)),
-        stencilFuncBack: (e, t, r) => e.stencilFuncSeparate(1029, gt(34816, t, r), gt(36003, t, r), gt(36004, t, r)),
-        stencilOpFront: (e, t, r) => e.stencilOpSeparate(1028, gt(2964, t, r), gt(2965, t, r), gt(2966, t, r)),
-        stencilOpBack: (e, t, r) => e.stencilOpSeparate(1029, gt(34817, t, r), gt(34818, t, r), gt(34819, t, r))
+var H1 = {
+        blendEquation: (e, t, r) => e.blendEquationSeparate(te(32777, t, r), te(34877, t, r)),
+        blendFunc: (e, t, r) => e.blendFuncSeparate(te(32969, t, r), te(32968, t, r), te(32971, t, r), te(32970, t, r)),
+        polygonOffset: (e, t, r) => e.polygonOffset(te(32824, t, r), te(10752, t, r)),
+        sampleCoverage: (e, t, r) => e.sampleCoverage(te(32938, t, r), te(32939, t, r)),
+        stencilFuncFront: (e, t, r) => e.stencilFuncSeparate(1028, te(2962, t, r), te(2967, t, r), te(2963, t, r)),
+        stencilFuncBack: (e, t, r) => e.stencilFuncSeparate(1029, te(34816, t, r), te(36003, t, r), te(36004, t, r)),
+        stencilOpFront: (e, t, r) => e.stencilOpSeparate(1028, te(2964, t, r), te(2965, t, r), te(2966, t, r)),
+        stencilOpBack: (e, t, r) => e.stencilOpSeparate(1029, te(34817, t, r), te(34818, t, r), te(34819, t, r))
     },
-    xd = {
+    cb = {
         enable: (e, t) => e({
             [t]: !0
         }),
         disable: (e, t) => e({
             [t]: !1
         }),
         pixelStorei: (e, t, r) => e({
@@ -16938,16 +16938,16 @@
             } [t];
             return i ? e({
                 [i]: r
             }) : {
                 valueChanged: !0
             }
         },
-        blendColor: (e, t, r, i, s) => e({
-            32773: new Float32Array([t, r, i, s])
+        blendColor: (e, t, r, i, n) => e({
+            32773: new Float32Array([t, r, i, n])
         }),
         blendEquation: (e, t) => e({
             32777: t,
             34877: t
         }),
         blendEquationSeparate: (e, t, r) => e({
             32777: t,
@@ -16955,31 +16955,31 @@
         }),
         blendFunc: (e, t, r) => e({
             32969: t,
             32968: r,
             32971: t,
             32970: r
         }),
-        blendFuncSeparate: (e, t, r, i, s) => e({
+        blendFuncSeparate: (e, t, r, i, n) => e({
             32969: t,
             32968: r,
             32971: i,
-            32970: s
+            32970: n
         }),
-        clearColor: (e, t, r, i, s) => e({
-            3106: new Float32Array([t, r, i, s])
+        clearColor: (e, t, r, i, n) => e({
+            3106: new Float32Array([t, r, i, n])
         }),
         clearDepth: (e, t) => e({
             2931: t
         }),
         clearStencil: (e, t) => e({
             2961: t
         }),
-        colorMask: (e, t, r, i, s) => e({
-            3107: [t, r, i, s]
+        colorMask: (e, t, r, i, n) => e({
+            3107: [t, r, i, n]
         }),
         cullFace: (e, t) => e({
             2885: t
         }),
         depthFunc: (e, t) => e({
             2932: t
         }),
@@ -16999,16 +16999,16 @@
             32824: t,
             10752: r
         }),
         sampleCoverage: (e, t, r) => e({
             32938: t,
             32939: r
         }),
-        scissor: (e, t, r, i, s) => e({
-            3088: new Int32Array([t, r, i, s])
+        scissor: (e, t, r, i, n) => e({
+            3088: new Int32Array([t, r, i, n])
         }),
         stencilMask: (e, t) => e({
             2968: t,
             36005: t
         }),
         stencilMaskSeparate: (e, t, r) => e({
             [t === 1028 ? 2968 : 36005]: r
@@ -17017,293 +17017,293 @@
             2962: t,
             2967: r,
             2963: i,
             34816: t,
             36003: r,
             36004: i
         }),
-        stencilFuncSeparate: (e, t, r, i, s) => e({
+        stencilFuncSeparate: (e, t, r, i, n) => e({
             [t === 1028 ? 2962 : 34816]: r,
             [t === 1028 ? 2967 : 36003]: i,
-            [t === 1028 ? 2963 : 36004]: s
+            [t === 1028 ? 2963 : 36004]: n
         }),
         stencilOp: (e, t, r, i) => e({
             2964: t,
             2965: r,
             2966: i,
             34817: t,
             34818: r,
             34819: i
         }),
-        stencilOpSeparate: (e, t, r, i, s) => e({
+        stencilOpSeparate: (e, t, r, i, n) => e({
             [t === 1028 ? 2964 : 34817]: r,
             [t === 1028 ? 2965 : 34818]: i,
-            [t === 1028 ? 2966 : 34819]: s
+            [t === 1028 ? 2966 : 34819]: n
         }),
-        viewport: (e, t, r, i, s) => e({
-            2978: [t, r, i, s]
+        viewport: (e, t, r, i, n) => e({
+            2978: [t, r, i, n]
         })
     },
-    Qe = (e, t) => e.isEnabled(t),
-    Td = {
-        3042: Qe,
-        2884: Qe,
-        2929: Qe,
-        3024: Qe,
-        32823: Qe,
-        32926: Qe,
-        32928: Qe,
-        3089: Qe,
-        2960: Qe,
-        35977: Qe
+    Xi = (e, t) => e.isEnabled(t),
+    lb = {
+        3042: Xi,
+        2884: Xi,
+        2929: Xi,
+        3024: Xi,
+        32823: Xi,
+        32926: Xi,
+        32928: Xi,
+        3089: Xi,
+        2960: Xi,
+        35977: Xi
     },
-    S0 = new Set([34016, 36388, 36387, 35983, 35368, 34965, 35739, 35738, 3074, 34853, 34854, 34855, 34856, 34857, 34858, 34859, 34860, 34861, 34862, 34863, 34864, 34865, 34866, 34867, 34868, 35097, 32873, 35869, 32874, 34068]);
+    $1 = new Set([34016, 36388, 36387, 35983, 35368, 34965, 35739, 35738, 3074, 34853, 34854, 34855, 34856, 34857, 34858, 34859, 34860, 34861, 34862, 34863, 34864, 34865, 34866, 34867, 34868, 35097, 32873, 35869, 32874, 34068]);
 
-function Me(e, t) {
-    if (tR(t)) return;
+function si(e, t) {
+    if (sD(t)) return;
     let r = {};
-    for (let s in t) {
-        let n = Number(s),
-            o = A0[s];
-        o && (typeof o == "string" ? r[o] = !0 : o(e, t[s], n))
+    for (let n in t) {
+        let s = Number(n),
+            o = j1[n];
+        o && (typeof o == "string" ? r[o] = !0 : o(e, t[n], s))
     }
     let i = e.state && e.state.cache;
     if (i)
-        for (let s in r) {
-            let n = E0[s];
-            n(e, t, i)
+        for (let n in r) {
+            let s = H1[n];
+            s(e, t, i)
         }
 }
 
-function $c(e, t = uo) {
+function Zd(e, t = nu) {
     if (typeof t == "number") {
-        let s = t,
-            n = Td[s];
-        return n ? n(e, s) : e.getParameter(s)
+        let n = t,
+            s = lb[n];
+        return s ? s(e, n) : e.getParameter(n)
     }
     let r = Array.isArray(t) ? t : Object.keys(t),
         i = {};
-    for (let s of r) {
-        let n = Td[s];
-        i[s] = n ? n(e, Number(s)) : e.getParameter(Number(s))
+    for (let n of r) {
+        let s = lb[n];
+        i[n] = s ? s(e, Number(n)) : e.getParameter(Number(n))
     }
     return i
 }
 
-function w0(e) {
-    Me(e, uo)
+function X1(e) {
+    si(e, nu)
 }
 
-function tR(e) {
+function sD(e) {
     for (let t in e) return !1;
     return !0
 }
 
-function v0(e, t) {
+function Y1(e, t) {
     if (e === t) return !0;
     let r = Array.isArray(e) || ArrayBuffer.isView(e),
         i = Array.isArray(t) || ArrayBuffer.isView(t);
     if (r && i && e.length === t.length) {
-        for (let s = 0; s < e.length; ++s)
-            if (e[s] !== t[s]) return !1;
+        for (let n = 0; n < e.length; ++n)
+            if (e[n] !== t[n]) return !1;
         return !0
     }
     return !1
 }
-var bd = class {
+var ub = class {
     constructor(t, {
         copyState: r = !1,
         log: i = () => {}
     } = {}) {
-        p(this, "gl");
-        p(this, "program", null);
-        p(this, "stateStack", []);
-        p(this, "enable", !0);
-        p(this, "cache");
-        p(this, "log");
-        this.gl = t, this.cache = r ? $c(t) : Object.assign({}, uo), this.log = i, this._updateCache = this._updateCache.bind(this), Object.seal(this)
+        m(this, "gl");
+        m(this, "program", null);
+        m(this, "stateStack", []);
+        m(this, "enable", !0);
+        m(this, "cache");
+        m(this, "log");
+        this.gl = t, this.cache = r ? Zd(t) : Object.assign({}, nu), this.log = i, this._updateCache = this._updateCache.bind(this), Object.seal(this)
     }
     push(t = {}) {
         this.stateStack.push({})
     }
     pop() {
-        Q(this.stateStack.length > 0);
+        _t(this.stateStack.length > 0);
         let t = this.stateStack[this.stateStack.length - 1];
-        Me(this.gl, t), this.stateStack.pop()
+        si(this.gl, t), this.stateStack.pop()
     }
     _updateCache(t) {
         let r = !1,
-            i, s = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
-        for (let n in t) {
-            Q(n !== void 0);
-            let o = t[n],
-                a = this.cache[n];
-            v0(o, a) || (r = !0, i = a, s && !(n in s) && (s[n] = a), this.cache[n] = o)
+            i, n = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
+        for (let s in t) {
+            _t(s !== void 0);
+            let o = t[s],
+                a = this.cache[s];
+            Y1(o, a) || (r = !0, i = a, n && !(s in n) && (n[s] = a), this.cache[s] = o)
         }
         return {
             valueChanged: r,
             oldValue: i
         }
     }
 };
 
-function ki(e) {
+function Co(e) {
     return e.state
 }
 
-function Ad(e, t) {
+function fb(e, t) {
     let {
         enable: r = !0,
         copyState: i
     } = t;
-    if (Q(i !== void 0), !e.state) {
-        e.state = new bd(e, {
+    if (_t(i !== void 0), !e.state) {
+        e.state = new ub(e, {
             copyState: i
-        }), rR(e);
-        for (let n in xd) {
-            let o = xd[n];
-            eR(e, n, o)
+        }), aD(e);
+        for (let s in cb) {
+            let o = cb[s];
+            oD(e, s, o)
         }
-        R0(e, "getParameter"), R0(e, "isEnabled")
+        q1(e, "getParameter"), q1(e, "isEnabled")
     }
-    let s = ki(e);
-    return s.enable = r, e
+    let n = Co(e);
+    return n.enable = r, e
 }
 
-function Gr(e) {
-    let t = ki(e);
-    t || (Ad(e, {
+function Os(e) {
+    let t = Co(e);
+    t || (fb(e, {
         copyState: !1
-    }), t = ki(e)), t.push()
+    }), t = Co(e)), t.push()
 }
 
-function yr(e) {
-    let t = ki(e);
-    Q(t), t.pop()
+function In(e) {
+    let t = Co(e);
+    _t(t), t.pop()
 }
 
-function R0(e, t) {
+function q1(e, t) {
     let r = e[t].bind(e);
-    e[t] = function(s) {
-        if (s === void 0 || S0.has(s)) return r(s);
-        let n = ki(e);
-        return s in n.cache || (n.cache[s] = r(s)), n.enable ? n.cache[s] : r(s)
+    e[t] = function(n) {
+        if (n === void 0 || $1.has(n)) return r(n);
+        let s = Co(e);
+        return n in s.cache || (s.cache[n] = r(n)), s.enable ? s.cache[n] : r(n)
     }, Object.defineProperty(e[t], "name", {
         value: `${t}-from-cache`,
         configurable: !1
     })
 }
 
-function eR(e, t, r) {
+function oD(e, t, r) {
     if (!e[t]) return;
     let i = e[t].bind(e);
-    e[t] = function(...n) {
-        let o = ki(e),
+    e[t] = function(...s) {
+        let o = Co(e),
             {
                 valueChanged: a,
                 oldValue: c
-            } = r(o._updateCache, ...n);
-        return a && i(...n), c
+            } = r(o._updateCache, ...s);
+        return a && i(...s), c
     }, Object.defineProperty(e[t], "name", {
         value: `${t}-to-cache`,
         configurable: !1
     })
 }
 
-function rR(e) {
+function aD(e) {
     let t = e.useProgram.bind(e);
     e.useProgram = function(i) {
-        let s = ki(e);
-        s.program !== i && (t(i), s.program = i)
+        let n = Co(e);
+        n.program !== i && (t(i), n.program = i)
     }
 }
-var iR = {
+var cD = {
     powerPreference: "high-performance",
     onContextLost: () => console.error("WebGL context lost"),
     onContextRestored: () => console.info("WebGL context restored")
 };
 
-function P0(e, t) {
+function Z1(e, t) {
     t = {
-        ...iR,
+        ...cD,
         ...t
     };
     let r = null,
-        i = n => r = n.statusMessage || r;
+        i = s => r = s.statusMessage || r;
     e.addEventListener("webglcontextcreationerror", i, !1);
-    let s = null;
-    if (s || (s = e.getContext("webgl2", t)), e.removeEventListener("webglcontextcreationerror", i, !1), !s) throw new Error(`Failed to create WebGL context: ${r||"Unknown error"}`);
+    let n = null;
+    if (n || (n = e.getContext("webgl2", t)), e.removeEventListener("webglcontextcreationerror", i, !1), !n) throw new Error(`Failed to create WebGL context: ${r||"Unknown error"}`);
     if (t.onContextLost) {
         let {
-            onContextLost: n
+            onContextLost: s
         } = t;
-        e.addEventListener("webglcontextlost", o => n(o), !1)
+        e.addEventListener("webglcontextlost", o => s(o), !1)
     }
     if (t.onContextRestored) {
         let {
-            onContextRestored: n
+            onContextRestored: s
         } = t;
-        e.addEventListener("webglcontextrestored", o => n(o), !1)
+        e.addEventListener("webglcontextrestored", o => s(o), !1)
     }
-    return s
+    return n
 }
 
-function xe(e, t, r) {
+function Vr(e, t, r) {
     return r[t] === void 0 && (r[t] = e.getExtension(t) || null), r[t]
 }
 
-function M0(e, t) {
+function K1(e, t) {
     let r = e.getParameter(7936),
         i = e.getParameter(7937);
-    xe(e, "WEBGL_debug_renderer_info", t);
-    let s = t.WEBGL_debug_renderer_info,
-        n = e.getParameter(s ? s.UNMASKED_VENDOR_WEBGL : 7936),
-        o = e.getParameter(s ? s.UNMASKED_RENDERER_WEBGL : 7937),
-        a = n || r,
+    Vr(e, "WEBGL_debug_renderer_info", t);
+    let n = t.WEBGL_debug_renderer_info,
+        s = e.getParameter(n ? n.UNMASKED_VENDOR_WEBGL : 7936),
+        o = e.getParameter(n ? n.UNMASKED_RENDERER_WEBGL : 7937),
+        a = s || r,
         c = o || i,
         l = e.getParameter(7938),
-        h = C0(a, c),
-        f = sR(a, c),
-        u = nR(a, c);
+        u = G1(a, c),
+        f = lD(a, c),
+        h = uD(a, c);
     return {
         type: "webgl",
-        gpu: h,
-        gpuType: u,
+        gpu: u,
+        gpuType: h,
         gpuBackend: f,
         vendor: a,
         renderer: c,
         version: l,
         shadingLanguage: "glsl",
         shadingLanguageVersion: 300
     }
 }
 
-function C0(e, t) {
+function G1(e, t) {
     return /NVIDIA/i.exec(e) || /NVIDIA/i.exec(t) ? "nvidia" : /INTEL/i.exec(e) || /INTEL/i.exec(t) ? "intel" : /Apple/i.exec(e) || /Apple/i.exec(t) ? "apple" : /AMD/i.exec(e) || /AMD/i.exec(t) || /ATI/i.exec(e) || /ATI/i.exec(t) ? "amd" : /SwiftShader/i.exec(e) || /SwiftShader/i.exec(t) ? "software" : "unknown"
 }
 
-function sR(e, t) {
+function lD(e, t) {
     return /Metal/i.exec(e) || /Metal/i.exec(t) ? "metal" : /ANGLE/i.exec(e) || /ANGLE/i.exec(t) ? "opengl" : "unknown"
 }
 
-function nR(e, t) {
+function uD(e, t) {
     if (/SwiftShader/i.exec(e) || /SwiftShader/i.exec(t)) return "cpu";
-    switch (C0(e, t)) {
+    switch (G1(e, t)) {
         case "intel":
             return "integrated";
         case "software":
             return "cpu";
         case "unknown":
             return "unknown";
         default:
             return "discrete"
     }
 }
 
-function Yc(e) {
+function Kd(e) {
     switch (e) {
         case "uint8":
             return 5121;
         case "sint8":
             return 5120;
         case "unorm8":
             return 5121;
@@ -17324,69 +17324,69 @@
         case "float16":
             return 5131;
         case "float32":
             return 5126
     }
     throw new Error(String(e))
 }
-var Ft = "texture-compression-bc",
-    at = "texture-compression-astc",
-    Ge = "texture-compression-etc2",
-    oR = "texture-compression-etc1-webgl",
-    qc = "texture-compression-pvrtc-webgl",
-    Ed = "texture-compression-atc-webgl",
-    po = "float32-renderable-webgl",
-    Sd = "float16-renderable-webgl",
-    aR = "rgb9e5ufloat_renderable-webgl",
-    wd = "snorm8-renderable-webgl",
-    go = "norm16-renderable-webgl",
-    vd = "snorm16-renderable-webgl",
-    Zc = "float32-filterable",
-    I0 = "float16-filterable-webgl",
-    mo = "WEBGL_compressed_texture_s3tc",
-    _o = "WEBGL_compressed_texture_s3tc_srgb",
-    Ns = "EXT_texture_compression_rgtc",
-    Fs = "EXT_texture_compression_bptc",
-    cR = "WEBGL_compressed_texture_etc",
-    lR = "WEBGL_compressed_texture_astc",
-    hR = "WEBGL_compressed_texture_etc1",
-    fR = "WEBGL_compressed_texture_pvrtc",
-    uR = "WEBGL_compressed_texture_atc",
-    O0 = "EXT_texture_norm16",
-    N0 = "EXT_render_snorm",
-    dR = "EXT_color_buffer_float",
-    Kc = {
+var Ce = "texture-compression-bc",
+    Lt = "texture-compression-astc",
+    Yi = "texture-compression-etc2",
+    fD = "texture-compression-etc1-webgl",
+    Gd = "texture-compression-pvrtc-webgl",
+    hb = "texture-compression-atc-webgl",
+    su = "float32-renderable-webgl",
+    db = "float16-renderable-webgl",
+    hD = "rgb9e5ufloat_renderable-webgl",
+    pb = "snorm8-renderable-webgl",
+    ou = "norm16-renderable-webgl",
+    mb = "snorm16-renderable-webgl",
+    Jd = "float32-filterable",
+    J1 = "float16-filterable-webgl",
+    au = "WEBGL_compressed_texture_s3tc",
+    cu = "WEBGL_compressed_texture_s3tc_srgb",
+    Ja = "EXT_texture_compression_rgtc",
+    Qa = "EXT_texture_compression_bptc",
+    dD = "WEBGL_compressed_texture_etc",
+    pD = "WEBGL_compressed_texture_astc",
+    mD = "WEBGL_compressed_texture_etc1",
+    gD = "WEBGL_compressed_texture_pvrtc",
+    _D = "WEBGL_compressed_texture_atc",
+    Q1 = "EXT_texture_norm16",
+    tA = "EXT_render_snorm",
+    yD = "EXT_color_buffer_float",
+    Qd = {
         "float32-renderable-webgl": ["EXT_color_buffer_float"],
         "float16-renderable-webgl": ["EXT_color_buffer_half_float"],
         "rgb9e5ufloat_renderable-webgl": ["WEBGL_render_shared_exponent"],
-        "snorm8-renderable-webgl": [N0],
-        "norm16-renderable-webgl": [O0],
-        "snorm16-renderable-webgl": [O0, N0],
+        "snorm8-renderable-webgl": [tA],
+        "norm16-renderable-webgl": [Q1],
+        "snorm16-renderable-webgl": [Q1, tA],
         "float32-filterable": ["OES_texture_float_linear"],
         "float16-filterable-webgl": ["OES_texture_half_float_linear"],
         "texture-filterable-anisotropic-webgl": ["EXT_texture_filter_anisotropic"],
         "texture-blend-float-webgl": ["EXT_float_blend"],
-        "texture-compression-bc": [mo, _o, Ns, Fs],
-        "texture-compression-bc5-webgl": [Ns],
-        "texture-compression-bc7-webgl": [Fs],
-        "texture-compression-etc2": [cR],
-        "texture-compression-astc": [lR],
-        "texture-compression-etc1-webgl": [hR],
-        "texture-compression-pvrtc-webgl": [fR],
-        "texture-compression-atc-webgl": [uR]
+        "texture-compression-bc": [au, cu, Ja, Qa],
+        "texture-compression-bc5-webgl": [Ja],
+        "texture-compression-bc7-webgl": [Qa],
+        "texture-compression-etc2": [dD],
+        "texture-compression-astc": [pD],
+        "texture-compression-etc1-webgl": [mD],
+        "texture-compression-pvrtc-webgl": [gD],
+        "texture-compression-atc-webgl": [_D]
     };
 
-function F0(e) {
-    return e in Kc
+function eA(e) {
+    return e in Qd
 }
 
-function D0(e, t, r) {
-    return (Kc[t] || []).every(s => xe(e, s, r))
+function rA(e, t, r) {
+    return (Qd[t] || []).every(n => Vr(e, n, r))
 }
-var Qc = {
+var tp = {
         "rgb8unorm-unsized": {
             gl: 6407,
             b: 4,
             c: 2,
             bpp: 4,
             dataFormat: 6407,
             types: [5121, 33635]
@@ -17405,15 +17405,15 @@
             c: 1,
             rb: !0
         },
         r8snorm: {
             gl: 36756,
             b: 1,
             c: 1,
-            render: wd
+            render: pb
         },
         r8uint: {
             gl: 33330,
             b: 1,
             c: 1,
             rb: !0
         },
@@ -17429,15 +17429,15 @@
             c: 2,
             rb: !0
         },
         rg8snorm: {
             gl: 36757,
             b: 2,
             c: 2,
-            render: wd
+            render: pb
         },
         rg8uint: {
             gl: 33336,
             b: 2,
             c: 2,
             rb: !0
         },
@@ -17459,30 +17459,30 @@
             c: 1,
             rb: !0
         },
         r16float: {
             gl: 33325,
             b: 2,
             c: 1,
-            render: Sd,
+            render: db,
             filter: "float16-filterable-webgl",
             rb: !0
         },
         "r16unorm-webgl": {
             gl: 33322,
             b: 2,
             c: 1,
-            f: go,
+            f: ou,
             rb: !0
         },
         "r16snorm-webgl": {
             gl: 36760,
             b: 2,
             c: 1,
-            f: vd
+            f: mb
         },
         "rgba4unorm-webgl": {
             gl: 32854,
             b: 2,
             c: 4,
             wgpu: !1,
             rb: !0
@@ -17525,15 +17525,15 @@
             c: 4,
             bpp: 4
         },
         rgba8snorm: {
             gl: 36759,
             b: 4,
             c: 4,
-            render: wd
+            render: pb
         },
         rgba8uint: {
             gl: 36220,
             b: 4,
             c: 4,
             bpp: 4
         },
@@ -17564,29 +17564,29 @@
             bpp: 4
         },
         rg16float: {
             gl: 33327,
             bpp: 4,
             b: 4,
             c: 2,
-            render: Sd,
-            filter: I0,
+            render: db,
+            filter: J1,
             rb: !0
         },
         "rg16unorm-webgl": {
             gl: 33324,
             b: 2,
             c: 2,
-            render: go
+            render: ou
         },
         "rg16snorm-webgl": {
             gl: 36761,
             b: 2,
             c: 2,
-            render: vd
+            render: mb
         },
         r32uint: {
             gl: 33334,
             b: 4,
             c: 1,
             bpp: 4,
             rb: !0
@@ -17599,30 +17599,30 @@
             rb: !0
         },
         r32float: {
             gl: 33326,
             bpp: 4,
             b: 4,
             c: 1,
-            render: po,
-            filter: Zc
+            render: su,
+            filter: Jd
         },
         rgb9e5ufloat: {
             gl: 35901,
             b: 4,
             c: 3,
             p: 1,
-            render: aR
+            render: hD
         },
         rg11b10ufloat: {
             gl: 35898,
             b: 4,
             c: 3,
             p: 1,
-            render: po,
+            render: su,
             rb: !0
         },
         rgb10a2unorm: {
             gl: 32857,
             b: 4,
             c: 4,
             p: 1,
@@ -17637,21 +17637,21 @@
             bpp: 4,
             rb: !0
         },
         "rgb16unorm-webgl": {
             gl: 32852,
             b: 2,
             c: 3,
-            f: go
+            f: ou
         },
         "rgb16snorm-webgl": {
             gl: 36762,
             b: 2,
             c: 3,
-            f: go
+            f: ou
         },
         rg32uint: {
             gl: 33340,
             b: 8,
             c: 2,
             rb: !0
         },
@@ -17661,16 +17661,16 @@
             c: 2,
             rb: !0
         },
         rg32float: {
             gl: 33328,
             b: 8,
             c: 2,
-            render: po,
-            filter: Zc,
+            render: su,
+            filter: Jd,
             rb: !0
         },
         rgba16uint: {
             gl: 36214,
             b: 8,
             c: 4,
             rb: !0
@@ -17681,35 +17681,35 @@
             c: 4,
             rb: !0
         },
         rgba16float: {
             gl: 34842,
             b: 8,
             c: 4,
-            render: Sd,
-            filter: I0
+            render: db,
+            filter: J1
         },
         "rgba16unorm-webgl": {
             gl: 32859,
             b: 2,
             c: 4,
-            render: go,
+            render: ou,
             rb: !0
         },
         "rgba16snorm-webgl": {
             gl: 36763,
             b: 2,
             c: 4,
-            render: vd
+            render: mb
         },
         "rgb32float-webgl": {
             gl: 34837,
-            render: po,
-            filter: Zc,
-            gl2ext: dR,
+            render: su,
+            filter: Jd,
+            gl2ext: yD,
             dataFormat: 6407,
             types: [5126]
         },
         rgba32uint: {
             gl: 36208,
             b: 16,
             c: 4,
@@ -17721,16 +17721,16 @@
             c: 4,
             rb: !0
         },
         rgba32float: {
             gl: 34836,
             b: 16,
             c: 4,
-            render: po,
-            filter: Zc,
+            render: su,
+            filter: Jd,
             rb: !0
         },
         stencil8: {
             gl: 36168,
             b: 1,
             c: 1,
             attachment: 36128,
@@ -17791,412 +17791,412 @@
             attachment: 33306,
             dataFormat: 34041,
             types: [36269],
             rb: !0
         },
         "bc1-rgb-unorm-webgl": {
             gl: 33776,
-            x: mo,
-            f: Ft
+            x: au,
+            f: Ce
         },
         "bc1-rgb-unorm-srgb-webgl": {
             gl: 35916,
-            x: _o,
-            f: Ft
+            x: cu,
+            f: Ce
         },
         "bc1-rgba-unorm": {
             gl: 33777,
-            x: mo,
-            f: Ft
+            x: au,
+            f: Ce
         },
         "bc1-rgba-unorm-srgb": {
             gl: 35916,
-            x: _o,
-            f: Ft
+            x: cu,
+            f: Ce
         },
         "bc2-rgba-unorm": {
             gl: 33778,
-            x: mo,
-            f: Ft
+            x: au,
+            f: Ce
         },
         "bc2-rgba-unorm-srgb": {
             gl: 35918,
-            x: _o,
-            f: Ft
+            x: cu,
+            f: Ce
         },
         "bc3-rgba-unorm": {
             gl: 33779,
-            x: mo,
-            f: Ft
+            x: au,
+            f: Ce
         },
         "bc3-rgba-unorm-srgb": {
             gl: 35919,
-            x: _o,
-            f: Ft
+            x: cu,
+            f: Ce
         },
         "bc4-r-unorm": {
             gl: 36283,
-            x: Ns,
-            f: Ft
+            x: Ja,
+            f: Ce
         },
         "bc4-r-snorm": {
             gl: 36284,
-            x: Ns,
-            f: Ft
+            x: Ja,
+            f: Ce
         },
         "bc5-rg-unorm": {
             gl: 36285,
-            x: Ns,
-            f: Ft
+            x: Ja,
+            f: Ce
         },
         "bc5-rg-snorm": {
             gl: 36286,
-            x: Ns,
-            f: Ft
+            x: Ja,
+            f: Ce
         },
         "bc6h-rgb-ufloat": {
             gl: 36495,
-            x: Fs,
-            f: Ft
+            x: Qa,
+            f: Ce
         },
         "bc6h-rgb-float": {
             gl: 36494,
-            x: Fs,
-            f: Ft
+            x: Qa,
+            f: Ce
         },
         "bc7-rgba-unorm": {
             gl: 36492,
-            x: Fs,
-            f: Ft
+            x: Qa,
+            f: Ce
         },
         "bc7-rgba-unorm-srgb": {
             gl: 36493,
-            x: Fs,
-            f: Ft
+            x: Qa,
+            f: Ce
         },
         "etc2-rgb8unorm": {
             gl: 37492,
-            f: Ge
+            f: Yi
         },
         "etc2-rgb8unorm-srgb": {
             gl: 37494,
-            f: Ge
+            f: Yi
         },
         "etc2-rgb8a1unorm": {
             gl: 37496,
-            f: Ge
+            f: Yi
         },
         "etc2-rgb8a1unorm-srgb": {
             gl: 37497,
-            f: Ge
+            f: Yi
         },
         "etc2-rgba8unorm": {
             gl: 37493,
-            f: Ge
+            f: Yi
         },
         "etc2-rgba8unorm-srgb": {
             gl: 37495,
-            f: Ge
+            f: Yi
         },
         "eac-r11unorm": {
             gl: 37488,
-            f: Ge
+            f: Yi
         },
         "eac-r11snorm": {
             gl: 37489,
-            f: Ge
+            f: Yi
         },
         "eac-rg11unorm": {
             gl: 37490,
-            f: Ge
+            f: Yi
         },
         "eac-rg11snorm": {
             gl: 37491,
-            f: Ge
+            f: Yi
         },
         "astc-4x4-unorm": {
             gl: 37808,
-            f: at
+            f: Lt
         },
         "astc-4x4-unorm-srgb": {
             gl: 37840,
-            f: at
+            f: Lt
         },
         "astc-5x4-unorm": {
             gl: 37809,
-            f: at
+            f: Lt
         },
         "astc-5x4-unorm-srgb": {
             gl: 37841,
-            f: at
+            f: Lt
         },
         "astc-5x5-unorm": {
             gl: 37810,
-            f: at
+            f: Lt
         },
         "astc-5x5-unorm-srgb": {
             gl: 37842,
-            f: at
+            f: Lt
         },
         "astc-6x5-unorm": {
             gl: 37811,
-            f: at
+            f: Lt
         },
         "astc-6x5-unorm-srgb": {
             gl: 37843,
-            f: at
+            f: Lt
         },
         "astc-6x6-unorm": {
             gl: 37812,
-            f: at
+            f: Lt
         },
         "astc-6x6-unorm-srgb": {
             gl: 37844,
-            f: at
+            f: Lt
         },
         "astc-8x5-unorm": {
             gl: 37813,
-            f: at
+            f: Lt
         },
         "astc-8x5-unorm-srgb": {
             gl: 37845,
-            f: at
+            f: Lt
         },
         "astc-8x6-unorm": {
             gl: 37814,
-            f: at
+            f: Lt
         },
         "astc-8x6-unorm-srgb": {
             gl: 37846,
-            f: at
+            f: Lt
         },
         "astc-8x8-unorm": {
             gl: 37815,
-            f: at
+            f: Lt
         },
         "astc-8x8-unorm-srgb": {
             gl: 37847,
-            f: at
+            f: Lt
         },
         "astc-10x5-unorm": {
             gl: 37819,
-            f: at
+            f: Lt
         },
         "astc-10x5-unorm-srgb": {
             gl: 37851,
-            f: at
+            f: Lt
         },
         "astc-10x6-unorm": {
             gl: 37817,
-            f: at
+            f: Lt
         },
         "astc-10x6-unorm-srgb": {
             gl: 37849,
-            f: at
+            f: Lt
         },
         "astc-10x8-unorm": {
             gl: 37818,
-            f: at
+            f: Lt
         },
         "astc-10x8-unorm-srgb": {
             gl: 37850,
-            f: at
+            f: Lt
         },
         "astc-10x10-unorm": {
             gl: 37819,
-            f: at
+            f: Lt
         },
         "astc-10x10-unorm-srgb": {
             gl: 37851,
-            f: at
+            f: Lt
         },
         "astc-12x10-unorm": {
             gl: 37820,
-            f: at
+            f: Lt
         },
         "astc-12x10-unorm-srgb": {
             gl: 37852,
-            f: at
+            f: Lt
         },
         "astc-12x12-unorm": {
             gl: 37821,
-            f: at
+            f: Lt
         },
         "astc-12x12-unorm-srgb": {
             gl: 37853,
-            f: at
+            f: Lt
         },
         "pvrtc-rgb4unorm-webgl": {
             gl: 35840,
-            f: qc
+            f: Gd
         },
         "pvrtc-rgba4unorm-webgl": {
             gl: 35842,
-            f: qc
+            f: Gd
         },
         "pvrtc-rbg2unorm-webgl": {
             gl: 35841,
-            f: qc
+            f: Gd
         },
         "pvrtc-rgba2unorm-webgl": {
             gl: 35843,
-            f: qc
+            f: Gd
         },
         "etc1-rbg-unorm-webgl": {
             gl: 36196,
-            f: oR
+            f: fD
         },
         "atc-rgb-unorm-webgl": {
             gl: 35986,
-            f: Ed
+            f: hb
         },
         "atc-rgba-unorm-webgl": {
             gl: 35986,
-            f: Ed
+            f: hb
         },
         "atc-rgbai-unorm-webgl": {
             gl: 34798,
-            f: Ed
+            f: hb
         }
     },
-    pR = {
+    bD = {
         6403: 1,
         36244: 1,
         33319: 2,
         33320: 2,
         6407: 3,
         36248: 3,
         6408: 4,
         36249: 4,
         6402: 1,
         34041: 1,
         6406: 1,
         6409: 1,
         6410: 2
     },
-    gR = {
+    xD = {
         5126: 4,
         5125: 4,
         5124: 4,
         5123: 2,
         5122: 2,
         5131: 2,
         5120: 1,
         5121: 1
     };
 
-function Gc(e, t, r) {
-    let i = Qc[t];
+function ep(e, t, r) {
+    let i = tp[t];
     if (!i || i.gl === void 0) return !1;
-    let s = i.x || i.gl2ext;
-    return s ? !!xe(e, s, r) : !0
+    let n = i.x || i.gl2ext;
+    return n ? !!Vr(e, n, r) : !0
 }
 
-function Rd(e) {
-    let r = Qc[e]?.gl;
+function gb(e) {
+    let r = tp[e]?.gl;
     if (r === void 0) throw new Error(`Unsupported texture format ${e}`);
     return r
 }
 
-function k0(e, t, r) {
-    if (!Gc(e, t, r) || t.startsWith("depth") || t.startsWith("stencil")) return !1;
+function iA(e, t, r) {
+    if (!ep(e, t, r) || t.startsWith("depth") || t.startsWith("stencil")) return !1;
     try {
-        if (Ia(t).signed) return !1
+        if (Bh(t).signed) return !1
     } catch {
         return !1
     }
-    return t.endsWith("32float") ? !!xe(e, "OES_texture_float_linear, extensions", r) : t.endsWith("16float") ? !!xe(e, "OES_texture_half_float_linear, extensions", r) : !0
+    return t.endsWith("32float") ? !!Vr(e, "OES_texture_float_linear, extensions", r) : t.endsWith("16float") ? !!Vr(e, "OES_texture_half_float_linear, extensions", r) : !0
 }
 
-function L0(e, t, r) {
-    return !(!Gc(e, t, r) || typeof t == "number")
+function nA(e, t, r) {
+    return !(!ep(e, t, r) || typeof t == "number")
 }
 
-function Ds(e) {
-    let t = Qc[e],
-        r = Rd(e),
-        i = Ia(e);
+function tc(e) {
+    let t = tp[e],
+        r = gb(e),
+        i = Bh(e);
     return {
         format: r,
-        dataFormat: t?.dataFormat || mR(i.format, i.integer, i.normalized, r),
-        type: i.dataType ? Yc(i.dataType) : t?.types?.[0] || 5121,
+        dataFormat: t?.dataFormat || wD(i.format, i.integer, i.normalized, r),
+        type: i.dataType ? Kd(i.dataType) : t?.types?.[0] || 5121,
         compressed: i.compressed
     }
 }
 
-function B0(e) {
-    let t = Qc[e];
+function sA(e) {
+    let t = tp[e];
     if (!t?.attachment) throw new Error(`${e} is not a depth stencil format`);
     return t.attachment
 }
 
-function Pd(e) {
-    let t = Ds(e),
-        r = pR[t.dataFormat] || 4,
-        i = gR[t.type] || 1;
+function _b(e) {
+    let t = tc(e),
+        r = bD[t.dataFormat] || 4,
+        i = xD[t.type] || 1;
     return r * i
 }
 
-function mR(e, t, r, i) {
+function wD(e, t, r, i) {
     if (i === 6408 || i === 6407) return i;
     switch (e) {
         case "r":
             return t && !r ? 36244 : 6403;
         case "rg":
             return t && !r ? 33320 : 33319;
         case "rgb":
             return t && !r ? 36248 : 6407;
         case "rgba":
             return t && !r ? 36249 : 6408;
         default:
             return 6408
     }
 }
-var U0 = {
+var oA = {
         "depth-clip-control": "EXT_depth_clamp",
         "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
         "compilation-status-async-webgl": "KHR_parallel_shader_compile",
         "polygon-mode-webgl": "WEBGL_polygon_mode",
         "provoking-vertex-webgl": "WEBGL_provoking_vertex",
         "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
         "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
         "shader-conservative-depth-webgl": "EXT_conservative_depth"
     },
-    Jc = class extends Sn {
-        constructor(r, i, s) {
-            super([], s);
-            p(this, "gl");
-            p(this, "extensions");
-            p(this, "testedFeatures", new Set);
-            this.gl = r, this.extensions = i, xe(r, "EXT_color_buffer_float", i)
+    rp = class extends gl {
+        constructor(r, i, n) {
+            super([], n);
+            m(this, "gl");
+            m(this, "extensions");
+            m(this, "testedFeatures", new Set);
+            this.gl = r, this.extensions = i, Vr(r, "EXT_color_buffer_float", i)
         }*[Symbol.iterator]() {
             let r = this.getFeatures();
             for (let i of r) this.has(i) && (yield i);
             return []
         }
         has(r) {
-            return this.disabledFeatures[r] ? !1 : (this.testedFeatures.has(r) || (this.testedFeatures.add(r), F0(r) && D0(this.gl, r, this.extensions) && this.features.add(r), this.getWebGLFeature(r) && this.features.add(r)), this.features.has(r))
+            return this.disabledFeatures[r] ? !1 : (this.testedFeatures.has(r) || (this.testedFeatures.add(r), eA(r) && rA(this.gl, r, this.extensions) && this.features.add(r), this.getWebGLFeature(r) && this.features.add(r)), this.features.has(r))
         }
         initializeFeatures() {
             let r = this.getFeatures().filter(i => i !== "polygon-mode-webgl");
             for (let i of r) this.has(i)
         }
         getFeatures() {
-            return [...Object.keys(U0), ...Object.keys(Kc)]
+            return [...Object.keys(oA), ...Object.keys(Qd)]
         }
         getWebGLFeature(r) {
-            let i = U0[r];
-            return typeof i == "string" ? !!xe(this.gl, i, this.extensions) : !!i
+            let i = oA[r];
+            return typeof i == "string" ? !!Vr(this.gl, i, this.extensions) : !!i
         }
     };
-var tl = class extends En {
+var ip = class extends ml {
     constructor(r) {
         super();
-        p(this, "gl");
-        p(this, "limits", {});
+        m(this, "gl");
+        m(this, "limits", {});
         this.gl = r
     }
     get maxTextureDimension1D() {
         return 0
     }
     get maxTextureDimension2D() {
         return this.getParameter(3379)
@@ -18274,47 +18274,47 @@
         return 0
     }
     getParameter(r) {
         return this.limits[r] === void 0 && (this.limits[r] = this.gl.getParameter(r)), this.limits[r]
     }
 };
 
-function Te(e, t, r) {
-    if (_R(t)) return r(e);
+function zr(e, t, r) {
+    if (TD(t)) return r(e);
     let {
         nocatch: i = !0
     } = t;
-    Gr(e), Me(e, t);
-    let s;
-    if (i) s = r(e), yr(e);
+    Os(e), si(e, t);
+    let n;
+    if (i) n = r(e), In(e);
     else try {
-        s = r(e)
+        n = r(e)
     } finally {
-        yr(e)
+        In(e)
     }
-    return s
+    return n
 }
 
-function _R(e) {
+function TD(e) {
     for (let t in e) return !1;
     return !0
 }
 
-function z0(e, t, r, i) {
-    if (Br(t)) return i(e);
-    let s = e;
-    Gr(s.gl);
+function cA(e, t, r, i) {
+    if (ys(t)) return i(e);
+    let n = e;
+    Os(n.gl);
     try {
-        return yR(e, t), Me(s.gl, r), i(e)
+        return vD(e, t), si(n.gl, r), i(e)
     } finally {
-        yr(s.gl)
+        In(n.gl)
     }
 }
 
-function yR(e, t) {
+function vD(e, t) {
     let r = e,
         {
             gl: i
         } = r;
     if (t.cullMode) switch (t.cullMode) {
         case "none":
             i.disable(2884);
@@ -18322,102 +18322,102 @@
         case "front":
             i.enable(2884), i.cullFace(1028);
             break;
         case "back":
             i.enable(2884), i.cullFace(1029);
             break
     }
-    if (t.frontFace && i.frontFace(Li("frontFace", t.frontFace, {
+    if (t.frontFace && i.frontFace(Oo("frontFace", t.frontFace, {
             ccw: 2305,
             cw: 2304
         })), t.unclippedDepth && e.features.has("depth-clip-control") && i.enable(34383), t.depthBias !== void 0 && (i.enable(32823), i.polygonOffset(t.depthBias, t.depthBiasSlopeScale || 0)), t.provokingVertex && e.features.has("provoking-vertex-webgl")) {
-        let n = r.getExtension("WEBGL_provoking_vertex").WEBGL_provoking_vertex,
-            o = Li("provokingVertex", t.provokingVertex, {
+        let s = r.getExtension("WEBGL_provoking_vertex").WEBGL_provoking_vertex,
+            o = Oo("provokingVertex", t.provokingVertex, {
                 first: 36429,
                 last: 36430
             });
-        n?.provokingVertexWEBGL(o)
+        s?.provokingVertexWEBGL(o)
     }
     if ((t.polygonMode || t.polygonOffsetLine) && e.features.has("polygon-mode-webgl")) {
         if (t.polygonMode) {
-            let n = r.getExtension("WEBGL_polygon_mode").WEBGL_polygon_mode,
-                o = Li("polygonMode", t.polygonMode, {
+            let s = r.getExtension("WEBGL_polygon_mode").WEBGL_polygon_mode,
+                o = Oo("polygonMode", t.polygonMode, {
                     fill: 6914,
                     line: 6913
                 });
-            n?.polygonModeWEBGL(1028, o), n?.polygonModeWEBGL(1029, o)
+            s?.polygonModeWEBGL(1028, o), s?.polygonModeWEBGL(1029, o)
         }
         t.polygonOffsetLine && i.enable(10754)
     }
-    if (e.features.has("shader-clip-cull-distance-webgl") && (t.clipDistance0 && i.enable(12288), t.clipDistance1 && i.enable(12289), t.clipDistance2 && i.enable(12290), t.clipDistance3 && i.enable(12291), t.clipDistance4 && i.enable(12292), t.clipDistance5 && i.enable(12293), t.clipDistance6 && i.enable(12294), t.clipDistance7 && i.enable(12295)), t.depthWriteEnabled !== void 0 && i.depthMask(TR("depthWriteEnabled", t.depthWriteEnabled)), t.depthCompare && (t.depthCompare !== "always" ? i.enable(2929) : i.disable(2929), i.depthFunc(rl("depthCompare", t.depthCompare))), t.stencilWriteMask) {
-        let s = t.stencilWriteMask;
-        i.stencilMaskSeparate(1028, s), i.stencilMaskSeparate(1029, s)
-    }
-    if (t.stencilReadMask && O.warn("stencilReadMask not supported under WebGL"), t.stencilCompare) {
-        let s = t.stencilReadMask || 4294967295,
-            n = rl("depthCompare", t.stencilCompare);
-        t.stencilCompare !== "always" ? i.enable(2960) : i.disable(2960), i.stencilFuncSeparate(1028, n, 0, s), i.stencilFuncSeparate(1029, n, 0, s)
+    if (e.features.has("shader-clip-cull-distance-webgl") && (t.clipDistance0 && i.enable(12288), t.clipDistance1 && i.enable(12289), t.clipDistance2 && i.enable(12290), t.clipDistance3 && i.enable(12291), t.clipDistance4 && i.enable(12292), t.clipDistance5 && i.enable(12293), t.clipDistance6 && i.enable(12294), t.clipDistance7 && i.enable(12295)), t.depthWriteEnabled !== void 0 && i.depthMask(AD("depthWriteEnabled", t.depthWriteEnabled)), t.depthCompare && (t.depthCompare !== "always" ? i.enable(2929) : i.disable(2929), i.depthFunc(sp("depthCompare", t.depthCompare))), t.stencilWriteMask) {
+        let n = t.stencilWriteMask;
+        i.stencilMaskSeparate(1028, n), i.stencilMaskSeparate(1029, n)
+    }
+    if (t.stencilReadMask && N.warn("stencilReadMask not supported under WebGL"), t.stencilCompare) {
+        let n = t.stencilReadMask || 4294967295,
+            s = sp("depthCompare", t.stencilCompare);
+        t.stencilCompare !== "always" ? i.enable(2960) : i.disable(2960), i.stencilFuncSeparate(1028, s, 0, n), i.stencilFuncSeparate(1029, s, 0, n)
     }
     if (t.stencilPassOperation && t.stencilFailOperation && t.stencilDepthFailOperation) {
-        let s = Md("stencilPassOperation", t.stencilPassOperation),
-            n = Md("stencilFailOperation", t.stencilFailOperation),
-            o = Md("stencilDepthFailOperation", t.stencilDepthFailOperation);
-        i.stencilOpSeparate(1028, n, o, s), i.stencilOpSeparate(1029, n, o, s)
+        let n = yb("stencilPassOperation", t.stencilPassOperation),
+            s = yb("stencilFailOperation", t.stencilFailOperation),
+            o = yb("stencilDepthFailOperation", t.stencilDepthFailOperation);
+        i.stencilOpSeparate(1028, s, o, n), i.stencilOpSeparate(1029, s, o, n)
     }
     if (t.blendColorOperation || t.blendAlphaOperation) {
         i.enable(3042);
-        let s = V0("blendColorOperation", t.blendColorOperation || "add"),
-            n = V0("blendAlphaOperation", t.blendAlphaOperation || "add");
-        i.blendEquationSeparate(s, n);
-        let o = el("blendColorSrcFactor", t.blendColorSrcFactor || "one"),
-            a = el("blendColorDstFactor", t.blendColorDstFactor || "zero"),
-            c = el("blendAlphaSrcFactor", t.blendAlphaSrcFactor || "one"),
-            l = el("blendAlphaDstFactor", t.blendAlphaDstFactor || "zero");
+        let n = aA("blendColorOperation", t.blendColorOperation || "add"),
+            s = aA("blendAlphaOperation", t.blendAlphaOperation || "add");
+        i.blendEquationSeparate(n, s);
+        let o = np("blendColorSrcFactor", t.blendColorSrcFactor || "one"),
+            a = np("blendColorDstFactor", t.blendColorDstFactor || "zero"),
+            c = np("blendAlphaSrcFactor", t.blendAlphaSrcFactor || "one"),
+            l = np("blendAlphaDstFactor", t.blendAlphaDstFactor || "zero");
         i.blendFuncSeparate(o, a, c, l)
     }
 }
 
-function rl(e, t) {
-    return Li(e, t, {
+function sp(e, t) {
+    return Oo(e, t, {
         never: 512,
         less: 513,
         equal: 514,
         "less-equal": 515,
         greater: 516,
         "not-equal": 517,
         "greater-equal": 518,
         always: 519
     })
 }
 
-function Md(e, t) {
-    return Li(e, t, {
+function yb(e, t) {
+    return Oo(e, t, {
         keep: 7680,
         zero: 0,
         replace: 7681,
         invert: 5386,
         "increment-clamp": 7682,
         "decrement-clamp": 7683,
         "increment-wrap": 34055,
         "decrement-wrap": 34056
     })
 }
 
-function V0(e, t) {
-    return Li(e, t, {
+function aA(e, t) {
+    return Oo(e, t, {
         add: 32774,
         subtract: 32778,
         "reverse-subtract": 32779,
         min: 32775,
         max: 32776
     })
 }
 
-function el(e, t) {
-    return Li(e, t, {
+function np(e, t) {
+    return Oo(e, t, {
         one: 1,
         zero: 0,
         "src-color": 768,
         "one-minus-src-color": 769,
         "dst-color": 774,
         "one-minus-dst-color": 775,
         "src-alpha": 770,
@@ -18428,426 +18428,426 @@
         "constant-color": 32769,
         "one-minus-constant-color": 32770,
         "constant-alpha": 32771,
         "one-minus-constant-alpha": 32772
     })
 }
 
-function xR(e, t) {
+function SD(e, t) {
     return `Illegal parameter ${t} for ${e}`
 }
 
-function Li(e, t, r) {
-    if (!(t in r)) throw new Error(xR(e, t));
+function Oo(e, t, r) {
+    if (!(t in r)) throw new Error(SD(e, t));
     return r[t]
 }
 
-function TR(e, t) {
+function AD(e, t) {
     return t
 }
 
-function il(e) {
+function op(e) {
     let t = {};
-    return e.addressModeU && (t[10242] = Cd(e.addressModeU)), e.addressModeV && (t[10243] = Cd(e.addressModeV)), e.addressModeW && (t[32882] = Cd(e.addressModeW)), e.magFilter && (t[10240] = W0(e.magFilter)), (e.minFilter || e.mipmapFilter) && (t[10241] = bR(e.minFilter || "linear", e.mipmapFilter)), e.lodMinClamp !== void 0 && (t[33082] = e.lodMinClamp), e.lodMaxClamp !== void 0 && (t[33083] = e.lodMaxClamp), e.type === "comparison-sampler" && (t[34892] = 34894), e.compare && (t[34893] = rl("compare", e.compare)), e.maxAnisotropy && (t[34046] = e.maxAnisotropy), t
+    return e.addressModeU && (t[10242] = bb(e.addressModeU)), e.addressModeV && (t[10243] = bb(e.addressModeV)), e.addressModeW && (t[32882] = bb(e.addressModeW)), e.magFilter && (t[10240] = lA(e.magFilter)), (e.minFilter || e.mipmapFilter) && (t[10241] = ED(e.minFilter || "linear", e.mipmapFilter)), e.lodMinClamp !== void 0 && (t[33082] = e.lodMinClamp), e.lodMaxClamp !== void 0 && (t[33083] = e.lodMaxClamp), e.type === "comparison-sampler" && (t[34892] = 34894), e.compare && (t[34893] = sp("compare", e.compare)), e.maxAnisotropy && (t[34046] = e.maxAnisotropy), t
 }
 
-function Cd(e) {
+function bb(e) {
     switch (e) {
         case "clamp-to-edge":
             return 33071;
         case "repeat":
             return 10497;
         case "mirror-repeat":
             return 33648
     }
 }
 
-function W0(e) {
+function lA(e) {
     switch (e) {
         case "nearest":
             return 9728;
         case "linear":
             return 9729
     }
 }
 
-function bR(e, t) {
-    if (!t) return W0(e);
+function ED(e, t) {
+    if (!t) return lA(e);
     switch (e) {
         case "nearest":
             return t === "nearest" ? 9984 : 9986;
         case "linear":
             return t === "nearest" ? 9985 : 9987
     }
 }
-var Wt = class extends it {
+var ze = class extends Mt {
     constructor(r, i = {}) {
         super(r, i);
-        p(this, "device");
-        p(this, "gl");
-        p(this, "handle");
-        p(this, "glTarget");
-        p(this, "glUsage");
-        p(this, "glIndexType", 5123);
-        p(this, "byteLength");
-        p(this, "bytesUsed");
+        m(this, "device");
+        m(this, "gl");
+        m(this, "handle");
+        m(this, "glTarget");
+        m(this, "glUsage");
+        m(this, "glIndexType", 5123);
+        m(this, "byteLength");
+        m(this, "bytesUsed");
         this.device = r, this.gl = this.device.gl;
-        let s = typeof i == "object" ? i.handle : void 0;
-        this.handle = s || this.gl.createBuffer(), r.setSpectorMetadata(this.handle, {
+        let n = typeof i == "object" ? i.handle : void 0;
+        this.handle = n || this.gl.createBuffer(), r.setSpectorMetadata(this.handle, {
             ...this.props,
             data: typeof this.props.data
-        }), this.glTarget = AR(this.props.usage), this.glUsage = ER(this.props.usage), this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123, i.data ? this._initWithData(i.data, i.byteOffset, i.byteLength) : this._initWithByteLength(i.byteLength || 0)
+        }), this.glTarget = ID(this.props.usage), this.glUsage = RD(this.props.usage), this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123, i.data ? this._initWithData(i.data, i.byteOffset, i.byteLength) : this._initWithByteLength(i.byteLength || 0)
     }
-    _initWithData(r, i = 0, s = r.byteLength + i) {
-        let n = this.glTarget;
-        this.gl.bindBuffer(n, this.handle), this.gl.bufferData(n, s, this.glUsage), this.gl.bufferSubData(n, i, r), this.gl.bindBuffer(n, null), this.bytesUsed = s, this.byteLength = s, this._setDebugData(r, i, s), this.trackAllocatedMemory(s)
+    _initWithData(r, i = 0, n = r.byteLength + i) {
+        let s = this.glTarget;
+        this.gl.bindBuffer(s, this.handle), this.gl.bufferData(s, n, this.glUsage), this.gl.bufferSubData(s, i, r), this.gl.bindBuffer(s, null), this.bytesUsed = n, this.byteLength = n, this._setDebugData(r, i, n), this.trackAllocatedMemory(n)
     }
     _initWithByteLength(r) {
-        Q(r >= 0);
+        _t(r >= 0);
         let i = r;
         r === 0 && (i = new Float32Array(0));
-        let s = this.glTarget;
-        return this.gl.bindBuffer(s, this.handle), this.gl.bufferData(s, i, this.glUsage), this.gl.bindBuffer(s, null), this.bytesUsed = r, this.byteLength = r, this._setDebugData(null, 0, r), this.trackAllocatedMemory(r), this
+        let n = this.glTarget;
+        return this.gl.bindBuffer(n, this.handle), this.gl.bufferData(n, i, this.glUsage), this.gl.bindBuffer(n, null), this.bytesUsed = r, this.byteLength = r, this._setDebugData(null, 0, r), this.trackAllocatedMemory(r), this
     }
     destroy() {
         !this.destroyed && this.handle && (this.removeStats(), this.trackDeallocatedMemory(), this.gl.deleteBuffer(this.handle), this.destroyed = !0, this.handle = null)
     }
     write(r, i = 0) {
         this.gl.bindBuffer(36663, this.handle), this.gl.bufferSubData(36663, i, r), this.gl.bindBuffer(36663, null), this._setDebugData(r, i, r.byteLength)
     }
     async readAsync(r = 0, i) {
         return this.readSyncWebGL(r, i)
     }
     readSyncWebGL(r = 0, i) {
         i = i ?? this.byteLength - r;
-        let s = new Uint8Array(i),
-            n = 0;
-        return this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, r, s, n, i), this.gl.bindBuffer(36662, null), this._setDebugData(s, r, i), s
+        let n = new Uint8Array(i),
+            s = 0;
+        return this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, r, n, s, i), this.gl.bindBuffer(36662, null), this._setDebugData(n, r, i), n
     }
 };
 
-function AR(e) {
-    return e & it.INDEX ? 34963 : e & it.VERTEX ? 34962 : e & it.UNIFORM ? 35345 : 34962
+function ID(e) {
+    return e & Mt.INDEX ? 34963 : e & Mt.VERTEX ? 34962 : e & Mt.UNIFORM ? 35345 : 34962
 }
 
-function ER(e) {
-    return e & it.INDEX || e & it.VERTEX ? 35044 : e & it.UNIFORM ? 35048 : 35044
+function RD(e) {
+    return e & Mt.INDEX || e & Mt.VERTEX ? 35044 : e & Mt.UNIFORM ? 35048 : 35044
 }
-var Bi = class extends Ai {
+var No = class extends _o {
     constructor(r, i) {
         super(r, i);
-        p(this, "device");
-        p(this, "handle");
-        p(this, "parameters");
-        this.device = r, this.parameters = il(i), this.handle = this.handle || this.device.gl.createSampler(), this._setSamplerParameters(this.parameters)
+        m(this, "device");
+        m(this, "handle");
+        m(this, "parameters");
+        this.device = r, this.parameters = op(i), this.handle = this.handle || this.device.gl.createSampler(), this._setSamplerParameters(this.parameters)
     }
     destroy() {
         this.handle && (this.device.gl.deleteSampler(this.handle), this.handle = void 0)
     }
     toString() {
         return `Sampler(${this.id},${JSON.stringify(this.props)})`
     }
     _setSamplerParameters(r) {
-        for (let [i, s] of Object.entries(r)) {
-            let n = Number(i);
-            switch (n) {
+        for (let [i, n] of Object.entries(r)) {
+            let s = Number(i);
+            switch (s) {
                 case 33082:
                 case 33083:
-                    this.device.gl.samplerParameterf(this.handle, n, s);
+                    this.device.gl.samplerParameterf(this.handle, s, n);
                     break;
                 default:
-                    this.device.gl.samplerParameteri(this.handle, n, s);
+                    this.device.gl.samplerParameteri(this.handle, s, n);
                     break
             }
         }
     }
 };
-var Ce = class extends Ti {
+var oi = class extends mo {
     constructor(r, i) {
         super(r, {
-            ...Tt.defaultProps,
+            ...ae.defaultProps,
             ...i
         });
-        p(this, "device");
-        p(this, "gl");
-        p(this, "handle");
-        p(this, "texture");
+        m(this, "device");
+        m(this, "gl");
+        m(this, "handle");
+        m(this, "texture");
         this.device = r, this.gl = this.device.gl, this.handle = null, this.texture = i.texture
     }
 };
-var SR = {
+var MD = {
         parameters: {},
         pixelStore: {},
         pixels: null,
         border: 0,
         dataFormat: void 0,
         textureUnit: void 0,
         target: void 0
     },
-    yo = class yo extends Tt {
+    lu = class lu extends ae {
         constructor(r, i) {
             super(r, {
-                ...SR,
+                ...MD,
                 format: "rgba8unorm",
                 ...i
             });
-            p(this, "MAX_ATTRIBUTES");
-            p(this, "device");
-            p(this, "gl");
-            p(this, "handle");
-            p(this, "sampler");
-            p(this, "view");
-            p(this, "glFormat");
-            p(this, "type");
-            p(this, "dataFormat");
-            p(this, "mipmaps");
-            p(this, "target");
-            p(this, "textureUnit");
-            p(this, "loaded", !1);
-            p(this, "_video");
+            m(this, "MAX_ATTRIBUTES");
+            m(this, "device");
+            m(this, "gl");
+            m(this, "handle");
+            m(this, "sampler");
+            m(this, "view");
+            m(this, "glFormat");
+            m(this, "type");
+            m(this, "dataFormat");
+            m(this, "mipmaps");
+            m(this, "target");
+            m(this, "textureUnit");
+            m(this, "loaded", !1);
+            m(this, "_video");
             this.device = r, this.gl = this.device.gl, this.handle = this.props.handle || this.gl.createTexture(), this.device.setSpectorMetadata(this.handle, {
                 ...this.props,
                 data: typeof this.props.data
-            }), this.glFormat = 6408, this.target = wR(this.props), this.loaded = !1, typeof this.props?.data == "string" && Object.assign(this.props, {
-                data: vf(this.props.data)
+            }), this.glFormat = 6408, this.target = PD(this.props), this.loaded = !1, typeof this.props?.data == "string" && Object.assign(this.props, {
+                data: my(this.props.data)
             }), this.initialize(this.props), Object.seal(this)
         }
         destroy() {
             this.handle && (this.gl.deleteTexture(this.handle), this.removeStats(), this.trackDeallocatedMemory("Texture"), this.destroyed = !0)
         }
         toString() {
             return `Texture(${this.id},${this.width}x${this.height})`
         }
         createView(r) {
-            return new Ce(this.device, {
+            return new oi(this.device, {
                 ...r,
                 texture: this
             })
         }
         initialize(r = {}) {
             if (this.props.dimension === "cube") return this.initializeCube(r);
             let i = r.data;
-            if (i instanceof Promise) return i.then(A => this.initialize(Object.assign({}, r, {
-                pixels: A,
-                data: A
+            if (i instanceof Promise) return i.then(T => this.initialize(Object.assign({}, r, {
+                pixels: T,
+                data: T
             }))), this;
-            let s = typeof HTMLVideoElement < "u" && i instanceof HTMLVideoElement;
-            if (s && i.readyState < HTMLVideoElement.HAVE_METADATA) return this._video = null, i.addEventListener("loadeddata", () => this.initialize(r)), this;
+            let n = typeof HTMLVideoElement < "u" && i instanceof HTMLVideoElement;
+            if (n && i.readyState < HTMLVideoElement.HAVE_METADATA) return this._video = null, i.addEventListener("loadeddata", () => this.initialize(r)), this;
             let {
-                parameters: n = {}
+                parameters: s = {}
             } = r, {
                 pixels: o = null,
                 pixelStore: a = {},
                 textureUnit: c = void 0,
                 mipmaps: l = !0
             } = r;
             i || (i = o);
             let {
-                width: h,
+                width: u,
                 height: f,
-                dataFormat: u,
+                dataFormat: h,
                 type: d,
-                compressed: m = !1
+                compressed: p = !1
             } = r, {
                 depth: y = 0
-            } = r, x = Rd(r.format);
+            } = r, b = gb(r.format);
             return {
-                width: h,
+                width: u,
                 height: f,
-                compressed: m,
-                dataFormat: u,
+                compressed: p,
+                dataFormat: h,
                 type: d
             } = this._deduceParameters({
                 format: r.format,
                 type: d,
-                dataFormat: u,
-                compressed: m,
+                dataFormat: h,
+                compressed: p,
                 data: i,
-                width: h,
+                width: u,
                 height: f
-            }), this.width = h, this.height = f, this.glFormat = x, this.type = d, this.dataFormat = u, this.textureUnit = c, Number.isFinite(this.textureUnit) && (this.gl.activeTexture(33984 + this.textureUnit), this.gl.bindTexture(this.target, this.handle)), this.mipmaps = l, this.setImageData({
+            }), this.width = u, this.height = f, this.glFormat = b, this.type = d, this.dataFormat = h, this.textureUnit = c, Number.isFinite(this.textureUnit) && (this.gl.activeTexture(33984 + this.textureUnit), this.gl.bindTexture(this.target, this.handle)), this.mipmaps = l, this.setImageData({
                 data: i,
-                width: h,
+                width: u,
                 height: f,
                 depth: y,
-                format: x,
+                format: b,
                 type: d,
-                dataFormat: u,
+                dataFormat: h,
                 parameters: a,
-                compressed: m
-            }), this.setSampler(r.sampler), this._setSamplerParameters(n), this.view = this.createView({
+                compressed: p
+            }), this.setSampler(r.sampler), this._setSamplerParameters(s), this.view = this.createView({
                 ...this.props,
                 mipLevelCount: 1,
                 arrayLayerCount: 1
-            }), l && this.device.isTextureFormatFilterable(r.format) && this.generateMipmap(), s && (this._video = {
+            }), l && this.device.isTextureFormatFilterable(r.format) && this.generateMipmap(), n && (this._video = {
                 video: i,
-                parameters: n,
+                parameters: s,
                 lastTime: i.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? i.currentTime : -1
             }), this
         }
         initializeCube(r) {
             let {
                 mipmaps: i = !0,
-                parameters: s = {}
+                parameters: n = {}
             } = r;
             return this.setCubeMapImageData(r).then(() => {
-                this.loaded = !0, i && this.generateMipmap(r), this.setSampler(r.sampler), this._setSamplerParameters(s)
+                this.loaded = !0, i && this.generateMipmap(r), this.setSampler(r.sampler), this._setSamplerParameters(n)
             }), this
         }
         setSampler(r = {}) {
             let i;
-            r instanceof Bi ? (this.sampler = r, i = r.props) : (this.sampler = new Bi(this.device, r), i = r);
-            let s = il(i);
-            return this._setSamplerParameters(s), this
+            r instanceof No ? (this.sampler = r, i = r.props) : (this.sampler = new No(this.device, r), i = r);
+            let n = op(i);
+            return this._setSamplerParameters(n), this
         }
         resize(r) {
             let {
                 height: i,
-                width: s,
-                mipmaps: n = !1
+                width: n,
+                mipmaps: s = !1
             } = r;
-            return s !== this.width || i !== this.height ? this.initialize({
-                width: s,
+            return n !== this.width || i !== this.height ? this.initialize({
+                width: n,
                 height: i,
                 format: this.format,
                 type: this.type,
                 dataFormat: this.dataFormat,
-                mipmaps: n
+                mipmaps: s
             }) : this
         }
         update() {
             if (this._video) {
                 let {
                     video: r,
                     parameters: i,
-                    lastTime: s
+                    lastTime: n
                 } = this._video;
-                if (s === r.currentTime || r.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) return;
+                if (n === r.currentTime || r.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) return;
                 this.setSubImageData({
                     data: r,
                     parameters: i
                 }), this.mipmaps && this.generateMipmap(), this._video.lastTime = r.currentTime
             }
         }
         generateMipmap(r = {}) {
-            return this.mipmaps = !0, this.gl.bindTexture(this.target, this.handle), Te(this.gl, r, () => {
+            return this.mipmaps = !0, this.gl.bindTexture(this.target, this.handle), zr(this.gl, r, () => {
                 this.gl.generateMipmap(this.target)
             }), this.gl.bindTexture(this.target, null), this
         }
         setImageData(r) {
             if (this.props.dimension === "3d" || this.props.dimension === "2d-array") return this.setImageData3D(r);
             this.trackDeallocatedMemory("Texture");
             let {
                 target: i = this.target,
-                pixels: s = null,
-                level: n = 0,
+                pixels: n = null,
+                level: s = 0,
                 glFormat: o = this.glFormat,
                 offset: a = 0,
                 parameters: c = {}
             } = r, {
                 data: l = null,
-                type: h = this.type,
+                type: u = this.type,
                 width: f = this.width,
-                height: u = this.height,
+                height: h = this.height,
                 dataFormat: d = this.dataFormat,
-                compressed: m = !1
+                compressed: p = !1
             } = r;
-            l || (l = s), {
-                type: h,
+            l || (l = n), {
+                type: u,
                 dataFormat: d,
-                compressed: m,
+                compressed: p,
                 width: f,
-                height: u
+                height: h
             } = this._deduceParameters({
                 format: this.props.format,
-                type: h,
+                type: u,
                 dataFormat: d,
-                compressed: m,
+                compressed: p,
                 data: l,
                 width: f,
-                height: u
+                height: h
             });
             let {
                 gl: y
             } = this;
             y.bindTexture(this.target, this.handle);
-            let x = null;
+            let b = null;
             if ({
                     data: l,
-                    dataType: x
+                    dataType: b
                 } = this._getDataType({
                     data: l,
-                    compressed: m
-                }), Te(this.gl, c, () => {
-                    switch (x) {
+                    compressed: p
+                }), zr(this.gl, c, () => {
+                    switch (b) {
                         case "null":
-                            y.texImage2D(i, n, o, f, u, 0, d, h, l);
+                            y.texImage2D(i, s, o, f, h, 0, d, u, l);
                             break;
                         case "typed-array":
-                            y.texImage2D(i, n, o, f, u, 0, d, h, l, a);
+                            y.texImage2D(i, s, o, f, h, 0, d, u, l, a);
                             break;
                         case "buffer":
-                            this.device.gl.bindBuffer(35052, l.handle || l), this.device.gl.texImage2D(i, n, o, f, u, 0, d, h, a), this.device.gl.bindBuffer(35052, null);
+                            this.device.gl.bindBuffer(35052, l.handle || l), this.device.gl.texImage2D(i, s, o, f, h, 0, d, u, a), this.device.gl.bindBuffer(35052, null);
                             break;
                         case "browser-object":
-                            y.texImage2D(i, n, o, f, u, 0, d, h, l);
+                            y.texImage2D(i, s, o, f, h, 0, d, u, l);
                             break;
                         case "compressed":
-                            for (let [A, v] of l.entries()) y.compressedTexImage2D(i, A, v.format, v.width, v.height, 0, v.data);
+                            for (let [T, I] of l.entries()) y.compressedTexImage2D(i, T, I.format, I.width, I.height, 0, I.data);
                             break;
                         default:
-                            Q(!1, "Unknown image data type")
+                            _t(!1, "Unknown image data type")
                     }
                 }), l && l.byteLength) this.trackAllocatedMemory(l.byteLength, "Texture");
             else {
-                let A = Pd(this.props.format);
-                this.trackAllocatedMemory(this.width * this.height * A, "Texture")
+                let T = _b(this.props.format);
+                this.trackAllocatedMemory(this.width * this.height * T, "Texture")
             }
             return this.loaded = !0, this
         }
         setSubImageData({
             target: r = this.target,
             pixels: i = null,
-            data: s = null,
-            x: n = 0,
+            data: n = null,
+            x: s = 0,
             y: o = 0,
             width: a = this.width,
             height: c = this.height,
             level: l = 0,
-            glFormat: h = this.glFormat,
+            glFormat: u = this.glFormat,
             type: f = this.type,
-            dataFormat: u = this.dataFormat,
+            dataFormat: h = this.dataFormat,
             compressed: d = !1,
-            offset: m = 0,
+            offset: p = 0,
             parameters: y = {}
         }) {
             if ({
                     type: f,
-                    dataFormat: u,
+                    dataFormat: h,
                     compressed: d,
                     width: a,
                     height: c
                 } = this._deduceParameters({
                     format: this.props.format,
                     type: f,
-                    dataFormat: u,
+                    dataFormat: h,
                     compressed: d,
-                    data: s,
+                    data: n,
                     width: a,
                     height: c
-                }), Q(this.depth === 1, "texSubImage not supported for 3D textures"), s || (s = i), s && s.data) {
-                let x = s;
-                s = x.data, a = x.shape[0], c = x.shape[1]
+                }), _t(this.depth === 1, "texSubImage not supported for 3D textures"), n || (n = i), n && n.data) {
+                let b = n;
+                n = b.data, a = b.shape[0], c = b.shape[1]
             }
-            s instanceof Wt && (s = s.handle), this.gl.bindTexture(this.target, this.handle), Te(this.gl, y, () => {
-                d ? this.gl.compressedTexSubImage2D(r, l, n, o, a, c, h, s) : s === null ? this.gl.texSubImage2D(r, l, n, o, a, c, u, f, null) : ArrayBuffer.isView(s) ? this.gl.texSubImage2D(r, l, n, o, a, c, u, f, s, m) : typeof WebGLBuffer < "u" && s instanceof WebGLBuffer ? (this.device.gl.bindBuffer(35052, s), this.device.gl.texSubImage2D(r, l, n, o, a, c, u, f, m), this.device.gl.bindBuffer(35052, null)) : this.device.gl.texSubImage2D(r, l, n, o, a, c, u, f, s)
+            n instanceof ze && (n = n.handle), this.gl.bindTexture(this.target, this.handle), zr(this.gl, y, () => {
+                d ? this.gl.compressedTexSubImage2D(r, l, s, o, a, c, u, n) : n === null ? this.gl.texSubImage2D(r, l, s, o, a, c, h, f, null) : ArrayBuffer.isView(n) ? this.gl.texSubImage2D(r, l, s, o, a, c, h, f, n, p) : typeof WebGLBuffer < "u" && n instanceof WebGLBuffer ? (this.device.gl.bindBuffer(35052, n), this.device.gl.texSubImage2D(r, l, s, o, a, c, h, f, p), this.device.gl.bindBuffer(35052, null)) : this.device.gl.texSubImage2D(r, l, s, o, a, c, h, f, n)
             }), this.gl.bindTexture(this.target, null)
         }
         copyFramebuffer(r = {}) {
-            return O.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null
+            return N.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null
         }
         getActiveUnit() {
             return this.gl.getParameter(34016) - 33984
         }
         bind(r = this.textureUnit) {
             let {
                 gl: i
@@ -18869,160 +18869,160 @@
                 dataType: "compressed"
             } : r === null ? {
                 data: r,
                 dataType: "null"
             } : ArrayBuffer.isView(r) ? {
                 data: r,
                 dataType: "typed-array"
-            } : r instanceof Wt ? {
+            } : r instanceof ze ? {
                 data: r.handle,
                 dataType: "buffer"
             } : typeof WebGLBuffer < "u" && r instanceof WebGLBuffer ? {
                 data: r,
                 dataType: "buffer"
             } : {
                 data: r,
                 dataType: "browser-object"
             }
         }
         _deduceParameters(r) {
             let {
                 format: i,
-                data: s
+                data: n
             } = r, {
-                width: n,
+                width: s,
                 height: o,
                 dataFormat: a,
                 type: c,
                 compressed: l
-            } = r, h = Ds(i);
-            return a = a || h.dataFormat, c = c || h.type, l = l || h.compressed, {
-                width: n,
+            } = r, u = tc(i);
+            return a = a || u.dataFormat, c = c || u.type, l = l || u.compressed, {
+                width: s,
                 height: o
-            } = this._deduceImageSize(s, n, o), {
+            } = this._deduceImageSize(n, s, o), {
                 dataFormat: a,
                 type: c,
                 compressed: l,
-                width: n,
+                width: s,
                 height: o,
                 format: i,
-                data: s
+                data: n
             }
         }
-        _deduceImageSize(r, i, s) {
-            let n;
-            return typeof ImageData < "u" && r instanceof ImageData ? n = {
+        _deduceImageSize(r, i, n) {
+            let s;
+            return typeof ImageData < "u" && r instanceof ImageData ? s = {
                 width: r.width,
                 height: r.height
-            } : typeof HTMLImageElement < "u" && r instanceof HTMLImageElement ? n = {
+            } : typeof HTMLImageElement < "u" && r instanceof HTMLImageElement ? s = {
                 width: r.naturalWidth,
                 height: r.naturalHeight
-            } : typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement ? n = {
+            } : typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement ? s = {
                 width: r.width,
                 height: r.height
-            } : typeof ImageBitmap < "u" && r instanceof ImageBitmap ? n = {
+            } : typeof ImageBitmap < "u" && r instanceof ImageBitmap ? s = {
                 width: r.width,
                 height: r.height
-            } : typeof HTMLVideoElement < "u" && r instanceof HTMLVideoElement ? n = {
+            } : typeof HTMLVideoElement < "u" && r instanceof HTMLVideoElement ? s = {
                 width: r.videoWidth,
                 height: r.videoHeight
-            } : r ? n = {
+            } : r ? s = {
                 width: i,
-                height: s
-            } : n = {
+                height: n
+            } : s = {
                 width: i >= 0 ? i : 1,
-                height: s >= 0 ? s : 1
-            }, Q(n, "Could not deduced texture size"), Q(i === void 0 || n.width === i, "Deduced texture width does not match supplied width"), Q(s === void 0 || n.height === s, "Deduced texture height does not match supplied height"), n
+                height: n >= 0 ? n : 1
+            }, _t(s, "Could not deduced texture size"), _t(i === void 0 || s.width === i, "Deduced texture width does not match supplied width"), _t(n === void 0 || s.height === n, "Deduced texture height does not match supplied height"), s
         }
         async setCubeMapImageData(r) {
             let {
                 gl: i
             } = this, {
-                width: s,
-                height: n,
+                width: n,
+                height: s,
                 pixels: o,
                 data: a,
                 format: c = 6408,
                 type: l = 5121
-            } = r, h = o || a, f = await Promise.all(yo.FACES.map(u => {
-                let d = h[u];
+            } = r, u = o || a, f = await Promise.all(lu.FACES.map(h => {
+                let d = u[h];
                 return Promise.all(Array.isArray(d) ? d : [d])
             }));
-            this.bind(), yo.FACES.forEach((u, d) => {
-                f[d].length > 1 && this.props.mipmaps !== !1 && O.warn(`${this.id} has mipmap and multiple LODs.`)(), f[d].forEach((m, y) => {
-                    s && n ? i.texImage2D(u, y, c, s, n, 0, c, l, m) : i.texImage2D(u, y, c, c, l, m)
+            this.bind(), lu.FACES.forEach((h, d) => {
+                f[d].length > 1 && this.props.mipmaps !== !1 && N.warn(`${this.id} has mipmap and multiple LODs.`)(), f[d].forEach((p, y) => {
+                    n && s ? i.texImage2D(h, y, c, n, s, 0, c, l, p) : i.texImage2D(h, y, c, c, l, p)
                 })
             }), this.unbind()
         }
         setImageDataForFace(r) {
             let {
                 face: i,
-                width: s,
-                height: n,
+                width: n,
+                height: s,
                 pixels: o,
                 data: a,
                 format: c = 6408,
                 type: l = 5121
             } = r, {
-                gl: h
+                gl: u
             } = this, f = o || a;
-            return this.bind(), f instanceof Promise ? f.then(u => this.setImageDataForFace(Object.assign({}, r, {
+            return this.bind(), f instanceof Promise ? f.then(h => this.setImageDataForFace(Object.assign({}, r, {
                 face: i,
-                data: u,
-                pixels: u
-            }))) : this.width || this.height ? h.texImage2D(i, 0, c, s, n, 0, c, l, f) : h.texImage2D(i, 0, c, c, l, f), this
+                data: h,
+                pixels: h
+            }))) : this.width || this.height ? u.texImage2D(i, 0, c, n, s, 0, c, l, f) : u.texImage2D(i, 0, c, c, l, f), this
         }
         setImageData3D(r) {
             let {
                 level: i = 0,
-                dataFormat: s,
-                format: n,
+                dataFormat: n,
+                format: s,
                 type: o,
                 width: a,
                 height: c,
                 depth: l = 1,
-                offset: h = 0,
+                offset: u = 0,
                 data: f,
-                parameters: u = {}
+                parameters: h = {}
             } = r;
             this.trackDeallocatedMemory("Texture"), this.gl.bindTexture(this.target, this.handle);
-            let d = Ds(n);
-            if (Te(this.gl, u, () => {
-                    ArrayBuffer.isView(f) && this.gl.texImage3D(this.target, i, d.format, a, c, l, 0, d.dataFormat, d.type, f), f instanceof Wt && (this.gl.bindBuffer(35052, f.handle), this.gl.texImage3D(this.target, i, s, a, c, l, 0, n, o, h))
+            let d = tc(s);
+            if (zr(this.gl, h, () => {
+                    ArrayBuffer.isView(f) && this.gl.texImage3D(this.target, i, d.format, a, c, l, 0, d.dataFormat, d.type, f), f instanceof ze && (this.gl.bindBuffer(35052, f.handle), this.gl.texImage3D(this.target, i, n, a, c, l, 0, s, o, u))
                 }), f && f.byteLength) this.trackAllocatedMemory(f.byteLength, "Texture");
             else {
-                let m = Pd(this.props.format);
-                this.trackAllocatedMemory(this.width * this.height * this.depth * m, "Texture")
+                let p = _b(this.props.format);
+                this.trackAllocatedMemory(this.width * this.height * this.depth * p, "Texture")
             }
             return this.loaded = !0, this
         }
         _setSamplerParameters(r) {
-            if (!Br(r)) {
-                vR(r), this.gl.bindTexture(this.target, this.handle);
-                for (let [i, s] of Object.entries(r)) {
-                    let n = Number(i),
-                        o = s;
-                    switch (n) {
+            if (!ys(r)) {
+                CD(r), this.gl.bindTexture(this.target, this.handle);
+                for (let [i, n] of Object.entries(r)) {
+                    let s = Number(i),
+                        o = n;
+                    switch (s) {
                         case 33082:
                         case 33083:
-                            this.gl.texParameterf(this.target, n, o);
+                            this.gl.texParameterf(this.target, s, o);
                             break;
                         default:
-                            this.gl.texParameteri(this.target, n, o);
+                            this.gl.texParameteri(this.target, s, o);
                             break
                     }
                 }
                 this.gl.bindTexture(this.target, null)
             }
         }
     };
-p(yo, "FACES", [34069, 34070, 34071, 34072, 34073, 34074]);
-var Gt = yo;
+m(lu, "FACES", [34069, 34070, 34071, 34072, 34073, 34074]);
+var rr = lu;
 
-function wR(e) {
+function PD(e) {
     switch (e.dimension) {
         case "2d":
             return 3553;
         case "cube":
             return 34067;
         case "2d-array":
             return 35866;
@@ -19031,109 +19031,109 @@
         case "1d":
         case "cube-array":
         default:
             throw new Error(e.dimension)
     }
 }
 
-function vR(e) {
-    O.log(1, "texture sampler parameters", e)()
+function CD(e) {
+    N.log(1, "texture sampler parameters", e)()
 }
-var Je = class extends Ei {
+var qi = class extends yo {
     constructor(r, i) {
         super(r, i);
-        p(this, "device");
-        p(this, "gl");
-        p(this, "handle");
-        let s = i.handle === null;
-        if (this.device = r, this.gl = r.gl, this.handle = this.props.handle || s ? this.props.handle : this.gl.createFramebuffer(), !s) {
+        m(this, "device");
+        m(this, "gl");
+        m(this, "handle");
+        let n = i.handle === null;
+        if (this.device = r, this.gl = r.gl, this.handle = this.props.handle || n ? this.props.handle : this.gl.createFramebuffer(), !n) {
             r.setSpectorMetadata(this.handle, {
                 id: this.props.id,
                 props: this.props
             }), this.autoCreateAttachmentTextures();
-            let n = this.gl.bindFramebuffer(36160, this.handle);
+            let s = this.gl.bindFramebuffer(36160, this.handle);
             for (let o = 0; o < this.colorAttachments.length; ++o) {
                 let a = this.colorAttachments[o],
                     c = 36064 + o;
                 a && this._attachOne(c, a)
             }
-            if (this.depthStencilAttachment && this._attachOne(B0(this.depthStencilAttachment.props.format), this.depthStencilAttachment), i.check !== !1) {
+            if (this.depthStencilAttachment && this._attachOne(sA(this.depthStencilAttachment.props.format), this.depthStencilAttachment), i.check !== !1) {
                 let o = this.gl.checkFramebufferStatus(36160);
-                if (o !== 36053) throw new Error(`Framebuffer ${PR(o)}`)
+                if (o !== 36053) throw new Error(`Framebuffer ${ND(o)}`)
             }
-            this.gl.bindFramebuffer(36160, n)
+            this.gl.bindFramebuffer(36160, s)
         }
     }
     get texture() {
         return this.colorAttachments[0]
     }
     destroy() {
         super.destroy(), !this.destroyed && this.handle !== null && this.gl.deleteFramebuffer(this.handle)
     }
     createDepthStencilTexture(r) {
-        return new Gt(this.device, {
+        return new rr(this.device, {
             id: `${this.id}-depth-stencil`,
             format: r,
             width: this.width,
             height: this.height,
             mipmaps: !1
         })
     }
     resizeAttachments(r, i) {
         if (this.handle === null) return this.width = this.gl.drawingBufferWidth, this.height = this.gl.drawingBufferHeight, this;
         r === void 0 && (r = this.gl.drawingBufferWidth), i === void 0 && (i = this.gl.drawingBufferHeight);
-        for (let s of this.colorAttachments) s.texture.resize({
+        for (let n of this.colorAttachments) n.texture.resize({
             width: r,
             height: i
         });
         return this.depthStencilAttachment && this.depthStencilAttachment.texture.resize({
             width: r,
             height: i
         }), this
     }
     _attachOne(r, i) {
         if (Array.isArray(i)) {
-            let [s, n = 0, o = 0] = i;
-            return this._attachTexture(r, s, n, o), s
+            let [n, s = 0, o = 0] = i;
+            return this._attachTexture(r, n, s, o), n
         }
-        if (i instanceof Gt) return this._attachTexture(r, i, 0, 0), i;
-        if (i instanceof Ce) {
-            let s = i;
-            return this._attachTexture(r, s.texture, s.props.baseMipLevel, s.props.baseArrayLayer), i.texture
+        if (i instanceof rr) return this._attachTexture(r, i, 0, 0), i;
+        if (i instanceof oi) {
+            let n = i;
+            return this._attachTexture(r, n.texture, n.props.baseMipLevel, n.props.baseArrayLayer), i.texture
         }
         throw new Error("attach")
     }
-    _attachTexture(r, i, s, n) {
+    _attachTexture(r, i, n, s) {
         let {
             gl: o
         } = this.device;
         switch (o.bindTexture(i.target, i.handle), i.target) {
             case 35866:
             case 32879:
-                o.framebufferTextureLayer(36160, r, i.target, n, s);
+                o.framebufferTextureLayer(36160, r, i.target, s, n);
                 break;
             case 34067:
-                let a = RR(s);
-                o.framebufferTexture2D(36160, r, a, i.handle, n);
+                let a = OD(n);
+                o.framebufferTexture2D(36160, r, a, i.handle, s);
                 break;
             case 3553:
-                o.framebufferTexture2D(36160, r, 3553, i.handle, n);
+                o.framebufferTexture2D(36160, r, 3553, i.handle, s);
                 break;
             default:
-                Q(!1, "Illegal texture type")
+                _t(!1, "Illegal texture type")
         }
         o.bindTexture(i.target, null)
     }
 };
 
-function RR(e) {
+function OD(e) {
     return e < 34069 ? e + 34069 : e
 }
 
-function PR(e) {
+function ND(e) {
     switch (e) {
         case 36053:
             return "success";
         case 36054:
             return "Mismatched attachments";
         case 36055:
             return "No attachments";
@@ -19143,24 +19143,24 @@
             return "Unsupported or split attachments";
         case 36182:
             return "Samples mismatch";
         default:
             return `${e}`
     }
 }
-var sl = class extends Ur {
+var ap = class extends bs {
     constructor(r, i) {
         super(i);
-        p(this, "device");
-        p(this, "presentationSize");
-        p(this, "_framebuffer", null);
+        m(this, "device");
+        m(this, "presentationSize");
+        m(this, "_framebuffer", null);
         this.device = r, this.presentationSize = [-1, -1], this._setAutoCreatedCanvasId(`${this.device.id}-canvas`), this.update()
     }
     getCurrentFramebuffer() {
-        return this.update(), this._framebuffer = this._framebuffer || new Je(this.device, {
+        return this.update(), this._framebuffer = this._framebuffer || new qi(this.device, {
             handle: null
         }), this._framebuffer
     }
     update() {
         let r = this.getPixelSize();
         (r[0] !== this.presentationSize[0] || r[1] !== this.presentationSize[1]) && (this.presentationSize = r, this.resize())
     }
@@ -19169,144 +19169,144 @@
             let i = this.getDevicePixelRatio(r?.useDevicePixels);
             this.setDevicePixelRatio(i, r);
             return
         }
     }
     commit() {}
 };
-var MR = {
-        spector: O.get("spector") || O.get("inspect")
+var BD = {
+        spector: N.get("spector") || N.get("inspect")
     },
-    CR = "https://spectorcdn.babylonjs.com/spector.bundle.js",
-    IR = 1,
-    Jt = null,
-    j0 = !1;
-async function H0(e) {
+    FD = "https://spectorcdn.babylonjs.com/spector.bundle.js",
+    DD = 1,
+    ir = null,
+    uA = !1;
+async function fA(e) {
     if (!globalThis.SPECTOR) try {
-        await Dn(CR)
+        await Il(FD)
     } catch (t) {
-        O.warn(String(t))
+        N.warn(String(t))
     }
 }
 
-function X0(e) {
+function hA(e) {
     if (e = {
-            ...MR,
+            ...BD,
             ...e
-        }, !e?.spector || (!Jt && globalThis.SPECTOR && (O.probe(IR, "SPECTOR found and initialized")(), Jt = new globalThis.SPECTOR.Spector, globalThis.luma && (globalThis.luma.spector = Jt)), !Jt)) return null;
-    if (j0 || (j0 = !0, Jt.spyCanvases(), Jt?.onCaptureStarted.add(t => O.info("Spector capture started:", t)()), Jt?.onCapture.add(t => {
-            O.info("Spector capture complete:", t)(), Jt?.getResultUI(), Jt?.resultView.display(), Jt?.resultView.addCapture(t)
+        }, !e?.spector || (!ir && globalThis.SPECTOR && (N.probe(DD, "SPECTOR found and initialized")(), ir = new globalThis.SPECTOR.Spector, globalThis.luma && (globalThis.luma.spector = ir)), !ir)) return null;
+    if (uA || (uA = !0, ir.spyCanvases(), ir?.onCaptureStarted.add(t => N.info("Spector capture started:", t)()), ir?.onCapture.add(t => {
+            N.info("Spector capture complete:", t)(), ir?.getResultUI(), ir?.resultView.display(), ir?.resultView.addCapture(t)
         })), e?.canvas) {
-        if (typeof e.spector == "string" && e.spector !== e.canvas.id) return Jt;
-        Jt?.startCapture(e?.canvas, 500), new Promise(t => setTimeout(t, 2e3)).then(t => {
-            O.info("Spector capture stopped after 2 seconds")(), Jt?.stopCapture()
+        if (typeof e.spector == "string" && e.spector !== e.canvas.id) return ir;
+        ir?.startCapture(e?.canvas, 500), new Promise(t => setTimeout(t, 2e3)).then(t => {
+            N.info("Spector capture stopped after 2 seconds")(), ir?.stopCapture()
         })
     }
-    return Jt
+    return ir
 }
-var OR = "https://unpkg.com/webgl-debug@2.0.1/index.js";
+var LD = "https://unpkg.com/webgl-debug@2.0.1/index.js";
 
-function $0(e) {
+function dA(e) {
     return e.luma = e.luma || {}, e.luma
 }
-async function Y0() {
-    Ot() && !globalThis.WebGLDebugUtils && (globalThis.global = globalThis.global || globalThis, globalThis.global.module = {}, await Dn(OR))
+async function pA() {
+    Me() && !globalThis.WebGLDebugUtils && (globalThis.global = globalThis.global || globalThis, globalThis.global.module = {}, await Il(LD))
 }
 
-function q0(e, t = {}) {
-    return e ? t.debug ? FR(e, t) : NR(e) : null
+function mA(e, t = {}) {
+    return e ? t.debug ? UD(e, t) : kD(e) : null
 }
 
-function NR(e) {
-    let t = $0(e);
+function kD(e) {
+    let t = dA(e);
     return t.realContext ? t.realContext : e
 }
 
-function FR(e, t) {
-    if (!globalThis.WebGLDebugUtils) return O.warn("webgl-debug not loaded")(), e;
-    let r = $0(e);
+function UD(e, t) {
+    if (!globalThis.WebGLDebugUtils) return N.warn("webgl-debug not loaded")(), e;
+    let r = dA(e);
     if (r.debugContext) return r.debugContext;
     globalThis.WebGLDebugUtils.init({
-        ...Qr,
+        ...Cs,
         ...e
     });
-    let i = globalThis.WebGLDebugUtils.makeDebugContext(e, DR.bind(null, t), kR.bind(null, t));
-    for (let o in Qr) !(o in i) && typeof Qr[o] == "number" && (i[o] = Qr[o]);
-    class s {}
-    Object.setPrototypeOf(i, Object.getPrototypeOf(e)), Object.setPrototypeOf(s, i);
-    let n = Object.create(s);
-    return r.realContext = e, r.debugContext = n, n.debug = !0, n
+    let i = globalThis.WebGLDebugUtils.makeDebugContext(e, VD.bind(null, t), zD.bind(null, t));
+    for (let o in Cs) !(o in i) && typeof Cs[o] == "number" && (i[o] = Cs[o]);
+    class n {}
+    Object.setPrototypeOf(i, Object.getPrototypeOf(e)), Object.setPrototypeOf(n, i);
+    let s = Object.create(n);
+    return r.realContext = e, r.debugContext = s, s.debug = !0, s
 }
 
-function Id(e, t) {
+function xb(e, t) {
     t = Array.from(t).map(i => i === void 0 ? "undefined" : i);
     let r = globalThis.WebGLDebugUtils.glFunctionArgsToString(e, t);
     return r = `${r.slice(0,100)}${r.length>100?"...":""}`, `gl.${e}(${r})`
 }
 
-function DR(e, t, r, i) {
+function VD(e, t, r, i) {
     i = Array.from(i).map(a => a === void 0 ? "undefined" : a);
-    let s = globalThis.WebGLDebugUtils.glEnumToString(t),
-        n = globalThis.WebGLDebugUtils.glFunctionArgsToString(r, i),
-        o = `${s} in gl.${r}(${n})`;
-    O.error(o)();
+    let n = globalThis.WebGLDebugUtils.glEnumToString(t),
+        s = globalThis.WebGLDebugUtils.glFunctionArgsToString(r, i),
+        o = `${n} in gl.${r}(${s})`;
+    N.error(o)();
     debugger;
     if (e.throwOnError) throw new Error(o)
 }
 
-function kR(e, t, r) {
+function zD(e, t, r) {
     let i = "";
-    if (O.level >= 1 && (i = Id(t, r), O.log(1, i)()), e.break && e.break.length > 0 && (i = i || Id(t, r), e.break.every(n => i.indexOf(n) !== -1))) debugger;
-    for (let s of r)
-        if (s === void 0) {
-            if (i = i || Id(t, r), e.throwOnError) throw new Error(`Undefined argument: ${i}`);
-            O.error(`Undefined argument: ${i}`)();
+    if (N.level >= 1 && (i = xb(t, r), N.log(1, i)()), e.break && e.break.length > 0 && (i = i || xb(t, r), e.break.every(s => i.indexOf(s) !== -1))) debugger;
+    for (let n of r)
+        if (n === void 0) {
+            if (i = i || xb(t, r), e.throwOnError) throw new Error(`Undefined argument: ${i}`);
+            N.error(`Undefined argument: ${i}`)();
             debugger
         }
 }
 
-function K0(e) {
+function _A(e) {
     let t = e.split(/\r?\n/),
         r = [];
     for (let i of t) {
         if (i.length <= 1) continue;
-        let s = i.split(":");
-        if (s.length === 2) {
-            let [f, u] = s;
+        let n = i.split(":");
+        if (n.length === 2) {
+            let [f, h] = n;
             r.push({
-                message: u.trim(),
-                type: Z0(f),
+                message: h.trim(),
+                type: gA(f),
                 lineNum: 0,
                 linePos: 0
             });
             continue
         }
-        let [n, o, a, ...c] = s, l = parseInt(a, 10);
+        let [s, o, a, ...c] = n, l = parseInt(a, 10);
         isNaN(l) && (l = 0);
-        let h = parseInt(o, 10);
-        isNaN(h) && (h = 0), r.push({
+        let u = parseInt(o, 10);
+        isNaN(u) && (u = 0), r.push({
             message: c.join(":").trim(),
-            type: Z0(n),
+            type: gA(s),
             lineNum: l,
-            linePos: h
+            linePos: u
         })
     }
     return r
 }
 
-function Z0(e) {
+function gA(e) {
     let t = ["warning", "error", "info"],
         r = e.toLowerCase();
     return t.includes(r) ? r : "info"
 }
-var nl = class extends bi {
+var cp = class extends go {
     constructor(r, i) {
         super(r, i);
-        p(this, "device");
-        p(this, "handle");
+        m(this, "device");
+        m(this, "handle");
         switch (this.device = r, this.props.stage) {
             case "vertex":
                 this.handle = this.props.handle || this.device.gl.createShader(35633);
                 break;
             case "fragment":
                 this.handle = this.props.handle || this.device.gl.createShader(35632);
                 break;
@@ -19319,114 +19319,114 @@
         this.handle && (this.removeStats(), this.device.gl.deleteShader(this.handle), this.destroyed = !0)
     }
     async getCompilationInfo() {
         return await this._waitForCompilationComplete(), this.getCompilationInfoSync()
     }
     getCompilationInfoSync() {
         let r = this.device.gl.getShaderInfoLog(this.handle);
-        return K0(r)
+        return _A(r)
     }
     getTranslatedSource() {
         return this.device.getExtension("WEBGL_debug_shaders").WEBGL_debug_shaders?.getTranslatedShaderSource(this.handle)
     }
     async _compile(r) {
-        r = (n => n.startsWith("#version ") ? n : `#version 100
-${n}`)(r);
+        r = (s => s.startsWith("#version ") ? s : `#version 100
+${s}`)(r);
         let {
-            gl: s
+            gl: n
         } = this.device;
-        if (s.shaderSource(this.handle, r), s.compileShader(this.handle), O.level === 0) {
+        if (n.shaderSource(this.handle, r), n.compileShader(this.handle), N.level === 0) {
             this.compilationStatus = "pending";
             return
         }
         if (!this.device.features.has("compilation-status-async-webgl")) {
             if (this._getCompilationStatus(), this.debugShader(), this.compilationStatus === "error") throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
             return
         }
-        O.once(1, "Shader compilation is asynchronous")(), await this._waitForCompilationComplete(), O.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)(), this._getCompilationStatus(), this.debugShader()
+        N.once(1, "Shader compilation is asynchronous")(), await this._waitForCompilationComplete(), N.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)(), this._getCompilationStatus(), this.debugShader()
     }
     async _waitForCompilationComplete() {
-        let r = async n => await new Promise(o => setTimeout(o, n));
+        let r = async s => await new Promise(o => setTimeout(o, s));
         if (!this.device.features.has("compilation-status-async-webgl")) {
             await r(10);
             return
         }
         let {
-            gl: s
+            gl: n
         } = this.device;
         for (;;) {
-            if (s.getShaderParameter(this.handle, 37297)) return;
+            if (n.getShaderParameter(this.handle, 37297)) return;
             await r(10)
         }
     }
     _getCompilationStatus() {
         this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error"
     }
 };
-var LR = 256,
-    BR = 1024,
-    UR = 16384,
-    Od = 6144,
-    VR = [1, 2, 4, 8],
-    ol = class extends vn {
+var WD = 256,
+    jD = 1024,
+    HD = 16384,
+    wb = 6144,
+    $D = [1, 2, 4, 8],
+    lp = class extends yl {
         constructor(r, i) {
             super(r, i);
-            p(this, "device");
-            p(this, "glParameters");
-            this.device = r, Gr(this.device.gl), this.setParameters(this.props.parameters), this.clear()
+            m(this, "device");
+            m(this, "glParameters");
+            this.device = r, Os(this.device.gl), this.setParameters(this.props.parameters), this.clear()
         }
         end() {
-            yr(this.device.gl)
+            In(this.device.gl)
         }
         pushDebugGroup(r) {}
         popDebugGroup() {}
         insertDebugMarker(r) {}
         setParameters(r = {}) {
             let i = {
                 ...this.glParameters
             };
-            this.props.framebuffer && (i.framebuffer = this.props.framebuffer), this.props.depthReadOnly && (i.depthMask = !this.props.depthReadOnly), i.stencilMask = this.props.stencilReadOnly ? 0 : 1, i[35977] = this.props.discard, r.viewport && (r.viewport.length >= 6 ? (i.viewport = r.viewport.slice(0, 4), i.depthRange = [r.viewport[4], r.viewport[5]]) : i.viewport = r.viewport), r.scissorRect && (i.scissorTest = !0, i.scissor = r.scissorRect), r.blendConstant && (i.blendColor = r.blendConstant), r.stencilReference && (console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL"), r[2967] = r.stencilReference), r.colorMask && (i.colorMask = VR.map(s => !!(s & r.colorMask))), this.glParameters = i, Me(this.device.gl, i)
+            this.props.framebuffer && (i.framebuffer = this.props.framebuffer), this.props.depthReadOnly && (i.depthMask = !this.props.depthReadOnly), i.stencilMask = this.props.stencilReadOnly ? 0 : 1, i[35977] = this.props.discard, r.viewport && (r.viewport.length >= 6 ? (i.viewport = r.viewport.slice(0, 4), i.depthRange = [r.viewport[4], r.viewport[5]]) : i.viewport = r.viewport), r.scissorRect && (i.scissorTest = !0, i.scissor = r.scissorRect), r.blendConstant && (i.blendColor = r.blendConstant), r.stencilReference && (console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL"), r[2967] = r.stencilReference), r.colorMask && (i.colorMask = $D.map(n => !!(n & r.colorMask))), this.glParameters = i, si(this.device.gl, i)
         }
         beginOcclusionQuery(r) {
             this.props.occlusionQuerySet?.beginOcclusionQuery()
         }
         endOcclusionQuery() {
             this.props.occlusionQuerySet?.endOcclusionQuery()
         }
         clear() {
             let r = {
                     ...this.glParameters
                 },
                 i = 0;
-            this.props.clearColor !== !1 && (i |= UR, r.clearColor = this.props.clearColor), this.props.clearDepth !== !1 && (i |= LR, r.clearDepth = this.props.clearDepth), this.props.clearStencil !== !1 && (i |= BR, r.clearStencil = this.props.clearStencil), i !== 0 && Te(this.device.gl, r, () => {
+            this.props.clearColor !== !1 && (i |= HD, r.clearColor = this.props.clearColor), this.props.clearDepth !== !1 && (i |= WD, r.clearDepth = this.props.clearDepth), this.props.clearStencil !== !1 && (i |= jD, r.clearStencil = this.props.clearStencil), i !== 0 && zr(this.device.gl, r, () => {
                 this.device.gl.clear(i)
             })
         }
         clearColorBuffer(r = 0, i = [0, 0, 0, 0]) {
-            Te(this.device.gl, {
+            zr(this.device.gl, {
                 framebuffer: this.props.framebuffer
             }, () => {
                 switch (i.constructor) {
                     case Int32Array:
-                        this.device.gl.clearBufferiv(Od, r, i);
+                        this.device.gl.clearBufferiv(wb, r, i);
                         break;
                     case Uint32Array:
-                        this.device.gl.clearBufferuiv(Od, r, i);
+                        this.device.gl.clearBufferuiv(wb, r, i);
                         break;
                     case Float32Array:
                     default:
-                        this.device.gl.clearBufferfv(Od, r, i);
+                        this.device.gl.clearBufferfv(wb, r, i);
                         break
                 }
             })
         }
     };
-var zR = "Failed to deduce GL constant from typed array";
+var XD = "Failed to deduce GL constant from typed array";
 
-function Q0(e) {
+function yA(e) {
     switch (ArrayBuffer.isView(e) ? e.constructor : e) {
         case Float32Array:
             return 5126;
         case Uint16Array:
             return 5123;
         case Uint32Array:
             return 5125;
@@ -19437,19 +19437,19 @@
         case Int8Array:
             return 5120;
         case Int16Array:
             return 5122;
         case Int32Array:
             return 5124;
         default:
-            throw new Error(zR)
+            throw new Error(XD)
     }
 }
 
-function xo(e, t) {
+function uu(e, t) {
     let {
         clamped: r = !0
     } = t || {};
     switch (e) {
         case 5126:
             return Float32Array;
         case 5123:
@@ -19467,70 +19467,70 @@
             return Int16Array;
         case 5124:
             return Int32Array;
         default:
             throw new Error("Failed to deduce typed array type from GL constant")
     }
 }
-var WR = {
+var YD = {
         offset: 0,
         stride: 0,
         type: 5126,
         size: 1,
         divisor: 0,
         normalized: !1,
         integer: !1
     },
-    jR = {
+    qD = {
         deprecatedProps: {
             instanced: "divisor",
             isInstanced: "divisor"
         }
     },
-    al = class e {
+    up = class e {
         constructor(...t) {
-            p(this, "offset");
-            p(this, "stride");
-            p(this, "type");
-            p(this, "size");
-            p(this, "divisor");
-            p(this, "normalized");
-            p(this, "integer");
-            p(this, "buffer");
-            p(this, "index");
+            m(this, "offset");
+            m(this, "stride");
+            m(this, "type");
+            m(this, "size");
+            m(this, "divisor");
+            m(this, "normalized");
+            m(this, "integer");
+            m(this, "buffer");
+            m(this, "index");
             t.forEach(r => this._assign(r)), Object.freeze(this)
         }
         static getBytesPerElement(t) {
-            return xo(t.type || 5126).BYTES_PER_ELEMENT
+            return uu(t.type || 5126).BYTES_PER_ELEMENT
         }
         static getBytesPerVertex(t) {
-            return Q(t.size), xo(t.type || 5126).BYTES_PER_ELEMENT * t.size
+            return _t(t.size), uu(t.type || 5126).BYTES_PER_ELEMENT * t.size
         }
         static resolve(...t) {
-            return new e(WR, ...t)
+            return new e(YD, ...t)
         }
         toString() {
             return JSON.stringify(this)
         }
         get BYTES_PER_ELEMENT() {
             return e.getBytesPerElement(this)
         }
         get BYTES_PER_VERTEX() {
             return e.getBytesPerVertex(this)
         }
         _assign(t = {}) {
-            return t = wf("Accessor", t, jR), t.type !== void 0 && (this.type = t.type, (t.type === 5124 || t.type === 5125) && (this.integer = !0)), t.size !== void 0 && (this.size = t.size), t.offset !== void 0 && (this.offset = t.offset), t.stride !== void 0 && (this.stride = t.stride), t.normalize !== void 0 && (this.normalized = t.normalize), t.normalized !== void 0 && (this.normalized = t.normalized), t.integer !== void 0 && (this.integer = t.integer), t.divisor !== void 0 && (this.divisor = t.divisor), t.buffer !== void 0 && (this.buffer = t.buffer), t.index !== void 0 && (typeof t.index == "boolean" ? this.index = t.index ? 1 : 0 : this.index = t.index), t.instanced !== void 0 && (this.divisor = t.instanced ? 1 : 0), t.isInstanced !== void 0 && (this.divisor = t.isInstanced ? 1 : 0), this.offset === void 0 && delete this.offset, this.stride === void 0 && delete this.stride, this.type === void 0 && delete this.type, this.size === void 0 && delete this.size, this.divisor === void 0 && delete this.divisor, this.normalized === void 0 && delete this.normalized, this.integer === void 0 && delete this.integer, this.buffer === void 0 && delete this.buffer, this.index === void 0 && delete this.index, this
+            return t = py("Accessor", t, qD), t.type !== void 0 && (this.type = t.type, (t.type === 5124 || t.type === 5125) && (this.integer = !0)), t.size !== void 0 && (this.size = t.size), t.offset !== void 0 && (this.offset = t.offset), t.stride !== void 0 && (this.stride = t.stride), t.normalize !== void 0 && (this.normalized = t.normalize), t.normalized !== void 0 && (this.normalized = t.normalized), t.integer !== void 0 && (this.integer = t.integer), t.divisor !== void 0 && (this.divisor = t.divisor), t.buffer !== void 0 && (this.buffer = t.buffer), t.index !== void 0 && (typeof t.index == "boolean" ? this.index = t.index ? 1 : 0 : this.index = t.index), t.instanced !== void 0 && (this.divisor = t.instanced ? 1 : 0), t.isInstanced !== void 0 && (this.divisor = t.isInstanced ? 1 : 0), this.offset === void 0 && delete this.offset, this.stride === void 0 && delete this.stride, this.type === void 0 && delete this.type, this.size === void 0 && delete this.size, this.divisor === void 0 && delete this.divisor, this.normalized === void 0 && delete this.normalized, this.integer === void 0 && delete this.integer, this.buffer === void 0 && delete this.buffer, this.index === void 0 && delete this.index, this
         }
     };
 
-function G0(e) {
-    return HR.includes(e)
+function bA(e) {
+    return ZD.includes(e)
 }
-var HR = [35678, 35680, 35679, 35682, 36289, 36292, 36293, 36298, 36299, 36300, 36303, 36306, 36307, 36308, 36311],
-    J0 = {
+var ZD = [35678, 35680, 35679, 35682, 36289, 36292, 36293, 36298, 36299, 36300, 36303, 36306, 36307, 36308, 36311],
+    xA = {
         5126: [5126, 1, "float", "f32", "float32"],
         35664: [5126, 2, "vec2", "vec2<f32>", "float32x2"],
         35665: [5126, 3, "vec3", "vec3<f32>", "float32x3"],
         35666: [5126, 4, "vec4", "vec4<f32>", "float32x4"],
         5124: [5124, 1, "int", "i32", "sint32"],
         35667: [5124, 2, "ivec2", "vec2<i32>", "sint32x2"],
         35668: [5124, 3, "ivec3", "vec3<i32>", "sint32x3"],
@@ -19550,43 +19550,43 @@
         35675: [5126, 12, "mat3", "mat3x3<f32>"],
         35688: [5126, 12, "mat3x4", "mat3x4<f32>"],
         35689: [5126, 16, "mat4x2", "mat4x2<f32>"],
         35690: [5126, 16, "mat4x3", "mat4x3<f32>"],
         35676: [5126, 16, "mat4", "mat4x4<f32>"]
     };
 
-function Nd(e) {
-    let t = J0[e];
+function Tb(e) {
+    let t = xA[e];
     if (!t) throw new Error("uniform");
-    let [r, i, , s] = t;
+    let [r, i, , n] = t;
     return {
-        format: s,
+        format: n,
         components: i,
         glType: r
     }
 }
 
-function ty(e) {
-    let t = J0[e];
+function wA(e) {
+    let t = xA[e];
     if (!t) throw new Error("attribute");
-    let [, r, , i, s] = t;
+    let [, r, , i, n] = t;
     return {
         attributeType: i,
-        vertexFormat: s,
+        vertexFormat: n,
         components: r
     }
 }
 
-function ey(e, t) {
+function TA(e, t) {
     let r = {
         attributes: [],
         bindings: []
     };
-    r.attributes = XR(e, t);
-    let i = qR(e, t);
+    r.attributes = KD(e, t);
+    let i = QD(e, t);
     for (let a of i) {
         let c = a.uniforms.map(l => ({
             name: l.name,
             format: l.format,
             byteOffset: l.byteOffset,
             byteStride: l.byteStride,
             arrayLength: l.arrayLength
@@ -19596,156 +19596,156 @@
             name: a.name,
             location: a.location,
             visibility: (a.vertex ? 1 : 0) & (a.fragment ? 2 : 0),
             minBindingSize: a.byteLength,
             uniforms: c
         })
     }
-    let s = YR(e, t),
-        n = 0;
-    for (let a of s)
-        if (G0(a.type)) {
+    let n = JD(e, t),
+        s = 0;
+    for (let a of n)
+        if (bA(a.type)) {
             let {
                 viewDimension: c,
                 sampleType: l
-            } = KR(a.type);
+            } = eL(a.type);
             r.bindings.push({
                 type: "texture",
                 name: a.name,
-                location: n,
+                location: s,
                 viewDimension: c,
                 sampleType: l
-            }), a.textureUnit = n, n += 1
-        } s.length && (r.uniforms = s);
-    let o = $R(e, t);
+            }), a.textureUnit = s, s += 1
+        } n.length && (r.uniforms = n);
+    let o = GD(e, t);
     return o?.length && (r.varyings = o), r
 }
 
-function XR(e, t) {
+function KD(e, t) {
     let r = [],
         i = e.getProgramParameter(t, 35721);
-    for (let s = 0; s < i; s++) {
-        let n = e.getActiveAttrib(t, s);
-        if (!n) throw new Error("activeInfo");
+    for (let n = 0; n < i; n++) {
+        let s = e.getActiveAttrib(t, n);
+        if (!s) throw new Error("activeInfo");
         let {
             name: o,
             type: a
-        } = n, c = e.getAttribLocation(t, o);
+        } = s, c = e.getAttribLocation(t, o);
         if (c >= 0) {
             let {
                 attributeType: l
-            } = ty(a), h = /instance/i.test(o) ? "instance" : "vertex";
+            } = wA(a), u = /instance/i.test(o) ? "instance" : "vertex";
             r.push({
                 name: o,
                 location: c,
-                stepMode: h,
+                stepMode: u,
                 type: l
             })
         }
     }
-    return r.sort((s, n) => s.location - n.location), r
+    return r.sort((n, s) => n.location - s.location), r
 }
 
-function $R(e, t) {
+function GD(e, t) {
     let r = [],
         i = e.getProgramParameter(t, 35971);
-    for (let s = 0; s < i; s++) {
-        let n = e.getTransformFeedbackVarying(t, s);
-        if (!n) throw new Error("activeInfo");
+    for (let n = 0; n < i; n++) {
+        let s = e.getTransformFeedbackVarying(t, n);
+        if (!s) throw new Error("activeInfo");
         let {
             name: o,
             type: a,
             size: c
-        } = n, {
+        } = s, {
             glType: l,
-            components: h
-        } = Nd(a), f = new al({
+            components: u
+        } = Tb(a), f = new up({
             type: l,
-            size: c * h
-        }), u = {
-            location: s,
+            size: c * u
+        }), h = {
+            location: n,
             name: o,
             accessor: f
         };
-        r.push(u)
+        r.push(h)
     }
-    return r.sort((s, n) => s.location - n.location), r
+    return r.sort((n, s) => n.location - s.location), r
 }
 
-function YR(e, t) {
+function JD(e, t) {
     let r = [],
         i = e.getProgramParameter(t, 35718);
-    for (let s = 0; s < i; s++) {
-        let n = e.getActiveUniform(t, s);
-        if (!n) throw new Error("activeInfo");
+    for (let n = 0; n < i; n++) {
+        let s = e.getActiveUniform(t, n);
+        if (!s) throw new Error("activeInfo");
         let {
             name: o,
             size: a,
             type: c
-        } = n, {
+        } = s, {
             name: l,
-            isArray: h
-        } = QR(o), f = e.getUniformLocation(t, l), u = {
+            isArray: u
+        } = rL(o), f = e.getUniformLocation(t, l), h = {
             location: f,
             name: l,
             size: a,
             type: c,
-            isArray: h
+            isArray: u
         };
-        if (r.push(u), u.size > 1)
-            for (let d = 0; d < u.size; d++) {
-                let m = `${l}[${d}]`;
-                f = e.getUniformLocation(t, m);
+        if (r.push(h), h.size > 1)
+            for (let d = 0; d < h.size; d++) {
+                let p = `${l}[${d}]`;
+                f = e.getUniformLocation(t, p);
                 let y = {
-                    ...u,
-                    name: m,
+                    ...h,
+                    name: p,
                     location: f
                 };
                 r.push(y)
             }
     }
     return r
 }
 
-function qR(e, t) {
-    let r = (n, o) => e.getActiveUniformBlockParameter(t, n, o),
+function QD(e, t) {
+    let r = (s, o) => e.getActiveUniformBlockParameter(t, s, o),
         i = [],
-        s = e.getProgramParameter(t, 35382);
-    for (let n = 0; n < s; n++) {
+        n = e.getProgramParameter(t, 35382);
+    for (let s = 0; s < n; s++) {
         let o = {
-                name: e.getActiveUniformBlockName(t, n) || "",
-                location: r(n, 35391),
-                byteLength: r(n, 35392),
-                vertex: r(n, 35396),
-                fragment: r(n, 35398),
-                uniformCount: r(n, 35394),
+                name: e.getActiveUniformBlockName(t, s) || "",
+                location: r(s, 35391),
+                byteLength: r(s, 35392),
+                vertex: r(s, 35396),
+                fragment: r(s, 35398),
+                uniformCount: r(s, 35394),
                 uniforms: []
             },
-            a = r(n, 35395) || [],
+            a = r(s, 35395) || [],
             c = e.getActiveUniforms(t, a, 35383),
             l = e.getActiveUniforms(t, a, 35384),
-            h = e.getActiveUniforms(t, a, 35387),
+            u = e.getActiveUniforms(t, a, 35387),
             f = e.getActiveUniforms(t, a, 35388);
-        for (let u = 0; u < o.uniformCount; ++u) {
-            let d = e.getActiveUniform(t, a[u]);
+        for (let h = 0; h < o.uniformCount; ++h) {
+            let d = e.getActiveUniform(t, a[h]);
             if (!d) throw new Error("activeInfo");
             o.uniforms.push({
                 name: d.name,
-                format: Nd(c[u]).format,
-                type: c[u],
-                arrayLength: l[u],
-                byteOffset: h[u],
-                byteStride: f[u]
+                format: Tb(c[h]).format,
+                type: c[h],
+                arrayLength: l[h],
+                byteOffset: u[h],
+                byteStride: f[h]
             })
         }
         i.push(o)
     }
-    return i.sort((n, o) => n.location - o.location), i
+    return i.sort((s, o) => s.location - o.location), i
 }
-var ZR = {
+var tL = {
     35678: ["2d", "float"],
     35680: ["cube", "float"],
     35679: ["3d", "float"],
     35682: ["3d", "depth"],
     36289: ["2d-array", "float"],
     36292: ["2d-array", "depth"],
     36293: ["cube", "float"],
@@ -19755,44 +19755,44 @@
     36303: ["2d-array", "uint"],
     36306: ["2d", "uint"],
     36307: ["3d", "uint"],
     36308: ["cube", "uint"],
     36311: ["2d-array", "uint"]
 };
 
-function KR(e) {
-    let t = ZR[e];
+function eL(e) {
+    let t = tL[e];
     if (!t) throw new Error("sampler");
     let [r, i] = t;
     return {
         viewDimension: r,
         sampleType: i
     }
 }
 
-function QR(e) {
+function rL(e) {
     if (e[e.length - 1] !== "]") return {
         name: e,
         length: 1,
         isArray: !1
     };
     let r = /([^[]*)(\[[0-9]+\])?/.exec(e);
     if (!r || r.length < 2) throw new Error(`Failed to parse GLSL uniform name ${e}`);
     return {
         name: r[1],
         length: r[2] ? 1 : 0,
         isArray: !!r[2]
     }
 }
 
-function ry(e, t, r, i) {
-    let s = e,
-        n = i;
-    n === !0 && (n = 1), n === !1 && (n = 0);
-    let o = typeof n == "number" ? [n] : n;
+function vA(e, t, r, i) {
+    let n = e,
+        s = i;
+    s === !0 && (s = 1), s === !1 && (s = 0);
+    let o = typeof s == "number" ? [s] : s;
     switch (r) {
         case 35678:
         case 35680:
         case 35679:
         case 35682:
         case 36289:
         case 36292:
@@ -19828,44 +19828,44 @@
         case 35671:
             return e.uniform2iv(t, o);
         case 35672:
             return e.uniform3iv(t, o);
         case 35673:
             return e.uniform4iv(t, o);
         case 5125:
-            return s.uniform1uiv(t, o, 1);
+            return n.uniform1uiv(t, o, 1);
         case 36294:
-            return s.uniform2uiv(t, o, 2);
+            return n.uniform2uiv(t, o, 2);
         case 36295:
-            return s.uniform3uiv(t, o, 3);
+            return n.uniform3uiv(t, o, 3);
         case 36296:
-            return s.uniform4uiv(t, o, 4);
+            return n.uniform4uiv(t, o, 4);
         case 35674:
             return e.uniformMatrix2fv(t, !1, o);
         case 35675:
             return e.uniformMatrix3fv(t, !1, o);
         case 35676:
             return e.uniformMatrix4fv(t, !1, o);
         case 35685:
-            return s.uniformMatrix2x3fv(t, !1, o);
+            return n.uniformMatrix2x3fv(t, !1, o);
         case 35686:
-            return s.uniformMatrix2x4fv(t, !1, o);
+            return n.uniformMatrix2x4fv(t, !1, o);
         case 35687:
-            return s.uniformMatrix3x2fv(t, !1, o);
+            return n.uniformMatrix3x2fv(t, !1, o);
         case 35688:
-            return s.uniformMatrix3x4fv(t, !1, o);
+            return n.uniformMatrix3x4fv(t, !1, o);
         case 35689:
-            return s.uniformMatrix4x2fv(t, !1, o);
+            return n.uniformMatrix4x2fv(t, !1, o);
         case 35690:
-            return s.uniformMatrix4x3fv(t, !1, o)
+            return n.uniformMatrix4x3fv(t, !1, o)
     }
     throw new Error("Illegal uniform")
 }
 
-function iy(e) {
+function SA(e) {
     switch (e) {
         case "point-list":
             return 0;
         case "line-list":
             return 1;
         case "line-strip":
             return 3;
@@ -19878,15 +19878,15 @@
         case "triangle-fan-webgl":
             return 6;
         default:
             throw new Error(e)
     }
 }
 
-function sy(e) {
+function AA(e) {
     switch (e) {
         case "point-list":
             return 0;
         case "line-list":
             return 1;
         case "line-strip":
             return 1;
@@ -19898,108 +19898,108 @@
             return 4;
         case "triangle-fan-webgl":
             return 4;
         default:
             throw new Error(e)
     }
 }
-var ny = 4,
-    cl = class extends He {
+var EA = 4,
+    fp = class extends Ui {
         constructor(r, i) {
             super(r, i);
-            p(this, "device");
-            p(this, "handle");
-            p(this, "vs");
-            p(this, "fs");
-            p(this, "introspectedLayout");
-            p(this, "uniforms", {});
-            p(this, "bindings", {});
-            p(this, "varyings", null);
-            p(this, "_uniformCount", 0);
-            p(this, "_uniformSetters", {});
+            m(this, "device");
+            m(this, "handle");
+            m(this, "vs");
+            m(this, "fs");
+            m(this, "introspectedLayout");
+            m(this, "uniforms", {});
+            m(this, "bindings", {});
+            m(this, "varyings", null);
+            m(this, "_uniformCount", 0);
+            m(this, "_uniformSetters", {});
             this.device = r, this.handle = this.props.handle || this.device.gl.createProgram(), this.device.setSpectorMetadata(this.handle, {
                 id: this.props.id
             }), this.vs = i.vs, this.fs = i.fs;
             let {
-                varyings: s,
-                bufferMode: n = 35981
+                varyings: n,
+                bufferMode: s = 35981
             } = i;
-            switch (s && s.length > 0 && (this.varyings = s, this.device.gl.transformFeedbackVaryings(this.handle, s, n)), this._linkShaders(), O.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.introspectedLayout = ey(this.device.gl, this.handle), O.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.shaderLayout = bf(this.introspectedLayout, i.shaderLayout), this.props.topology) {
+            switch (n && n.length > 0 && (this.varyings = n, this.device.gl.transformFeedbackVaryings(this.handle, n, s)), this._linkShaders(), N.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.introspectedLayout = TA(this.device.gl, this.handle), N.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.shaderLayout = uy(this.introspectedLayout, i.shaderLayout), this.props.topology) {
                 case "triangle-fan-webgl":
                 case "line-loop-webgl":
-                    O.warn(`Primitive topology ${this.props.topology} is deprecated and will be removed in v9.1`);
+                    N.warn(`Primitive topology ${this.props.topology} is deprecated and will be removed in v9.1`);
                     break;
                 default:
             }
         }
         destroy() {
             this.handle && (this.device.gl.deleteProgram(this.handle), this.destroyed = !0)
         }
         setBindings(r, i) {
-            for (let [s, n] of Object.entries(r)) {
-                let o = this.shaderLayout.bindings.find(a => a.name === s) || this.shaderLayout.bindings.find(a => a.name === `${s}Uniforms`);
+            for (let [n, s] of Object.entries(r)) {
+                let o = this.shaderLayout.bindings.find(a => a.name === n) || this.shaderLayout.bindings.find(a => a.name === `${n}Uniforms`);
                 if (!o) {
                     let a = this.shaderLayout.bindings.map(c => `"${c.name}"`).join(", ");
-                    i?.disableWarnings || O.warn(`Unknown binding "${s}" in render pipeline "${this.id}", expected one of ${a}`)();
+                    i?.disableWarnings || N.warn(`Unknown binding "${n}" in render pipeline "${this.id}", expected one of ${a}`)();
                     continue
                 }
-                switch (n || O.warn(`Unsetting binding "${s}" in render pipeline "${this.id}"`)(), o.type) {
+                switch (s || N.warn(`Unsetting binding "${n}" in render pipeline "${this.id}"`)(), o.type) {
                     case "uniform":
-                        if (!(n instanceof Wt) && !(n.buffer instanceof Wt)) throw new Error("buffer value");
+                        if (!(s instanceof ze) && !(s.buffer instanceof ze)) throw new Error("buffer value");
                         break;
                     case "texture":
-                        if (!(n instanceof Ce || n instanceof Gt || n instanceof Je)) throw new Error("texture value");
+                        if (!(s instanceof oi || s instanceof rr || s instanceof qi)) throw new Error("texture value");
                         break;
                     case "sampler":
-                        O.warn(`Ignoring sampler ${s}`)();
+                        N.warn(`Ignoring sampler ${n}`)();
                         break;
                     default:
                         throw new Error(o.type)
                 }
-                this.bindings[s] = n
+                this.bindings[n] = s
             }
         }
         draw(r) {
             let {
                 renderPass: i,
-                parameters: s = this.props.parameters,
-                topology: n = this.props.topology,
+                parameters: n = this.props.parameters,
+                topology: s = this.props.topology,
                 vertexArray: o,
                 vertexCount: a,
                 instanceCount: c,
                 firstVertex: l = 0,
-                transformFeedback: h
-            } = r, f = iy(n), u = !!o.indexBuffer, d = o.indexBuffer?.glIndexType, m = Number(c) > 0;
-            if (this.linkStatus !== "success") return O.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)(), !1;
-            if (!this._areTexturesRenderable() || a === 0) return O.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)(), !1;
-            if (a === 0) return O.info(2, `RenderPipeline:${this.id}.draw() aborted - no vertices to draw`)(), !0;
-            this.device.gl.useProgram(this.handle), o.bindBeforeRender(i), h && h.begin(this.props.topology), this._applyBindings(), this._applyUniforms();
+                transformFeedback: u
+            } = r, f = SA(s), h = !!o.indexBuffer, d = o.indexBuffer?.glIndexType, p = Number(c) > 0;
+            if (this.linkStatus !== "success") return N.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)(), !1;
+            if (!this._areTexturesRenderable() || a === 0) return N.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)(), !1;
+            if (a === 0) return N.info(2, `RenderPipeline:${this.id}.draw() aborted - no vertices to draw`)(), !0;
+            this.device.gl.useProgram(this.handle), o.bindBeforeRender(i), u && u.begin(this.props.topology), this._applyBindings(), this._applyUniforms();
             let y = i;
-            return z0(this.device, s, y.glParameters, () => {
-                u && m ? this.device.gl.drawElementsInstanced(f, a || 0, d, l, c || 0) : u ? this.device.gl.drawElements(f, a || 0, d, l) : m ? this.device.gl.drawArraysInstanced(f, l, a || 0, c || 0) : this.device.gl.drawArrays(f, l, a || 0), h && h.end()
+            return cA(this.device, n, y.glParameters, () => {
+                h && p ? this.device.gl.drawElementsInstanced(f, a || 0, d, l, c || 0) : h ? this.device.gl.drawElements(f, a || 0, d, l) : p ? this.device.gl.drawArraysInstanced(f, l, a || 0, c || 0) : this.device.gl.drawArrays(f, l, a || 0), u && u.end()
             }), o.unbindAfterRender(i), !0
         }
         setUniformsWebGL(r) {
             let {
                 bindings: i
-            } = Fn(r);
-            Object.keys(i).forEach(s => {
-                O.warn(`Unsupported value "${JSON.stringify(i[s])}" used in setUniforms() for key ${s}. Use setBindings() instead?`)()
+            } = El(r);
+            Object.keys(i).forEach(n => {
+                N.warn(`Unsupported value "${JSON.stringify(i[n])}" used in setUniforms() for key ${n}. Use setBindings() instead?`)()
             }), Object.assign(this.uniforms, r)
         }
         async _linkShaders() {
             let {
                 gl: r
             } = this.device;
-            if (r.attachShader(this.handle, this.vs.handle), r.attachShader(this.handle, this.fs.handle), O.time(ny, `linkProgram for ${this.id}`)(), r.linkProgram(this.handle), O.timeEnd(ny, `linkProgram for ${this.id}`)(), O.level, !this.device.features.has("compilation-status-async-webgl")) {
-                let s = this._getLinkStatus();
-                this._reportLinkStatus(s);
+            if (r.attachShader(this.handle, this.vs.handle), r.attachShader(this.handle, this.fs.handle), N.time(EA, `linkProgram for ${this.id}`)(), r.linkProgram(this.handle), N.timeEnd(EA, `linkProgram for ${this.id}`)(), N.level, !this.device.features.has("compilation-status-async-webgl")) {
+                let n = this._getLinkStatus();
+                this._reportLinkStatus(n);
                 return
             }
-            O.once(1, "RenderPipeline linking is asynchronous")(), await this._waitForLinkComplete(), O.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
+            N.once(1, "RenderPipeline linking is asynchronous")(), await this._waitForLinkComplete(), N.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
             let i = this._getLinkStatus();
             this._reportLinkStatus(i)
         }
         _reportLinkStatus(r) {
             switch (r) {
                 case "success":
                     return;
@@ -20010,180 +20010,180 @@
         _getLinkStatus() {
             let {
                 gl: r
             } = this.device;
             return r.getProgramParameter(this.handle, 35714) ? (r.validateProgram(this.handle), r.getProgramParameter(this.handle, 35715) ? (this.linkStatus = "success", "success") : (this.linkStatus = "error", "validation")) : (this.linkStatus = "error", "linking")
         }
         async _waitForLinkComplete() {
-            let r = async n => await new Promise(o => setTimeout(o, n));
+            let r = async s => await new Promise(o => setTimeout(o, s));
             if (!this.device.features.has("compilation-status-async-webgl")) {
                 await r(10);
                 return
             }
             let {
-                gl: s
+                gl: n
             } = this.device;
             for (;;) {
-                if (s.getProgramParameter(this.handle, 37297)) return;
+                if (n.getProgramParameter(this.handle, 37297)) return;
                 await r(10)
             }
         }
         _areTexturesRenderable() {
             let r = !0;
-            for (let [, i] of Object.entries(this.bindings)) i instanceof Gt && (i.update(), r = r && i.loaded);
+            for (let [, i] of Object.entries(this.bindings)) i instanceof rr && (i.update(), r = r && i.loaded);
             return r
         }
         _applyBindings() {
             if (this.linkStatus !== "success") return;
             let {
                 gl: r
             } = this.device;
             r.useProgram(this.handle);
             let i = 0,
-                s = 0;
-            for (let n of this.shaderLayout.bindings) {
-                let o = this.bindings[n.name] || this.bindings[n.name.replace(/Uniforms$/, "")];
-                if (!o) throw new Error(`No value for binding ${n.name} in ${this.id}`);
-                switch (n.type) {
+                n = 0;
+            for (let s of this.shaderLayout.bindings) {
+                let o = this.bindings[s.name] || this.bindings[s.name.replace(/Uniforms$/, "")];
+                if (!o) throw new Error(`No value for binding ${s.name} in ${this.id}`);
+                switch (s.type) {
                     case "uniform":
                         let {
                             name: a
-                        } = n, c = r.getUniformBlockIndex(this.handle, a);
+                        } = s, c = r.getUniformBlockIndex(this.handle, a);
                         if (c === 4294967295) throw new Error(`Invalid uniform block name ${a}`);
-                        r.uniformBlockBinding(this.handle, s, c), o instanceof Wt ? r.bindBufferBase(35345, s, o.handle) : r.bindBufferRange(35345, s, o.buffer.handle, o.offset || 0, o.size || o.buffer.byteLength - o.offset), s += 1;
+                        r.uniformBlockBinding(this.handle, n, c), o instanceof ze ? r.bindBufferBase(35345, n, o.handle) : r.bindBufferRange(35345, n, o.buffer.handle, o.offset || 0, o.size || o.buffer.byteLength - o.offset), n += 1;
                         break;
                     case "texture":
-                        if (!(o instanceof Ce || o instanceof Gt || o instanceof Je)) throw new Error("texture");
+                        if (!(o instanceof oi || o instanceof rr || o instanceof qi)) throw new Error("texture");
                         let l;
-                        if (o instanceof Ce) l = o.texture;
-                        else if (o instanceof Gt) l = o;
-                        else if (o instanceof Je && o.colorAttachments[0] instanceof Ce) O.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")(), l = o.colorAttachments[0].texture;
+                        if (o instanceof oi) l = o.texture;
+                        else if (o instanceof rr) l = o;
+                        else if (o instanceof qi && o.colorAttachments[0] instanceof oi) N.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")(), l = o.colorAttachments[0].texture;
                         else throw new Error("No texture");
                         r.activeTexture(33984 + i), r.bindTexture(l.target, l.handle), i += 1;
                         break;
                     case "sampler":
                         break;
                     case "storage":
                     case "read-only-storage":
-                        throw new Error(`binding type '${n.type}' not supported in WebGL`)
+                        throw new Error(`binding type '${s.type}' not supported in WebGL`)
                 }
             }
         }
         _applyUniforms() {
             for (let r of this.shaderLayout.uniforms || []) {
                 let {
                     name: i,
-                    location: s,
-                    type: n,
+                    location: n,
+                    type: s,
                     textureUnit: o
                 } = r, a = this.uniforms[i] ?? o;
-                a !== void 0 && ry(this.device.gl, s, n, a)
+                a !== void 0 && vA(this.device.gl, n, s, a)
             }
         }
     };
-var ll = class extends Pn {
+var hp = class extends xl {
     constructor(r) {
         super(r, {});
-        p(this, "device");
-        p(this, "commands", []);
+        m(this, "device");
+        m(this, "commands", []);
         this.device = r
     }
     submitCommands(r = this.commands) {
         for (let i of r) switch (i.name) {
             case "copy-buffer-to-buffer":
-                GR(this.device, i.options);
+                iL(this.device, i.options);
                 break;
             case "copy-buffer-to-texture":
-                JR(this.device, i.options);
+                nL(this.device, i.options);
                 break;
             case "copy-texture-to-buffer":
-                tP(this.device, i.options);
+                sL(this.device, i.options);
                 break;
             case "copy-texture-to-texture":
-                eP(this.device, i.options);
+                oL(this.device, i.options);
                 break
         }
     }
 };
 
-function GR(e, t) {
+function iL(e, t) {
     let r = t.source,
         i = t.destination;
     e.gl.bindBuffer(36662, r.handle), e.gl.bindBuffer(36663, i.handle), e.gl.copyBufferSubData(36662, 36663, t.sourceOffset ?? 0, t.destinationOffset ?? 0, t.size), e.gl.bindBuffer(36662, null), e.gl.bindBuffer(36663, null)
 }
 
-function JR(e, t) {
+function nL(e, t) {
     throw new Error("Not implemented")
 }
 
-function tP(e, t) {
+function sL(e, t) {
     let {
         source: r,
         mipLevel: i = 0,
-        aspect: s = "all",
-        width: n = t.source.width,
+        aspect: n = "all",
+        width: s = t.source.width,
         height: o = t.source.height,
         depthOrArrayLayers: a = 0,
         origin: c = [0, 0],
         destination: l,
-        byteOffset: h = 0,
+        byteOffset: u = 0,
         bytesPerRow: f,
-        rowsPerImage: u
+        rowsPerImage: h
     } = t;
-    if (s !== "all") throw new Error("not supported");
-    if (i !== 0 || a !== 0 || f || u) throw new Error("not implemented");
+    if (n !== "all") throw new Error("not supported");
+    if (i !== 0 || a !== 0 || f || h) throw new Error("not implemented");
     let {
         framebuffer: d,
-        destroyFramebuffer: m
-    } = oy(r), y;
+        destroyFramebuffer: p
+    } = IA(r), y;
     try {
-        let x = l,
-            A = n || d.width,
-            v = o || d.height,
-            E = Ds(d.texture.props.format),
-            R = E.dataFormat,
-            M = E.type;
-        e.gl.bindBuffer(35051, x.handle), y = e.gl.bindFramebuffer(36160, d.handle), e.gl.readPixels(c[0], c[1], A, v, R, M, h)
+        let b = l,
+            T = s || d.width,
+            I = o || d.height,
+            S = tc(d.texture.props.format),
+            R = S.dataFormat,
+            P = S.type;
+        e.gl.bindBuffer(35051, b.handle), y = e.gl.bindFramebuffer(36160, d.handle), e.gl.readPixels(c[0], c[1], T, I, R, P, u)
     } finally {
-        e.gl.bindBuffer(35051, null), y !== void 0 && e.gl.bindFramebuffer(36160, y), m && d.destroy()
+        e.gl.bindBuffer(35051, null), y !== void 0 && e.gl.bindFramebuffer(36160, y), p && d.destroy()
     }
 }
 
-function eP(e, t) {
+function oL(e, t) {
     let {
         source: r,
         destinationMipLevel: i = 0,
-        origin: s = [0, 0],
-        destinationOrigin: n = [0, 0],
+        origin: n = [0, 0],
+        destinationOrigin: s = [0, 0],
         destination: o
     } = t, {
         width: a = t.destination.width,
         height: c = t.destination.height
     } = t, {
         framebuffer: l,
-        destroyFramebuffer: h
-    } = oy(r), [f, u] = s, [d, m, y] = n, x = e.gl.bindFramebuffer(36160, l.handle), A = null, v;
-    if (o instanceof Gt) A = o, a = Number.isFinite(a) ? a : A.width, c = Number.isFinite(c) ? c : A.height, A.bind(0), v = A.target;
+        destroyFramebuffer: u
+    } = IA(r), [f, h] = n, [d, p, y] = s, b = e.gl.bindFramebuffer(36160, l.handle), T = null, I;
+    if (o instanceof rr) T = o, a = Number.isFinite(a) ? a : T.width, c = Number.isFinite(c) ? c : T.height, T.bind(0), I = T.target;
     else throw new Error("invalid destination");
-    switch (v) {
+    switch (I) {
         case 3553:
         case 34067:
-            e.gl.copyTexSubImage2D(v, i, d, m, f, u, a, c);
+            e.gl.copyTexSubImage2D(I, i, d, p, f, h, a, c);
             break;
         case 35866:
         case 32879:
-            e.gl.copyTexSubImage3D(v, i, d, m, y, f, u, a, c);
+            e.gl.copyTexSubImage3D(I, i, d, p, y, f, h, a, c);
             break;
         default:
     }
-    A && A.unbind(), e.gl.bindFramebuffer(36160, x), h && l.destroy()
+    T && T.unbind(), e.gl.bindFramebuffer(36160, b), u && l.destroy()
 }
 
-function oy(e) {
-    if (e instanceof Tt) {
+function IA(e) {
+    if (e instanceof ae) {
         let {
             width: t,
             height: r,
             id: i
         } = e;
         return {
             framebuffer: e.device.createFramebuffer({
@@ -20196,20 +20196,20 @@
         }
     }
     return {
         framebuffer: e,
         destroyFramebuffer: !1
     }
 }
-var hl = class extends Rn {
+var dp = class extends bl {
     constructor(r, i) {
         super(r, i);
-        p(this, "device");
-        p(this, "commandBuffer");
-        this.device = r, this.commandBuffer = new ll(r)
+        m(this, "device");
+        m(this, "commandBuffer");
+        this.device = r, this.commandBuffer = new hp(r)
     }
     destroy() {}
     finish() {
         this.commandBuffer.submitCommands()
     }
     copyBufferToBuffer(r) {
         this.commandBuffer.commands.push({
@@ -20234,52 +20234,52 @@
             name: "copy-texture-to-texture",
             options: r
         })
     }
     pushDebugGroup(r) {}
     popDebugGroup() {}
     insertDebugMarker(r) {}
-    resolveQuerySet(r, i, s) {}
+    resolveQuerySet(r, i, n) {}
 };
-var fl = class e extends Mn {
+var pp = class e extends wl {
     constructor(r, i) {
         super(r, i);
-        p(this, "device");
-        p(this, "handle");
-        p(this, "buffer", null);
-        p(this, "bufferValue", null);
+        m(this, "device");
+        m(this, "handle");
+        m(this, "buffer", null);
+        m(this, "bufferValue", null);
         this.device = r, this.handle = this.device.gl.createVertexArray()
     }
     get[Symbol.toStringTag]() {
         return "VertexArray"
     }
     static isConstantAttributeZeroSupported(r) {
-        return jh() === "Chrome"
+        return N_() === "Chrome"
     }
     destroy() {
         super.destroy(), this.buffer && this.buffer?.destroy(), this.handle && (this.device.gl.deleteVertexArray(this.handle), this.handle = void 0)
     }
     setIndexBuffer(r) {
         let i = r;
         if (i && i.glTarget !== 34963) throw new Error("Use .setBuffer()");
         this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34963, i ? i.handle : null), this.indexBuffer = i, this.device.gl.bindVertexArray(null)
     }
     setBuffer(r, i) {
-        let s = i;
-        if (s.glTarget === 34963) throw new Error("Use .setIndexBuffer()");
+        let n = i;
+        if (n.glTarget === 34963) throw new Error("Use .setIndexBuffer()");
         let {
-            size: n,
+            size: s,
             type: o,
             stride: a,
             offset: c,
             normalized: l,
-            integer: h,
+            integer: u,
             divisor: f
         } = this._getAccessor(r);
-        this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34962, s.handle), h ? this.device.gl.vertexAttribIPointer(r, n, o, a, c) : this.device.gl.vertexAttribPointer(r, n, o, l, a, c), this.device.gl.enableVertexAttribArray(r), this.device.gl.vertexAttribDivisor(r, f || 0), this.attributes[r] = s, this.device.gl.bindVertexArray(null)
+        this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34962, n.handle), u ? this.device.gl.vertexAttribIPointer(r, s, o, a, c) : this.device.gl.vertexAttribPointer(r, s, o, l, a, c), this.device.gl.enableVertexAttribArray(r), this.device.gl.vertexAttribDivisor(r, f || 0), this.attributes[r] = n, this.device.gl.bindVertexArray(null)
     }
     setConstantWebGL(r, i) {
         this._enable(r, !1), this.attributes[r] = i
     }
     bindBeforeRender() {
         this.device.gl.bindVertexArray(this.handle), this._applyConstantAttributes()
     }
@@ -20291,170 +20291,170 @@
             let i = this.attributes[r];
             ArrayBuffer.isView(i) && this.device.setConstantAttributeWebGL(r, i)
         }
     }
     _getAccessor(r) {
         let i = this.attributeInfos[r];
         if (!i) throw new Error(`Unknown attribute location ${r}`);
-        let s = Yc(i.bufferDataType);
+        let n = Kd(i.bufferDataType);
         return {
             size: i.bufferComponents,
-            type: s,
+            type: n,
             stride: i.byteStride,
             offset: i.byteOffset,
             normalized: i.normalized,
             integer: i.integer,
             divisor: i.stepMode === "instance" ? 1 : 0
         }
     }
     _enable(r, i = !0) {
-        let n = e.isConstantAttributeZeroSupported(this.device) || r !== 0;
-        (i || n) && (r = Number(r), this.device.gl.bindVertexArray(this.handle), i ? this.device.gl.enableVertexAttribArray(r) : this.device.gl.disableVertexAttribArray(r), this.device.gl.bindVertexArray(null))
+        let s = e.isConstantAttributeZeroSupported(this.device) || r !== 0;
+        (i || s) && (r = Number(r), this.device.gl.bindVertexArray(this.handle), i ? this.device.gl.enableVertexAttribArray(r) : this.device.gl.disableVertexAttribArray(r), this.device.gl.bindVertexArray(null))
     }
     getConstantBuffer(r, i) {
-        let s = rP(i),
-            n = s.byteLength * r,
-            o = s.length * r;
-        if (this.buffer && n !== this.buffer.byteLength) throw new Error(`Buffer size is immutable, byte length ${n} !== ${this.buffer.byteLength}.`);
+        let n = aL(i),
+            s = n.byteLength * r,
+            o = n.length * r;
+        if (this.buffer && s !== this.buffer.byteLength) throw new Error(`Buffer size is immutable, byte length ${s} !== ${this.buffer.byteLength}.`);
         let a = !this.buffer;
         if (this.buffer = this.buffer || this.device.createBuffer({
-                byteLength: n
-            }), a = a || !iP(s, this.bufferValue), a) {
-            let c = Af(i.constructor, o);
-            Ef({
+                byteLength: s
+            }), a = a || !cL(n, this.bufferValue), a) {
+            let c = fy(i.constructor, o);
+            hy({
                 target: c,
-                source: s,
+                source: n,
                 start: 0,
                 count: o
             }), this.buffer.write(c), this.bufferValue = i
         }
         return this.buffer
     }
 };
 
-function rP(e) {
+function aL(e) {
     return Array.isArray(e) ? new Float32Array(e) : e
 }
 
-function iP(e, t) {
+function cL(e, t) {
     if (!e || !t || e.length !== t.length || e.constructor !== t.constructor) return !1;
     for (let r = 0; r < e.length; ++r)
         if (e[r] !== t[r]) return !1;
     return !0
 }
-var ul = class extends Cn {
+var mp = class extends Tl {
     constructor(r, i) {
         super(r, i);
-        p(this, "device");
-        p(this, "gl");
-        p(this, "handle");
-        p(this, "layout");
-        p(this, "buffers", {});
-        p(this, "unusedBuffers", {});
-        p(this, "bindOnUse", !0);
-        p(this, "_bound", !1);
+        m(this, "device");
+        m(this, "gl");
+        m(this, "handle");
+        m(this, "layout");
+        m(this, "buffers", {});
+        m(this, "unusedBuffers", {});
+        m(this, "bindOnUse", !0);
+        m(this, "_bound", !1);
         this.device = r, this.gl = r.gl, this.handle = this.props.handle || this.gl.createTransformFeedback(), this.layout = this.props.layout, i.buffers && this.setBuffers(i.buffers), Object.seal(this)
     }
     destroy() {
         this.gl.deleteTransformFeedback(this.handle), super.destroy()
     }
     begin(r = "point-list") {
-        this.gl.bindTransformFeedback(36386, this.handle), this.bindOnUse && this._bindBuffers(), this.gl.beginTransformFeedback(sy(r))
+        this.gl.bindTransformFeedback(36386, this.handle), this.bindOnUse && this._bindBuffers(), this.gl.beginTransformFeedback(AA(r))
     }
     end() {
         this.gl.endTransformFeedback(), this.bindOnUse || this._unbindBuffers(), this.gl.bindTransformFeedback(36386, null)
     }
     setBuffers(r) {
         this.buffers = {}, this.unusedBuffers = {}, this.bind(() => {
             for (let i in r) this.setBuffer(i, r[i])
         })
     }
     setBuffer(r, i) {
-        let s = this._getVaryingIndex(r),
+        let n = this._getVaryingIndex(r),
             {
-                buffer: n,
+                buffer: s,
                 byteLength: o,
                 byteOffset: a
             } = this._getBufferRange(i);
-        if (s < 0) {
-            this.unusedBuffers[r] = n, O.warn(`${this.id} unusedBuffers varying buffer ${r}`)();
+        if (n < 0) {
+            this.unusedBuffers[r] = s, N.warn(`${this.id} unusedBuffers varying buffer ${r}`)();
             return
         }
-        this.buffers[s] = {
-            buffer: n,
+        this.buffers[n] = {
+            buffer: s,
             byteLength: o,
             byteOffset: a
-        }, this.bindOnUse || this._bindBuffer(s, n, a, o)
+        }, this.bindOnUse || this._bindBuffer(n, s, a, o)
     }
     getBuffer(r) {
-        if (ay(r)) return this.buffers[r] || null;
+        if (RA(r)) return this.buffers[r] || null;
         let i = this._getVaryingIndex(r);
         return i >= 0 ? this.buffers[i] : null
     }
     bind(r = this.handle) {
         if (typeof r != "function") return this.gl.bindTransformFeedback(36386, r), this;
         let i;
         return this._bound ? i = r() : (this.gl.bindTransformFeedback(36386, this.handle), this._bound = !0, i = r(), this._bound = !1, this.gl.bindTransformFeedback(36386, null)), i
     }
     unbind() {
         this.bind(null)
     }
     _getBufferRange(r) {
-        if (r instanceof Wt) return {
+        if (r instanceof ze) return {
             buffer: r,
             byteOffset: 0,
             byteLength: r.byteLength
         };
         let {
             buffer: i,
-            byteOffset: s = 0,
-            byteLength: n = r.buffer.byteLength
+            byteOffset: n = 0,
+            byteLength: s = r.buffer.byteLength
         } = r;
         return {
             buffer: i,
-            byteOffset: s,
-            byteLength: n
+            byteOffset: n,
+            byteLength: s
         }
     }
     _getVaryingIndex(r) {
-        if (ay(r)) return Number(r);
+        if (RA(r)) return Number(r);
         for (let i of this.layout.varyings)
             if (r === i.name) return i.location;
         return -1
     }
     _bindBuffers() {
         for (let r in this.buffers) {
             let {
                 buffer: i,
-                byteLength: s,
-                byteOffset: n
+                byteLength: n,
+                byteOffset: s
             } = this._getBufferRange(this.buffers[r]);
-            this._bindBuffer(Number(r), i, n, s)
+            this._bindBuffer(Number(r), i, s, n)
         }
     }
     _unbindBuffers() {
         for (let r in this.buffers) this.gl.bindBufferBase(35982, Number(r), null)
     }
-    _bindBuffer(r, i, s = 0, n) {
+    _bindBuffer(r, i, n = 0, s) {
         let o = i && i.handle;
-        !o || n === void 0 ? this.gl.bindBufferBase(35982, r, o) : this.gl.bindBufferRange(35982, r, o, s, n)
+        !o || s === void 0 ? this.gl.bindBufferBase(35982, r, o) : this.gl.bindBufferRange(35982, r, o, n, s)
     }
 };
 
-function ay(e) {
+function RA(e) {
     return typeof e == "number" ? Number.isInteger(e) : /^\d+$/.test(e)
 }
-var dl = class extends In {
+var gp = class extends vl {
     constructor(r, i) {
         super(r, i);
-        p(this, "device");
-        p(this, "handle");
-        p(this, "target", null);
-        p(this, "_queryPending", !1);
-        p(this, "_pollingPromise", null);
+        m(this, "device");
+        m(this, "handle");
+        m(this, "target", null);
+        m(this, "_queryPending", !1);
+        m(this, "_pollingPromise", null);
         if (this.device = r, i.count > 1) throw new Error("WebGL QuerySet can only have one value");
         this.handle = this.device.gl.createQuery(), Object.seal(this)
     }
     get[Symbol.toStringTag]() {
         return "Query"
     }
     destroy() {
@@ -20500,24 +20500,24 @@
     }
     getTimerMilliseconds() {
         return this.getResult() / 1e6
     }
     pollQuery(r = Number.POSITIVE_INFINITY) {
         if (this._pollingPromise) return this._pollingPromise;
         let i = 0;
-        return this._pollingPromise = new Promise((s, n) => {
+        return this._pollingPromise = new Promise((n, s) => {
             let o = () => {
-                this.isResultAvailable() ? (s(this.getResult()), this._pollingPromise = null) : i++ > r ? (n("Timed out"), this._pollingPromise = null) : requestAnimationFrame(o)
+                this.isResultAvailable() ? (n(this.getResult()), this._pollingPromise = null) : i++ > r ? (s("Timed out"), this._pollingPromise = null) : requestAnimationFrame(o)
             };
             requestAnimationFrame(o)
         }), this._pollingPromise
     }
 };
 
-function Fd(e) {
+function vb(e) {
     switch (e) {
         case 6406:
         case 33326:
         case 6403:
             return 1;
         case 33328:
         case 33319:
@@ -20525,516 +20525,516 @@
         case 6407:
         case 34837:
             return 3;
         case 6408:
         case 34836:
             return 4;
         default:
-            return Q(!1), 0
+            return _t(!1), 0
     }
 }
 
-function cy(e) {
+function MA(e) {
     switch (e) {
         case 5121:
             return 1;
         case 33635:
         case 32819:
         case 32820:
             return 2;
         case 5126:
             return 4;
         default:
-            return Q(!1), 0
+            return _t(!1), 0
     }
 }
 
-function ly(e, t) {
+function PA(e, t) {
     let {
         sourceX: r = 0,
         sourceY: i = 0,
-        sourceFormat: s = 6408,
-        sourceAttachment: n = 36064
+        sourceFormat: n = 6408,
+        sourceAttachment: s = 36064
     } = t || {}, {
         target: o = null,
         sourceWidth: a,
         sourceHeight: c,
         sourceType: l
     } = t || {}, {
-        framebuffer: h,
+        framebuffer: u,
         deleteFramebuffer: f
-    } = fy(e);
-    Q(h);
+    } = OA(e);
+    _t(u);
     let {
-        gl: u,
+        gl: h,
         handle: d
-    } = h;
-    a = a || h.width, c = c || h.height;
-    let m = n - 36064;
-    l = l || h.colorAttachments[m]?.texture?.type || 5121, o = nP(o, l, s, a, c), l = l || Q0(o);
-    let y = u.bindFramebuffer(36160, d);
-    return u.readPixels(r, i, a, c, s, l, o), u.bindFramebuffer(36160, y || null), f && h.destroy(), o
+    } = u;
+    a = a || u.width, c = c || u.height;
+    let p = s - 36064;
+    l = l || u.colorAttachments[p]?.texture?.type || 5121, o = uL(o, l, n, a, c), l = l || yA(o);
+    let y = h.bindFramebuffer(36160, d);
+    return h.readPixels(r, i, a, c, n, l, o), h.bindFramebuffer(36160, y || null), f && u.destroy(), o
 }
 
-function hy(e, t) {
+function CA(e, t) {
     let {
         target: r,
         sourceX: i = 0,
-        sourceY: s = 0,
-        sourceFormat: n = 6408,
+        sourceY: n = 0,
+        sourceFormat: s = 6408,
         targetByteOffset: o = 0
     } = t || {}, {
         sourceWidth: a,
         sourceHeight: c,
         sourceType: l
     } = t || {}, {
-        framebuffer: h,
+        framebuffer: u,
         deleteFramebuffer: f
-    } = fy(e);
-    Q(h), a = a || h.width, c = c || h.height;
-    let u = h;
+    } = OA(e);
+    _t(u), a = a || u.width, c = c || u.height;
+    let h = u;
     l = l || 5121;
     let d = r;
     if (!d) {
-        let y = Fd(n),
-            x = cy(l),
-            A = o + a * c * y * x;
-        d = u.device.createBuffer({
-            byteLength: A
+        let y = vb(s),
+            b = MA(l),
+            T = o + a * c * y * b;
+        d = h.device.createBuffer({
+            byteLength: T
         })
     }
-    let m = e.device.createCommandEncoder();
-    return m.copyTextureToBuffer({
+    let p = e.device.createCommandEncoder();
+    return p.copyTextureToBuffer({
         source: e,
         width: a,
         height: c,
-        origin: [i, s],
+        origin: [i, n],
         destination: d,
         byteOffset: o
-    }), m.destroy(), f && h.destroy(), d
+    }), p.destroy(), f && u.destroy(), d
 }
 
-function fy(e) {
-    return e instanceof Ei ? {
+function OA(e) {
+    return e instanceof yo ? {
         framebuffer: e,
         deleteFramebuffer: !1
     } : {
-        framebuffer: sP(e),
+        framebuffer: lL(e),
         deleteFramebuffer: !0
     }
 }
 
-function sP(e, t) {
+function lL(e, t) {
     let {
         device: r,
         width: i,
-        height: s,
-        id: n
+        height: n,
+        id: s
     } = e;
     return r.createFramebuffer({
         ...t,
-        id: `framebuffer-for-${n}`,
+        id: `framebuffer-for-${s}`,
         width: i,
-        height: s,
+        height: n,
         colorAttachments: [e]
     })
 }
 
-function nP(e, t, r, i, s) {
+function uL(e, t, r, i, n) {
     if (e) return e;
     t = t || 5121;
-    let n = xo(t, {
+    let s = uu(t, {
             clamped: !1
         }),
-        o = Fd(r);
-    return new n(i * s * o)
+        o = vb(r);
+    return new s(i * n * o)
 }
-var oP = 256,
-    aP = 1024,
-    cP = 16384;
-var lP = "clear: bad arguments";
+var fL = 256,
+    hL = 1024,
+    dL = 16384;
+var pL = "clear: bad arguments";
 
-function uy(e, t) {
+function NA(e, t) {
     let {
         framebuffer: r = null,
         color: i = null,
-        depth: s = null,
-        stencil: n = null
+        depth: n = null,
+        stencil: s = null
     } = t || {}, o = {};
     r && (o.framebuffer = r);
     let a = 0;
-    i && (a |= cP, i !== !0 && (o.clearColor = i)), s && (a |= oP, s !== !0 && (o.clearDepth = s)), n && (a |= aP, s !== !0 && (o.clearStencil = s)), Q(a !== 0, lP);
+    i && (a |= dL, i !== !0 && (o.clearColor = i)), n && (a |= fL, n !== !0 && (o.clearDepth = n)), s && (a |= hL, n !== !0 && (o.clearStencil = n)), _t(a !== 0, pL);
     let c = e.gl;
-    Te(c, o, () => {
+    zr(c, o, () => {
         c.clear(a)
     })
 }
-var To = 1,
-    Ui = class Ui extends je {
+var fu = 1,
+    Bo = class Bo extends ki {
         constructor(r) {
             super({
                 ...r,
-                id: r.id || Lt("webgl-device")
+                id: r.id || De("webgl-device")
             });
-            p(this, "type", "webgl");
-            p(this, "handle");
-            p(this, "features");
-            p(this, "limits");
-            p(this, "info");
-            p(this, "canvasContext");
-            p(this, "lost");
-            p(this, "_resolveContextLost");
-            p(this, "renderPass", null);
-            p(this, "gl");
-            p(this, "debug", !1);
-            p(this, "_canvasSizeInfo", {
+            m(this, "type", "webgl");
+            m(this, "handle");
+            m(this, "features");
+            m(this, "limits");
+            m(this, "info");
+            m(this, "canvasContext");
+            m(this, "lost");
+            m(this, "_resolveContextLost");
+            m(this, "renderPass", null);
+            m(this, "gl");
+            m(this, "debug", !1);
+            m(this, "_canvasSizeInfo", {
                 clientWidth: 0,
                 clientHeight: 0,
                 devicePixelRatio: 1
             });
-            p(this, "_extensions", {});
-            p(this, "_polyfilled", !1);
-            p(this, "spectorJS");
-            p(this, "_constants");
+            m(this, "_extensions", {});
+            m(this, "_polyfilled", !1);
+            m(this, "spectorJS");
+            m(this, "_constants");
             let i = r.gl?.device;
             if (i) throw new Error(`WebGL context already attached to device ${i.id}`);
-            let s = r.gl?.canvas || r.canvas;
-            this.canvasContext = new sl(this, {
+            let n = r.gl?.canvas || r.canvas;
+            this.canvasContext = new ap(this, {
                 ...r,
-                canvas: s
+                canvas: n
             }), this.lost = new Promise(c => {
                 this._resolveContextLost = c
             });
-            let n = r.gl || null;
-            if (n || (n = P0(this.canvasContext.canvas, {
+            let s = r.gl || null;
+            if (s || (s = Z1(this.canvasContext.canvas, {
                     ...r,
                     onContextLost: c => this._resolveContextLost?.({
                         reason: "destroyed",
                         message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
                     })
-                })), !n) throw new Error("WebGL context creation failed");
-            this.handle = n, this.gl = n, this.gl.device = this, this.gl._version = 2, this.info = M0(this.gl, this._extensions), this.limits = new tl(this.gl), this.features = new Jc(this.gl, this._extensions, this.props.disabledFeatures), this.props.initalizeFeatures && this.features.initializeFeatures(), this.canvasContext.resize();
+                })), !s) throw new Error("WebGL context creation failed");
+            this.handle = s, this.gl = s, this.gl.device = this, this.gl._version = 2, this.info = K1(this.gl, this._extensions), this.limits = new ip(this.gl), this.features = new rp(this.gl, this._extensions, this.props.disabledFeatures), this.props.initalizeFeatures && this.features.initializeFeatures(), this.canvasContext.resize();
             let {
                 enable: o = !0,
                 copyState: a = !1
             } = r;
-            Ad(this.gl, {
+            fb(this.gl, {
                 enable: o,
                 copyState: a,
-                log: (...c) => O.log(1, ...c)()
-            }), r.debug && (this.gl = q0(this.gl, {
+                log: (...c) => N.log(1, ...c)()
+            }), r.debug && (this.gl = mA(this.gl, {
                 ...r,
                 throwOnError: !0
-            }), this.debug = !0, O.level = Math.max(O.level, 1), O.warn("WebGL debug mode activated. Performance reduced.")()), r.spector && (this.spectorJS = X0({
+            }), this.debug = !0, N.level = Math.max(N.level, 1), N.warn("WebGL debug mode activated. Performance reduced.")()), r.spector && (this.spectorJS = hA({
                 ...this.props,
                 canvas: this.handle.canvas
             }))
         }
         static isSupported() {
             return typeof WebGL2RenderingContext < "u"
         }
         static attach(r) {
-            if (r instanceof Ui) return r;
-            if (r?.device instanceof je) return r.device;
-            if (!hP(r)) throw new Error("Invalid WebGL2RenderingContext");
-            return new Ui({
+            if (r instanceof Bo) return r;
+            if (r?.device instanceof ki) return r.device;
+            if (!mL(r)) throw new Error("Invalid WebGL2RenderingContext");
+            return new Bo({
                 gl: r
             })
         }
         static async create(r = {}) {
-            O.groupCollapsed(To, "WebGLDevice created")();
+            N.groupCollapsed(fu, "WebGLDevice created")();
             let i = [];
-            r.debug && i.push(Y0()), r.spector && i.push(H0()), typeof r.canvas == "string" && i.push(Ur.pageLoaded);
-            let s = await Promise.allSettled(i);
-            for (let a of s) a.status === "rejected" && O.error(`Failed to initialize debug libraries ${a.reason}`)();
-            if (O.probe(To + 1, "DOM is loaded")(), r.gl?.device) return O.warn("reattaching existing device")(), Ui.attach(r.gl);
-            let n = new Ui(r),
-                o = `Created ${n.type}${n.debug?" debug":""} context: ${n.info.vendor}, ${n.info.renderer} for canvas: ${n.canvasContext.id}`;
-            return O.probe(To, o)(), O.table(To, n.info)(), O.groupEnd(To)(), n
+            r.debug && i.push(pA()), r.spector && i.push(fA()), typeof r.canvas == "string" && i.push(bs.pageLoaded);
+            let n = await Promise.allSettled(i);
+            for (let a of n) a.status === "rejected" && N.error(`Failed to initialize debug libraries ${a.reason}`)();
+            if (N.probe(fu + 1, "DOM is loaded")(), r.gl?.device) return N.warn("reattaching existing device")(), Bo.attach(r.gl);
+            let s = new Bo(r),
+                o = `Created ${s.type}${s.debug?" debug":""} context: ${s.info.vendor}, ${s.info.renderer} for canvas: ${s.canvasContext.id}`;
+            return N.probe(fu, o)(), N.table(fu, s.info)(), N.groupEnd(fu)(), s
         }
         destroy() {}
         get isLost() {
             return this.gl.isContextLost()
         }
         getSize() {
             return [this.gl.drawingBufferWidth, this.gl.drawingBufferHeight]
         }
         isTextureFormatSupported(r) {
-            return Gc(this.gl, r, this._extensions)
+            return ep(this.gl, r, this._extensions)
         }
         isTextureFormatFilterable(r) {
-            return k0(this.gl, r, this._extensions)
+            return iA(this.gl, r, this._extensions)
         }
         isTextureFormatRenderable(r) {
-            return L0(this.gl, r, this._extensions)
+            return nA(this.gl, r, this._extensions)
         }
         createCanvasContext(r) {
             throw new Error("WebGL only supports a single canvas")
         }
         createBuffer(r) {
             let i = this._getBufferProps(r);
-            return new Wt(this, i)
+            return new ze(this, i)
         }
         _createTexture(r) {
-            return new Gt(this, r)
+            return new rr(this, r)
         }
         createExternalTexture(r) {
             throw new Error("createExternalTexture() not implemented")
         }
         createSampler(r) {
-            return new Bi(this, r)
+            return new No(this, r)
         }
         createShader(r) {
-            return new nl(this, r)
+            return new cp(this, r)
         }
         createFramebuffer(r) {
-            return new Je(this, r)
+            return new qi(this, r)
         }
         createVertexArray(r) {
-            return new fl(this, r)
+            return new pp(this, r)
         }
         createTransformFeedback(r) {
-            return new ul(this, r)
+            return new mp(this, r)
         }
         createQuerySet(r) {
-            return new dl(this, r)
+            return new gp(this, r)
         }
         createRenderPipeline(r) {
-            return new cl(this, r)
+            return new fp(this, r)
         }
         beginRenderPass(r) {
-            return new ol(this, r)
+            return new lp(this, r)
         }
         createComputePipeline(r) {
             throw new Error("ComputePipeline not supported in WebGL")
         }
         beginComputePass(r) {
             throw new Error("ComputePass not supported in WebGL")
         }
         createCommandEncoder(r) {
-            return new hl(this, r)
+            return new dp(this, r)
         }
         submit() {
             this.renderPass?.end(), this.renderPass = null
         }
         readPixelsToArrayWebGL(r, i) {
-            return ly(r, i)
+            return PA(r, i)
         }
         readPixelsToBufferWebGL(r, i) {
-            return hy(r, i)
+            return CA(r, i)
         }
         setParametersWebGL(r) {
-            Me(this.gl, r)
+            si(this.gl, r)
         }
         getParametersWebGL(r) {
-            return $c(this.gl, r)
+            return Zd(this.gl, r)
         }
         withParametersWebGL(r, i) {
-            return Te(this.gl, r, i)
+            return zr(this.gl, r, i)
         }
         clearWebGL(r) {
-            uy(this, r)
+            NA(this, r)
         }
         resetWebGL() {
-            O.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")(), w0(this.gl)
+            N.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")(), X1(this.gl)
         }
         loseDevice() {
             let r = !1,
-                s = this.getExtension("WEBGL_lose_context").WEBGL_lose_context;
-            return s && (r = !0, s.loseContext()), this._resolveContextLost?.({
+                n = this.getExtension("WEBGL_lose_context").WEBGL_lose_context;
+            return n && (r = !0, n.loseContext()), this._resolveContextLost?.({
                 reason: "destroyed",
                 message: "Application triggered context loss"
             }), r
         }
         pushState() {
-            Gr(this.gl)
+            Os(this.gl)
         }
         popState() {
-            yr(this.gl)
+            In(this.gl)
         }
         setSpectorMetadata(r, i) {
             r.__SPECTOR_Metadata = i
         }
         getGLKey(r, i) {
             i = i || this.gl2 || this.gl;
-            let s = Number(r);
-            for (let n in i)
-                if (i[n] === s) return `GL.${n}`;
+            let n = Number(r);
+            for (let s in i)
+                if (i[s] === n) return `GL.${s}`;
             return String(r)
         }
         setConstantAttributeWebGL(r, i) {
-            let s = this.limits.maxVertexAttributes;
-            this._constants = this._constants || new Array(s).fill(null);
-            let n = this._constants[r];
-            switch (n && pP(n, i) && O.info(1, `setConstantAttributeWebGL(${r}) could have been skipped, value unchanged`)(), this._constants[r] = i, i.constructor) {
+            let n = this.limits.maxVertexAttributes;
+            this._constants = this._constants || new Array(n).fill(null);
+            let s = this._constants[r];
+            switch (s && bL(s, i) && N.info(1, `setConstantAttributeWebGL(${r}) could have been skipped, value unchanged`)(), this._constants[r] = i, i.constructor) {
                 case Float32Array:
-                    fP(this, r, i);
+                    gL(this, r, i);
                     break;
                 case Int32Array:
-                    uP(this, r, i);
+                    _L(this, r, i);
                     break;
                 case Uint32Array:
-                    dP(this, r, i);
+                    yL(this, r, i);
                     break;
                 default:
-                    Q(!1)
+                    _t(!1)
             }
         }
         getExtension(r) {
-            return xe(this.gl, r, this._extensions), this._extensions
+            return Vr(this.gl, r, this._extensions), this._extensions
         }
     };
-p(Ui, "type", "webgl");
-var Vi = Ui;
+m(Bo, "type", "webgl");
+var Fo = Bo;
 
-function hP(e) {
+function mL(e) {
     return typeof WebGL2RenderingContext < "u" && e instanceof WebGL2RenderingContext ? !0 : !!(e && Number.isFinite(e._version))
 }
 
-function fP(e, t, r) {
+function gL(e, t, r) {
     switch (r.length) {
         case 1:
             e.gl.vertexAttrib1fv(t, r);
             break;
         case 2:
             e.gl.vertexAttrib2fv(t, r);
             break;
         case 3:
             e.gl.vertexAttrib3fv(t, r);
             break;
         case 4:
             e.gl.vertexAttrib4fv(t, r);
             break;
         default:
-            Q(!1)
+            _t(!1)
     }
 }
 
-function uP(e, t, r) {
+function _L(e, t, r) {
     e.gl.vertexAttribI4iv(t, r)
 }
 
-function dP(e, t, r) {
+function yL(e, t, r) {
     e.gl.vertexAttribI4uiv(t, r)
 }
 
-function pP(e, t) {
+function bL(e, t) {
     if (!e || !t || e.length !== t.length || e.constructor !== t.constructor) return !1;
     for (let r = 0; r < e.length; ++r)
         if (e[r] !== t[r]) return !1;
     return !0
 }
-var zi = Fp(dy());
-var gP = {
+var Do = eT(BA());
+var xL = {
     mousedown: 1,
     mousemove: 2,
     mouseup: 4
 };
 
-function mP(e, t) {
+function wL(e, t) {
     for (let r = 0; r < e.length; r++)
         if (t(e[r])) return !0;
     return !1
 }
 
-function py(e) {
+function FA(e) {
     let t = e.prototype.handler;
     e.prototype.handler = function(i) {
-        let s = this.store;
-        i.button > 0 && i.type === "pointerdown" && (mP(s, n => n.pointerId === i.pointerId) || s.push(i)), t.call(this, i)
+        let n = this.store;
+        i.button > 0 && i.type === "pointerdown" && (wL(n, s => s.pointerId === i.pointerId) || n.push(i)), t.call(this, i)
     }
 }
 
-function gy(e) {
+function DA(e) {
     e.prototype.handler = function(r) {
-        let i = gP[r.type];
+        let i = xL[r.type];
         i & 1 && r.button >= 0 && (this.pressed = !0), i & 2 && r.which === 0 && (i = 4), this.pressed && (i & 4 && (this.pressed = !1), this.callback(this.manager, i, {
             pointers: [r],
             changedPointers: [r],
             pointerType: "mouse",
             srcEvent: r
         }))
     }
 }
-py(zi.PointerEventInput);
-gy(zi.MouseInput);
-var my = zi.Manager,
-    Ie = zi;
-var Oe = class {
+FA(Do.PointerEventInput);
+DA(Do.MouseInput);
+var LA = Do.Manager,
+    ai = Do;
+var ci = class {
     constructor(t, r, i) {
         this.element = t, this.callback = r, this.options = {
             enable: !0,
             ...i
         }
     }
 };
-var _y = Ie ? [
-        [Ie.Pan, {
+var kA = ai ? [
+        [ai.Pan, {
             event: "tripan",
             pointers: 3,
             threshold: 0,
             enable: !1
         }],
-        [Ie.Rotate, {
+        [ai.Rotate, {
             enable: !1
         }],
-        [Ie.Pinch, {
+        [ai.Pinch, {
             enable: !1
         }],
-        [Ie.Swipe, {
+        [ai.Swipe, {
             enable: !1
         }],
-        [Ie.Pan, {
+        [ai.Pan, {
             threshold: 0,
             enable: !1
         }],
-        [Ie.Press, {
+        [ai.Press, {
             enable: !1
         }],
-        [Ie.Tap, {
+        [ai.Tap, {
             event: "doubletap",
             taps: 2,
             enable: !1
         }],
-        [Ie.Tap, {
+        [ai.Tap, {
             event: "anytap",
             enable: !1
         }],
-        [Ie.Tap, {
+        [ai.Tap, {
             enable: !1
         }]
     ] : null,
-    Dd = {
+    Sb = {
         tripan: ["rotate", "pinch", "pan"],
         rotate: ["pinch"],
         pinch: ["pan"],
         pan: ["press", "doubletap", "anytap", "tap"],
         doubletap: ["anytap"],
         anytap: ["tap"]
     },
-    yy = {
+    UA = {
         doubletap: ["tap"]
     },
-    xy = {
+    VA = {
         pointerdown: "pointerdown",
         pointermove: "pointermove",
         pointerup: "pointerup",
         touchstart: "pointerdown",
         touchmove: "pointermove",
         touchend: "pointerup",
         mousedown: "pointerdown",
         mousemove: "pointermove",
         mouseup: "pointerup"
     },
-    ks = {
+    ec = {
         KEY_EVENTS: ["keydown", "keyup"],
         MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
         WHEEL_EVENTS: ["wheel", "mousewheel"]
     },
-    Ty = {
+    zA = {
         tap: "tap",
         anytap: "anytap",
         doubletap: "doubletap",
         press: "press",
         pinch: "pinch",
         pinchin: "pinch",
         pinchout: "pinch",
@@ -21067,110 +21067,110 @@
         pancancel: "pan",
         swipe: "swipe",
         swipeleft: "swipe",
         swiperight: "swipe",
         swipeup: "swipe",
         swipedown: "swipe"
     },
-    kd = {
+    Ab = {
         click: "tap",
         anyclick: "anytap",
         dblclick: "doubletap",
         mousedown: "pointerdown",
         mousemove: "pointermove",
         mouseup: "pointerup",
         mouseover: "pointerover",
         mouseout: "pointerout",
         mouseleave: "pointerleave"
     };
-var by = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "",
-    Wi = typeof window < "u" ? window : global;
-var gl = !1;
+var WA = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "",
+    Lo = typeof window < "u" ? window : global;
+var yp = !1;
 try {
     let e = {
         get passive() {
-            return gl = !0, !0
+            return yp = !0, !0
         }
     };
-    Wi.addEventListener("test", null, e), Wi.removeEventListener("test", null)
+    Lo.addEventListener("test", null, e), Lo.removeEventListener("test", null)
 } catch {
-    gl = !1
+    yp = !1
 }
-var _P = by.indexOf("firefox") !== -1,
+var TL = WA.indexOf("firefox") !== -1,
     {
-        WHEEL_EVENTS: yP
-    } = ks,
-    Ay = "wheel",
-    Ey = 4.000244140625,
-    xP = 40,
-    TP = .25,
-    bo = class extends Oe {
+        WHEEL_EVENTS: vL
+    } = ec,
+    jA = "wheel",
+    HA = 4.000244140625,
+    SL = 40,
+    AL = .25,
+    hu = class extends ci {
         constructor(t, r, i) {
-            super(t, r, i), this.handleEvent = s => {
+            super(t, r, i), this.handleEvent = n => {
                 if (!this.options.enable) return;
-                let n = s.deltaY;
-                Wi.WheelEvent && (_P && s.deltaMode === Wi.WheelEvent.DOM_DELTA_PIXEL && (n /= Wi.devicePixelRatio), s.deltaMode === Wi.WheelEvent.DOM_DELTA_LINE && (n *= xP)), n !== 0 && n % Ey === 0 && (n = Math.floor(n / Ey)), s.shiftKey && n && (n = n * TP), this.callback({
-                    type: Ay,
+                let s = n.deltaY;
+                Lo.WheelEvent && (TL && n.deltaMode === Lo.WheelEvent.DOM_DELTA_PIXEL && (s /= Lo.devicePixelRatio), n.deltaMode === Lo.WheelEvent.DOM_DELTA_LINE && (s *= SL)), s !== 0 && s % HA === 0 && (s = Math.floor(s / HA)), n.shiftKey && s && (s = s * AL), this.callback({
+                    type: jA,
                     center: {
-                        x: s.clientX,
-                        y: s.clientY
+                        x: n.clientX,
+                        y: n.clientY
                     },
-                    delta: -n,
-                    srcEvent: s,
+                    delta: -s,
+                    srcEvent: n,
                     pointerType: "mouse",
-                    target: s.target
+                    target: n.target
                 })
-            }, this.events = (this.options.events || []).concat(yP), this.events.forEach(s => t.addEventListener(s, this.handleEvent, gl ? {
+            }, this.events = (this.options.events || []).concat(vL), this.events.forEach(n => t.addEventListener(n, this.handleEvent, yp ? {
                 passive: !1
             } : !1))
         }
         destroy() {
             this.events.forEach(t => this.element.removeEventListener(t, this.handleEvent))
         }
         enableEventType(t, r) {
-            t === Ay && (this.options.enable = r)
+            t === jA && (this.options.enable = r)
         }
     };
 var {
-    MOUSE_EVENTS: bP
-} = ks, Sy = "pointermove", wy = "pointerover", vy = "pointerout", Ry = "pointerenter", Py = "pointerleave", Ao = class extends Oe {
+    MOUSE_EVENTS: EL
+} = ec, $A = "pointermove", XA = "pointerover", YA = "pointerout", qA = "pointerenter", ZA = "pointerleave", du = class extends ci {
     constructor(t, r, i) {
-        super(t, r, i), this.handleEvent = n => {
-            this.handleOverEvent(n), this.handleOutEvent(n), this.handleEnterEvent(n), this.handleLeaveEvent(n), this.handleMoveEvent(n)
+        super(t, r, i), this.handleEvent = s => {
+            this.handleOverEvent(s), this.handleOutEvent(s), this.handleEnterEvent(s), this.handleLeaveEvent(s), this.handleMoveEvent(s)
         }, this.pressed = !1;
         let {
-            enable: s
+            enable: n
         } = this.options;
-        this.enableMoveEvent = s, this.enableLeaveEvent = s, this.enableEnterEvent = s, this.enableOutEvent = s, this.enableOverEvent = s, this.events = (this.options.events || []).concat(bP), this.events.forEach(n => t.addEventListener(n, this.handleEvent))
+        this.enableMoveEvent = n, this.enableLeaveEvent = n, this.enableEnterEvent = n, this.enableOutEvent = n, this.enableOverEvent = n, this.events = (this.options.events || []).concat(EL), this.events.forEach(s => t.addEventListener(s, this.handleEvent))
     }
     destroy() {
         this.events.forEach(t => this.element.removeEventListener(t, this.handleEvent))
     }
     enableEventType(t, r) {
-        t === Sy && (this.enableMoveEvent = r), t === wy && (this.enableOverEvent = r), t === vy && (this.enableOutEvent = r), t === Ry && (this.enableEnterEvent = r), t === Py && (this.enableLeaveEvent = r)
+        t === $A && (this.enableMoveEvent = r), t === XA && (this.enableOverEvent = r), t === YA && (this.enableOutEvent = r), t === qA && (this.enableEnterEvent = r), t === ZA && (this.enableLeaveEvent = r)
     }
     handleOverEvent(t) {
-        this.enableOverEvent && t.type === "mouseover" && this._emit(wy, t)
+        this.enableOverEvent && t.type === "mouseover" && this._emit(XA, t)
     }
     handleOutEvent(t) {
-        this.enableOutEvent && t.type === "mouseout" && this._emit(vy, t)
+        this.enableOutEvent && t.type === "mouseout" && this._emit(YA, t)
     }
     handleEnterEvent(t) {
-        this.enableEnterEvent && t.type === "mouseenter" && this._emit(Ry, t)
+        this.enableEnterEvent && t.type === "mouseenter" && this._emit(qA, t)
     }
     handleLeaveEvent(t) {
-        this.enableLeaveEvent && t.type === "mouseleave" && this._emit(Py, t)
+        this.enableLeaveEvent && t.type === "mouseleave" && this._emit(ZA, t)
     }
     handleMoveEvent(t) {
         if (this.enableMoveEvent) switch (t.type) {
             case "mousedown":
                 t.button >= 0 && (this.pressed = !0);
                 break;
             case "mousemove":
-                t.which === 0 && (this.pressed = !1), this.pressed || this._emit(Sy, t);
+                t.which === 0 && (this.pressed = !1), this.pressed || this._emit($A, t);
                 break;
             case "mouseup":
                 this.pressed = !1;
                 break;
             default:
         }
     }
@@ -21184,238 +21184,238 @@
             srcEvent: r,
             pointerType: "mouse",
             target: r.target
         })
     }
 };
 var {
-    KEY_EVENTS: AP
-} = ks, My = "keydown", Cy = "keyup", Eo = class extends Oe {
+    KEY_EVENTS: IL
+} = ec, KA = "keydown", GA = "keyup", pu = class extends ci {
     constructor(t, r, i) {
-        super(t, r, i), this.handleEvent = s => {
-            let n = s.target || s.srcElement;
-            n.tagName === "INPUT" && n.type === "text" || n.tagName === "TEXTAREA" || (this.enableDownEvent && s.type === "keydown" && this.callback({
-                type: My,
-                srcEvent: s,
-                key: s.key,
-                target: s.target
-            }), this.enableUpEvent && s.type === "keyup" && this.callback({
-                type: Cy,
-                srcEvent: s,
-                key: s.key,
-                target: s.target
+        super(t, r, i), this.handleEvent = n => {
+            let s = n.target || n.srcElement;
+            s.tagName === "INPUT" && s.type === "text" || s.tagName === "TEXTAREA" || (this.enableDownEvent && n.type === "keydown" && this.callback({
+                type: KA,
+                srcEvent: n,
+                key: n.key,
+                target: n.target
+            }), this.enableUpEvent && n.type === "keyup" && this.callback({
+                type: GA,
+                srcEvent: n,
+                key: n.key,
+                target: n.target
             }))
-        }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, this.events = (this.options.events || []).concat(AP), t.tabIndex = this.options.tabIndex || 0, t.style.outline = "none", this.events.forEach(s => t.addEventListener(s, this.handleEvent))
+        }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, this.events = (this.options.events || []).concat(IL), t.tabIndex = this.options.tabIndex || 0, t.style.outline = "none", this.events.forEach(n => t.addEventListener(n, this.handleEvent))
     }
     destroy() {
         this.events.forEach(t => this.element.removeEventListener(t, this.handleEvent))
     }
     enableEventType(t, r) {
-        t === My && (this.enableDownEvent = r), t === Cy && (this.enableUpEvent = r)
+        t === KA && (this.enableDownEvent = r), t === GA && (this.enableUpEvent = r)
     }
 };
-var Iy = "contextmenu",
-    So = class extends Oe {
+var JA = "contextmenu",
+    mu = class extends ci {
         constructor(t, r, i) {
-            super(t, r, i), this.handleEvent = s => {
+            super(t, r, i), this.handleEvent = n => {
                 this.options.enable && this.callback({
-                    type: Iy,
+                    type: JA,
                     center: {
-                        x: s.clientX,
-                        y: s.clientY
+                        x: n.clientX,
+                        y: n.clientY
                     },
-                    srcEvent: s,
+                    srcEvent: n,
                     pointerType: "mouse",
-                    target: s.target
+                    target: n.target
                 })
             }, t.addEventListener("contextmenu", this.handleEvent)
         }
         destroy() {
             this.element.removeEventListener("contextmenu", this.handleEvent)
         }
         enableEventType(t, r) {
-            t === Iy && (this.options.enable = r)
+            t === JA && (this.options.enable = r)
         }
     };
-var EP = {
+var RL = {
         pointerdown: 1,
         pointermove: 2,
         pointerup: 4,
         mousedown: 1,
         mousemove: 2,
         mouseup: 4
     },
-    SP = 1,
-    wP = 2,
-    vP = 3,
-    RP = 0,
-    PP = 1,
-    MP = 2,
-    CP = 1,
-    IP = 2,
-    OP = 4;
+    ML = 1,
+    PL = 2,
+    CL = 3,
+    OL = 0,
+    NL = 1,
+    BL = 2,
+    FL = 1,
+    DL = 2,
+    LL = 4;
 
-function Oy(e) {
-    let t = EP[e.srcEvent.type];
+function QA(e) {
+    let t = RL[e.srcEvent.type];
     if (!t) return null;
     let {
         buttons: r,
         button: i,
-        which: s
-    } = e.srcEvent, n = !1, o = !1, a = !1;
-    return t === 4 || t === 2 && !Number.isFinite(r) ? (n = s === SP, o = s === wP, a = s === vP) : t === 2 ? (n = !!(r & CP), o = !!(r & OP), a = !!(r & IP)) : t === 1 && (n = i === RP, o = i === PP, a = i === MP), {
-        leftButton: n,
+        which: n
+    } = e.srcEvent, s = !1, o = !1, a = !1;
+    return t === 4 || t === 2 && !Number.isFinite(r) ? (s = n === ML, o = n === PL, a = n === CL) : t === 2 ? (s = !!(r & FL), o = !!(r & LL), a = !!(r & DL)) : t === 1 && (s = i === OL, o = i === NL, a = i === BL), {
+        leftButton: s,
         middleButton: o,
         rightButton: a
     }
 }
 
-function Ny(e, t) {
+function tE(e, t) {
     let r = e.center;
     if (!r) return null;
     let i = t.getBoundingClientRect(),
-        s = i.width / t.offsetWidth || 1,
-        n = i.height / t.offsetHeight || 1,
+        n = i.width / t.offsetWidth || 1,
+        s = i.height / t.offsetHeight || 1,
         o = {
-            x: (r.x - i.left - t.clientLeft) / s,
-            y: (r.y - i.top - t.clientTop) / n
+            x: (r.x - i.left - t.clientLeft) / n,
+            y: (r.y - i.top - t.clientTop) / s
         };
     return {
         center: r,
         offsetCenter: o
     }
 }
-var Ld = {
+var Eb = {
         srcElement: "root",
         priority: 0
     },
-    wo = class {
+    gu = class {
         constructor(t) {
             this.handleEvent = r => {
                 if (this.isEmpty()) return;
                 let i = this._normalizeEvent(r),
-                    s = r.srcEvent.target;
-                for (; s && s !== i.rootElement;) {
-                    if (this._emit(i, s), i.handled) return;
-                    s = s.parentNode
+                    n = r.srcEvent.target;
+                for (; n && n !== i.rootElement;) {
+                    if (this._emit(i, n), i.handled) return;
+                    n = n.parentNode
                 }
                 this._emit(i, "root")
             }, this.eventManager = t, this.handlers = [], this.handlersByElement = new Map, this._active = !1
         }
         isEmpty() {
             return !this._active
         }
-        add(t, r, i, s = !1, n = !1) {
+        add(t, r, i, n = !1, s = !1) {
             let {
                 handlers: o,
                 handlersByElement: a
-            } = this, c = Ld;
+            } = this, c = Eb;
             typeof i == "string" || i && i.addEventListener ? c = {
-                ...Ld,
+                ...Eb,
                 srcElement: i
             } : i && (c = {
-                ...Ld,
+                ...Eb,
                 ...i
             });
             let l = a.get(c.srcElement);
             l || (l = [], a.set(c.srcElement, l));
-            let h = {
+            let u = {
                 type: t,
                 handler: r,
                 srcElement: c.srcElement,
                 priority: c.priority
             };
-            s && (h.once = !0), n && (h.passive = !0), o.push(h), this._active = this._active || !h.passive;
+            n && (u.once = !0), s && (u.passive = !0), o.push(u), this._active = this._active || !u.passive;
             let f = l.length - 1;
-            for (; f >= 0 && !(l[f].priority >= h.priority);) f--;
-            l.splice(f + 1, 0, h)
+            for (; f >= 0 && !(l[f].priority >= u.priority);) f--;
+            l.splice(f + 1, 0, u)
         }
         remove(t, r) {
             let {
                 handlers: i,
-                handlersByElement: s
+                handlersByElement: n
             } = this;
-            for (let n = i.length - 1; n >= 0; n--) {
-                let o = i[n];
+            for (let s = i.length - 1; s >= 0; s--) {
+                let o = i[s];
                 if (o.type === t && o.handler === r) {
-                    i.splice(n, 1);
-                    let a = s.get(o.srcElement);
-                    a.splice(a.indexOf(o), 1), a.length === 0 && s.delete(o.srcElement)
+                    i.splice(s, 1);
+                    let a = n.get(o.srcElement);
+                    a.splice(a.indexOf(o), 1), a.length === 0 && n.delete(o.srcElement)
                 }
             }
-            this._active = i.some(n => !n.passive)
+            this._active = i.some(s => !s.passive)
         }
         _emit(t, r) {
             let i = this.handlersByElement.get(r);
             if (i) {
-                let s = !1,
-                    n = () => {
+                let n = !1,
+                    s = () => {
                         t.handled = !0
                     },
                     o = () => {
-                        t.handled = !0, s = !0
+                        t.handled = !0, n = !0
                     },
                     a = [];
                 for (let c = 0; c < i.length; c++) {
                     let {
                         type: l,
-                        handler: h,
+                        handler: u,
                         once: f
                     } = i[c];
-                    if (h({
+                    if (u({
                             ...t,
                             type: l,
-                            stopPropagation: n,
+                            stopPropagation: s,
                             stopImmediatePropagation: o
-                        }), f && a.push(i[c]), s) break
+                        }), f && a.push(i[c]), n) break
                 }
                 for (let c = 0; c < a.length; c++) {
                     let {
                         type: l,
-                        handler: h
+                        handler: u
                     } = a[c];
-                    this.remove(l, h)
+                    this.remove(l, u)
                 }
             }
         }
         _normalizeEvent(t) {
             let r = this.eventManager.getElement();
             return {
                 ...t,
-                ...Oy(t),
-                ...Ny(t, r),
+                ...QA(t),
+                ...tE(t, r),
                 preventDefault: () => {
                     t.srcEvent.preventDefault()
                 },
                 stopImmediatePropagation: null,
                 stopPropagation: null,
                 handled: !1,
                 rootElement: r
             }
         }
     };
-var NP = {
+var kL = {
         events: null,
         recognizers: null,
         recognizerOptions: {},
-        Manager: my,
+        Manager: LA,
         touchAction: "none",
         tabIndex: 0
     },
-    Ls = class {
+    rc = class {
         constructor(t = null, r) {
-            this._onBasicInput = s => {
+            this._onBasicInput = n => {
                 let {
-                    srcEvent: n
-                } = s, o = xy[n.type];
-                o && this.manager.emit(o, s)
-            }, this._onOtherEvent = s => {
-                this.manager.emit(s.type, s)
+                    srcEvent: s
+                } = n, o = VA[s.type];
+                o && this.manager.emit(o, n)
+            }, this._onOtherEvent = n => {
+                this.manager.emit(n.type, n)
             }, this.options = {
-                ...NP,
+                ...kL,
                 ...r
             }, this.events = new Map, this.setElement(t);
             let {
                 events: i
             } = this.options;
             i && this.on(i)
         }
@@ -21425,39 +21425,39 @@
         setElement(t) {
             if (this.element && this.destroy(), this.element = t, !t) return;
             let {
                 options: r
             } = this, i = r.Manager;
             this.manager = new i(t, {
                 touchAction: r.touchAction,
-                recognizers: r.recognizers || _y
-            }).on("hammer.input", this._onBasicInput), r.recognizers || Object.keys(Dd).forEach(s => {
-                let n = this.manager.get(s);
-                n && Dd[s].forEach(o => {
-                    n.recognizeWith(o)
+                recognizers: r.recognizers || kA
+            }).on("hammer.input", this._onBasicInput), r.recognizers || Object.keys(Sb).forEach(n => {
+                let s = this.manager.get(n);
+                s && Sb[n].forEach(o => {
+                    s.recognizeWith(o)
                 })
             });
-            for (let s in r.recognizerOptions) {
-                let n = this.manager.get(s);
-                if (n) {
-                    let o = r.recognizerOptions[s];
-                    delete o.enable, n.set(o)
+            for (let n in r.recognizerOptions) {
+                let s = this.manager.get(n);
+                if (s) {
+                    let o = r.recognizerOptions[n];
+                    delete o.enable, s.set(o)
                 }
             }
-            this.wheelInput = new bo(t, this._onOtherEvent, {
+            this.wheelInput = new hu(t, this._onOtherEvent, {
                 enable: !1
-            }), this.moveInput = new Ao(t, this._onOtherEvent, {
+            }), this.moveInput = new du(t, this._onOtherEvent, {
                 enable: !1
-            }), this.keyInput = new Eo(t, this._onOtherEvent, {
+            }), this.keyInput = new pu(t, this._onOtherEvent, {
                 enable: !1,
                 tabIndex: r.tabIndex
-            }), this.contextmenuInput = new So(t, this._onOtherEvent, {
+            }), this.contextmenuInput = new mu(t, this._onOtherEvent, {
                 enable: !1
             });
-            for (let [s, n] of this.events) n.isEmpty() || (this._toggleRecognizer(n.recognizerName, !0), this.manager.on(s, n.handleEvent))
+            for (let [n, s] of this.events) s.isEmpty() || (this._toggleRecognizer(s.recognizerName, !0), this.manager.on(n, s.handleEvent))
         }
         destroy() {
             this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy(), this.wheelInput = null, this.moveInput = null, this.keyInput = null, this.contextmenuInput = null, this.manager = null, this.element = null)
         }
         on(t, r, i) {
             this._addEventHandler(t, r, i, !1)
         }
@@ -21471,65 +21471,65 @@
             this._removeEventHandler(t, r)
         }
         _toggleRecognizer(t, r) {
             let {
                 manager: i
             } = this;
             if (!i) return;
-            let s = i.get(t);
-            if (s && s.options.enable !== r) {
-                s.set({
+            let n = i.get(t);
+            if (n && n.options.enable !== r) {
+                n.set({
                     enable: r
                 });
-                let n = yy[t];
-                n && !this.options.recognizers && n.forEach(o => {
+                let s = UA[t];
+                s && !this.options.recognizers && s.forEach(o => {
                     let a = i.get(o);
-                    r ? (a.requireFailure(t), s.dropRequireFailure(o)) : a.dropRequireFailure(t)
+                    r ? (a.requireFailure(t), n.dropRequireFailure(o)) : a.dropRequireFailure(t)
                 })
             }
             this.wheelInput.enableEventType(t, r), this.moveInput.enableEventType(t, r), this.keyInput.enableEventType(t, r), this.contextmenuInput.enableEventType(t, r)
         }
-        _addEventHandler(t, r, i, s, n) {
+        _addEventHandler(t, r, i, n, s) {
             if (typeof t != "string") {
                 i = r;
-                for (let h in t) this._addEventHandler(h, t[h], i, s, n);
+                for (let u in t) this._addEventHandler(u, t[u], i, n, s);
                 return
             }
             let {
                 manager: o,
                 events: a
-            } = this, c = kd[t] || t, l = a.get(c);
-            l || (l = new wo(this), a.set(c, l), l.recognizerName = Ty[c] || c, o && o.on(c, l.handleEvent)), l.add(t, r, i, s, n), l.isEmpty() || this._toggleRecognizer(l.recognizerName, !0)
+            } = this, c = Ab[t] || t, l = a.get(c);
+            l || (l = new gu(this), a.set(c, l), l.recognizerName = zA[c] || c, o && o.on(c, l.handleEvent)), l.add(t, r, i, n, s), l.isEmpty() || this._toggleRecognizer(l.recognizerName, !0)
         }
         _removeEventHandler(t, r) {
             if (typeof t != "string") {
                 for (let o in t) this._removeEventHandler(o, t[o]);
                 return
             }
             let {
                 events: i
-            } = this, s = kd[t] || t, n = i.get(s);
-            if (n && (n.remove(t, r), n.isEmpty())) {
+            } = this, n = Ab[t] || t, s = i.get(n);
+            if (s && (s.remove(t, r), s.isEmpty())) {
                 let {
                     recognizerName: o
-                } = n, a = !1;
+                } = s, a = !1;
                 for (let c of i.values())
                     if (c.recognizerName === o && !c.isEmpty()) {
                         a = !0;
                         break
                     } a || this._toggleRecognizer(o, !1)
             }
         }
     };
 
-function Jr() {}
-var FP = ({
+function Ns() {}
+var UL = ({
         isDragging: e
     }) => e ? "grabbing" : "grab",
-    Fy = {
+    eE = {
         id: "",
         width: "100%",
         height: "100%",
         style: null,
         viewState: null,
         initialViewState: null,
         pickingRadius: 0,
@@ -21552,40 +21552,40 @@
         eventRecognizerOptions: {},
         _framebuffer: null,
         _animate: !1,
         _pickable: !0,
         _typedArrayManagerProps: {},
         _customRender: null,
         widgets: [],
-        onDeviceInitialized: Jr,
-        onWebGLInitialized: Jr,
-        onResize: Jr,
-        onViewStateChange: Jr,
-        onInteractionStateChange: Jr,
-        onBeforeRender: Jr,
-        onAfterRender: Jr,
-        onLoad: Jr,
-        onError: e => j.error(e.message, e.cause)(),
+        onDeviceInitialized: Ns,
+        onWebGLInitialized: Ns,
+        onResize: Ns,
+        onViewStateChange: Ns,
+        onInteractionStateChange: Ns,
+        onBeforeRender: Ns,
+        onAfterRender: Ns,
+        onLoad: Ns,
+        onError: e => Z.error(e.message, e.cause)(),
         onHover: null,
         onClick: null,
         onDragStart: null,
         onDrag: null,
         onDragEnd: null,
         _onMetrics: null,
-        getCursor: FP,
+        getCursor: UL,
         getTooltip: null,
         debug: !1,
         drawPickingColors: !1
     },
-    ml = class ml {
+    bp = class bp {
         constructor(t) {
             this.width = 0, this.height = 0, this.userData = {}, this.device = null, this.canvas = null, this.viewManager = null, this.layerManager = null, this.effectManager = null, this.deckRenderer = null, this.deckPicker = null, this.eventManager = null, this.widgetManager = null, this.tooltip = null, this.animationLoop = null, this.cursorState = {
                 isHovering: !1,
                 isDragging: !1
-            }, this.stats = new Xt({
+            }, this.stats = new Ke({
                 id: "deck.gl"
             }), this.metrics = {
                 fps: 0,
                 setPropsTime: 0,
                 updateAttributesTime: 0,
                 framesRedrawn: 0,
                 pickTime: 0,
@@ -21602,72 +21602,72 @@
                 mode: "hover",
                 x: -1,
                 y: -1,
                 radius: 0,
                 event: null
             }, this._lastPointerDownInfo = null, this._onPointerMove = i => {
                 let {
-                    _pickRequest: s
+                    _pickRequest: n
                 } = this;
-                if (i.type === "pointerleave") s.x = -1, s.y = -1, s.radius = 0;
+                if (i.type === "pointerleave") n.x = -1, n.y = -1, n.radius = 0;
                 else {
                     if (i.leftButton || i.rightButton) return;
                     {
-                        let n = i.offsetCenter;
-                        if (!n) return;
-                        s.x = n.x, s.y = n.y, s.radius = this.props.pickingRadius
+                        let s = i.offsetCenter;
+                        if (!s) return;
+                        n.x = s.x, n.y = s.y, n.radius = this.props.pickingRadius
                     }
                 }
                 this.layerManager && (this.layerManager.context.mousePosition = {
-                    x: s.x,
-                    y: s.y
-                }), s.event = i
+                    x: n.x,
+                    y: n.y
+                }), n.event = i
             }, this._onEvent = i => {
-                let s = Xn[i.type],
-                    n = i.offsetCenter;
-                if (!s || !n || !this.layerManager) return;
+                let n = Ll[i.type],
+                    s = i.offsetCenter;
+                if (!n || !s || !this.layerManager) return;
                 let o = this.layerManager.getLayers(),
                     a = this.deckPicker.getLastPickedObject({
-                        x: n.x,
-                        y: n.y,
+                        x: s.x,
+                        y: s.y,
                         layers: o,
-                        viewports: this.getViewports(n)
+                        viewports: this.getViewports(s)
                     }, this._lastPointerDownInfo),
                     {
                         layer: c
                     } = a,
-                    l = c && (c[s.handler] || c.props[s.handler]),
-                    h = this.props[s.handler],
+                    l = c && (c[n.handler] || c.props[n.handler]),
+                    u = this.props[n.handler],
                     f = !1;
-                l && (f = l.call(c, a, i)), f || (h?.(a, i), this.widgetManager.onEvent(a, i))
+                l && (f = l.call(c, a, i)), f || (u?.(a, i), this.widgetManager.onEvent(a, i))
             }, this._onPointerDown = i => {
-                let s = i.offsetCenter,
-                    n = this._pick("pickObject", "pickObject Time", {
-                        x: s.x,
-                        y: s.y,
+                let n = i.offsetCenter,
+                    s = this._pick("pickObject", "pickObject Time", {
+                        x: n.x,
+                        y: n.y,
                         radius: this.props.pickingRadius
                     });
-                this._lastPointerDownInfo = n.result[0] || n.emptyInfo
+                this._lastPointerDownInfo = s.result[0] || s.emptyInfo
             }, this.props = {
-                ...Fy,
+                ...eE,
                 ...t
-            }, t = this.props, t.viewState && t.initialViewState && j.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), this.viewState = this.props.initialViewState, t.device ? this.device = t.device : t.gl && (t.gl instanceof WebGLRenderingContext && j.error("WebGL1 context not supported.")(), this.device = Vi.attach(t.gl));
+            }, t = this.props, t.viewState && t.initialViewState && Z.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), this.viewState = this.props.initialViewState, t.device ? this.device = t.device : t.gl && (t.gl instanceof WebGLRenderingContext && Z.error("WebGL1 context not supported.")(), this.device = Fo.attach(t.gl));
             let r = this.device;
-            r || (fe.registerDevices([Vi]), r = fe.createDevice({
+            r || (Or.registerDevices([Fo]), r = Or.createDevice({
                 ...t.deviceProps,
                 canvas: this._createCanvas(t)
             }), r.then(i => {
                 this.device = i
-            })), this.animationLoop = this._createAnimationLoop(r, t), this.setProps(t), t._typedArrayManagerProps && ve.setOptions(t._typedArrayManagerProps), this.animationLoop.start()
+            })), this.animationLoop = this._createAnimationLoop(r, t), this.setProps(t), t._typedArrayManagerProps && ri.setOptions(t._typedArrayManagerProps), this.animationLoop.start()
         }
         finalize() {
             this.animationLoop?.stop(), this.animationLoop?.destroy(), this.animationLoop = null, this._lastPointerDownInfo = null, this.layerManager?.finalize(), this.layerManager = null, this.viewManager?.finalize(), this.viewManager = null, this.effectManager?.finalize(), this.effectManager = null, this.deckRenderer?.finalize(), this.deckRenderer = null, this.deckPicker?.finalize(), this.deckPicker = null, this.eventManager?.destroy(), this.eventManager = null, this.widgetManager?.finalize(), this.widgetManager = null, !this.props.canvas && !this.props.device && this.canvas && (this.canvas.parentElement?.removeChild(this.canvas), this.canvas = null)
         }
         setProps(t) {
-            this.stats.get("setProps Time").timeStart(), "onLayerHover" in t && j.removed("onLayerHover", "onHover")(), "onLayerClick" in t && j.removed("onLayerClick", "onClick")(), t.initialViewState && !Ct(this.props.initialViewState, t.initialViewState, 3) && (this.viewState = t.initialViewState), Object.assign(this.props, t), this._setCanvasSize(this.props);
+            this.stats.get("setProps Time").timeStart(), "onLayerHover" in t && Z.removed("onLayerHover", "onHover")(), "onLayerClick" in t && Z.removed("onLayerClick", "onClick")(), t.initialViewState && !Se(this.props.initialViewState, t.initialViewState, 3) && (this.viewState = t.initialViewState), Object.assign(this.props, t), this._setCanvasSize(this.props);
             let r = Object.create(this.props);
             Object.assign(r, {
                 views: this._getViews(),
                 width: this.width,
                 height: this.height,
                 viewState: this._getViewState()
             }), this.animationLoop?.setProps(r), this.layerManager && (this.viewManager.setProps(r), this.layerManager.activateViewport(this.getViewports()[0]), this.layerManager.setProps(r), this.effectManager.setProps(r), this.deckRenderer.setProps(r), this.deckPicker.setProps(r), this.widgetManager.setProps(r)), this.stats.get("setProps Time").timeEnd()
@@ -21676,34 +21676,34 @@
             clearRedrawFlags: !1
         }) {
             if (!this.layerManager) return !1;
             if (this.props._animate) return "Deck._animate";
             let r = this._needsRedraw;
             t.clearRedrawFlags && (this._needsRedraw = !1);
             let i = this.viewManager.needsRedraw(t),
-                s = this.layerManager.needsRedraw(t),
-                n = this.effectManager.needsRedraw(t),
+                n = this.layerManager.needsRedraw(t),
+                s = this.effectManager.needsRedraw(t),
                 o = this.deckRenderer.needsRedraw(t);
-            return r = r || i || s || n || o, r
+            return r = r || i || n || s || o, r
         }
         redraw(t) {
             if (!this.layerManager) return;
             let r = this.needsRedraw({
                 clearRedrawFlags: !0
             });
             r = t || r, r && (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(r) : this._drawLayers(r))
         }
         get isInitialized() {
             return this.viewManager !== null
         }
         getViews() {
-            return lt(this.viewManager), this.viewManager.views
+            return Ht(this.viewManager), this.viewManager.views
         }
         getViewports(t) {
-            return lt(this.viewManager), this.viewManager.getViewports(t)
+            return Ht(this.viewManager), this.viewManager.getViewports(t)
         }
         getCanvas() {
             return this.canvas
         }
         pickObject(t) {
             let r = this._pick("pickObject", "pickObject Time", t).result;
             return r.length ? r[0] : null
@@ -21730,46 +21730,46 @@
         _addDefaultShaderModule(t) {
             this.layerManager.addDefaultShaderModule(t)
         }
         _removeDefaultShaderModule(t) {
             this.layerManager?.removeDefaultShaderModule(t)
         }
         _pick(t, r, i) {
-            lt(this.deckPicker);
+            Ht(this.deckPicker);
             let {
-                stats: s
+                stats: n
             } = this;
-            s.get("Pick Count").incrementCount(), s.get(r).timeStart();
-            let n = this.deckPicker[t]({
+            n.get("Pick Count").incrementCount(), n.get(r).timeStart();
+            let s = this.deckPicker[t]({
                 layers: this.layerManager.getLayers(i),
                 views: this.viewManager.getViews(),
                 viewports: this.getViewports(i),
                 onViewportActive: this.layerManager.activateViewport,
                 effects: this.effectManager.getEffects(),
                 ...i
             });
-            return s.get(r).timeEnd(), n
+            return n.get(r).timeEnd(), s
         }
         _createCanvas(t) {
             let r = t.canvas;
-            return typeof r == "string" && (r = document.getElementById(r), lt(r)), r || (r = document.createElement("canvas"), r.id = t.id || "deckgl-overlay", (t.parent || document.body).appendChild(r)), Object.assign(r.style, t.style), r
+            return typeof r == "string" && (r = document.getElementById(r), Ht(r)), r || (r = document.createElement("canvas"), r.id = t.id || "deckgl-overlay", (t.parent || document.body).appendChild(r)), Object.assign(r.style, t.style), r
         }
         _setCanvasSize(t) {
             if (!this.canvas) return;
             let {
                 width: r,
                 height: i
             } = t;
             if (r || r === 0) {
-                let s = Number.isFinite(r) ? `${r}px` : r;
-                this.canvas.style.width = s
+                let n = Number.isFinite(r) ? `${r}px` : r;
+                this.canvas.style.width = n
             }
             if (i || i === 0) {
-                let s = Number.isFinite(i) ? `${i}px` : i;
-                this.canvas.style.position = t.style?.position || "absolute", this.canvas.style.height = s
+                let n = Number.isFinite(i) ? `${i}px` : i;
+                this.canvas.style.position = t.style?.position || "absolute", this.canvas.style.height = n
             }
         }
         _updateCanvasSize() {
             let {
                 canvas: t
             } = this;
             if (!t) return;
@@ -21782,34 +21782,34 @@
                 width: r,
                 height: i
             }))
         }
         _createAnimationLoop(t, r) {
             let {
                 gl: i,
-                onError: s,
-                useDevicePixels: n
+                onError: n,
+                useDevicePixels: s
             } = r;
-            return new ro({
+            return new ql({
                 device: t,
-                useDevicePixels: n,
+                useDevicePixels: s,
                 autoResizeDrawingBuffer: !i,
                 autoResizeViewport: !1,
                 onInitialize: o => this._setDevice(o.device),
                 onRender: this._onRenderFrame.bind(this),
-                onError: s
+                onError: n
             })
         }
         _getViewState() {
             return this.props.viewState || this.viewState || {}
         }
         _getViews() {
             let {
                 views: t
-            } = this.props, r = Array.isArray(t) ? t : t ? [t] : [new Is({
+            } = this.props, r = Array.isArray(t) ? t : t ? [t] : [new Ka({
                 id: "default-view"
             })];
             return r.length && this.props.controller && (r[0].props.controller = this.props.controller), r
         }
         _onContextLost() {
             let {
                 onError: t
@@ -21822,97 +21822,97 @@
             } = this;
             if (t.event) {
                 let {
                     result: r,
                     emptyInfo: i
                 } = this._pick("pickObject", "pickObject Time", t);
                 this.cursorState.isHovering = r.length > 0;
-                let s = i,
-                    n = !1;
-                for (let o of r) s = o, n = o.layer?.onHover(o, t.event) || n;
-                n || (this.props.onHover?.(s, t.event), this.widgetManager.onHover(s, t.event)), t.event = null
+                let n = i,
+                    s = !1;
+                for (let o of r) n = o, s = o.layer?.onHover(o, t.event) || s;
+                s || (this.props.onHover?.(n, t.event), this.widgetManager.onHover(n, t.event)), t.event = null
             }
         }
         _updateCursor() {
             let t = this.props.parent || this.canvas;
             t && (t.style.cursor = this.props.getCursor(this.cursorState))
         }
         _setDevice(t) {
             if (this.device = t, !this.animationLoop) return;
             this.canvas || (this.canvas = this.device.canvasContext?.canvas), this.device.setParametersWebGL({
                 blend: !0,
                 blendFunc: [770, 771, 1, 771],
                 polygonOffsetFill: !0,
                 depthTest: !0,
                 depthFunc: 515
-            }), this.props.onDeviceInitialized(this.device), this.device instanceof Vi && this.props.onWebGLInitialized(this.device.gl);
-            let r = new Ii;
-            r.play(), this.animationLoop.attachTimeline(r), this.eventManager = new Ls(this.props.parent || this.canvas, {
+            }), this.props.onDeviceInitialized(this.device), this.device instanceof Fo && this.props.onWebGLInitialized(this.device.gl);
+            let r = new Eo;
+            r.play(), this.animationLoop.attachTimeline(r), this.eventManager = new rc(this.props.parent || this.canvas, {
                 touchAction: this.props.touchAction,
                 recognizerOptions: this.props.eventRecognizerOptions,
                 events: {
                     pointerdown: this._onPointerDown,
                     pointermove: this._onPointerMove,
                     pointerleave: this._onPointerMove
                 }
             });
-            for (let s in Xn) this.eventManager.on(s, this._onEvent);
-            this.viewManager = new no({
+            for (let n in Ll) this.eventManager.on(n, this._onEvent);
+            this.viewManager = new Gl({
                 timeline: r,
                 eventManager: this.eventManager,
                 onViewStateChange: this._onViewStateChange.bind(this),
                 onInteractionStateChange: this._onInteractionStateChange.bind(this),
                 views: this._getViews(),
                 viewState: this._getViewState(),
                 width: this.width,
                 height: this.height
             });
             let i = this.viewManager.getViewports()[0];
-            this.layerManager = new Rs(this.device, {
+            this.layerManager = new Xa(this.device, {
                 deck: this,
                 stats: this.stats,
                 viewport: i,
                 timeline: r
-            }), this.effectManager = new ao({
+            }), this.effectManager = new Ql({
                 deck: this,
                 device: this.device
-            }), this.deckRenderer = new Os(this.device), this.deckPicker = new lo(this.device), this.widgetManager = new Xc({
+            }), this.deckRenderer = new Ga(this.device), this.deckPicker = new eu(this.device), this.widgetManager = new qd({
                 deck: this,
                 parentElement: this.canvas?.parentElement
-            }), this.widgetManager.addDefault(new ho), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad()
+            }), this.widgetManager.addDefault(new ru), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad()
         }
         _drawLayers(t, r) {
             let {
                 device: i,
-                gl: s
+                gl: n
             } = this.layerManager.context;
             this.props.onBeforeRender({
                 device: i,
-                gl: s
+                gl: n
             });
-            let n = {
+            let s = {
                 target: this.props._framebuffer,
                 layers: this.layerManager.getLayers(),
                 viewports: this.viewManager.getViewports(),
                 onViewportActive: this.layerManager.activateViewport,
                 views: this.viewManager.getViews(),
                 pass: "screen",
                 effects: this.effectManager.getEffects(),
                 ...r
             };
-            this.deckRenderer?.renderLayers(n), n.pass === "screen" && this.widgetManager.onRedraw({
-                viewports: n.viewports,
-                layers: n.layers
+            this.deckRenderer?.renderLayers(s), s.pass === "screen" && this.widgetManager.onRedraw({
+                viewports: s.viewports,
+                layers: s.layers
             }), this.props.onAfterRender({
                 device: i,
-                gl: s
+                gl: n
             })
         }
         _onRenderFrame() {
-            this._getFrameStats(), this._metricsCounter++ % 60 === 0 && (this._getMetrics(), this.stats.reset(), j.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.layerManager.updateLayers(), this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates()
+            this._getFrameStats(), this._metricsCounter++ % 60 === 0 && (this._getMetrics(), this.stats.reset(), Z.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.layerManager.updateLayers(), this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates()
         }
         _onViewStateChange(t) {
             let r = this.props.onViewStateChange(t) || t.viewState;
             this.viewState && (this.viewState = {
                 ...this.viewState,
                 [t.viewId]: r
             }, this.props.viewState || this.viewManager && this.viewManager.setProps({
@@ -21932,90 +21932,90 @@
         }
         _getMetrics() {
             let {
                 metrics: t,
                 stats: r
             } = this;
             t.fps = r.get("frameRate").getHz(), t.setPropsTime = r.get("setProps Time").time, t.updateAttributesTime = r.get("Update Attributes").time, t.framesRedrawn = r.get("Redraw Count").count, t.pickTime = r.get("pickObject Time").time + r.get("pickMultipleObjects Time").time + r.get("pickObjects Time").time, t.pickCount = r.get("Pick Count").count, t.gpuTime = r.get("GPU Time").time, t.cpuTime = r.get("CPU Time").time, t.gpuTimePerFrame = r.get("GPU Time").getAverageTime(), t.cpuTimePerFrame = r.get("CPU Time").getAverageTime();
-            let i = fe.stats.get("Memory Usage");
+            let i = Or.stats.get("Memory Usage");
             t.bufferMemory = i.get("Buffer Memory").count, t.textureMemory = i.get("Texture Memory").count, t.renderbufferMemory = i.get("Renderbuffer Memory").count, t.gpuMemory = i.get("GPU Memory").count
         }
     };
-ml.defaultProps = Fy, ml.VERSION = af;
-var ji = ml;
+bp.defaultProps = eE, bp.VERSION = K_;
+var ko = bp;
 
-function Dy(e) {
+function rE(e) {
     switch (e) {
         case "float64":
             return Float64Array;
         case "uint8":
         case "unorm8":
             return Uint8ClampedArray;
         default:
-            return Nn(e)
+            return Al(e)
     }
 }
-var ky = Ka;
+var iE = Qh;
 
-function vo(e, t) {
+function _u(e, t) {
     return {
         attribute: e,
         format: t.size > 1 ? `${t.type}x${t.size}` : t.type,
         byteOffset: t.offset || 0
     }
 }
 
-function ti(e) {
+function Bs(e) {
     return e.stride || e.size * e.bytesPerElement
 }
 
-function Ly(e, t) {
-    return e.type === t.type && e.size === t.size && ti(e) === ti(t) && (e.offset || 0) === (t.offset || 0)
+function nE(e, t) {
+    return e.type === t.type && e.size === t.size && Bs(e) === Bs(t) && (e.offset || 0) === (t.offset || 0)
 }
 
-function Bd(e, t) {
-    t.offset && j.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
-    let r = ti(e),
+function Ib(e, t) {
+    t.offset && Z.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
+    let r = Bs(e),
         i = t.vertexOffset !== void 0 ? t.vertexOffset : e.vertexOffset || 0,
-        s = t.elementOffset || 0,
-        n = i * r + s * e.bytesPerElement + (e.offset || 0);
+        n = t.elementOffset || 0,
+        s = i * r + n * e.bytesPerElement + (e.offset || 0);
     return {
         ...t,
-        offset: n,
+        offset: s,
         stride: r
     }
 }
 
-function DP(e, t) {
-    let r = Bd(e, t);
+function VL(e, t) {
+    let r = Ib(e, t);
     return {
         high: r,
         low: {
             ...r,
             offset: r.offset + e.size * 4
         }
     }
 }
-var Ro = class {
+var yu = class {
     constructor(t, r, i) {
         this._buffer = null, this.device = t, this.id = r.id || "", this.size = r.size || 1;
-        let s = r.logicalType || r.type,
-            n = s === "float64",
+        let n = r.logicalType || r.type,
+            s = n === "float64",
             {
                 defaultValue: o
             } = r;
         o = Number.isFinite(o) ? [o] : o || new Array(this.size).fill(0);
         let a;
-        n ? a = "float32" : !s && r.isIndexed ? a = "uint32" : a = s || "float32";
-        let c = Dy(s || a);
-        this.doublePrecision = n, n && r.fp64 === !1 && (c = Float32Array), this.value = null, this.settings = {
+        s ? a = "float32" : !n && r.isIndexed ? a = "uint32" : a = n || "float32";
+        let c = rE(n || a);
+        this.doublePrecision = s, s && r.fp64 === !1 && (c = Float32Array), this.value = null, this.settings = {
             ...r,
             defaultType: c,
             defaultValue: o,
-            logicalType: s,
+            logicalType: n,
             type: a,
             normalized: a.includes("norm"),
             size: this.size,
             bytesPerElement: c.BYTES_PER_ELEMENT
         }, this.state = {
             ...i,
             externalBuffer: null,
@@ -22030,66 +22030,66 @@
         return this.state.constant
     }
     get buffer() {
         return this._buffer
     }
     get byteOffset() {
         let t = this.getAccessor();
-        return t.vertexOffset ? t.vertexOffset * ti(t) : 0
+        return t.vertexOffset ? t.vertexOffset * Bs(t) : 0
     }
     get numInstances() {
         return this.state.numInstances
     }
     set numInstances(t) {
         this.state.numInstances = t
     }
     delete() {
-        this._buffer && (this._buffer.delete(), this._buffer = null), ve.release(this.state.allocatedValue)
+        this._buffer && (this._buffer.delete(), this._buffer = null), ri.release(this.state.allocatedValue)
     }
     getBuffer() {
         return this.state.constant ? null : this.state.externalBuffer || this._buffer
     }
     getValue(t = this.id, r = null) {
         let i = {};
         if (this.state.constant) {
-            let s = this.value;
+            let n = this.value;
             if (r) {
-                let n = Bd(this.getAccessor(), r),
-                    o = n.offset / s.BYTES_PER_ELEMENT,
-                    a = n.size || this.size;
-                i[t] = s.subarray(o, o + a)
-            } else i[t] = s
+                let s = Ib(this.getAccessor(), r),
+                    o = s.offset / n.BYTES_PER_ELEMENT,
+                    a = s.size || this.size;
+                i[t] = n.subarray(o, o + a)
+            } else i[t] = n
         } else i[t] = this.getBuffer();
         return this.doublePrecision && (this.value instanceof Float64Array ? i[`${t}64Low`] = i[t] : i[`${t}64Low`] = new Float32Array(this.size)), i
     }
     getBufferLayout(t = this.id, r = null) {
         let i = this.getAccessor(),
-            s = [],
-            n = {
+            n = [],
+            s = {
                 name: this.id,
-                byteStride: ti(i),
-                attributes: s
+                byteStride: Bs(i),
+                attributes: n
             };
         if (this.doublePrecision) {
-            let o = DP(i, r || {});
-            s.push(vo(t, {
+            let o = VL(i, r || {});
+            n.push(_u(t, {
                 ...i,
                 ...o.high
-            }), vo(`${t}64Low`, {
+            }), _u(`${t}64Low`, {
                 ...i,
                 ...o.low
             }))
         } else if (r) {
-            let o = Bd(i, r);
-            s.push(vo(t, {
+            let o = Ib(i, r);
+            n.push(_u(t, {
                 ...i,
                 ...o
             }))
-        } else s.push(vo(t, i));
-        return n
+        } else n.push(_u(t, i));
+        return s
     }
     setAccessor(t) {
         this.state.bufferAccessor = t
     }
     getAccessor() {
         return this.state.bufferAccessor
     }
@@ -22099,111 +22099,111 @@
         if (this.state.constant && this.value) {
             let r = Array.from(this.value);
             t = [r, r]
         } else {
             let {
                 value: r,
                 numInstances: i,
-                size: s
-            } = this, n = i * s;
-            if (r && n && r.length >= n) {
-                let o = new Array(s).fill(1 / 0),
-                    a = new Array(s).fill(-1 / 0);
-                for (let c = 0; c < n;)
-                    for (let l = 0; l < s; l++) {
-                        let h = r[c++];
-                        h < o[l] && (o[l] = h), h > a[l] && (a[l] = h)
+                size: n
+            } = this, s = i * n;
+            if (r && s && r.length >= s) {
+                let o = new Array(n).fill(1 / 0),
+                    a = new Array(n).fill(-1 / 0);
+                for (let c = 0; c < s;)
+                    for (let l = 0; l < n; l++) {
+                        let u = r[c++];
+                        u < o[l] && (o[l] = u), u > a[l] && (a[l] = u)
                     }
                 t = [o, a]
             }
         }
         return this.state.bounds = t, t
     }
     setData(t) {
         let {
             state: r
         } = this, i;
         ArrayBuffer.isView(t) ? i = {
             value: t
-        } : t instanceof it ? i = {
+        } : t instanceof Mt ? i = {
             buffer: t
         } : i = t;
-        let s = {
+        let n = {
             ...this.settings,
             ...i
         };
         if (ArrayBuffer.isView(i.value)) {
             if (!i.type)
-                if (this.doublePrecision && i.value instanceof Float64Array) s.type = "float32";
+                if (this.doublePrecision && i.value instanceof Float64Array) n.type = "float32";
                 else {
-                    let o = ky(i.value);
-                    s.type = s.normalized ? o.replace("int", "norm") : o
-                } s.bytesPerElement = i.value.BYTES_PER_ELEMENT, s.stride = ti(s)
+                    let o = iE(i.value);
+                    n.type = n.normalized ? o.replace("int", "norm") : o
+                } n.bytesPerElement = i.value.BYTES_PER_ELEMENT, n.stride = Bs(n)
         }
         if (r.bounds = null, i.constant) {
-            let n = i.value;
-            if (n = this._normalizeValue(n, [], 0), this.settings.normalized && (n = this.normalizeConstant(n)), !(!r.constant || !this._areValuesEqual(n, this.value))) return !1;
-            r.externalBuffer = null, r.constant = !0, this.value = ArrayBuffer.isView(n) ? n : new Float32Array(n)
+            let s = i.value;
+            if (s = this._normalizeValue(s, [], 0), this.settings.normalized && (s = this.normalizeConstant(s)), !(!r.constant || !this._areValuesEqual(s, this.value))) return !1;
+            r.externalBuffer = null, r.constant = !0, this.value = ArrayBuffer.isView(s) ? s : new Float32Array(s)
         } else if (i.buffer) {
-            let n = i.buffer;
-            r.externalBuffer = n, r.constant = !1, this.value = i.value || null
+            let s = i.buffer;
+            r.externalBuffer = s, r.constant = !1, this.value = i.value || null
         } else if (i.value) {
             this._checkExternalBuffer(i);
-            let n = i.value;
-            r.externalBuffer = null, r.constant = !1, this.value = n;
+            let s = i.value;
+            r.externalBuffer = null, r.constant = !1, this.value = s;
             let {
                 buffer: o
-            } = this, a = ti(s), c = (s.vertexOffset || 0) * a;
-            if (this.doublePrecision && n instanceof Float64Array && (n = Nc(n, s)), this.settings.isIndexed) {
-                let h = this.settings.defaultType;
-                n.constructor !== h && (n = new h(n))
+            } = this, a = Bs(n), c = (n.vertexOffset || 0) * a;
+            if (this.doublePrecision && s instanceof Float64Array && (s = Dd(s, n)), this.settings.isIndexed) {
+                let u = this.settings.defaultType;
+                s.constructor !== u && (s = new u(s))
             }
-            let l = n.byteLength + c + a * 2;
-            (!o || o.byteLength < l) && (o = this._createBuffer(l)), o.write(n, c)
+            let l = s.byteLength + c + a * 2;
+            (!o || o.byteLength < l) && (o = this._createBuffer(l)), o.write(s, c)
         }
-        return this.setAccessor(s), !0
+        return this.setAccessor(n), !0
     }
     updateSubBuffer(t = {}) {
         this.state.bounds = null;
         let r = this.value,
             {
                 startOffset: i = 0,
-                endOffset: s
+                endOffset: n
             } = t;
-        this.buffer.write(this.doublePrecision && r instanceof Float64Array ? Nc(r, {
+        this.buffer.write(this.doublePrecision && r instanceof Float64Array ? Dd(r, {
             size: this.size,
             startIndex: i,
-            endIndex: s
-        }) : r.subarray(i, s), i * r.BYTES_PER_ELEMENT + this.byteOffset)
+            endIndex: n
+        }) : r.subarray(i, n), i * r.BYTES_PER_ELEMENT + this.byteOffset)
     }
     allocate(t, r = !1) {
         let {
             state: i
-        } = this, s = i.allocatedValue, n = ve.allocate(s, t + 1, {
+        } = this, n = i.allocatedValue, s = ri.allocate(n, t + 1, {
             size: this.size,
             type: this.settings.defaultType,
             copy: r
         });
-        this.value = n;
+        this.value = s;
         let {
             byteOffset: o
         } = this, {
             buffer: a
         } = this;
-        return (!a || a.byteLength < n.byteLength + o) && (a = this._createBuffer(n.byteLength + o), r && s && a.write(s instanceof Float64Array ? Nc(s, this) : s, o)), i.allocatedValue = n, i.constant = !1, i.externalBuffer = null, this.setAccessor(this.settings), !0
+        return (!a || a.byteLength < s.byteLength + o) && (a = this._createBuffer(s.byteLength + o), r && n && a.write(n instanceof Float64Array ? Dd(n, this) : n, o)), i.allocatedValue = s, i.constant = !1, i.externalBuffer = null, this.setAccessor(this.settings), !0
     }
     _checkExternalBuffer(t) {
         let {
             value: r
         } = t;
         if (!ArrayBuffer.isView(r)) throw new Error(`Attribute ${this.id} value is not TypedArray`);
         let i = this.settings.defaultType,
-            s = !1;
-        if (this.doublePrecision && (s = r.BYTES_PER_ELEMENT < 4), s) throw new Error(`Attribute ${this.id} does not support ${r.constructor.name}`);
-        !(r instanceof i) && this.settings.normalized && !("normalized" in t) && j.warn(`Attribute ${this.id} is normalized`)()
+            n = !1;
+        if (this.doublePrecision && (n = r.BYTES_PER_ELEMENT < 4), n) throw new Error(`Attribute ${this.id} does not support ${r.constructor.name}`);
+        !(r instanceof i) && this.settings.normalized && !("normalized" in t) && Z.warn(`Attribute ${this.id} is normalized`)()
     }
     normalizeConstant(t) {
         switch (this.settings.type) {
             case "snorm8":
                 return new Float32Array(t).map(r => (r + 128) / 255 * 2 - 1);
             case "snorm16":
                 return new Float32Array(t).map(r => (r + 32768) / 65535 * 2 - 1);
@@ -22213,175 +22213,175 @@
                 return new Float32Array(t).map(r => r / 65535);
             default:
                 return t
         }
     }
     _normalizeValue(t, r, i) {
         let {
-            defaultValue: s,
-            size: n
+            defaultValue: n,
+            size: s
         } = this.settings;
         if (Number.isFinite(t)) return r[i] = t, r;
         if (!t) {
-            let o = n;
-            for (; --o >= 0;) r[i + o] = s[o];
+            let o = s;
+            for (; --o >= 0;) r[i + o] = n[o];
             return r
         }
-        switch (n) {
+        switch (s) {
             case 4:
-                r[i + 3] = Number.isFinite(t[3]) ? t[3] : s[3];
+                r[i + 3] = Number.isFinite(t[3]) ? t[3] : n[3];
             case 3:
-                r[i + 2] = Number.isFinite(t[2]) ? t[2] : s[2];
+                r[i + 2] = Number.isFinite(t[2]) ? t[2] : n[2];
             case 2:
-                r[i + 1] = Number.isFinite(t[1]) ? t[1] : s[1];
+                r[i + 1] = Number.isFinite(t[1]) ? t[1] : n[1];
             case 1:
-                r[i + 0] = Number.isFinite(t[0]) ? t[0] : s[0];
+                r[i + 0] = Number.isFinite(t[0]) ? t[0] : n[0];
                 break;
             default:
-                let o = n;
-                for (; --o >= 0;) r[i + o] = Number.isFinite(t[o]) ? t[o] : s[o]
+                let o = s;
+                for (; --o >= 0;) r[i + o] = Number.isFinite(t[o]) ? t[o] : n[o]
         }
         return r
     }
     _areValuesEqual(t, r) {
         if (!t || !r) return !1;
         let {
             size: i
         } = this;
-        for (let s = 0; s < i; s++)
-            if (t[s] !== r[s]) return !1;
+        for (let n = 0; n < i; n++)
+            if (t[n] !== r[n]) return !1;
         return !0
     }
     _createBuffer(t) {
         this._buffer && this._buffer.destroy();
         let {
             isIndexed: r,
             type: i
         } = this.settings;
         return this._buffer = this.device.createBuffer({
             ...this._buffer?.props,
             id: this.id,
-            usage: r ? it.INDEX : it.VERTEX,
+            usage: r ? Mt.INDEX : Mt.VERTEX,
             indexType: r ? i : void 0,
             byteLength: t
         }), this._buffer
     }
 };
-var By = [],
-    Uy = [];
+var sE = [],
+    oE = [];
 
-function tr(e, t = 0, r = 1 / 0) {
-    let i = By,
-        s = {
+function Zi(e, t = 0, r = 1 / 0) {
+    let i = sE,
+        n = {
             index: -1,
             data: e,
             target: []
         };
-    return e ? typeof e[Symbol.iterator] == "function" ? i = e : e.length > 0 && (Uy.length = e.length, i = Uy) : i = By, (t > 0 || Number.isFinite(r)) && (i = (Array.isArray(i) ? i : Array.from(i)).slice(t, r), s.index = t - 1), {
+    return e ? typeof e[Symbol.iterator] == "function" ? i = e : e.length > 0 && (oE.length = e.length, i = oE) : i = sE, (t > 0 || Number.isFinite(r)) && (i = (Array.isArray(i) ? i : Array.from(i)).slice(t, r), n.index = t - 1), {
         iterable: i,
-        objectInfo: s
+        objectInfo: n
     }
 }
 
-function _l(e) {
+function xp(e) {
     return e && e[Symbol.asyncIterator]
 }
 
-function yl(e, t) {
+function wp(e, t) {
     let {
         size: r,
         stride: i,
-        offset: s,
-        startIndices: n,
+        offset: n,
+        startIndices: s,
         nested: o
-    } = t, a = e.BYTES_PER_ELEMENT, c = i ? i / a : r, l = s ? s / a : 0, h = Math.floor((e.length - l) / c);
+    } = t, a = e.BYTES_PER_ELEMENT, c = i ? i / a : r, l = n ? n / a : 0, u = Math.floor((e.length - l) / c);
     return (f, {
-        index: u,
+        index: h,
         target: d
     }) => {
-        if (!n) {
-            let A = u * c + l;
-            for (let v = 0; v < r; v++) d[v] = e[A + v];
+        if (!s) {
+            let T = h * c + l;
+            for (let I = 0; I < r; I++) d[I] = e[T + I];
             return d
         }
-        let m = n[u],
-            y = n[u + 1] || h,
-            x;
+        let p = s[h],
+            y = s[h + 1] || u,
+            b;
         if (o) {
-            x = new Array(y - m);
-            for (let A = m; A < y; A++) {
-                let v = A * c + l;
+            b = new Array(y - p);
+            for (let T = p; T < y; T++) {
+                let I = T * c + l;
                 d = new Array(r);
-                for (let E = 0; E < r; E++) d[E] = e[v + E];
-                x[A - m] = d
+                for (let S = 0; S < r; S++) d[S] = e[I + S];
+                b[T - p] = d
             }
-        } else if (c === r) x = e.subarray(m * r + l, y * r + l);
+        } else if (c === r) b = e.subarray(p * r + l, y * r + l);
         else {
-            x = new e.constructor((y - m) * r);
-            let A = 0;
-            for (let v = m; v < y; v++) {
-                let E = v * c + l;
-                for (let R = 0; R < r; R++) x[A++] = e[E + R]
+            b = new e.constructor((y - p) * r);
+            let T = 0;
+            for (let I = p; I < y; I++) {
+                let S = I * c + l;
+                for (let R = 0; R < r; R++) b[T++] = e[S + R]
             }
         }
-        return x
+        return b
     }
 }
-var Vy = [],
-    Po = [
+var aE = [],
+    bu = [
         [0, 1 / 0]
     ];
 
-function zy(e, t) {
-    if (e === Po || (t[0] < 0 && (t[0] = 0), t[0] >= t[1])) return e;
+function cE(e, t) {
+    if (e === bu || (t[0] < 0 && (t[0] = 0), t[0] >= t[1])) return e;
     let r = [],
         i = e.length,
-        s = 0;
-    for (let n = 0; n < i; n++) {
-        let o = e[n];
-        o[1] < t[0] ? (r.push(o), s = n + 1) : o[0] > t[1] ? r.push(o) : t = [Math.min(o[0], t[0]), Math.max(o[1], t[1])]
+        n = 0;
+    for (let s = 0; s < i; s++) {
+        let o = e[s];
+        o[1] < t[0] ? (r.push(o), n = s + 1) : o[0] > t[1] ? r.push(o) : t = [Math.min(o[0], t[0]), Math.max(o[1], t[1])]
     }
-    return r.splice(s, 0, t), r
+    return r.splice(n, 0, t), r
 }
-var LP = {
+var WL = {
     interpolation: {
         duration: 0,
         easing: e => e
     },
     spring: {
         stiffness: .05,
         damping: .5
     }
 };
 
-function xl(e, t) {
+function Tp(e, t) {
     if (!e) return null;
     Number.isFinite(e) && (e = {
         type: "interpolation",
         duration: e
     });
     let r = e.type || "interpolation";
     return {
-        ...LP[r],
+        ...WL[r],
         ...t,
         ...e,
         type: r
     }
 }
-var ei = class extends Ro {
+var Fs = class extends yu {
     constructor(t, r) {
         super(t, r, {
             startIndices: null,
             lastExternalBuffer: null,
             binaryValue: null,
             binaryAccessor: null,
             needsUpdate: !0,
             needsRedraw: !1,
             layoutChanged: !1,
-            updateRanges: Po
+            updateRanges: bu
         }), this.constant = !1, this.settings.update = r.update || (r.accessor ? this._autoUpdater : void 0), Object.seal(this.settings), Object.seal(this.state), this._validateAttributeUpdaters()
     }
     get startIndices() {
         return this.state.startIndices
     }
     set startIndices(t) {
         this.state.startIndices = t
@@ -22396,90 +22396,90 @@
         return this.state.needsRedraw = r && !t, r
     }
     layoutChanged() {
         return this.state.layoutChanged
     }
     setAccessor(t) {
         var r;
-        (r = this.state).layoutChanged || (r.layoutChanged = !Ly(t, this.getAccessor())), super.setAccessor(t)
+        (r = this.state).layoutChanged || (r.layoutChanged = !nE(t, this.getAccessor())), super.setAccessor(t)
     }
     getUpdateTriggers() {
         let {
             accessor: t
         } = this.settings;
         return [this.id].concat(typeof t != "function" && t || [])
     }
     supportsTransition() {
         return !!this.settings.transition
     }
     getTransitionSetting(t) {
         if (!t || !this.supportsTransition()) return null;
         let {
             accessor: r
-        } = this.settings, i = this.settings.transition, s = Array.isArray(r) ? t[r.find(n => t[n])] : t[r];
-        return xl(s, i)
+        } = this.settings, i = this.settings.transition, n = Array.isArray(r) ? t[r.find(s => t[s])] : t[r];
+        return Tp(n, i)
     }
     setNeedsUpdate(t = this.id, r) {
         if (this.state.needsUpdate = this.state.needsUpdate || t, this.setNeedsRedraw(t), r) {
             let {
                 startRow: i = 0,
-                endRow: s = 1 / 0
+                endRow: n = 1 / 0
             } = r;
-            this.state.updateRanges = zy(this.state.updateRanges, [i, s])
-        } else this.state.updateRanges = Po
+            this.state.updateRanges = cE(this.state.updateRanges, [i, n])
+        } else this.state.updateRanges = bu
     }
     clearNeedsUpdate() {
-        this.state.needsUpdate = !1, this.state.updateRanges = Vy
+        this.state.needsUpdate = !1, this.state.updateRanges = aE
     }
     setNeedsRedraw(t = this.id) {
         this.state.needsRedraw = this.state.needsRedraw || t
     }
     allocate(t) {
         let {
             state: r,
             settings: i
         } = this;
-        return i.noAlloc ? !1 : i.update ? (super.allocate(t, r.updateRanges !== Po), !0) : !1
+        return i.noAlloc ? !1 : i.update ? (super.allocate(t, r.updateRanges !== bu), !0) : !1
     }
     updateBuffer({
         numInstances: t,
         data: r,
         props: i,
-        context: s
+        context: n
     }) {
         if (!this.needsUpdate()) return !1;
         let {
             state: {
-                updateRanges: n
+                updateRanges: s
             },
             settings: {
                 update: o,
                 noAlloc: a
             }
         } = this, c = !0;
         if (o) {
-            for (let [l, h] of n) o.call(s, this, {
+            for (let [l, u] of s) o.call(n, this, {
                 data: r,
                 startRow: l,
-                endRow: h,
+                endRow: u,
                 props: i,
                 numInstances: t
             });
             if (this.value)
                 if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset) this.setData({
                     value: this.value,
                     constant: this.constant
                 }), this.constant = !1;
                 else
-                    for (let [l, h] of n) {
+                    for (let [l, u] of s) {
                         let f = Number.isFinite(l) ? this.getVertexOffset(l) : 0,
-                            u = Number.isFinite(h) ? this.getVertexOffset(h) : a || !Number.isFinite(t) ? this.value.length : t * this.size;
+                            h = Number.isFinite(u) ? this.getVertexOffset(u) : a || !Number.isFinite(t) ? this.value.length : t * this.size;
                         super.updateSubBuffer({
                             startOffset: f,
-                            endOffset: u
+                            endOffset: h
                         })
                     }
             this._checkAttributeArray()
         } else c = !1;
         return this.clearNeedsUpdate(), this.setNeedsRedraw(), c
     }
     setConstantValue(t) {
@@ -22493,27 +22493,27 @@
             state: r
         } = this;
         return t ? (this.clearNeedsUpdate(), r.lastExternalBuffer === t || (r.lastExternalBuffer = t, this.setNeedsRedraw(), this.setData(t)), !0) : (r.lastExternalBuffer = null, !1)
     }
     setBinaryValue(t, r = null) {
         let {
             state: i,
-            settings: s
+            settings: n
         } = this;
         if (!t) return i.binaryValue = null, i.binaryAccessor = null, !1;
-        if (s.noAlloc) return !1;
+        if (n.noAlloc) return !1;
         if (i.binaryValue === t) return this.clearNeedsUpdate(), !0;
-        if (i.binaryValue = t, this.setNeedsRedraw(), s.transform || r !== this.startIndices) {
+        if (i.binaryValue = t, this.setNeedsRedraw(), n.transform || r !== this.startIndices) {
             ArrayBuffer.isView(t) && (t = {
                 value: t
             });
             let o = t;
-            lt(ArrayBuffer.isView(o.value), `invalid ${s.accessor}`);
+            Ht(ArrayBuffer.isView(o.value), `invalid ${n.accessor}`);
             let a = !!o.size && o.size !== this.size;
-            return i.binaryAccessor = yl(o.value, {
+            return i.binaryAccessor = wp(o.value, {
                 size: o.size || this.size,
                 stride: o.stride,
                 offset: o.offset,
                 startIndices: r,
                 nested: a
             }), !1
         }
@@ -22534,59 +22534,59 @@
     }
     getBufferLayout() {
         this.state.layoutChanged = !1;
         let t = this.settings.shaderAttributes,
             r = super.getBufferLayout();
         if (!t) return r;
         for (let i in t) {
-            let s = super.getBufferLayout(i, t[i]);
-            r.attributes.push(...s.attributes)
+            let n = super.getBufferLayout(i, t[i]);
+            r.attributes.push(...n.attributes)
         }
         return r
     }
     _autoUpdater(t, {
         data: r,
         startRow: i,
-        endRow: s,
-        props: n,
+        endRow: n,
+        props: s,
         numInstances: o
     }) {
         if (t.constant) return;
         let {
             settings: a,
             state: c,
             value: l,
-            size: h,
+            size: u,
             startIndices: f
         } = t, {
-            accessor: u,
+            accessor: h,
             transform: d
-        } = a, m = c.binaryAccessor || (typeof u == "function" ? u : n[u]);
-        lt(typeof m == "function", `accessor "${u}" is not a function`);
+        } = a, p = c.binaryAccessor || (typeof h == "function" ? h : s[h]);
+        Ht(typeof p == "function", `accessor "${h}" is not a function`);
         let y = t.getVertexOffset(i),
             {
-                iterable: x,
-                objectInfo: A
-            } = tr(r, i, s);
-        for (let v of x) {
-            A.index++;
-            let E = m(v, A);
-            if (d && (E = d.call(this, E)), f) {
-                let R = (A.index < f.length - 1 ? f[A.index + 1] : o) - f[A.index];
-                if (E && Array.isArray(E[0])) {
-                    let M = y;
-                    for (let C of E) t._normalizeValue(C, l, M), M += h
-                } else E && E.length > h ? l.set(E, y) : (t._normalizeValue(E, A.target, 0), dd({
+                iterable: b,
+                objectInfo: T
+            } = Zi(r, i, n);
+        for (let I of b) {
+            T.index++;
+            let S = p(I, T);
+            if (d && (S = d.call(this, S)), f) {
+                let R = (T.index < f.length - 1 ? f[T.index + 1] : o) - f[T.index];
+                if (S && Array.isArray(S[0])) {
+                    let P = y;
+                    for (let C of S) t._normalizeValue(C, l, P), P += u
+                } else S && S.length > u ? l.set(S, y) : (t._normalizeValue(S, T.target, 0), rb({
                     target: l,
-                    source: A.target,
+                    source: T.target,
                     start: y,
                     count: R
                 }));
-                y += R * h
-            } else t._normalizeValue(E, l, y), y += h
+                y += R * u
+            } else t._normalizeValue(S, l, y), y += u
         }
     }
     _validateAttributeUpdaters() {
         let {
             settings: t
         } = this;
         if (!(t.noAlloc || typeof t.update == "function")) throw new Error(`Attribute ${this.id} missing update or accessor`)
@@ -22611,195 +22611,195 @@
                     i = !1
             }
             if (!i) throw new Error(`Illegal attribute generated for ${this.id}`)
         }
     }
 };
 
-function Ud(e) {
+function Rb(e) {
     let {
         source: t,
         target: r,
         start: i = 0,
-        size: s,
-        getData: n
+        size: n,
+        getData: s
     } = e, o = e.end || r.length, a = t.length, c = o - i;
     if (a > c) {
         r.set(t.subarray(0, c), i);
         return
     }
-    if (r.set(t, i), !n) return;
+    if (r.set(t, i), !s) return;
     let l = a;
     for (; l < c;) {
-        let h = n(l, t);
-        for (let f = 0; f < s; f++) r[i + l] = h[f] || 0, l++
+        let u = s(l, t);
+        for (let f = 0; f < n; f++) r[i + l] = u[f] || 0, l++
     }
 }
 
-function Wy({
+function lE({
     source: e,
     target: t,
     size: r,
     getData: i,
-    sourceStartIndices: s,
-    targetStartIndices: n
+    sourceStartIndices: n,
+    targetStartIndices: s
 }) {
-    if (!s || !n) return Ud({
+    if (!n || !s) return Rb({
         source: e,
         target: t,
         size: r,
         getData: i
     }), t;
     let o = 0,
         a = 0,
-        c = i && ((h, f) => i(h + a, f)),
-        l = Math.min(s.length, n.length);
-    for (let h = 1; h < l; h++) {
-        let f = s[h] * r,
-            u = n[h] * r;
-        Ud({
+        c = i && ((u, f) => i(u + a, f)),
+        l = Math.min(n.length, s.length);
+    for (let u = 1; u < l; u++) {
+        let f = n[u] * r,
+            h = s[u] * r;
+        Rb({
             source: e.subarray(o, f),
             target: t,
             start: a,
-            end: u,
+            end: h,
             size: r,
             getData: c
-        }), o = f, a = u
+        }), o = f, a = h
     }
-    return a < t.length && Ud({
+    return a < t.length && Rb({
         source: [],
         target: t,
         start: a,
         size: r,
         getData: c
     }), t
 }
 
-function jy(e) {
+function uE(e) {
     let {
         device: t,
         settings: r,
         value: i
-    } = e, s = new ei(t, r);
-    return s.setData({
+    } = e, n = new Fs(t, r);
+    return n.setData({
         value: i instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
         normalized: r.normalized
-    }), s
+    }), n
 }
 
-function Tl(e) {
+function vp(e) {
     switch (e) {
         case 1:
             return "float";
         case 2:
             return "vec2";
         case 3:
             return "vec3";
         case 4:
             return "vec4";
         default:
             throw new Error(`No defined attribute type for size "${e}"`)
     }
 }
 
-function bl(e) {
+function Sp(e) {
     switch (e) {
         case 1:
             return "float32";
         case 2:
             return "float32x2";
         case 3:
             return "float32x3";
         case 4:
             return "float32x4";
         default:
             throw new Error("invalid type size")
     }
 }
 
-function Al(e) {
+function Ap(e) {
     e.push(e.shift())
 }
 
-function Hy(e, t) {
+function fE(e, t) {
     let {
         doublePrecision: r,
         settings: i,
-        value: s,
-        size: n
-    } = e, o = r && s instanceof Float64Array ? 2 : 1, a = 0, {
+        value: n,
+        size: s
+    } = e, o = r && n instanceof Float64Array ? 2 : 1, a = 0, {
         shaderAttributes: c
     } = e.settings;
     if (c)
         for (let l of Object.values(c)) a = Math.max(a, l.vertexOffset ?? 0);
-    return (i.noAlloc ? s.length : (t + a) * n) * o
+    return (i.noAlloc ? n.length : (t + a) * s) * o
 }
 
-function El({
+function Ep({
     device: e,
     source: t,
     target: r
 }) {
     return (!r || r.byteLength < t.byteLength) && (r?.destroy(), r = e.createBuffer({
         byteLength: t.byteLength,
         usage: t.usage
     })), r
 }
 
-function Sl({
+function Ip({
     device: e,
     buffer: t,
     attribute: r,
     fromLength: i,
-    toLength: s,
-    fromStartIndices: n,
+    toLength: n,
+    fromStartIndices: s,
     getData: o = a => a
 }) {
     let a = r.doublePrecision && r.value instanceof Float64Array ? 2 : 1,
         c = r.size * a,
         l = r.byteOffset,
-        h = r.settings.bytesPerElement < 4 ? l / r.settings.bytesPerElement * 4 : l,
+        u = r.settings.bytesPerElement < 4 ? l / r.settings.bytesPerElement * 4 : l,
         f = r.startIndices,
-        u = n && f,
+        h = s && f,
         d = r.isConstant;
-    if (!u && t && i >= s) return t;
-    let m = r.value instanceof Float64Array ? Float32Array : r.value.constructor,
-        y = d ? r.value : new m(r.getBuffer().readSyncWebGL(l, s * m.BYTES_PER_ELEMENT).buffer);
+    if (!h && t && i >= n) return t;
+    let p = r.value instanceof Float64Array ? Float32Array : r.value.constructor,
+        y = d ? r.value : new p(r.getBuffer().readSyncWebGL(l, n * p.BYTES_PER_ELEMENT).buffer);
     if (r.settings.normalized && !d) {
-        let E = o;
-        o = (R, M) => r.normalizeConstant(E(R, M))
+        let S = o;
+        o = (R, P) => r.normalizeConstant(S(R, P))
     }
-    let x = d ? (E, R) => o(y, R) : (E, R) => o(y.subarray(E + l, E + l + c), R),
-        A = t ? new Float32Array(t.readSyncWebGL(h, i * 4).buffer) : new Float32Array(0),
-        v = new Float32Array(s);
-    return Wy({
-        source: A,
-        target: v,
-        sourceStartIndices: n,
+    let b = d ? (S, R) => o(y, R) : (S, R) => o(y.subarray(S + l, S + l + c), R),
+        T = t ? new Float32Array(t.readSyncWebGL(u, i * 4).buffer) : new Float32Array(0),
+        I = new Float32Array(n);
+    return lE({
+        source: T,
+        target: I,
+        sourceStartIndices: s,
         targetStartIndices: f,
         size: c,
-        getData: x
-    }), (!t || t.byteLength < v.byteLength + h) && (t?.destroy(), t = e.createBuffer({
-        byteLength: v.byteLength + h,
+        getData: b
+    }), (!t || t.byteLength < I.byteLength + u) && (t?.destroy(), t = e.createBuffer({
+        byteLength: I.byteLength + u,
         usage: 35050
-    })), t.write(v, h), t
+    })), t.write(I, u), t
 }
-var Bs = class {
+var ic = class {
     constructor({
         device: t,
         attribute: r,
         timeline: i
     }) {
-        this.buffers = [], this.currentLength = 0, this.device = t, this.transition = new Pe(i), this.attribute = r, this.attributeInTransition = jy(r), this.currentStartIndices = r.startIndices
+        this.buffers = [], this.currentLength = 0, this.device = t, this.transition = new ni(i), this.attribute = r, this.attributeInTransition = uE(r), this.currentStartIndices = r.startIndices
     }
     get inProgress() {
         return this.transition.inProgress
     }
     start(t, r, i = 1 / 0) {
-        this.settings = t, this.currentStartIndices = this.attribute.startIndices, this.currentLength = Hy(this.attribute, r), this.transition.start({
+        this.settings = t, this.currentStartIndices = this.attribute.startIndices, this.currentLength = fE(this.attribute, r), this.transition.start({
             ...t,
             duration: i
         })
     }
     update() {
         let t = this.transition.update();
         return t && this.onUpdate(), t
@@ -22816,188 +22816,188 @@
     }
     delete() {
         this.cancel();
         for (let t of this.buffers) t.destroy();
         this.buffers.length = 0
     }
 };
-var Mo = class extends Bs {
+var xu = class extends ic {
         constructor({
             device: t,
             attribute: r,
             timeline: i
         }) {
             super({
                 device: t,
                 attribute: r,
                 timeline: i
-            }), this.type = "interpolation", this.transform = UP(t, r)
+            }), this.type = "interpolation", this.transform = HL(t, r)
         }
         start(t, r) {
             let i = this.currentLength,
-                s = this.currentStartIndices;
+                n = this.currentStartIndices;
             if (super.start(t, r, t.duration), t.duration <= 0) {
                 this.transition.cancel();
                 return
             }
             let {
-                buffers: n,
+                buffers: s,
                 attribute: o
             } = this;
-            Al(n), n[0] = Sl({
+            Ap(s), s[0] = Ip({
                 device: this.device,
-                buffer: n[0],
+                buffer: s[0],
                 attribute: o,
                 fromLength: i,
                 toLength: this.currentLength,
-                fromStartIndices: s,
+                fromStartIndices: n,
                 getData: t.enter
-            }), n[1] = El({
+            }), s[1] = Ep({
                 device: this.device,
-                source: n[0],
-                target: n[1]
-            }), this.setBuffer(n[1]);
+                source: s[0],
+                target: s[1]
+            }), this.setBuffer(s[1]);
             let {
                 transform: a
             } = this, c = a.model;
             c.setVertexCount(Math.floor(this.currentLength / o.size)), o.isConstant ? (c.setAttributes({
-                aFrom: n[0]
+                aFrom: s[0]
             }), c.setConstantAttributes({
                 aTo: o.value
             })) : c.setAttributes({
-                aFrom: n[0],
+                aFrom: s[0],
                 aTo: o.getBuffer()
             }), a.transformFeedback.setBuffers({
-                vCurrent: n[1]
+                vCurrent: s[1]
             })
         }
         onUpdate() {
             let {
                 duration: t,
                 easing: r
             } = this.settings, {
                 time: i
-            } = this.transition, s = i / t;
-            r && (s = r(s));
+            } = this.transition, n = i / t;
+            r && (n = r(n));
             let {
-                model: n
+                model: s
             } = this.transform;
-            n.setUniforms({
-                time: s
-            }), n.device.gl.bindBuffer(34962, null), this.transform.run({
+            s.setUniforms({
+                time: n
+            }), s.device.gl.bindBuffer(34962, null), this.transform.run({
                 discard: !0
             })
         }
         delete() {
             super.delete(), this.transform.destroy()
         }
     },
-    BP = `#version 300 es
+    jL = `#version 300 es
 #define SHADER_NAME interpolation-transition-vertex-shader
 
 uniform float time;
 in ATTRIBUTE_TYPE aFrom;
 in ATTRIBUTE_TYPE aTo;
 out ATTRIBUTE_TYPE vCurrent;
 
 void main(void) {
   vCurrent = mix(aFrom, aTo, time);
   gl_Position = vec4(0.0);
 }
 `;
 
-function UP(e, t) {
-    let r = Tl(t.size);
-    return new Oi(e, {
-        vs: BP,
+function HL(e, t) {
+    let r = vp(t.size);
+    return new Io(e, {
+        vs: jL,
         bufferLayout: [{
             name: "aFrom",
-            format: bl(t.size)
+            format: Sp(t.size)
         }, {
             name: "aTo",
             format: t.getBufferLayout().attributes[0].format
         }],
         defines: {
             ATTRIBUTE_TYPE: r
         },
         varyings: ["vCurrent"]
     })
 }
-var Co = class extends Bs {
+var wu = class extends ic {
         constructor({
             device: t,
             attribute: r,
             timeline: i
         }) {
             super({
                 device: t,
                 attribute: r,
                 timeline: i
-            }), this.type = "spring", this.texture = jP(t), this.framebuffer = HP(t, this.texture), this.transform = WP(t, r)
+            }), this.type = "spring", this.texture = qL(t), this.framebuffer = ZL(t, this.texture), this.transform = YL(t, r)
         }
         start(t, r) {
             let i = this.currentLength,
-                s = this.currentStartIndices;
+                n = this.currentStartIndices;
             super.start(t, r);
             let {
-                buffers: n,
+                buffers: s,
                 attribute: o
             } = this;
-            for (let c = 0; c < 2; c++) n[c] = Sl({
+            for (let c = 0; c < 2; c++) s[c] = Ip({
                 device: this.device,
-                buffer: n[c],
+                buffer: s[c],
                 attribute: o,
                 fromLength: i,
                 toLength: this.currentLength,
-                fromStartIndices: s,
+                fromStartIndices: n,
                 getData: t.enter
             });
-            n[2] = El({
+            s[2] = Ep({
                 device: this.device,
-                source: n[0],
-                target: n[2]
-            }), this.setBuffer(n[1]);
+                source: s[0],
+                target: s[2]
+            }), this.setBuffer(s[1]);
             let {
                 model: a
             } = this.transform;
             a.setVertexCount(Math.floor(this.currentLength / o.size)), o.isConstant ? a.setConstantAttributes({
                 aTo: o.value
             }) : a.setAttributes({
                 aTo: o.getBuffer()
             })
         }
         onUpdate() {
             let {
                 buffers: t,
                 transform: r,
                 framebuffer: i,
-                transition: s
-            } = this, n = this.settings;
+                transition: n
+            } = this, s = this.settings;
             r.model.setAttributes({
                 aPrev: t[0],
                 aCur: t[1]
             }), r.transformFeedback.setBuffers({
                 vNext: t[2]
             }), r.model.setUniforms({
-                stiffness: n.stiffness,
-                damping: n.damping
+                stiffness: s.stiffness,
+                damping: s.damping
             }), r.run({
                 framebuffer: i,
                 discard: !1,
                 parameters: {
                     viewport: [0, 0, 1, 1]
                 },
                 clearColor: [0, 0, 0, 0]
-            }), Al(t), this.setBuffer(t[1]), this.device.readPixelsToArrayWebGL(i)[0] > 0 || s.end()
+            }), Ap(t), this.setBuffer(t[1]), this.device.readPixelsToArrayWebGL(i)[0] > 0 || n.end()
         }
         delete() {
             super.delete(), this.transform.destroy(), this.texture.destroy(), this.framebuffer.destroy()
         }
     },
-    VP = `#version 300 es
+    $L = `#version 300 es
 #define SHADER_NAME spring-transition-vertex-shader
 
 #define EPSILON 0.00001
 
 uniform float stiffness;
 uniform float damping;
 in ATTRIBUTE_TYPE aPrev;
@@ -23019,34 +23019,34 @@
   vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;
 
   vNext = getNextValue(aCur, aPrev, aTo);
   gl_Position = vec4(0, 0, 0, 1);
   gl_PointSize = 100.0;
 }
 `,
-    zP = `#version 300 es
+    XL = `#version 300 es
 #define SHADER_NAME spring-transition-is-transitioning-fragment-shader
 
 in float vIsTransitioningFlag;
 
 out vec4 fragColor;
 
 void main(void) {
   if (vIsTransitioningFlag == 0.0) {
     discard;
   }
   fragColor = vec4(1.0);
 }`;
 
-function WP(e, t) {
-    let r = Tl(t.size),
-        i = bl(t.size);
-    return new Oi(e, {
-        vs: VP,
-        fs: zP,
+function YL(e, t) {
+    let r = vp(t.size),
+        i = Sp(t.size);
+    return new Io(e, {
+        vs: $L,
+        fs: XL,
         bufferLayout: [{
             name: "aPrev",
             format: i
         }, {
             name: "aCur",
             format: i
         }, {
@@ -23065,37 +23065,37 @@
             blendAlphaOperation: "max",
             blendAlphaSrcFactor: "one",
             blendAlphaDstFactor: "one"
         }
     })
 }
 
-function jP(e) {
+function qL(e) {
     return e.createTexture({
         data: new Uint8Array(4),
         format: "rgba8unorm",
         mipmaps: !1,
         width: 1,
         height: 1
     })
 }
 
-function HP(e, t) {
+function ZL(e, t) {
     return e.createFramebuffer({
         id: "spring-transition-is-transitioning-framebuffer",
         width: 1,
         height: 1,
         colorAttachments: [t]
     })
 }
-var XP = {
-        interpolation: Mo,
-        spring: Co
+var KL = {
+        interpolation: xu,
+        spring: wu
     },
-    Io = class {
+    Tu = class {
         constructor(t, {
             id: r,
             timeline: i
         }) {
             if (!t) throw new Error("AttributeTransitionManager is constructed without device");
             this.id = r, this.device = t, this.timeline = i, this.transitions = {}, this.needsRedraw = !1, this.numInstances = 1
         }
@@ -23104,22 +23104,22 @@
         }
         update({
             attributes: t,
             transitions: r,
             numInstances: i
         }) {
             this.numInstances = i || 1;
-            for (let s in t) {
-                let n = t[s],
-                    o = n.getTransitionSetting(r);
-                o && this._updateAttribute(s, n, o)
-            }
-            for (let s in this.transitions) {
-                let n = t[s];
-                (!n || !n.getTransitionSetting(r)) && this._removeTransition(s)
+            for (let n in t) {
+                let s = t[n],
+                    o = s.getTransitionSetting(r);
+                o && this._updateAttribute(n, s, o)
+            }
+            for (let n in this.transitions) {
+                let s = t[n];
+                (!s || !s.getTransitionSetting(r)) && this._removeTransition(n)
             }
         }
         hasAttribute(t) {
             let r = this.transitions[t];
             return r && r.inProgress
         }
         getAttributes() {
@@ -23136,42 +23136,42 @@
             let t = this.needsRedraw;
             return this.needsRedraw = !1, t
         }
         _removeTransition(t) {
             this.transitions[t].delete(), delete this.transitions[t]
         }
         _updateAttribute(t, r, i) {
-            let s = this.transitions[t],
-                n = !s || s.type !== i.type;
-            if (n) {
-                s && this._removeTransition(t);
-                let o = XP[i.type];
+            let n = this.transitions[t],
+                s = !n || n.type !== i.type;
+            if (s) {
+                n && this._removeTransition(t);
+                let o = KL[i.type];
                 o ? this.transitions[t] = new o({
                     attribute: r,
                     timeline: this.timeline,
                     device: this.device
-                }) : (j.error(`unsupported transition type '${i.type}'`)(), n = !1)
-            }(n || r.needsRedraw()) && (this.needsRedraw = !0, this.transitions[t].start(i, this.numInstances))
+                }) : (Z.error(`unsupported transition type '${i.type}'`)(), s = !1)
+            }(s || r.needsRedraw()) && (this.needsRedraw = !0, this.transitions[t].start(i, this.numInstances))
         }
     };
-var Xy = "attributeManager.invalidate",
-    $P = "attributeManager.updateStart",
-    YP = "attributeManager.updateEnd",
-    qP = "attribute.updateStart",
-    ZP = "attribute.allocate",
-    KP = "attribute.updateEnd",
-    Us = class {
+var hE = "attributeManager.invalidate",
+    GL = "attributeManager.updateStart",
+    JL = "attributeManager.updateEnd",
+    QL = "attribute.updateStart",
+    tk = "attribute.allocate",
+    ek = "attribute.updateEnd",
+    nc = class {
         constructor(t, {
             id: r = "attribute-manager",
             stats: i,
-            timeline: s
+            timeline: n
         } = {}) {
-            this.mergeBoundsMemoized = Ye(s0), this.id = r, this.device = t, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = i, this.attributeTransitionManager = new Io(t, {
+            this.mergeBoundsMemoized = Wi(A1), this.id = r, this.device = t, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = i, this.attributeTransitionManager = new Tu(t, {
                 id: `${r}-transitions`,
-                timeline: s
+                timeline: n
             }), Object.seal(this)
         }
         finalize() {
             for (let t in this.attributes) this.attributes[t].delete();
             this.attributeTransitionManager.finalize()
         }
         getNeedsRedraw(t = {
@@ -23192,46 +23192,46 @@
             })
         }
         remove(t) {
             for (let r of t) this.attributes[r] !== void 0 && (this.attributes[r].delete(), delete this.attributes[r])
         }
         invalidate(t, r) {
             let i = this._invalidateTrigger(t, r);
-            pt(Xy, this, t, i)
+            Qt(hE, this, t, i)
         }
         invalidateAll(t) {
             for (let r in this.attributes) this.attributes[r].setNeedsUpdate(r, t);
-            pt(Xy, this, "all")
+            Qt(hE, this, "all")
         }
         update({
             data: t,
             numInstances: r,
             startIndices: i = null,
-            transitions: s,
-            props: n = {},
+            transitions: n,
+            props: s = {},
             buffers: o = {},
             context: a = {}
         }) {
             let c = !1;
-            pt($P, this), this.stats && this.stats.get("Update Attributes").timeStart();
+            Qt(GL, this), this.stats && this.stats.get("Update Attributes").timeStart();
             for (let l in this.attributes) {
-                let h = this.attributes[l],
-                    f = h.settings.accessor;
-                h.startIndices = i, h.numInstances = r, n[l] && j.removed(`props.${l}`, `data.attributes.${l}`)(), h.setExternalBuffer(o[l]) || h.setBinaryValue(typeof f == "string" ? o[f] : void 0, t.startIndices) || typeof f == "string" && !o[f] && h.setConstantValue(n[f]) || h.needsUpdate() && (c = !0, this._updateAttribute({
-                    attribute: h,
+                let u = this.attributes[l],
+                    f = u.settings.accessor;
+                u.startIndices = i, u.numInstances = r, s[l] && Z.removed(`props.${l}`, `data.attributes.${l}`)(), u.setExternalBuffer(o[l]) || u.setBinaryValue(typeof f == "string" ? o[f] : void 0, t.startIndices) || typeof f == "string" && !o[f] && u.setConstantValue(s[f]) || u.needsUpdate() && (c = !0, this._updateAttribute({
+                    attribute: u,
                     numInstances: r,
                     data: t,
-                    props: n,
+                    props: s,
                     context: a
-                })), this.needsRedraw = this.needsRedraw || h.needsRedraw()
+                })), this.needsRedraw = this.needsRedraw || u.needsRedraw()
             }
-            c && pt(YP, this, r), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
+            c && Qt(JL, this, r), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
                 attributes: this.attributes,
                 numInstances: r,
-                transitions: s
+                transitions: n
             })
         }
         updateTransition() {
             let {
                 attributeTransitionManager: t
             } = this, r = t.run();
             return this.needsRedraw = this.needsRedraw || r, r
@@ -23248,171 +23248,171 @@
         }
         getChangedAttributes(t = {
             clearChangedFlags: !1
         }) {
             let {
                 attributes: r,
                 attributeTransitionManager: i
-            } = this, s = {
+            } = this, n = {
                 ...i.getAttributes()
             };
-            for (let n in r) {
-                let o = r[n];
-                o.needsRedraw(t) && !i.hasAttribute(n) && (s[n] = o)
+            for (let s in r) {
+                let o = r[s];
+                o.needsRedraw(t) && !i.hasAttribute(s) && (n[s] = o)
             }
-            return s
+            return n
         }
         getBufferLayouts(t, r = {}) {
             t || (t = this.getAttributes());
             let i = [];
-            for (let s in t) r[s] || i.push(t[s].getBufferLayout());
+            for (let n in t) r[n] || i.push(t[n].getBufferLayout());
             return i
         }
         _add(t, r = {}) {
             for (let i in t) {
-                let s = t[i];
-                this.attributes[i] = this._createAttribute(i, s, r)
+                let n = t[i];
+                this.attributes[i] = this._createAttribute(i, n, r)
             }
             this._mapUpdateTriggersToAttributes()
         }
         _createAttribute(t, r, i) {
-            let s = {
+            let n = {
                 ...r,
                 id: t,
                 size: r.isIndexed && 1 || r.size || 1,
                 divisor: i.instanced ? 1 : r.divisor || 0
             };
-            return new ei(this.device, s)
+            return new Fs(this.device, n)
         }
         _mapUpdateTriggersToAttributes() {
             let t = {};
-            for (let r in this.attributes) this.attributes[r].getUpdateTriggers().forEach(s => {
-                t[s] || (t[s] = []), t[s].push(r)
+            for (let r in this.attributes) this.attributes[r].getUpdateTriggers().forEach(n => {
+                t[n] || (t[n] = []), t[n].push(r)
             });
             this.updateTriggers = t
         }
         _invalidateTrigger(t, r) {
             let {
                 attributes: i,
-                updateTriggers: s
-            } = this, n = s[t];
-            return n && n.forEach(o => {
+                updateTriggers: n
+            } = this, s = n[t];
+            return s && s.forEach(o => {
                 let a = i[o];
                 a && a.setNeedsUpdate(a.id, r)
-            }), n
+            }), s
         }
         _updateAttribute(t) {
             let {
                 attribute: r,
                 numInstances: i
             } = t;
-            if (pt(qP, r), r.constant) {
+            if (Qt(QL, r), r.constant) {
                 r.setConstantValue(r.value);
                 return
             }
-            r.allocate(i) && pt(ZP, r, i), r.updateBuffer(t) && (this.needsRedraw = !0, pt(KP, r, i))
+            r.allocate(i) && Qt(tk, r, i), r.updateBuffer(t) && (this.needsRedraw = !0, Qt(ek, r, i))
         }
     };
-var Oo = class extends Pe {
+var vu = class extends ni {
     get value() {
         return this._value
     }
     _onUpdate() {
         let {
             time: t,
             settings: {
                 fromValue: r,
                 toValue: i,
-                duration: s,
-                easing: n
+                duration: n,
+                easing: s
             }
-        } = this, o = n(t / s);
-        this._value = Ee(r, i, o)
+        } = this, o = s(t / n);
+        this._value = Qr(r, i, o)
     }
 };
-var $y = 1e-5;
+var dE = 1e-5;
 
-function Yy(e, t, r, i, s) {
-    let n = t - e,
-        a = (r - t) * s,
-        c = -n * i;
-    return a + c + n + t
+function pE(e, t, r, i, n) {
+    let s = t - e,
+        a = (r - t) * n,
+        c = -s * i;
+    return a + c + s + t
 }
 
-function QP(e, t, r, i, s) {
+function rk(e, t, r, i, n) {
     if (Array.isArray(r)) {
-        let n = [];
-        for (let o = 0; o < r.length; o++) n[o] = Yy(e[o], t[o], r[o], i, s);
-        return n
+        let s = [];
+        for (let o = 0; o < r.length; o++) s[o] = pE(e[o], t[o], r[o], i, n);
+        return s
     }
-    return Yy(e, t, r, i, s)
+    return pE(e, t, r, i, n)
 }
 
-function qy(e, t) {
+function mE(e, t) {
     if (Array.isArray(e)) {
         let r = 0;
         for (let i = 0; i < e.length; i++) {
-            let s = e[i] - t[i];
-            r += s * s
+            let n = e[i] - t[i];
+            r += n * n
         }
         return Math.sqrt(r)
     }
     return Math.abs(e - t)
 }
-var No = class extends Pe {
+var Su = class extends ni {
     get value() {
         return this._currValue
     }
     _onUpdate() {
         let {
             fromValue: t,
             toValue: r,
             damping: i,
-            stiffness: s
+            stiffness: n
         } = this.settings, {
-            _prevValue: n = t,
+            _prevValue: s = t,
             _currValue: o = t
-        } = this, a = QP(n, o, r, i, s), c = qy(a, r), l = qy(a, o);
-        c < $y && l < $y && (a = r, this.end()), this._prevValue = o, this._currValue = a
+        } = this, a = rk(s, o, r, i, n), c = mE(a, r), l = mE(a, o);
+        c < dE && l < dE && (a = r, this.end()), this._prevValue = o, this._currValue = a
     }
 };
-var GP = {
-        interpolation: Oo,
-        spring: No
+var ik = {
+        interpolation: vu,
+        spring: Su
     },
-    Fo = class {
+    Au = class {
         constructor(t) {
             this.transitions = new Map, this.timeline = t
         }
         get active() {
             return this.transitions.size > 0
         }
-        add(t, r, i, s) {
+        add(t, r, i, n) {
             let {
-                transitions: n
+                transitions: s
             } = this;
-            if (n.has(t)) {
-                let c = n.get(t),
+            if (s.has(t)) {
+                let c = s.get(t),
                     {
                         value: l = c.settings.fromValue
                     } = c;
                 r = l, this.remove(t)
             }
-            if (s = xl(s), !s) return;
-            let o = GP[s.type];
+            if (n = Tp(n), !n) return;
+            let o = ik[n.type];
             if (!o) {
-                j.error(`unsupported transition type '${s.type}'`)();
+                Z.error(`unsupported transition type '${n.type}'`)();
                 return
             }
             let a = new o(this.timeline);
             a.start({
-                ...s,
+                ...n,
                 fromValue: r,
                 toValue: i
-            }), n.set(t, a)
+            }), s.set(t, a)
         }
         remove(t) {
             let {
                 transitions: r
             } = this;
             r.has(t) && (r.get(t).cancel(), r.delete(t))
         }
@@ -23422,214 +23422,214 @@
             return t
         }
         clear() {
             for (let t of this.transitions.keys()) this.remove(t)
         }
     };
 
-function Ky(e) {
-    let t = e[ye];
+function _E(e) {
+    let t = e[Ur];
     for (let r in t) {
         let i = t[r],
             {
-                validate: s
+                validate: n
             } = i;
-        if (s && !s(e[r], i)) throw new Error(`Invalid prop ${r}: ${e[r]}`)
+        if (n && !n(e[r], i)) throw new Error(`Invalid prop ${r}: ${e[r]}`)
     }
 }
 
-function Qy(e, t) {
-    let r = Gy({
+function yE(e, t) {
+    let r = bE({
             newProps: e,
             oldProps: t,
-            propTypes: e[ye],
+            propTypes: e[Ur],
             ignoreProps: {
                 data: null,
                 updateTriggers: null,
                 extensions: null,
                 transitions: null
             }
         }),
-        i = t3(e, t),
-        s = !1;
-    return i || (s = e3(e, t)), {
+        i = sk(e, t),
+        n = !1;
+    return i || (n = ok(e, t)), {
         dataChanged: i,
         propsChanged: r,
-        updateTriggersChanged: s,
-        extensionsChanged: r3(e, t),
-        transitionsChanged: JP(e, t)
+        updateTriggersChanged: n,
+        extensionsChanged: ak(e, t),
+        transitionsChanged: nk(e, t)
     }
 }
 
-function JP(e, t) {
+function nk(e, t) {
     if (!e.transitions) return !1;
     let r = {},
-        i = e[ye],
-        s = !1;
-    for (let n in e.transitions) {
-        let o = i[n],
+        i = e[Ur],
+        n = !1;
+    for (let s in e.transitions) {
+        let o = i[s],
             a = o && o.type;
-        (a === "number" || a === "color" || a === "array") && Vd(e[n], t[n], o) && (r[n] = !0, s = !0)
+        (a === "number" || a === "color" || a === "array") && Mb(e[s], t[s], o) && (r[s] = !0, n = !0)
     }
-    return s ? r : !1
+    return n ? r : !1
 }
 
-function Gy({
+function bE({
     newProps: e,
     oldProps: t,
     ignoreProps: r = {},
     propTypes: i = {},
-    triggerName: s = "props"
+    triggerName: n = "props"
 }) {
     if (t === e) return !1;
-    if (typeof e != "object" || e === null) return `${s} changed shallowly`;
-    if (typeof t != "object" || t === null) return `${s} changed shallowly`;
-    for (let n of Object.keys(e))
-        if (!(n in r)) {
-            if (!(n in t)) return `${s}.${n} added`;
-            let o = Vd(e[n], t[n], i[n]);
-            if (o) return `${s}.${n} ${o}`
-        } for (let n of Object.keys(t))
-        if (!(n in r)) {
-            if (!(n in e)) return `${s}.${n} dropped`;
-            if (!Object.hasOwnProperty.call(e, n)) {
-                let o = Vd(e[n], t[n], i[n]);
-                if (o) return `${s}.${n} ${o}`
+    if (typeof e != "object" || e === null) return `${n} changed shallowly`;
+    if (typeof t != "object" || t === null) return `${n} changed shallowly`;
+    for (let s of Object.keys(e))
+        if (!(s in r)) {
+            if (!(s in t)) return `${n}.${s} added`;
+            let o = Mb(e[s], t[s], i[s]);
+            if (o) return `${n}.${s} ${o}`
+        } for (let s of Object.keys(t))
+        if (!(s in r)) {
+            if (!(s in e)) return `${n}.${s} dropped`;
+            if (!Object.hasOwnProperty.call(e, s)) {
+                let o = Mb(e[s], t[s], i[s]);
+                if (o) return `${n}.${s} ${o}`
             }
         } return !1
 }
 
-function Vd(e, t, r) {
+function Mb(e, t, r) {
     let i = r && r.equal;
     return i && !i(e, t, r) || !i && (i = e && t && e.equals, i && !i.call(e, t)) ? "changed deeply" : !i && t !== e ? "changed shallowly" : null
 }
 
-function t3(e, t) {
+function sk(e, t) {
     if (t === null) return "oldProps is null, initial diff";
     let r = !1,
         {
             dataComparator: i,
-            _dataDiff: s
+            _dataDiff: n
         } = e;
-    return i ? i(e.data, t.data) || (r = "Data comparator detected a change") : e.data !== t.data && (r = "A new data container was supplied"), r && s && (r = s(e.data, t.data) || r), r
+    return i ? i(e.data, t.data) || (r = "Data comparator detected a change") : e.data !== t.data && (r = "A new data container was supplied"), r && n && (r = n(e.data, t.data) || r), r
 }
 
-function e3(e, t) {
+function ok(e, t) {
     if (t === null) return {
         all: !0
     };
-    if ("all" in e.updateTriggers && Zy(e, t, "all")) return {
+    if ("all" in e.updateTriggers && gE(e, t, "all")) return {
         all: !0
     };
     let r = {},
         i = !1;
-    for (let s in e.updateTriggers) s !== "all" && Zy(e, t, s) && (r[s] = !0, i = !0);
+    for (let n in e.updateTriggers) n !== "all" && gE(e, t, n) && (r[n] = !0, i = !0);
     return i ? r : !1
 }
 
-function r3(e, t) {
+function ak(e, t) {
     if (t === null) return !0;
     let r = t.extensions,
         {
             extensions: i
         } = e;
     if (i === r) return !1;
     if (!r || !i || i.length !== r.length) return !0;
-    for (let s = 0; s < i.length; s++)
-        if (!i[s].equals(r[s])) return !0;
+    for (let n = 0; n < i.length; n++)
+        if (!i[n].equals(r[n])) return !0;
     return !1
 }
 
-function Zy(e, t, r) {
+function gE(e, t, r) {
     let i = e.updateTriggers[r];
     i = i ?? {};
-    let s = t.updateTriggers[r];
-    return s = s ?? {}, Gy({
-        oldProps: s,
+    let n = t.updateTriggers[r];
+    return n = n ?? {}, bE({
+        oldProps: n,
         newProps: i,
         triggerName: r
     })
 }
-var i3 = "count(): argument not an object",
-    s3 = "count(): argument not a container";
+var ck = "count(): argument not an object",
+    lk = "count(): argument not a container";
 
-function Jy(e) {
-    if (!o3(e)) throw new Error(i3);
+function xE(e) {
+    if (!fk(e)) throw new Error(ck);
     if (typeof e.count == "function") return e.count();
     if (Number.isFinite(e.size)) return e.size;
     if (Number.isFinite(e.length)) return e.length;
-    if (n3(e)) return Object.keys(e).length;
-    throw new Error(s3)
+    if (uk(e)) return Object.keys(e).length;
+    throw new Error(lk)
 }
 
-function n3(e) {
+function uk(e) {
     return e !== null && typeof e == "object" && e.constructor === Object
 }
 
-function o3(e) {
+function fk(e) {
     return e !== null && typeof e == "object"
 }
 
-function zd(e, t) {
+function Pb(e, t) {
     if (!t) return e;
     let r = {
         ...e,
         ...t
     };
     if ("defines" in t && (r.defines = {
             ...e.defines,
             ...t.defines
         }), "modules" in t && (r.modules = (e.modules || []).concat(t.modules), t.modules.some(i => i.name === "project64"))) {
-        let i = r.modules.findIndex(s => s.name === "project32");
+        let i = r.modules.findIndex(n => n.name === "project32");
         i >= 0 && r.modules.splice(i, 1)
     }
     if ("inject" in t)
         if (!e.inject) r.inject = t.inject;
         else {
             let i = {
                 ...e.inject
             };
-            for (let s in t.inject) i[s] = (i[s] || "") + t.inject[s];
+            for (let n in t.inject) i[n] = (i[n] || "") + t.inject[n];
             r.inject = i
         } return r
 }
-var a3 = {
+var hk = {
         minFilter: "linear",
         mipmapFilter: "linear",
         magFilter: "linear",
         addressModeU: "clamp-to-edge",
         addressModeV: "clamp-to-edge"
     },
-    Wd = {};
+    Cb = {};
 
-function tx(e, t, r, i) {
-    if (r instanceof Tt) return r;
+function wE(e, t, r, i) {
+    if (r instanceof ae) return r;
     r.constructor && r.constructor.name !== "Object" && (r = {
         data: r
     });
-    let s = null;
-    r.compressed && (s = {
+    let n = null;
+    r.compressed && (n = {
         minFilter: "linear",
         mipmapFilter: r.data.length > 1 ? "nearest" : "linear"
     });
-    let n = t.createTexture({
+    let s = t.createTexture({
         ...r,
         sampler: {
-            ...a3,
-            ...s,
+            ...hk,
+            ...n,
             ...i
         }
     });
-    return Wd[n.id] = e, n
+    return Cb[s.id] = e, s
 }
 
-function ex(e, t) {
-    !t || !(t instanceof Tt) || Wd[t.id] === e && (t.delete(), delete Wd[t.id])
+function TE(e, t) {
+    !t || !(t instanceof ae) || Cb[t.id] === e && (t.delete(), delete Cb[t.id])
 }
-var c3 = {
+var dk = {
     boolean: {
         validate(e, t) {
             return !0
         },
         equal(e, t, r) {
             return !!e == !!t
         }
@@ -23637,47 +23637,47 @@
     number: {
         validate(e, t) {
             return Number.isFinite(e) && (!("max" in t) || e <= t.max) && (!("min" in t) || e >= t.min)
         }
     },
     color: {
         validate(e, t) {
-            return t.optional && !e || jd(e) && (e.length === 3 || e.length === 4)
+            return t.optional && !e || Ob(e) && (e.length === 3 || e.length === 4)
         },
         equal(e, t, r) {
-            return Ct(e, t, 1)
+            return Se(e, t, 1)
         }
     },
     accessor: {
         validate(e, t) {
-            let r = wl(e);
-            return r === "function" || r === wl(t.value)
+            let r = Rp(e);
+            return r === "function" || r === Rp(t.value)
         },
         equal(e, t, r) {
-            return typeof t == "function" ? !0 : Ct(e, t, 1)
+            return typeof t == "function" ? !0 : Se(e, t, 1)
         }
     },
     array: {
         validate(e, t) {
-            return t.optional && !e || jd(e)
+            return t.optional && !e || Ob(e)
         },
         equal(e, t, r) {
             let {
                 compare: i
-            } = r, s = Number.isInteger(i) ? i : i ? 1 : 0;
-            return i ? Ct(e, t, s) : e === t
+            } = r, n = Number.isInteger(i) ? i : i ? 1 : 0;
+            return i ? Se(e, t, n) : e === t
         }
     },
     object: {
         equal(e, t, r) {
             if (r.ignore) return !0;
             let {
                 compare: i
-            } = r, s = Number.isInteger(i) ? i : i ? 1 : 0;
-            return i ? Ct(e, t, s) : e === t
+            } = r, n = Number.isInteger(i) ? i : i ? 1 : 0;
+            return i ? Se(e, t, n) : e === t
         }
     },
     function: {
         validate(e, t) {
             return t.optional && !e || typeof e == "function"
         },
         equal(e, t, r) {
@@ -23692,244 +23692,244 @@
             } = r.props;
             return i ? i(e) : typeof e.shape == "string" && e.shape.endsWith("-table") && Array.isArray(e.data) ? e.data : e
         }
     },
     image: {
         transform: (e, t, r) => {
             let i = r.context;
-            return !i || !i.device ? null : tx(r.id, i.device, e, {
+            return !i || !i.device ? null : wE(r.id, i.device, e, {
                 ...t.parameters,
                 ...r.props.textureParameters
             })
         },
         release: (e, t, r) => {
-            ex(r.id, e)
+            TE(r.id, e)
         }
     }
 };
 
-function rx(e) {
+function vE(e) {
     let t = {},
         r = {},
         i = {};
-    for (let [s, n] of Object.entries(e)) {
-        let o = n?.deprecatedFor;
-        if (o) i[s] = Array.isArray(o) ? o : [o];
+    for (let [n, s] of Object.entries(e)) {
+        let o = s?.deprecatedFor;
+        if (o) i[n] = Array.isArray(o) ? o : [o];
         else {
-            let a = l3(s, n);
-            t[s] = a, r[s] = a.value
+            let a = pk(n, s);
+            t[n] = a, r[n] = a.value
         }
     }
     return {
         propTypes: t,
         defaultProps: r,
         deprecatedProps: i
     }
 }
 
-function l3(e, t) {
-    switch (wl(t)) {
+function pk(e, t) {
+    switch (Rp(t)) {
         case "object":
-            return Do(e, t);
+            return Eu(e, t);
         case "array":
-            return Do(e, {
+            return Eu(e, {
                 type: "array",
                 value: t,
                 compare: !1
             });
         case "boolean":
-            return Do(e, {
+            return Eu(e, {
                 type: "boolean",
                 value: t
             });
         case "number":
-            return Do(e, {
+            return Eu(e, {
                 type: "number",
                 value: t
             });
         case "function":
-            return Do(e, {
+            return Eu(e, {
                 type: "function",
                 value: t,
                 compare: !0
             });
         default:
             return {
                 name: e, type: "unknown", value: t
             }
     }
 }
 
-function Do(e, t) {
+function Eu(e, t) {
     return "type" in t ? {
         name: e,
-        ...c3[t.type],
+        ...dk[t.type],
         ...t
     } : "value" in t ? {
         name: e,
-        type: wl(t.value),
+        type: Rp(t.value),
         ...t
     } : {
         name: e,
         type: "object",
         value: t
     }
 }
 
-function jd(e) {
+function Ob(e) {
     return Array.isArray(e) || ArrayBuffer.isView(e)
 }
 
-function wl(e) {
-    return jd(e) ? "array" : e === null ? "null" : typeof e
+function Rp(e) {
+    return Ob(e) ? "array" : e === null ? "null" : typeof e
 }
 
-function ix(e, t) {
+function SE(e, t) {
     let r;
-    for (let n = t.length - 1; n >= 0; n--) {
-        let o = t[n];
+    for (let s = t.length - 1; s >= 0; s--) {
+        let o = t[s];
         "extensions" in o && (r = o.extensions)
     }
-    let i = Hd(e.constructor, r),
-        s = Object.create(i);
-    s[vs] = e, s[Ze] = {}, s[Re] = {};
-    for (let n = 0; n < t.length; ++n) {
-        let o = t[n];
-        for (let a in o) s[a] = o[a]
+    let i = Nb(e.constructor, r),
+        n = Object.create(i);
+    n[$a] = e, n[Hi] = {}, n[ii] = {};
+    for (let s = 0; s < t.length; ++s) {
+        let o = t[s];
+        for (let a in o) n[a] = o[a]
     }
-    return Object.freeze(s), s
+    return Object.freeze(n), n
 }
-var h3 = "_mergedDefaultProps";
+var mk = "_mergedDefaultProps";
 
-function Hd(e, t) {
-    let r = h3;
+function Nb(e, t) {
+    let r = mk;
     if (t)
-        for (let s of t) {
-            let n = s.constructor;
-            n && (r += `:${n.extensionName||n.name}`)
+        for (let n of t) {
+            let s = n.constructor;
+            s && (r += `:${s.extensionName||s.name}`)
         }
-    let i = sx(e, r);
-    return i || (e[r] = f3(e, t || []))
+    let i = AE(e, r);
+    return i || (e[r] = gk(e, t || []))
 }
 
-function f3(e, t) {
+function gk(e, t) {
     if (!e.prototype) return null;
     let i = Object.getPrototypeOf(e),
-        s = Hd(i),
-        n = sx(e, "defaultProps") || {},
-        o = rx(n),
-        a = Object.assign(Object.create(null), s, o.defaultProps),
-        c = Object.assign(Object.create(null), s?.[ye], o.propTypes),
-        l = Object.assign(Object.create(null), s?.[Wc], o.deprecatedProps);
-    for (let h of t) {
-        let f = Hd(h.constructor);
-        f && (Object.assign(a, f), Object.assign(c, f[ye]), Object.assign(l, f[Wc]))
+        n = Nb(i),
+        s = AE(e, "defaultProps") || {},
+        o = vE(s),
+        a = Object.assign(Object.create(null), n, o.defaultProps),
+        c = Object.assign(Object.create(null), n?.[Ur], o.propTypes),
+        l = Object.assign(Object.create(null), n?.[$d], o.deprecatedProps);
+    for (let u of t) {
+        let f = Nb(u.constructor);
+        f && (Object.assign(a, f), Object.assign(c, f[Ur]), Object.assign(l, f[$d]))
     }
-    return u3(a, e), p3(a, c), d3(a, l), a[ye] = c, a[Wc] = l, t.length === 0 && !Xd(e, "_propTypes") && (e._propTypes = c), a
+    return _k(a, e), bk(a, c), yk(a, l), a[Ur] = c, a[$d] = l, t.length === 0 && !Bb(e, "_propTypes") && (e._propTypes = c), a
 }
 
-function u3(e, t) {
-    let r = m3(t);
+function _k(e, t) {
+    let r = wk(t);
     Object.defineProperties(e, {
         id: {
             writable: !0,
             value: r
         }
     })
 }
 
-function d3(e, t) {
+function yk(e, t) {
     for (let r in t) Object.defineProperty(e, r, {
         enumerable: !1,
         set(i) {
-            let s = `${this.id}: ${r}`;
-            for (let n of t[r]) Xd(this, n) || (this[n] = i);
-            j.deprecated(s, t[r].join("/"))()
+            let n = `${this.id}: ${r}`;
+            for (let s of t[r]) Bb(this, s) || (this[s] = i);
+            Z.deprecated(n, t[r].join("/"))()
         }
     })
 }
 
-function p3(e, t) {
+function bk(e, t) {
     let r = {},
         i = {};
-    for (let s in t) {
-        let n = t[s],
+    for (let n in t) {
+        let s = t[n],
             {
                 name: o,
                 value: a
-            } = n;
-        n.async && (r[o] = a, i[o] = g3(o))
+            } = s;
+        s.async && (r[o] = a, i[o] = xk(o))
     }
-    e[pr] = r, e[Ze] = {}, Object.defineProperties(e, i)
+    e[vn] = r, e[Hi] = {}, Object.defineProperties(e, i)
 }
 
-function g3(e) {
+function xk(e) {
     return {
         enumerable: !0,
         set(t) {
-            typeof t == "string" || t instanceof Promise || _l(t) ? this[Ze][e] = t : this[Re][e] = t
+            typeof t == "string" || t instanceof Promise || xp(t) ? this[Hi][e] = t : this[ii][e] = t
         },
         get() {
-            if (this[Re]) {
-                if (e in this[Re]) return this[Re][e] || this[pr][e];
-                if (e in this[Ze]) {
-                    let t = this[vs] && this[vs].internalState;
-                    if (t && t.hasAsyncProp(e)) return t.getAsyncProp(e) || this[pr][e]
+            if (this[ii]) {
+                if (e in this[ii]) return this[ii][e] || this[vn][e];
+                if (e in this[Hi]) {
+                    let t = this[$a] && this[$a].internalState;
+                    if (t && t.hasAsyncProp(e)) return t.getAsyncProp(e) || this[vn][e]
                 }
             }
-            return this[pr][e]
+            return this[vn][e]
         }
     }
 }
 
-function Xd(e, t) {
+function Bb(e, t) {
     return Object.prototype.hasOwnProperty.call(e, t)
 }
 
-function sx(e, t) {
-    return Xd(e, t) && e[t]
+function AE(e, t) {
+    return Bb(e, t) && e[t]
 }
 
-function m3(e) {
+function wk(e) {
     let t = e.componentName;
-    return t || j.warn(`${e.name}.componentName not specified`)(), t || e.name
+    return t || Z.warn(`${e.name}.componentName not specified`)(), t || e.name
 }
-var _3 = 0,
-    vl = class vl {
+var Tk = 0,
+    Mp = class Mp {
         constructor(...t) {
-            this.props = ix(this, t), this.id = this.props.id, this.count = _3++
+            this.props = SE(this, t), this.id = this.props.id, this.count = Tk++
         }
         clone(t) {
             let {
                 props: r
             } = this, i = {};
-            for (let s in r[pr]) s in r[Re] ? i[s] = r[Re][s] : s in r[Ze] && (i[s] = r[Ze][s]);
+            for (let n in r[vn]) n in r[ii] ? i[n] = r[ii][n] : n in r[Hi] && (i[n] = r[Hi][n]);
             return new this.constructor({
                 ...r,
                 ...i,
                 ...t
             })
         }
     };
-vl.componentName = "Component", vl.defaultProps = {};
-var ko = vl;
-var y3 = Object.freeze({}),
-    Lo = class {
+Mp.componentName = "Component", Mp.defaultProps = {};
+var Iu = Mp;
+var vk = Object.freeze({}),
+    Ru = class {
         constructor(t) {
             this.component = t, this.asyncProps = {}, this.onAsyncPropUpdated = () => {}, this.oldProps = null, this.oldAsyncProps = null
         }
         finalize() {
             for (let t in this.asyncProps) {
                 let r = this.asyncProps[t];
                 r && r.type && r.type.release && r.type.release(r.resolvedValue, r.type, this.component)
             }
             this.asyncProps = {}, this.component = null, this.resetOldProps()
         }
         getOldProps() {
-            return this.oldAsyncProps || this.oldProps || y3
+            return this.oldAsyncProps || this.oldProps || vk
         }
         resetOldProps() {
             this.oldAsyncProps = null, this.oldProps = this.component ? this.component.props : null
         }
         hasAsyncProp(t) {
             return t in this.asyncProps
         }
@@ -23946,39 +23946,39 @@
                 if (this.isAsyncPropLoading(r)) return !0;
             return !1
         }
         reloadAsyncProp(t, r) {
             this._watchPromise(t, Promise.resolve(r))
         }
         setAsyncProps(t) {
-            this.component = t[vs] || this.component;
-            let r = t[Re] || {},
-                i = t[Ze] || t,
-                s = t[pr] || {};
-            for (let n in r) {
-                let o = r[n];
-                this._createAsyncPropData(n, s[n]), this._updateAsyncProp(n, o), r[n] = this.getAsyncProp(n)
+            this.component = t[$a] || this.component;
+            let r = t[ii] || {},
+                i = t[Hi] || t,
+                n = t[vn] || {};
+            for (let s in r) {
+                let o = r[s];
+                this._createAsyncPropData(s, n[s]), this._updateAsyncProp(s, o), r[s] = this.getAsyncProp(s)
             }
-            for (let n in i) {
-                let o = i[n];
-                this._createAsyncPropData(n, s[n]), this._updateAsyncProp(n, o)
+            for (let s in i) {
+                let o = i[s];
+                this._createAsyncPropData(s, n[s]), this._updateAsyncProp(s, o)
             }
         }
         _fetch(t, r) {
             return null
         }
         _onResolve(t, r) {}
         _onError(t, r) {}
         _updateAsyncProp(t, r) {
             if (this._didAsyncInputValueChange(t, r)) {
                 if (typeof r == "string" && (r = this._fetch(t, r)), r instanceof Promise) {
                     this._watchPromise(t, r);
                     return
                 }
-                if (_l(r)) {
+                if (xp(r)) {
                     this._resolveAsyncIterable(t, r);
                     return
                 }
                 this._setPropValue(t, r)
             }
         }
         _freezeAsyncOldProps() {
@@ -23996,121 +23996,121 @@
         }
         _setPropValue(t, r) {
             this._freezeAsyncOldProps();
             let i = this.asyncProps[t];
             i && (r = this._postProcessValue(i, r), i.resolvedValue = r, i.pendingLoadCount++, i.resolvedLoadCount = i.pendingLoadCount)
         }
         _setAsyncPropValue(t, r, i) {
-            let s = this.asyncProps[t];
-            s && i >= s.resolvedLoadCount && r !== void 0 && (this._freezeAsyncOldProps(), s.resolvedValue = r, s.resolvedLoadCount = i, this.onAsyncPropUpdated(t, r))
+            let n = this.asyncProps[t];
+            n && i >= n.resolvedLoadCount && r !== void 0 && (this._freezeAsyncOldProps(), n.resolvedValue = r, n.resolvedLoadCount = i, this.onAsyncPropUpdated(t, r))
         }
         _watchPromise(t, r) {
             let i = this.asyncProps[t];
             if (i) {
                 i.pendingLoadCount++;
-                let s = i.pendingLoadCount;
-                r.then(n => {
-                    this.component && (n = this._postProcessValue(i, n), this._setAsyncPropValue(t, n, s), this._onResolve(t, n))
-                }).catch(n => {
-                    this._onError(t, n)
+                let n = i.pendingLoadCount;
+                r.then(s => {
+                    this.component && (s = this._postProcessValue(i, s), this._setAsyncPropValue(t, s, n), this._onResolve(t, s))
+                }).catch(s => {
+                    this._onError(t, s)
                 })
             }
         }
         async _resolveAsyncIterable(t, r) {
             if (t !== "data") {
                 this._setPropValue(t, r);
                 return
             }
             let i = this.asyncProps[t];
             if (!i) return;
             i.pendingLoadCount++;
-            let s = i.pendingLoadCount,
-                n = [],
+            let n = i.pendingLoadCount,
+                s = [],
                 o = 0;
             for await (let a of r) {
                 if (!this.component) return;
                 let {
                     dataTransform: c
                 } = this.component.props;
-                c ? n = c(a, n) : n = n.concat(a), Object.defineProperty(n, "__diff", {
+                c ? s = c(a, s) : s = s.concat(a), Object.defineProperty(s, "__diff", {
                     enumerable: !1,
                     value: [{
                         startRow: o,
-                        endRow: n.length
+                        endRow: s.length
                     }]
-                }), o = n.length, this._setAsyncPropValue(t, n, s)
+                }), o = s.length, this._setAsyncPropValue(t, s, n)
             }
-            this._onResolve(t, n)
+            this._onResolve(t, s)
         }
         _postProcessValue(t, r) {
             let i = t.type;
             return i && this.component && (i.release && i.release(t.resolvedValue, i, this.component), i.transform) ? i.transform(r, i, this.component) : r
         }
         _createAsyncPropData(t, r) {
             if (!this.asyncProps[t]) {
-                let s = this.component && this.component.props[ye];
+                let n = this.component && this.component.props[Ur];
                 this.asyncProps[t] = {
-                    type: s && s[t],
+                    type: n && n[t],
                     lastValue: null,
                     resolvedValue: r,
                     pendingLoadCount: 0,
                     resolvedLoadCount: 0
                 }
             }
         }
     };
-var Bo = class extends Lo {
+var Mu = class extends Ru {
     constructor({
         attributeManager: t,
         layer: r
     }) {
         super(r), this.attributeManager = t, this.needsRedraw = !0, this.needsUpdate = !0, this.subLayers = null, this.usesPickingColorCache = !1
     }
     get layer() {
         return this.component
     }
     _fetch(t, r) {
         let i = this.layer,
-            s = i?.props.fetch;
-        return s ? s(r, {
+            n = i?.props.fetch;
+        return n ? n(r, {
             propName: t,
             layer: i
         }) : super._fetch(t, r)
     }
     _onResolve(t, r) {
         let i = this.layer;
         if (i) {
-            let s = i.props.onDataLoad;
-            t === "data" && s && s(r, {
+            let n = i.props.onDataLoad;
+            t === "data" && n && n(r, {
                 propName: t,
                 layer: i
             })
         }
     }
     _onError(t, r) {
         let i = this.layer;
         i && i.raiseError(r, `loading ${t} of ${this.layer}`)
     }
 };
-var x3 = "layer.changeFlag",
-    T3 = "layer.initialize",
-    b3 = "layer.update",
-    A3 = "layer.finalize",
-    E3 = "layer.matched",
-    nx = 2 ** 24 - 1,
-    S3 = Object.freeze([]),
-    w3 = Ye(({
+var Sk = "layer.changeFlag",
+    Ak = "layer.initialize",
+    Ek = "layer.update",
+    Ik = "layer.finalize",
+    Rk = "layer.matched",
+    EE = 2 ** 24 - 1,
+    Mk = Object.freeze([]),
+    Pk = Wi(({
         oldViewport: e,
         viewport: t
     }) => e.equals(t)),
-    er = new Uint8ClampedArray(0),
-    v3 = {
+    Ki = new Uint8ClampedArray(0),
+    Ck = {
         data: {
             type: "data",
-            value: S3,
+            value: Mk,
             async: !0
         },
         dataComparator: {
             type: "function",
             value: null,
             optional: !0
         },
@@ -24136,38 +24136,38 @@
         },
         fetch: {
             type: "function",
             value: (e, {
                 propName: t,
                 layer: r,
                 loaders: i,
-                loadOptions: s,
-                signal: n
+                loadOptions: n,
+                signal: s
             }) => {
                 let {
                     resourceManager: o
                 } = r.context;
-                s = s || r.getLoadOptions(), i = i || r.props.loaders, n && (s = {
-                    ...s,
+                n = n || r.getLoadOptions(), i = i || r.props.loaders, s && (n = {
+                    ...n,
                     fetch: {
-                        ...s?.fetch,
-                        signal: n
+                        ...n?.fetch,
+                        signal: s
                     }
                 });
                 let a = o.contains(e);
-                return !a && !s && (o.add({
+                return !a && !n && (o.add({
                     resourceId: e,
-                    data: kr(e, i),
+                    data: va(e, i),
                     persistent: !1
                 }), a = !0), a ? o.subscribe({
                     resourceId: e,
                     onChange: c => r.internalState?.reloadAsyncProp(t, c),
                     consumerId: r.id,
                     requestId: t
-                }) : kr(e, i, s)
+                }) : va(e, i, n)
             }
         },
         updateTriggers: {},
         visible: !0,
         pickable: !1,
         opacity: {
             type: "number",
@@ -24197,15 +24197,15 @@
             optional: !0
         },
         onDragEnd: {
             type: "function",
             value: null,
             optional: !0
         },
-        coordinateSystem: K.DEFAULT,
+        coordinateSystem: gt.DEFAULT,
         coordinateOrigin: {
             type: "array",
             value: [0, 0, 0],
             compare: !0
         },
         modelMatrix: {
             type: "array",
@@ -24245,48 +24245,48 @@
         highlightedObjectIndex: null,
         autoHighlight: !1,
         highlightColor: {
             type: "accessor",
             value: [0, 0, 128, 128]
         }
     },
-    Rl = class Rl extends ko {
+    Pp = class Pp extends Iu {
         constructor() {
-            super(...arguments), this.internalState = null, this.lifecycle = Yr.NO_STATE, this.parent = null
+            super(...arguments), this.internalState = null, this.lifecycle = Is.NO_STATE, this.parent = null
         }
         static get componentName() {
             return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : ""
         }
         get root() {
             let t = this;
             for (; t.parent;) t = t.parent;
             return t
         }
         toString() {
             return `${this.constructor.layerName||this.constructor.name}({id: '${this.props.id}'})`
         }
         project(t) {
-            lt(this.internalState);
+            Ht(this.internalState);
             let r = this.internalState.viewport || this.context.viewport,
-                i = fd(t, {
+                i = tb(t, {
                     viewport: r,
                     modelMatrix: this.props.modelMatrix,
                     coordinateOrigin: this.props.coordinateOrigin,
                     coordinateSystem: this.props.coordinateSystem
                 }),
-                [s, n, o] = bs(i, r.pixelProjectionMatrix);
-            return t.length === 2 ? [s, n] : [s, n, o]
+                [n, s, o] = Va(i, r.pixelProjectionMatrix);
+            return t.length === 2 ? [n, s] : [n, s, o]
         }
         unproject(t) {
-            return lt(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(t)
+            return Ht(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(t)
         }
         projectPosition(t, r) {
-            lt(this.internalState);
+            Ht(this.internalState);
             let i = this.internalState.viewport || this.context.viewport;
-            return a0(t, {
+            return R1(t, {
                 viewport: i,
                 modelMatrix: this.props.modelMatrix,
                 coordinateOrigin: this.props.coordinateOrigin,
                 coordinateSystem: this.props.coordinateSystem,
                 ...r
             })
         }
@@ -24332,67 +24332,67 @@
         getLoadOptions() {
             return this.props.loadOptions
         }
         use64bitPositions() {
             let {
                 coordinateSystem: t
             } = this.props;
-            return t === K.DEFAULT || t === K.LNGLAT || t === K.CARTESIAN
+            return t === gt.DEFAULT || t === gt.LNGLAT || t === gt.CARTESIAN
         }
         onHover(t, r) {
             return this.props.onHover && this.props.onHover(t, r) || !1
         }
         onClick(t, r) {
             return this.props.onClick && this.props.onClick(t, r) || !1
         }
         nullPickingColor() {
             return [0, 0, 0]
         }
         encodePickingColor(t, r = []) {
             return r[0] = t + 1 & 255, r[1] = t + 1 >> 8 & 255, r[2] = t + 1 >> 8 >> 8 & 255, r
         }
         decodePickingColor(t) {
-            lt(t instanceof Uint8Array);
-            let [r, i, s] = t;
-            return r + i * 256 + s * 65536 - 1
+            Ht(t instanceof Uint8Array);
+            let [r, i, n] = t;
+            return r + i * 256 + n * 65536 - 1
         }
         getNumInstances() {
-            return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : Jy(this.props.data)
+            return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : xE(this.props.data)
         }
         getStartIndices() {
             return this.props.startIndices ? this.props.startIndices : this.state && this.state.startIndices ? this.state.startIndices : null
         }
         getBounds() {
             return this.getAttributeManager()?.getBounds(["positions", "instancePositions"])
         }
         getShaders(t) {
-            t = zd(t, {
+            t = Pb(t, {
                 disableWarnings: !0,
                 modules: this.context.defaultShaderModules
             });
-            for (let r of this.props.extensions) t = zd(t, r.getShaders.call(this, r));
+            for (let r of this.props.extensions) t = Pb(t, r.getShaders.call(this, r));
             return t
         }
         shouldUpdateState(t) {
             return t.changeFlags.propsOrDataChanged
         }
         updateState(t) {
             let r = this.getAttributeManager(),
                 {
                     dataChanged: i
                 } = t.changeFlags;
             if (i && r)
                 if (Array.isArray(i))
-                    for (let s of i) r.invalidateAll(s);
+                    for (let n of i) r.invalidateAll(n);
                 else r.invalidateAll();
             if (r) {
                 let {
-                    props: s
-                } = t, n = this.internalState.hasPickingBuffer, o = Number.isInteger(s.highlightedObjectIndex) || s.pickable || s.extensions.some(a => a.getNeedsPickingBuffer.call(this, a));
-                if (n !== o) {
+                    props: n
+                } = t, s = this.internalState.hasPickingBuffer, o = Number.isInteger(n.highlightedObjectIndex) || n.pickable || n.extensions.some(a => a.getNeedsPickingBuffer.call(this, a));
+                if (s !== o) {
                     this.internalState.hasPickingBuffer = o;
                     let {
                         pickingColors: a,
                         instancePickingColors: c
                     } = r.attributes, l = a || c;
                     l && (o && l.constant && (l.constant = !1, r.invalidate(l.id)), !l.value && !o && (l.constant = !0, l.value = [0, 0, 0]))
                 }
@@ -24410,17 +24410,17 @@
         }
         getPickingInfo({
             info: t,
             mode: r,
             sourceLayer: i
         }) {
             let {
-                index: s
+                index: n
             } = t;
-            return s >= 0 && Array.isArray(this.props.data) && (t.object = this.props.data[s]), t
+            return n >= 0 && Array.isArray(this.props.data) && (t.object = this.props.data[n]), t
         }
         raiseError(t, r) {
             r && (t = new Error(`${r}: ${t.message}`, {
                 cause: t
             })), this.props.onError?.(t) || this.context?.onError?.(t, this)
         }
         getNeedsRedraw(t = {
@@ -24433,15 +24433,15 @@
         }
         hasUniformTransition() {
             return this.internalState?.uniformTransitions.active || !1
         }
         activateViewport(t) {
             if (!this.internalState) return;
             let r = this.internalState.viewport;
-            this.internalState.viewport = t, (!r || !w3({
+            this.internalState.viewport = t, (!r || !Pk({
                 oldViewport: r,
                 viewport: t
             })) && (this.setChangeFlags({
                 viewportChanged: !0
             }), this.isComposite ? this.needsUpdate() && this.setNeedsUpdate() : this._update())
         }
         invalidateAttribute(t = "all") {
@@ -24454,247 +24454,247 @@
             for (let i of this.getModels()) this._setModelAttributes(i, t, r)
         }
         _updateAttributes() {
             let t = this.getAttributeManager();
             if (!t) return;
             let r = this.props,
                 i = this.getNumInstances(),
-                s = this.getStartIndices();
+                n = this.getStartIndices();
             t.update({
                 data: r.data,
                 numInstances: i,
-                startIndices: s,
+                startIndices: n,
                 props: r,
                 transitions: r.transitions,
                 buffers: r.data.attributes,
                 context: this
             });
-            let n = t.getChangedAttributes({
+            let s = t.getChangedAttributes({
                 clearChangedFlags: !0
             });
-            this.updateAttributes(n)
+            this.updateAttributes(s)
         }
         _updateAttributeTransition() {
             let t = this.getAttributeManager();
             t && t.updateTransition()
         }
         _updateUniformTransition() {
             let {
                 uniformTransitions: t
             } = this.internalState;
             if (t.active) {
                 let r = t.update(),
                     i = Object.create(this.props);
-                for (let s in r) Object.defineProperty(i, s, {
-                    value: r[s]
+                for (let n in r) Object.defineProperty(i, n, {
+                    value: r[n]
                 });
                 return i
             }
             return this.props
         }
         calculateInstancePickingColors(t, {
             numInstances: r
         }) {
             if (t.constant) return;
-            let i = Math.floor(er.length / 4);
+            let i = Math.floor(Ki.length / 4);
             if (this.internalState.usesPickingColorCache = !0, i < r) {
-                r > nx && j.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), er = ve.allocate(er, r, {
+                r > EE && Z.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), Ki = ri.allocate(Ki, r, {
                     size: 4,
                     copy: !0,
-                    maxCount: Math.max(r, nx)
+                    maxCount: Math.max(r, EE)
                 });
-                let s = Math.floor(er.length / 4),
-                    n = [];
-                for (let o = i; o < s; o++) this.encodePickingColor(o, n), er[o * 4 + 0] = n[0], er[o * 4 + 1] = n[1], er[o * 4 + 2] = n[2]
+                let n = Math.floor(Ki.length / 4),
+                    s = [];
+                for (let o = i; o < n; o++) this.encodePickingColor(o, s), Ki[o * 4 + 0] = s[0], Ki[o * 4 + 1] = s[1], Ki[o * 4 + 2] = s[2]
             }
-            t.value = er.subarray(0, r * 4)
+            t.value = Ki.subarray(0, r * 4)
         }
         _setModelAttributes(t, r, i = !1) {
             if (!Object.keys(r).length) return;
             if (i) {
                 let a = this.getAttributeManager();
                 t.setBufferLayout(a.getBufferLayouts()), r = a.getAttributes()
             }
-            let s = t.userData?.excludeAttributes || {},
-                n = {},
+            let n = t.userData?.excludeAttributes || {},
+                s = {},
                 o = {};
             for (let a in r) {
-                if (s[a]) continue;
+                if (n[a]) continue;
                 let c = r[a].getValue();
                 for (let l in c) {
-                    let h = c[l];
-                    h instanceof it ? r[a].settings.isIndexed ? t.setIndexBuffer(h) : n[l] = h : h && (o[l] = h)
+                    let u = c[l];
+                    u instanceof Mt ? r[a].settings.isIndexed ? t.setIndexBuffer(u) : s[l] = u : u && (o[l] = u)
                 }
             }
-            t.setAttributes(n), t.setConstantAttributes(o)
+            t.setAttributes(s), t.setConstantAttributes(o)
         }
         disablePickingIndex(t) {
             let r = this.props.data;
             if (!("attributes" in r)) {
                 this._disablePickingIndex(t);
                 return
             }
             let {
                 pickingColors: i,
-                instancePickingColors: s
-            } = this.getAttributeManager().attributes, n = i || s, o = n && r.attributes && r.attributes[n.id];
+                instancePickingColors: n
+            } = this.getAttributeManager().attributes, s = i || n, o = s && r.attributes && r.attributes[s.id];
             if (o && o.value) {
                 let a = o.value,
                     c = this.encodePickingColor(t);
                 for (let l = 0; l < r.length; l++) {
-                    let h = n.getVertexOffset(l);
-                    a[h] === c[0] && a[h + 1] === c[1] && a[h + 2] === c[2] && this._disablePickingIndex(l)
+                    let u = s.getVertexOffset(l);
+                    a[u] === c[0] && a[u + 1] === c[1] && a[u + 2] === c[2] && this._disablePickingIndex(l)
                 }
             } else this._disablePickingIndex(t)
         }
         _disablePickingIndex(t) {
             let {
                 pickingColors: r,
                 instancePickingColors: i
-            } = this.getAttributeManager().attributes, s = r || i;
-            if (!s) return;
-            let n = s.getVertexOffset(t),
-                o = s.getVertexOffset(t + 1);
-            s.buffer.write(new Uint8Array(o - n), n)
+            } = this.getAttributeManager().attributes, n = r || i;
+            if (!n) return;
+            let s = n.getVertexOffset(t),
+                o = n.getVertexOffset(t + 1);
+            n.buffer.write(new Uint8Array(o - s), s)
         }
         restorePickingColors() {
             let {
                 pickingColors: t,
                 instancePickingColors: r
             } = this.getAttributeManager().attributes, i = t || r;
-            i && (this.internalState.usesPickingColorCache && i.value.buffer !== er.buffer && (i.value = er.subarray(0, i.value.length)), i.updateSubBuffer({
+            i && (this.internalState.usesPickingColorCache && i.value.buffer !== Ki.buffer && (i.value = Ki.subarray(0, i.value.length)), i.updateSubBuffer({
                 startOffset: 0
             }))
         }
         _initialize() {
-            lt(!this.internalState), lt(Number.isFinite(this.props.coordinateSystem)), pt(T3, this);
+            Ht(!this.internalState), Ht(Number.isFinite(this.props.coordinateSystem)), Qt(Ak, this);
             let t = this._getAttributeManager();
             t && t.addInstanced({
                 instancePickingColors: {
                     type: "uint8",
                     size: 4,
                     noAlloc: !0,
                     update: this.calculateInstancePickingColors
                 }
-            }), this.internalState = new Bo({
+            }), this.internalState = new Mu({
                 attributeManager: t,
                 layer: this
             }), this._clearChangeFlags(), this.state = {}, Object.defineProperty(this.state, "attributeManager", {
-                get: () => (j.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), t)
-            }), this.internalState.uniformTransitions = new Fo(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
+                get: () => (Z.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), t)
+            }), this.internalState.uniformTransitions = new Au(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
             for (let r of this.props.extensions) r.initializeState.call(this, this.context, r);
             this.setChangeFlags({
                 dataChanged: "init",
                 propsChanged: "init",
                 viewportChanged: !0,
                 extensionsChanged: !0
             }), this._update()
         }
         _transferState(t) {
-            pt(E3, this, this === t);
+            Qt(Rk, this, this === t);
             let {
                 state: r,
                 internalState: i
             } = t;
             this !== t && (this.internalState = i, this.state = r, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()))
         }
         _update() {
             let t = this.needsUpdate();
-            if (pt(b3, this, t), !t) return;
+            if (Qt(Ek, this, t), !t) return;
             let r = this.props,
                 i = this.context,
-                s = this.internalState,
-                n = i.viewport,
+                n = this.internalState,
+                s = i.viewport,
                 o = this._updateUniformTransition();
-            s.propsInTransition = o, i.viewport = s.viewport || n, this.props = o;
+            n.propsInTransition = o, i.viewport = n.viewport || s, this.props = o;
             try {
                 let a = this._getUpdateParams(),
                     c = this.getModels();
                 if (i.device) this.updateState(a);
                 else try {
                     this.updateState(a)
                 } catch {}
-                for (let h of this.props.extensions) h.updateState.call(this, a, h);
+                for (let u of this.props.extensions) u.updateState.call(this, a, u);
                 let l = this.getModels()[0] !== c[0];
                 this._postUpdate(a, l)
             } finally {
-                i.viewport = n, this.props = r, this._clearChangeFlags(), s.needsUpdate = !1, s.resetOldProps()
+                i.viewport = s, this.props = r, this._clearChangeFlags(), n.needsUpdate = !1, n.resetOldProps()
             }
         }
         _finalize() {
-            pt(A3, this), this.finalizeState(this.context);
+            Qt(Ik, this), this.finalizeState(this.context);
             for (let t of this.props.extensions) t.finalizeState.call(this, this.context, t)
         }
         _drawLayer({
             renderPass: t,
             moduleParameters: r = null,
             uniforms: i = {},
-            parameters: s = {}
+            parameters: n = {}
         }) {
             this._updateAttributeTransition();
-            let n = this.props,
+            let s = this.props,
                 o = this.context;
-            this.props = this.internalState.propsInTransition || n;
+            this.props = this.internalState.propsInTransition || s;
             let a = this.props.opacity;
             i.opacity = Math.pow(a, 1 / 2.2);
             try {
                 if (r) {
                     let {
-                        isActive: h,
+                        isActive: u,
                         isAttribute: f
                     } = r.picking;
                     this.setModuleParameters(r), this.setShaderModuleProps({
                         picking: {
-                            isActive: h,
+                            isActive: u,
                             isAttribute: f
                         }
                     })
                 }
                 let {
                     getPolygonOffset: c
                 } = this.props, l = c && c(i) || [0, 0];
                 o.device.setParametersWebGL({
                     polygonOffset: l
                 });
-                for (let h of this.getModels()) h.setParameters(s);
-                o.device.withParametersWebGL(s, () => {
-                    let h = {
+                for (let u of this.getModels()) u.setParameters(n);
+                o.device.withParametersWebGL(n, () => {
+                    let u = {
                         renderPass: t,
                         moduleParameters: r,
                         uniforms: i,
-                        parameters: s,
+                        parameters: n,
                         context: o
                     };
-                    for (let f of this.props.extensions) f.draw.call(this, h, f);
-                    this.draw(h)
+                    for (let f of this.props.extensions) f.draw.call(this, u, f);
+                    this.draw(u)
                 })
             } finally {
-                this.props = n
+                this.props = s
             }
         }
         getChangeFlags() {
             return this.internalState?.changeFlags
         }
         setChangeFlags(t) {
             if (!this.internalState) return;
             let {
                 changeFlags: r
             } = this.internalState;
-            for (let s in t)
-                if (t[s]) {
-                    let n = !1;
-                    switch (s) {
+            for (let n in t)
+                if (t[n]) {
+                    let s = !1;
+                    switch (n) {
                         case "dataChanged":
-                            let o = t[s],
-                                a = r[s];
-                            o && Array.isArray(a) && (r.dataChanged = Array.isArray(o) ? a.concat(o) : o, n = !0);
+                            let o = t[n],
+                                a = r[n];
+                            o && Array.isArray(a) && (r.dataChanged = Array.isArray(o) ? a.concat(o) : o, s = !0);
                         default:
-                            r[s] || (r[s] = t[s], n = !0)
+                            r[n] || (r[n] = t[n], s = !0)
                     }
-                    n && pt(x3, this, s, t)
+                    s && Qt(Sk, this, n, t)
                 } let i = !!(r.dataChanged || r.updateTriggersChanged || r.propsChanged || r.extensionsChanged);
             r.propsOrDataChanged = i, r.somethingChanged = i || r.viewportChanged || r.stateChanged
         }
         _clearChangeFlags() {
             this.internalState.changeFlags = {
                 dataChanged: !1,
                 propsChanged: !1,
@@ -24703,23 +24703,23 @@
                 stateChanged: !1,
                 extensionsChanged: !1,
                 propsOrDataChanged: !1,
                 somethingChanged: !1
             }
         }
         _diffProps(t, r) {
-            let i = Qy(t, r);
+            let i = yE(t, r);
             if (i.updateTriggersChanged)
-                for (let s in i.updateTriggersChanged) i.updateTriggersChanged[s] && this.invalidateAttribute(s);
+                for (let n in i.updateTriggersChanged) i.updateTriggersChanged[n] && this.invalidateAttribute(n);
             if (i.transitionsChanged)
-                for (let s in i.transitionsChanged) this.internalState.uniformTransitions.add(s, r[s], t[s], t.transitions?.[s]);
+                for (let n in i.transitionsChanged) this.internalState.uniformTransitions.add(n, r[n], t[n], t.transitions?.[n]);
             return this.setChangeFlags(i)
         }
         validateProps() {
-            Ky(this.props)
+            _E(this.props)
         }
         updateAutoHighlight(t) {
             this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex) && this._updateAutoHighlight(t)
         }
         _updateAutoHighlight(t) {
             let r = {
                     highlightedObjectColor: t.picked ? t.color : null
@@ -24729,34 +24729,34 @@
                 } = this.props;
             t.picked && typeof i == "function" && (r.highlightColor = i(t)), this.setShaderModuleProps({
                 picking: r
             }), this.setNeedsRedraw()
         }
         _getAttributeManager() {
             let t = this.context;
-            return new Us(t.device, {
+            return new nc(t.device, {
                 id: this.props.id,
                 stats: t.stats,
                 timeline: t.timeline
             })
         }
         _postUpdate(t, r) {
             let {
                 props: i,
-                oldProps: s
+                oldProps: n
             } = t;
             this.setNeedsRedraw(), this._updateAttributes(), this.state.model?.setInstanceCount(this.getNumInstances());
             let {
                 autoHighlight: o,
                 highlightedObjectIndex: a,
                 highlightColor: c
             } = i;
-            if (r || s.autoHighlight !== o || s.highlightedObjectIndex !== a || s.highlightColor !== c) {
+            if (r || n.autoHighlight !== o || n.highlightedObjectIndex !== a || n.highlightColor !== c) {
                 let l = {};
-                o || (l.highlightedObjectColor = null), Array.isArray(c) && (l.highlightColor = c), (r || a !== s.highlightedObjectIndex) && (l.highlightedObjectColor = Number.isFinite(a) && a >= 0 ? this.encodePickingColor(a) : null), this.setShaderModuleProps({
+                o || (l.highlightedObjectColor = null), Array.isArray(c) && (l.highlightColor = c), (r || a !== n.highlightedObjectIndex) && (l.highlightedObjectColor = Number.isFinite(a) && a >= 0 ? this.encodePickingColor(a) : null), this.setShaderModuleProps({
                     picking: l
                 })
             }
         }
         _getUpdateParams() {
             return {
                 props: this.props,
@@ -24766,27 +24766,27 @@
             }
         }
         _getNeedsRedraw(t) {
             if (!this.internalState) return !1;
             let r = !1;
             r = r || this.internalState.needsRedraw && this.id;
             let i = this.getAttributeManager(),
-                s = i ? i.getNeedsRedraw(t) : !1;
-            if (r = r || s, r)
-                for (let n of this.props.extensions) n.onNeedsRedraw.call(this, n);
+                n = i ? i.getNeedsRedraw(t) : !1;
+            if (r = r || n, r)
+                for (let s of this.props.extensions) s.onNeedsRedraw.call(this, s);
             return this.internalState.needsRedraw = this.internalState.needsRedraw && !t.clearRedrawFlags, r
         }
         _onAsyncPropUpdated() {
             this._diffProps(this.props, this.internalState.getOldProps()), this.setNeedsUpdate()
         }
     };
-Rl.defaultProps = v3, Rl.layerName = "Layer";
-var Et = Rl;
-var R3 = "compositeLayer.renderLayers",
-    $d = class $d extends Et {
+Pp.defaultProps = Ck, Pp.layerName = "Layer";
+var de = Pp;
+var Ok = "compositeLayer.renderLayers",
+    Fb = class Fb extends de {
         get isComposite() {
             return !0
         }
         get isLoaded() {
             return super.isLoaded && this.getSubLayers().every(t => t.isLoaded)
         }
         getSubLayers() {
@@ -24826,197 +24826,197 @@
         getSubLayerAccessor(t) {
             if (typeof t == "function") {
                 let r = {
                     index: -1,
                     data: this.props.data,
                     target: []
                 };
-                return (i, s) => i && i.__source ? (r.index = i.__source.index, t(i.__source.object, r)) : t(i, s)
+                return (i, n) => i && i.__source ? (r.index = i.__source.index, t(i.__source.object, r)) : t(i, n)
             }
             return t
         }
         getSubLayerProps(t = {}) {
             let {
                 opacity: r,
                 pickable: i,
-                visible: s,
-                parameters: n,
+                visible: n,
+                parameters: s,
                 getPolygonOffset: o,
                 highlightedObjectIndex: a,
                 autoHighlight: c,
                 highlightColor: l,
-                coordinateSystem: h,
+                coordinateSystem: u,
                 coordinateOrigin: f,
-                wrapLongitude: u,
+                wrapLongitude: h,
                 positionFormat: d,
-                modelMatrix: m,
+                modelMatrix: p,
                 extensions: y,
-                fetch: x,
-                operation: A,
-                _subLayerProps: v
-            } = this.props, E = {
+                fetch: b,
+                operation: T,
+                _subLayerProps: I
+            } = this.props, S = {
                 id: "",
                 updateTriggers: {},
                 opacity: r,
                 pickable: i,
-                visible: s,
-                parameters: n,
+                visible: n,
+                parameters: s,
                 getPolygonOffset: o,
                 highlightedObjectIndex: a,
                 autoHighlight: c,
                 highlightColor: l,
-                coordinateSystem: h,
+                coordinateSystem: u,
                 coordinateOrigin: f,
-                wrapLongitude: u,
+                wrapLongitude: h,
                 positionFormat: d,
-                modelMatrix: m,
+                modelMatrix: p,
                 extensions: y,
-                fetch: x,
-                operation: A
-            }, R = v && t.id && v[t.id], M = R && R.updateTriggers, C = t.id || "sublayer";
+                fetch: b,
+                operation: T
+            }, R = I && t.id && I[t.id], P = R && R.updateTriggers, C = t.id || "sublayer";
             if (R) {
-                let B = this.props[ye],
-                    L = t.type ? t.type._propTypes : {};
+                let V = this.props[Ur],
+                    U = t.type ? t.type._propTypes : {};
                 for (let k in R) {
-                    let N = L[k] || B[k];
-                    N && N.type === "accessor" && (R[k] = this.getSubLayerAccessor(R[k]))
+                    let B = U[k] || V[k];
+                    B && B.type === "accessor" && (R[k] = this.getSubLayerAccessor(R[k]))
                 }
             }
-            Object.assign(E, t, R), E.id = `${this.props.id}-${C}`, E.updateTriggers = {
+            Object.assign(S, t, R), S.id = `${this.props.id}-${C}`, S.updateTriggers = {
                 all: this.props.updateTriggers?.all,
                 ...t.updateTriggers,
-                ...M
+                ...P
             };
-            for (let B of y) {
-                let L = B.getSubLayerProps.call(this, B);
-                L && Object.assign(E, L, {
-                    updateTriggers: Object.assign(E.updateTriggers, L.updateTriggers)
+            for (let V of y) {
+                let U = V.getSubLayerProps.call(this, V);
+                U && Object.assign(S, U, {
+                    updateTriggers: Object.assign(S.updateTriggers, U.updateTriggers)
                 })
             }
-            return E
+            return S
         }
         _updateAutoHighlight(t) {
             for (let r of this.getSubLayers()) r.updateAutoHighlight(t)
         }
         _getAttributeManager() {
             return null
         }
         _postUpdate(t, r) {
             let i = this.internalState.subLayers,
-                s = !i || this.needsUpdate();
-            if (s) {
-                let n = this.renderLayers();
-                i = gr(n, Boolean), this.internalState.subLayers = i
+                n = !i || this.needsUpdate();
+            if (n) {
+                let s = this.renderLayers();
+                i = Sn(s, Boolean), this.internalState.subLayers = i
             }
-            pt(R3, this, s, i);
-            for (let n of i) n.parent = this
+            Qt(Ok, this, n, i);
+            for (let s of i) s.parent = this
         }
     };
-$d.layerName = "CompositeLayer";
-var Ne = $d;
-var Pl = Math.PI / 180,
-    ox = 180 / Math.PI,
-    Ml = 6370972,
-    Vs = 256;
-
-function P3() {
-    let e = Vs / Ml,
-        t = Math.PI / 180 * Vs;
+Fb.layerName = "CompositeLayer";
+var li = Fb;
+var Cp = Math.PI / 180,
+    IE = 180 / Math.PI,
+    Op = 6370972,
+    sc = 256;
+
+function Nk() {
+    let e = sc / Op,
+        t = Math.PI / 180 * sc;
     return {
         unitsPerMeter: [e, e, e],
         unitsPerMeter2: [0, 0, 0],
         metersPerUnit: [1 / e, 1 / e, 1 / e],
         unitsPerDegree: [t, t, e],
         unitsPerDegree2: [0, 0, 0],
         degreesPerUnit: [1 / t, 1 / t, 1 / e]
     }
 }
-var Hi = class extends me {
+var Uo = class extends Lr {
     constructor(t = {}) {
         let {
             latitude: r = 0,
             longitude: i = 0,
-            zoom: s = 0,
-            nearZMultiplier: n = .1,
+            zoom: n = 0,
+            nearZMultiplier: s = .1,
             farZMultiplier: o = 2,
             resolution: a = 10
         } = t, {
             height: c,
             altitude: l = 1.5
         } = t;
         c = c || 1, l = Math.max(.75, l);
-        let h = new ot().lookAt({
+        let u = new Dt().lookAt({
                 eye: [0, -l, 0],
                 up: [0, 0, 1]
             }),
-            f = Math.pow(2, s);
-        h.rotateX(r * Pl), h.rotateZ(-i * Pl), h.scale(f / c);
-        let u = Math.atan(.5 / l),
-            d = Vs * 2 * f / c;
+            f = Math.pow(2, n);
+        u.rotateX(r * Cp), u.rotateZ(-i * Cp), u.scale(f / c);
+        let h = Math.atan(.5 / l),
+            d = sc * 2 * f / c;
         super({
             ...t,
             height: c,
-            viewMatrix: h,
+            viewMatrix: u,
             longitude: i,
             latitude: r,
-            zoom: s,
-            distanceScales: P3(),
-            fovyRadians: u * 2,
+            zoom: n,
+            distanceScales: Nk(),
+            fovyRadians: h * 2,
             focalDistance: l,
-            near: n,
+            near: s,
             far: Math.min(2, 1 / d + 1) * l * o
         }), this.latitude = r, this.longitude = i, this.resolution = a
     }
     get projectionMode() {
-        return Nt.GLOBE
+        return Pe.GLOBE
     }
     getDistanceScales() {
         return this.distanceScales
     }
     getBounds(t = {}) {
         let r = {
                 targetZ: t.z || 0
             },
             i = this.unproject([0, this.height / 2], r),
-            s = this.unproject([this.width / 2, 0], r),
-            n = this.unproject([this.width, this.height / 2], r),
+            n = this.unproject([this.width / 2, 0], r),
+            s = this.unproject([this.width, this.height / 2], r),
             o = this.unproject([this.width / 2, this.height], r);
-        return n[0] < this.longitude && (n[0] += 360), i[0] > this.longitude && (i[0] -= 360), [Math.min(i[0], n[0], s[0], o[0]), Math.min(i[1], n[1], s[1], o[1]), Math.max(i[0], n[0], s[0], o[0]), Math.max(i[1], n[1], s[1], o[1])]
+        return s[0] < this.longitude && (s[0] += 360), i[0] > this.longitude && (i[0] -= 360), [Math.min(i[0], s[0], n[0], o[0]), Math.min(i[1], s[1], n[1], o[1]), Math.max(i[0], s[0], n[0], o[0]), Math.max(i[1], s[1], n[1], o[1])]
     }
     unproject(t, {
         topLeft: r = !0,
         targetZ: i
     } = {}) {
-        let [s, n, o] = t, a = r ? n : this.height - n, {
+        let [n, s, o] = t, a = r ? s : this.height - s, {
             pixelUnprojectionMatrix: c
         } = this, l;
-        if (Number.isFinite(o)) l = Yd(c, [s, a, o, 1]);
+        if (Number.isFinite(o)) l = Db(c, [n, a, o, 1]);
         else {
-            let d = Yd(c, [s, a, -1, 1]),
-                m = Yd(c, [s, a, 1, 1]),
-                y = ((i || 0) / Ml + 1) * Vs,
-                x = qt.sqrLen(qt.sub([], d, m)),
-                A = qt.sqrLen(d),
-                v = qt.sqrLen(m),
-                R = 4 * ((4 * A * v - (x - A - v) ** 2) / 16) / x,
-                M = Math.sqrt(A - R),
+            let d = Db(c, [n, a, -1, 1]),
+                p = Db(c, [n, a, 1, 1]),
+                y = ((i || 0) / Op + 1) * sc,
+                b = Je.sqrLen(Je.sub([], d, p)),
+                T = Je.sqrLen(d),
+                I = Je.sqrLen(p),
+                R = 4 * ((4 * T * I - (b - T - I) ** 2) / 16) / b,
+                P = Math.sqrt(T - R),
                 C = Math.sqrt(Math.max(0, y * y - R)),
-                B = (M - C) / Math.sqrt(x);
-            l = qt.lerp([], d, m, B)
+                V = (P - C) / Math.sqrt(b);
+            l = Je.lerp([], d, p, V)
         }
-        let [h, f, u] = this.unprojectPosition(l);
-        return Number.isFinite(o) ? [h, f, u] : Number.isFinite(i) ? [h, f, i] : [h, f]
+        let [u, f, h] = this.unprojectPosition(l);
+        return Number.isFinite(o) ? [u, f, h] : Number.isFinite(i) ? [u, f, i] : [u, f]
     }
     projectPosition(t) {
-        let [r, i, s = 0] = t, n = r * Pl, o = i * Pl, a = Math.cos(o), c = (s / Ml + 1) * Vs;
-        return [Math.sin(n) * a * c, -Math.cos(n) * a * c, Math.sin(o) * c]
+        let [r, i, n = 0] = t, s = r * Cp, o = i * Cp, a = Math.cos(o), c = (n / Op + 1) * sc;
+        return [Math.sin(s) * a * c, -Math.cos(s) * a * c, Math.sin(o) * c]
     }
     unprojectPosition(t) {
-        let [r, i, s] = t, n = qt.len(t), o = Math.asin(s / n), c = Math.atan2(r, -i) * ox, l = o * ox, h = (n / Vs - 1) * Ml;
-        return [c, l, h]
+        let [r, i, n] = t, s = Je.len(t), o = Math.asin(n / s), c = Math.atan2(r, -i) * IE, l = o * IE, u = (s / sc - 1) * Op;
+        return [c, l, u]
     }
     projectFlat(t) {
         return t
     }
     unprojectFlat(t) {
         return t
     }
@@ -25025,85 +25025,85 @@
         return {
             longitude: t[0] - i[0] + this.longitude,
             latitude: t[1] - i[1] + this.latitude
         }
     }
 };
 
-function Yd(e, t) {
-    let r = Zt.transformMat4([], t, e);
-    return Zt.scale(r, r, 1 / r[3]), r
+function Db(e, t) {
+    let r = Qe.transformMat4([], t, e);
+    return Qe.scale(r, r, 1 / r[3]), r
 }
-var M3 = new ot().lookAt({
+var Bk = new Dt().lookAt({
     eye: [0, 0, 1]
 });
 
-function C3({
+function Fk({
     width: e,
     height: t,
     near: r,
     far: i,
-    padding: s
+    padding: n
 }) {
-    let n = -e / 2,
+    let s = -e / 2,
         o = e / 2,
         a = -t / 2,
         c = t / 2;
-    if (s) {
+    if (n) {
         let {
             left: l = 0,
-            right: h = 0,
+            right: u = 0,
             top: f = 0,
-            bottom: u = 0
-        } = s, d = ct((l + e - h) / 2, 0, e) - e / 2, m = ct((f + t - u) / 2, 0, t) - t / 2;
-        n -= d, o -= d, a += m, c += m
+            bottom: h = 0
+        } = n, d = jt((l + e - u) / 2, 0, e) - e / 2, p = jt((f + t - h) / 2, 0, t) - t / 2;
+        s -= d, o -= d, a += p, c += p
     }
-    return new ot().ortho({
-        left: n,
+    return new Dt().ortho({
+        left: s,
         right: o,
         bottom: a,
         top: c,
         near: r,
         far: i
     })
 }
-var zs = class extends me {
+var oc = class extends Lr {
     constructor(t) {
         let {
             width: r,
             height: i,
-            near: s = .1,
-            far: n = 1e3,
+            near: n = .1,
+            far: s = 1e3,
             zoom: o = 0,
             target: a = [0, 0, 0],
             padding: c = null,
             flipY: l = !0
-        } = t, h = Array.isArray(o) ? o[0] : o, f = Array.isArray(o) ? o[1] : o, u = Math.min(h, f), d = Math.pow(2, u), m;
-        if (h !== f) {
-            let y = Math.pow(2, h),
-                x = Math.pow(2, f);
-            m = {
-                unitsPerMeter: [y / d, x / d, 1],
-                metersPerUnit: [d / y, d / x, 1]
+        } = t, u = Array.isArray(o) ? o[0] : o, f = Array.isArray(o) ? o[1] : o, h = Math.min(u, f), d = Math.pow(2, h), p;
+        if (u !== f) {
+            let y = Math.pow(2, u),
+                b = Math.pow(2, f);
+            p = {
+                unitsPerMeter: [y / d, b / d, 1],
+                metersPerUnit: [d / y, d / b, 1]
             }
         }
         super({
             ...t,
             longitude: void 0,
             position: a,
-            viewMatrix: M3.clone().scale([d, d * (l ? -1 : 1), d]),
-            projectionMatrix: C3({
+            viewMatrix: Bk.clone().scale([d, d * (l ? -1 : 1), d]),
+            projectionMatrix: Fk({
                 width: r || 1,
                 height: i || 1,
                 padding: c,
-                near: s,
-                far: n
+                near: n,
+                far: s
             }),
-            zoom: u,
-            distanceScales: m
+            zoom: h,
+            distanceScales: p
         })
     }
     projectFlat([t, r]) {
         let {
             unitsPerMeter: i
         } = this.distanceScales;
         return [t * i[0], r * i[1]]
@@ -25111,61 +25111,61 @@
     unprojectFlat([t, r]) {
         let {
             metersPerUnit: i
         } = this.distanceScales;
         return [t * i[0], r * i[1]]
     }
     panByPosition(t, r) {
-        let i = qe(r, this.pixelUnprojectionMatrix),
-            s = this.projectFlat(t),
-            n = Yt.add([], s, Yt.negate([], i)),
-            o = Yt.add([], this.center, n);
+        let i = ji(r, this.pixelUnprojectionMatrix),
+            n = this.projectFlat(t),
+            s = Ge.add([], n, Ge.negate([], i)),
+            o = Ge.add([], this.center, s);
         return {
             target: this.unprojectFlat(o)
         }
     }
 };
-var Cl = class extends Di {
+var Np = class extends Po {
     constructor(t) {
         let {
             width: r,
             height: i,
-            rotationX: s = 0,
-            rotationOrbit: n = 0,
+            rotationX: n = 0,
+            rotationOrbit: s = 0,
             target: o = [0, 0, 0],
             zoom: a = 0,
             minRotationX: c = -90,
             maxRotationX: l = 90,
-            minZoom: h = -1 / 0,
+            minZoom: u = -1 / 0,
             maxZoom: f = 1 / 0,
-            startPanPosition: u,
+            startPanPosition: h,
             startRotatePos: d,
-            startRotationX: m,
+            startRotationX: p,
             startRotationOrbit: y,
-            startZoomPosition: x,
-            startZoom: A
+            startZoomPosition: b,
+            startZoom: T
         } = t;
         super({
             width: r,
             height: i,
-            rotationX: s,
-            rotationOrbit: n,
+            rotationX: n,
+            rotationOrbit: s,
             target: o,
             zoom: a,
             minRotationX: c,
             maxRotationX: l,
-            minZoom: h,
+            minZoom: u,
             maxZoom: f
         }, {
-            startPanPosition: u,
+            startPanPosition: h,
             startRotatePos: d,
-            startRotationX: m,
+            startRotationX: p,
             startRotationOrbit: y,
-            startZoomPosition: x,
-            startZoom: A
+            startZoomPosition: b,
+            startZoom: T
         }), this.makeViewport = t.makeViewport
     }
     panStart({
         pos: t
     }) {
         return this._getUpdatedState({
             startPanPosition: this._unproject(t)
@@ -25173,16 +25173,16 @@
     }
     pan({
         pos: t,
         startPosition: r
     }) {
         let i = this.getState().startPanPosition || r;
         if (!i) return this;
-        let n = this.makeViewport(this.getViewportProps()).panByPosition(i, t);
-        return this._getUpdatedState(n)
+        let s = this.makeViewport(this.getViewportProps()).panByPosition(i, t);
+        return this._getUpdatedState(s)
     }
     panEnd() {
         return this._getUpdatedState({
             startPanPosition: null
         })
     }
     rotateStart({
@@ -25196,32 +25196,32 @@
     }
     rotate({
         pos: t,
         deltaAngleX: r = 0,
         deltaAngleY: i = 0
     }) {
         let {
-            startRotatePos: s,
-            startRotationX: n,
+            startRotatePos: n,
+            startRotationX: s,
             startRotationOrbit: o
         } = this.getState(), {
             width: a,
             height: c
         } = this.getViewportProps();
-        if (!s || n === void 0 || o === void 0) return this;
+        if (!n || s === void 0 || o === void 0) return this;
         let l;
         if (t) {
-            let h = (t[0] - s[0]) / a,
-                f = (t[1] - s[1]) / c;
-            (n < -90 || n > 90) && (h *= -1), l = {
-                rotationX: n + f * 180,
-                rotationOrbit: o + h * 180
+            let u = (t[0] - n[0]) / a,
+                f = (t[1] - n[1]) / c;
+            (s < -90 || s > 90) && (u *= -1), l = {
+                rotationX: s + f * 180,
+                rotationOrbit: o + u * 180
             }
         } else l = {
-            rotationX: n + i,
+            rotationX: s + i,
             rotationOrbit: o + r
         };
         return this._getUpdatedState(l)
     }
     rotateEnd() {
         return this._getUpdatedState({
             startRotationX: null,
@@ -25230,17 +25230,17 @@
     }
     shortestPathFrom(t) {
         let r = t.getViewportProps(),
             i = {
                 ...this.getViewportProps()
             },
             {
-                rotationOrbit: s
+                rotationOrbit: n
             } = i;
-        return Math.abs(s - r.rotationOrbit) > 180 && (i.rotationOrbit = s < 0 ? s + 360 : s - 360), i
+        return Math.abs(n - r.rotationOrbit) > 180 && (i.rotationOrbit = n < 0 ? n + 360 : n - 360), i
     }
     zoomStart({
         pos: t
     }) {
         return this._getUpdatedState({
             startZoomPosition: this._unproject(t),
             startZoom: this.getViewportProps().zoom
@@ -25248,29 +25248,29 @@
     }
     zoom({
         pos: t,
         startPos: r,
         scale: i
     }) {
         let {
-            startZoom: s,
-            startZoomPosition: n
+            startZoom: n,
+            startZoomPosition: s
         } = this.getState();
-        if (n || (s = this.getViewportProps().zoom, n = this._unproject(r) || this._unproject(t)), !n) return this;
+        if (s || (n = this.getViewportProps().zoom, s = this._unproject(r) || this._unproject(t)), !s) return this;
         let o = this._calculateNewZoom({
                 scale: i,
-                startZoom: s
+                startZoom: n
             }),
             a = this.makeViewport({
                 ...this.getViewportProps(),
                 zoom: o
             });
         return this._getUpdatedState({
             zoom: o,
-            ...a.panByPosition(n, t)
+            ...a.panByPosition(s, t)
         })
     }
     zoomEnd() {
         return this._getUpdatedState({
             startZoomPosition: null,
             startZoom: null
         })
@@ -25327,28 +25327,28 @@
     }
     _calculateNewZoom({
         scale: t,
         startZoom: r
     }) {
         let {
             maxZoom: i,
-            minZoom: s
+            minZoom: n
         } = this.getViewportProps();
         r === void 0 && (r = this.getViewportProps().zoom);
-        let n = r + Math.log2(t);
-        return ct(n, s, i)
+        let s = r + Math.log2(t);
+        return jt(s, n, i)
     }
     _panFromCenter(t) {
         let {
             width: r,
             height: i,
-            target: s
+            target: n
         } = this.getViewportProps();
         return this.pan({
-            startPosition: s,
+            startPosition: n,
             pos: [r / 2 + t[0], i / 2 + t[1]]
         })
     }
     _getUpdatedState(t) {
         return new this.constructor({
             makeViewport: this.makeViewport,
             ...this.getViewportProps(),
@@ -25356,229 +25356,229 @@
             ...t
         })
     }
     applyConstraints(t) {
         let {
             maxZoom: r,
             minZoom: i,
-            zoom: s,
-            maxRotationX: n,
+            zoom: n,
+            maxRotationX: s,
             minRotationX: o,
             rotationOrbit: a
         } = t;
-        return t.zoom = Array.isArray(s) ? [ct(s[0], i, r), ct(s[1], i, r)] : ct(s, i, r), t.rotationX = ct(t.rotationX, o, n), (a < -180 || a > 180) && (t.rotationOrbit = t0(a + 180, 360) - 180), t
+        return t.zoom = Array.isArray(n) ? [jt(n[0], i, r), jt(n[1], i, r)] : jt(n, i, r), t.rotationX = jt(t.rotationX, o, s), (a < -180 || a > 180) && (t.rotationOrbit = w1(a + 180, 360) - 180), t
     }
 };
-var qd = class extends Cl {
+var Lb = class extends Np {
         constructor(t) {
             super(t), this.zoomAxis = t.zoomAxis || "all"
         }
         _calculateNewZoom({
             scale: t,
             startZoom: r
         }) {
             let {
                 maxZoom: i,
-                minZoom: s
+                minZoom: n
             } = this.getViewportProps();
             r === void 0 && (r = this.getViewportProps().zoom);
-            let n = Math.log2(t);
+            let s = Math.log2(t);
             if (Array.isArray(r)) {
                 let [o, a] = r;
                 switch (this.zoomAxis) {
                     case "X":
-                        o = ct(o + n, s, i);
+                        o = jt(o + s, n, i);
                         break;
                     case "Y":
-                        a = ct(a + n, s, i);
+                        a = jt(a + s, n, i);
                         break;
                     default:
-                        let c = Math.min(o + n, a + n);
-                        c < s && (n += s - c), c = Math.max(o + n, a + n), c > i && (n += i - c), o += n, a += n
+                        let c = Math.min(o + s, a + s);
+                        c < n && (s += n - c), c = Math.max(o + s, a + s), c > i && (s += i - c), o += s, a += s
                 }
                 return [o, a]
             }
-            return ct(r + n, s, i)
+            return jt(r + s, n, i)
         }
     },
-    Ws = class extends Kr {
+    ac = class extends Ps {
         constructor() {
-            super(...arguments), this.ControllerState = qd, this.transition = {
+            super(...arguments), this.ControllerState = Lb, this.transition = {
                 transitionDuration: 300,
-                transitionInterpolator: new Ke(["target", "zoom"])
+                transitionInterpolator: new $i(["target", "zoom"])
             }, this.dragMode = "pan"
         }
         _onPanRotate() {
             return !1
         }
     };
-var Zd = class Zd extends qr {
+var kb = class kb extends Rs {
     get ViewportType() {
-        return zs
+        return oc
     }
     get ControllerType() {
-        return Ws
+        return ac
     }
 };
-Zd.displayName = "OrthographicView";
-var Xi = Zd;
-var xr = class {
+kb.displayName = "OrthographicView";
+var Vo = kb;
+var Rn = class {
     constructor(t) {
         this.indexStarts = [0], this.vertexStarts = [0], this.vertexCount = 0, this.instanceCount = 0;
         let {
             attributes: r = {}
         } = t;
-        this.typedArrayManager = ve, this.attributes = {}, this._attributeDefs = r, this.opts = t, this.updateGeometry(t)
+        this.typedArrayManager = ri, this.attributes = {}, this._attributeDefs = r, this.opts = t, this.updateGeometry(t)
     }
     updateGeometry(t) {
         Object.assign(this.opts, t);
         let {
             data: r,
             buffers: i = {},
-            getGeometry: s,
-            geometryBuffer: n,
+            getGeometry: n,
+            geometryBuffer: s,
             positionFormat: o,
             dataChanged: a,
             normalize: c = !0
         } = this.opts;
-        if (this.data = r, this.getGeometry = s, this.positionSize = n && n.size || (o === "XY" ? 2 : 3), this.buffers = i, this.normalize = c, n && (lt(r.startIndices), this.getGeometry = this.getGeometryFromBuffer(n), c || (i.vertexPositions = n)), this.geometryBuffer = i.vertexPositions, Array.isArray(a))
+        if (this.data = r, this.getGeometry = n, this.positionSize = s && s.size || (o === "XY" ? 2 : 3), this.buffers = i, this.normalize = c, s && (Ht(r.startIndices), this.getGeometry = this.getGeometryFromBuffer(s), c || (i.vertexPositions = s)), this.geometryBuffer = i.vertexPositions, Array.isArray(a))
             for (let l of a) this._rebuildGeometry(l);
         else this._rebuildGeometry()
     }
     updatePartialGeometry({
         startRow: t,
         endRow: r
     }) {
         this._rebuildGeometry({
             startRow: t,
             endRow: r
         })
     }
     getGeometryFromBuffer(t) {
         let r = t.value || t;
-        return ArrayBuffer.isView(r) ? yl(r, {
+        return ArrayBuffer.isView(r) ? wp(r, {
             size: this.positionSize,
             offset: t.offset,
             stride: t.stride,
             startIndices: this.data.startIndices
         }) : null
     }
     _allocate(t, r) {
         let {
             attributes: i,
-            buffers: s,
-            _attributeDefs: n,
+            buffers: n,
+            _attributeDefs: s,
             typedArrayManager: o
         } = this;
-        for (let a in n)
-            if (a in s) o.release(i[a]), i[a] = null;
+        for (let a in s)
+            if (a in n) o.release(i[a]), i[a] = null;
             else {
-                let c = n[a];
+                let c = s[a];
                 c.copy = r, i[a] = o.allocate(i[a], t, c)
             }
     }
     _forEachGeometry(t, r, i) {
         let {
-            data: s,
-            getGeometry: n
+            data: n,
+            getGeometry: s
         } = this, {
             iterable: o,
             objectInfo: a
-        } = tr(s, r, i);
+        } = Zi(n, r, i);
         for (let c of o) {
             a.index++;
-            let l = n ? n(c, a) : null;
+            let l = s ? s(c, a) : null;
             t(l, a.index)
         }
     }
     _rebuildGeometry(t) {
         if (!this.data) return;
         let {
             indexStarts: r,
             vertexStarts: i,
-            instanceCount: s
+            instanceCount: n
         } = this, {
-            data: n,
+            data: s,
             geometryBuffer: o
         } = this, {
             startRow: a = 0,
             endRow: c = 1 / 0
         } = t || {}, l = {};
-        if (t || (r = [0], i = [0]), this.normalize || !o) this._forEachGeometry((f, u) => {
+        if (t || (r = [0], i = [0]), this.normalize || !o) this._forEachGeometry((f, h) => {
             let d = f && this.normalizeGeometry(f);
-            l[u] = d, i[u + 1] = i[u] + (d ? this.getGeometrySize(d) : 0)
-        }, a, c), s = i[i.length - 1];
-        else if (i = n.startIndices, s = i[n.length] || 0, ArrayBuffer.isView(o)) s = s || o.length / this.positionSize;
-        else if (o instanceof it) {
+            l[h] = d, i[h + 1] = i[h] + (d ? this.getGeometrySize(d) : 0)
+        }, a, c), n = i[i.length - 1];
+        else if (i = s.startIndices, n = i[s.length] || 0, ArrayBuffer.isView(o)) n = n || o.length / this.positionSize;
+        else if (o instanceof Mt) {
             let f = this.positionSize * 4;
-            s = s || o.byteLength / f
+            n = n || o.byteLength / f
         } else if (o.buffer) {
             let f = o.stride || this.positionSize * 4;
-            s = s || o.buffer.byteLength / f
+            n = n || o.buffer.byteLength / f
         } else if (o.value) {
             let f = o.value,
-                u = o.stride / f.BYTES_PER_ELEMENT || this.positionSize;
-            s = s || f.length / u
+                h = o.stride / f.BYTES_PER_ELEMENT || this.positionSize;
+            n = n || f.length / h
         }
-        this._allocate(s, !!t), this.indexStarts = r, this.vertexStarts = i, this.instanceCount = s;
-        let h = {};
-        this._forEachGeometry((f, u) => {
-            let d = l[u] || f;
-            h.vertexStart = i[u], h.indexStart = r[u];
-            let m = u < i.length - 1 ? i[u + 1] : s;
-            h.geometrySize = m - i[u], h.geometryIndex = u, this.updateGeometryAttributes(d, h)
+        this._allocate(n, !!t), this.indexStarts = r, this.vertexStarts = i, this.instanceCount = n;
+        let u = {};
+        this._forEachGeometry((f, h) => {
+            let d = l[h] || f;
+            u.vertexStart = i[h], u.indexStart = r[h];
+            let p = h < i.length - 1 ? i[h + 1] : n;
+            u.geometrySize = p - i[h], u.geometryIndex = h, this.updateGeometryAttributes(d, u)
         }, a, c), this.vertexCount = r[r.length - 1]
     }
 };
-var O3 = new Uint32Array([0, 2, 1, 0, 3, 2]),
-    N3 = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
+var Lk = new Uint32Array([0, 2, 1, 0, 3, 2]),
+    kk = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
 
-function Kd(e, t) {
-    if (!t) return F3(e);
+function Ub(e, t) {
+    if (!t) return Uk(e);
     let r = Math.max(Math.abs(e[0][0] - e[3][0]), Math.abs(e[1][0] - e[2][0])),
         i = Math.max(Math.abs(e[1][1] - e[0][1]), Math.abs(e[2][1] - e[3][1])),
-        s = Math.ceil(r / t) + 1,
-        n = Math.ceil(i / t) + 1,
-        o = (s - 1) * (n - 1) * 6,
+        n = Math.ceil(r / t) + 1,
+        s = Math.ceil(i / t) + 1,
+        o = (n - 1) * (s - 1) * 6,
         a = new Uint32Array(o),
-        c = new Float32Array(s * n * 2),
-        l = new Float64Array(s * n * 3),
-        h = 0,
+        c = new Float32Array(n * s * 2),
+        l = new Float64Array(n * s * 3),
+        u = 0,
         f = 0;
-    for (let u = 0; u < s; u++) {
-        let d = u / (s - 1);
-        for (let m = 0; m < n; m++) {
-            let y = m / (n - 1),
-                x = D3(e, d, y);
-            l[h * 3 + 0] = x[0], l[h * 3 + 1] = x[1], l[h * 3 + 2] = x[2] || 0, c[h * 2 + 0] = d, c[h * 2 + 1] = 1 - y, u > 0 && m > 0 && (a[f++] = h - n, a[f++] = h - n - 1, a[f++] = h - 1, a[f++] = h - n, a[f++] = h - 1, a[f++] = h), h++
+    for (let h = 0; h < n; h++) {
+        let d = h / (n - 1);
+        for (let p = 0; p < s; p++) {
+            let y = p / (s - 1),
+                b = Vk(e, d, y);
+            l[u * 3 + 0] = b[0], l[u * 3 + 1] = b[1], l[u * 3 + 2] = b[2] || 0, c[u * 2 + 0] = d, c[u * 2 + 1] = 1 - y, h > 0 && p > 0 && (a[f++] = u - s, a[f++] = u - s - 1, a[f++] = u - 1, a[f++] = u - s, a[f++] = u - 1, a[f++] = u), u++
         }
     }
     return {
         vertexCount: o,
         positions: l,
         indices: a,
         texCoords: c
     }
 }
 
-function F3(e) {
+function Uk(e) {
     let t = new Float64Array(12);
     for (let r = 0; r < e.length; r++) t[r * 3 + 0] = e[r][0], t[r * 3 + 1] = e[r][1], t[r * 3 + 2] = e[r][2] || 0;
     return {
         vertexCount: 6,
         positions: t,
-        indices: O3,
-        texCoords: N3
+        indices: Lk,
+        texCoords: kk
     }
 }
 
-function D3(e, t, r) {
-    return Ee(Ee(e[0], e[1], r), Ee(e[3], e[2], r), t)
+function Vk(e, t, r) {
+    return Qr(Qr(e[0], e[1], r), Qr(e[3], e[2], r), t)
 }
-var ax = `#version 300 es
+var RE = `#version 300 es
 #define SHADER_NAME bitmap-layer-vertex-shader
 
 in vec2 texCoords;
 in vec3 positions;
 in vec3 positions64Low;
 
 out vec2 vTexCoord;
@@ -25604,15 +25604,15 @@
     vTexPos = geometry.worldPosition.xy;
   }
 
   vec4 color = vec4(0.0);
   DECKGL_FILTER_COLOR(color, geometry);
 }
 `;
-var k3 = `
+var zk = `
 vec3 packUVsIntoRGB(vec2 uv) {
   // Extract the top 8 bits. We want values to be truncated down so we can add a fraction
   vec2 uv8bit = floor(uv * 256.);
 
   // Calculate the normalized remainders of u and v parts that do not fit into 8 bits
   // Scale and clamp to 0-1 range
   vec2 uvFraction = fract(uv * 256.);
@@ -25620,15 +25620,15 @@
 
   // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates
   float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;
 
   return vec3(uv8bit, fractions) / 255.;
 }
 `,
-    cx = `#version 300 es
+    ME = `#version 300 es
 #define SHADER_NAME bitmap-layer-fragment-shader
 
 #ifdef GL_ES
 precision highp float;
 #endif
 
 uniform sampler2D bitmapTexture;
@@ -25696,15 +25696,15 @@
 vec2 getUV(vec2 pos) {
   return vec2(
     (pos.x - bounds[0]) / (bounds[2] - bounds[0]),
     (pos.y - bounds[3]) / (bounds[1] - bounds[3])
   );
 }
 
-${k3}
+${zk}
 
 void main(void) {
   vec2 uv = vTexCoord;
   if (coordinateConversion < -0.5) {
     vec2 lnglat = mercator_to_lnglat(vTexPos);
     uv = getUV(lnglat);
   } else if (coordinateConversion > 0.5) {
@@ -25720,26 +25720,26 @@
 
   if (bool(picking.isActive) && !bool(picking.isAttribute)) {
     // Since instance information is not used, we can use picking color for pixel index
     fragColor.rgb = packUVsIntoRGB(uv);
   }
 }
 `;
-var L3 = {
+var Wk = {
         image: {
             type: "image",
             value: null,
             async: !0
         },
         bounds: {
             type: "array",
             value: [1, 0, 0, 1],
             compare: !0
         },
-        _imageCoordinateSystem: K.DEFAULT,
+        _imageCoordinateSystem: gt.DEFAULT,
         desaturate: {
             type: "number",
             min: 0,
             max: 1,
             value: 0
         },
         transparentColor: {
@@ -25752,20 +25752,20 @@
         },
         textureParameters: {
             type: "object",
             ignore: !0,
             value: null
         }
     },
-    Il = class Il extends Et {
+    Bp = class Bp extends de {
         getShaders() {
             return super.getShaders({
-                vs: ax,
-                fs: cx,
-                modules: [Ut, zt]
+                vs: RE,
+                fs: ME,
+                modules: [ke, Ve]
             })
         }
         initializeState() {
             let t = this.getAttributeManager();
             t.remove(["instancePickingColors"]);
             let r = !0;
             t.add({
@@ -25790,44 +25790,44 @@
             })
         }
         updateState({
             props: t,
             oldProps: r,
             changeFlags: i
         }) {
-            let s = this.getAttributeManager();
-            if (i.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), s.invalidateAll()), t.bounds !== r.bounds) {
-                let n = this.state.mesh,
+            let n = this.getAttributeManager();
+            if (i.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), n.invalidateAll()), t.bounds !== r.bounds) {
+                let s = this.state.mesh,
                     o = this._createMesh();
                 this.state.model.setVertexCount(o.vertexCount);
-                for (let a in o) n && n[a] !== o[a] && s.invalidate(a);
+                for (let a in o) s && s[a] !== o[a] && n.invalidate(a);
                 this.setState({
                     mesh: o,
                     ...this._getCoordinateUniforms()
                 })
             } else t._imageCoordinateSystem !== r._imageCoordinateSystem && this.setState(this._getCoordinateUniforms())
         }
         getPickingInfo(t) {
             let {
                 image: r
             } = this.props, i = t.info;
             if (!i.color || !r) return i.bitmap = null, i;
             let {
-                width: s,
-                height: n
+                width: n,
+                height: s
             } = r;
             i.index = 0;
-            let o = B3(i.color);
+            let o = jk(i.color);
             return i.bitmap = {
                 size: {
-                    width: s,
-                    height: n
+                    width: n,
+                    height: s
                 },
                 uv: o,
-                pixel: [Math.floor(o[0] * s), Math.floor(o[1] * n)]
+                pixel: [Math.floor(o[0] * n), Math.floor(o[1] * s)]
             }, i
         }
         disablePickingIndex() {
             this.setState({
                 disablePicking: !0
             })
         }
@@ -25842,100 +25842,100 @@
                 color: this.encodePickingColor(0)
             })
         }
         _createMesh() {
             let {
                 bounds: t
             } = this.props, r = t;
-            return lx(t) && (r = [
+            return PE(t) && (r = [
                 [t[0], t[1]],
                 [t[0], t[3]],
                 [t[2], t[3]],
                 [t[2], t[1]]
-            ]), Kd(r, this.context.viewport.resolution)
+            ]), Ub(r, this.context.viewport.resolution)
         }
         _getModel() {
-            return new bt(this.context.device, {
+            return new ce(this.context.device, {
                 ...this.getShaders(),
                 id: this.props.id,
                 bufferLayout: this.getAttributeManager().getBufferLayouts(),
                 topology: "triangle-list",
                 isInstanced: !1
             })
         }
         draw(t) {
             let {
                 uniforms: r,
                 moduleParameters: i
             } = t, {
-                model: s,
-                coordinateConversion: n,
+                model: n,
+                coordinateConversion: s,
                 bounds: o,
                 disablePicking: a
             } = this.state, {
                 image: c,
                 desaturate: l,
-                transparentColor: h,
+                transparentColor: u,
                 tintColor: f
             } = this.props;
-            i.picking.isActive && a || c && s && (s.setUniforms(r), s.setBindings({
+            i.picking.isActive && a || c && n && (n.setUniforms(r), n.setBindings({
                 bitmapTexture: c
-            }), s.setUniforms({
+            }), n.setUniforms({
                 desaturate: l,
-                transparentColor: h.map(u => u / 255),
-                tintColor: f.slice(0, 3).map(u => u / 255),
-                coordinateConversion: n,
+                transparentColor: u.map(h => h / 255),
+                tintColor: f.slice(0, 3).map(h => h / 255),
+                coordinateConversion: s,
                 bounds: o
-            }), s.draw(this.context.renderPass))
+            }), n.draw(this.context.renderPass))
         }
         _getCoordinateUniforms() {
             let {
                 LNGLAT: t,
                 CARTESIAN: r,
                 DEFAULT: i
-            } = K, {
-                _imageCoordinateSystem: s
+            } = gt, {
+                _imageCoordinateSystem: n
             } = this.props;
-            if (s !== i) {
+            if (n !== i) {
                 let {
-                    bounds: n
+                    bounds: s
                 } = this.props;
-                if (!lx(n)) throw new Error("_imageCoordinateSystem only supports rectangular bounds");
+                if (!PE(s)) throw new Error("_imageCoordinateSystem only supports rectangular bounds");
                 let o = this.context.viewport.resolution ? t : r;
-                if (s = s === t ? t : r, s === t && o === r) return {
+                if (n = n === t ? t : r, n === t && o === r) return {
                     coordinateConversion: -1,
-                    bounds: n
+                    bounds: s
                 };
-                if (s === r && o === t) {
-                    let a = Vt([n[0], n[1]]),
-                        c = Vt([n[2], n[3]]);
+                if (n === r && o === t) {
+                    let a = Ue([s[0], s[1]]),
+                        c = Ue([s[2], s[3]]);
                     return {
                         coordinateConversion: 1,
                         bounds: [a[0], a[1], c[0], c[1]]
                     }
                 }
             }
             return {
                 coordinateConversion: 0,
                 bounds: [0, 0, 0, 0]
             }
         }
     };
-Il.layerName = "BitmapLayer", Il.defaultProps = L3;
-var ri = Il;
+Bp.layerName = "BitmapLayer", Bp.defaultProps = Wk;
+var Ds = Bp;
 
-function B3(e) {
-    let [t, r, i] = e, s = (i & 240) / 256, n = (i & 15) / 16;
-    return [(t + n) / 256, (r + s) / 256]
+function jk(e) {
+    let [t, r, i] = e, n = (i & 240) / 256, s = (i & 15) / 16;
+    return [(t + s) / 256, (r + n) / 256]
 }
 
-function lx(e) {
+function PE(e) {
     return Number.isFinite(e[0])
 }
-var hx = `#version 300 es
+var CE = `#version 300 es
 #define SHADER_NAME icon-layer-vertex-shader
 in vec2 positions;
 in vec3 instancePositions;
 in vec3 instancePositions64Low;
 in float instanceSizes;
 in float instanceAngles;
 in vec4 instanceColors;
@@ -25994,15 +25994,15 @@
 (positions.xy + 1.0) / 2.0
 ) / iconsTextureDim;
 vColor = instanceColors;
 DECKGL_FILTER_COLOR(vColor, geometry);
 vColorMode = instanceColorModes;
 }
 `;
-var fx = `#version 300 es
+var OE = `#version 300 es
 #define SHADER_NAME icon-layer-fragment-shader
 precision highp float;
 uniform float opacity;
 uniform sampler2D iconsTexture;
 uniform float alphaCutoff;
 in float vColorMode;
 in vec4 vColor;
@@ -26017,239 +26017,1367 @@
 if (a < alphaCutoff) {
 discard;
 }
 fragColor = vec4(color, a);
 DECKGL_FILTER_COLOR(fragColor, geometry);
 }
 `;
-var U3 = 1024,
-    V3 = 4,
-    ux = () => {},
-    dx = {
+
+function Fp(e, t) {
+    if (!e) throw new Error(t || "loader assertion failed.")
+}
+var Gi = {
+        self: typeof self < "u" && self,
+        window: typeof window < "u" && window,
+        global: typeof global < "u" && global,
+        document: typeof document < "u" && document
+    },
+    Hk = Gi.self || Gi.window || Gi.global || {},
+    $k = Gi.window || Gi.self || Gi.global || {},
+    Xk = Gi.global || Gi.self || Gi.window || {},
+    Yk = Gi.document || {};
+var Pu = !!(typeof process != "object" || String(process) !== "[object process]" || process.browser);
+var NE = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version),
+    qk = NE && parseFloat(NE[1]) || 0;
+
+function Vb(e, t) {
+    return BE(e || {}, t)
+}
+
+function BE(e, t) {
+    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
+    if (r > 3) return t;
+    let i = {
+        ...e
+    };
+    for (let [n, s] of Object.entries(t)) s && typeof s == "object" && !Array.isArray(s) ? i[n] = BE(i[n] || {}, t[n], r + 1) : i[n] = t[n];
+    return i
+}
+var FE = "latest";
+
+function Zk() {
+    var e;
+    return (e = globalThis._loadersgl_) !== null && e !== void 0 && e.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = "4.1.1"), globalThis._loadersgl_.version
+}
+var zb = Zk();
+
+function We(e, t) {
+    if (!e) throw new Error(t || "loaders.gl assertion failed.")
+}
+var Ji = {
+        self: typeof self < "u" && self,
+        window: typeof window < "u" && window,
+        global: typeof global < "u" && global,
+        document: typeof document < "u" && document
+    },
+    cst = Ji.self || Ji.window || Ji.global || {},
+    lst = Ji.window || Ji.self || Ji.global || {},
+    ust = Ji.global || Ji.self || Ji.window || {},
+    fst = Ji.document || {};
+var Wr = typeof process != "object" || String(process) !== "[object process]" || process.browser;
+var LE = typeof window < "u" && typeof window.orientation < "u",
+    DE = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version),
+    hst = DE && parseFloat(DE[1]) || 0;
+var Cu = class {
+    constructor(t, r) {
+        this.name = void 0, this.workerThread = void 0, this.isRunning = !0, this.result = void 0, this._resolve = () => {}, this._reject = () => {}, this.name = t, this.workerThread = r, this.result = new Promise((i, n) => {
+            this._resolve = i, this._reject = n
+        })
+    }
+    postMessage(t, r) {
+        this.workerThread.postMessage({
+            source: "loaders.gl",
+            type: t,
+            payload: r
+        })
+    }
+    done(t) {
+        We(this.isRunning), this.isRunning = !1, this._resolve(t)
+    }
+    error(t) {
+        We(this.isRunning), this.isRunning = !1, this._reject(t)
+    }
+};
+var cc = class {
+    terminate() {}
+};
+var Wb = new Map;
+
+function kE(e) {
+    We(e.source && !e.url || !e.source && e.url);
+    let t = Wb.get(e.source || e.url);
+    return t || (e.url && (t = Kk(e.url), Wb.set(e.url, t)), e.source && (t = UE(e.source), Wb.set(e.source, t))), We(t), t
+}
+
+function Kk(e) {
+    if (!e.startsWith("http")) return e;
+    let t = Gk(e);
+    return UE(t)
+}
+
+function UE(e) {
+    let t = new Blob([e], {
+        type: "application/javascript"
+    });
+    return URL.createObjectURL(t)
+}
+
+function Gk(e) {
+    return `try {
+  importScripts('${e}');
+} catch (error) {
+  console.error(error);
+  throw error;
+}`
+}
+
+function jb(e) {
+    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0,
+        r = arguments.length > 2 ? arguments[2] : void 0,
+        i = r || new Set;
+    if (e) {
+        if (VE(e)) i.add(e);
+        else if (VE(e.buffer)) i.add(e.buffer);
+        else if (!ArrayBuffer.isView(e)) {
+            if (t && typeof e == "object")
+                for (let n in e) jb(e[n], t, i)
+        }
+    }
+    return r === void 0 ? Array.from(i) : []
+}
+
+function VE(e) {
+    return e ? e instanceof ArrayBuffer || typeof MessagePort < "u" && e instanceof MessagePort || typeof ImageBitmap < "u" && e instanceof ImageBitmap || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas : !1
+}
+var Hb = () => {},
+    Ls = class {
+        static isSupported() {
+            return typeof Worker < "u" && Wr || typeof cc < "u" && !Wr
+        }
+        constructor(t) {
+            this.name = void 0, this.source = void 0, this.url = void 0, this.terminated = !1, this.worker = void 0, this.onMessage = void 0, this.onError = void 0, this._loadableURL = "";
+            let {
+                name: r,
+                source: i,
+                url: n
+            } = t;
+            We(i || n), this.name = r, this.source = i, this.url = n, this.onMessage = Hb, this.onError = s => console.log(s), this.worker = Wr ? this._createBrowserWorker() : this._createNodeWorker()
+        }
+        destroy() {
+            this.onMessage = Hb, this.onError = Hb, this.worker.terminate(), this.terminated = !0
+        }
+        get isRunning() {
+            return !!this.onMessage
+        }
+        postMessage(t, r) {
+            r = r || jb(t), this.worker.postMessage(t, r)
+        }
+        _getErrorFromErrorEvent(t) {
+            let r = "Failed to load ";
+            return r += `worker ${this.name} from ${this.url}. `, t.message && (r += `${t.message} in `), t.lineno && (r += `:${t.lineno}:${t.colno}`), new Error(r)
+        }
+        _createBrowserWorker() {
+            this._loadableURL = kE({
+                source: this.source,
+                url: this.url
+            });
+            let t = new Worker(this._loadableURL, {
+                name: this.name
+            });
+            return t.onmessage = r => {
+                r.data ? this.onMessage(r.data) : this.onError(new Error("No data received"))
+            }, t.onerror = r => {
+                this.onError(this._getErrorFromErrorEvent(r)), this.terminated = !0
+            }, t.onmessageerror = r => console.error(r), t
+        }
+        _createNodeWorker() {
+            let t;
+            if (this.url) {
+                let i = this.url.includes(":/") || this.url.startsWith("/") ? this.url : `./${this.url}`;
+                t = new cc(i, {
+                    eval: !1
+                })
+            } else if (this.source) t = new cc(this.source, {
+                eval: !0
+            });
+            else throw new Error("no worker");
+            return t.on("message", r => {
+                this.onMessage(r)
+            }), t.on("error", r => {
+                this.onError(r)
+            }), t.on("exit", r => {}), t
+        }
+    };
+var Ou = class {
+    static isSupported() {
+        return Ls.isSupported()
+    }
+    constructor(t) {
+        this.name = "unnamed", this.source = void 0, this.url = void 0, this.maxConcurrency = 1, this.maxMobileConcurrency = 1, this.onDebug = () => {}, this.reuseWorkers = !0, this.props = {}, this.jobQueue = [], this.idleQueue = [], this.count = 0, this.isDestroyed = !1, this.source = t.source, this.url = t.url, this.setProps(t)
+    }
+    destroy() {
+        this.idleQueue.forEach(t => t.destroy()), this.isDestroyed = !0
+    }
+    setProps(t) {
+        this.props = {
+            ...this.props,
+            ...t
+        }, t.name !== void 0 && (this.name = t.name), t.maxConcurrency !== void 0 && (this.maxConcurrency = t.maxConcurrency), t.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = t.maxMobileConcurrency), t.reuseWorkers !== void 0 && (this.reuseWorkers = t.reuseWorkers), t.onDebug !== void 0 && (this.onDebug = t.onDebug)
+    }
+    async startJob(t) {
+        let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (s, o, a) => s.done(a),
+            i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (s, o) => s.error(o),
+            n = new Promise(s => (this.jobQueue.push({
+                name: t,
+                onMessage: r,
+                onError: i,
+                onStart: s
+            }), this));
+        return this._startQueuedJob(), await n
+    }
+    async _startQueuedJob() {
+        if (!this.jobQueue.length) return;
+        let t = this._getAvailableWorker();
+        if (!t) return;
+        let r = this.jobQueue.shift();
+        if (r) {
+            this.onDebug({
+                message: "Starting job",
+                name: r.name,
+                workerThread: t,
+                backlog: this.jobQueue.length
+            });
+            let i = new Cu(r.name, t);
+            t.onMessage = n => r.onMessage(i, n.type, n.payload), t.onError = n => r.onError(i, n), r.onStart(i);
+            try {
+                await i.result
+            } catch (n) {
+                console.error(`Worker exception: ${n}`)
+            } finally {
+                this.returnWorkerToQueue(t)
+            }
+        }
+    }
+    returnWorkerToQueue(t) {
+        !Wr || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (t.destroy(), this.count--) : this.idleQueue.push(t), this.isDestroyed || this._startQueuedJob()
+    }
+    _getAvailableWorker() {
+        if (this.idleQueue.length > 0) return this.idleQueue.shift() || null;
+        if (this.count < this._getMaxConcurrency()) {
+            this.count++;
+            let t = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
+            return new Ls({
+                name: t,
+                source: this.source,
+                url: this.url
+            })
+        }
+        return null
+    }
+    _getMaxConcurrency() {
+        return LE ? this.maxMobileConcurrency : this.maxConcurrency
+    }
+};
+var Jk = {
+        maxConcurrency: 3,
+        maxMobileConcurrency: 1,
+        reuseWorkers: !0,
+        onDebug: () => {}
+    },
+    ks = class e {
+        static isSupported() {
+            return Ls.isSupported()
+        }
+        static getWorkerFarm() {
+            let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
+            return e._workerFarm = e._workerFarm || new e({}), e._workerFarm.setProps(t), e._workerFarm
+        }
+        constructor(t) {
+            this.props = void 0, this.workerPools = new Map, this.props = {
+                ...Jk
+            }, this.setProps(t), this.workerPools = new Map
+        }
+        destroy() {
+            for (let t of this.workerPools.values()) t.destroy();
+            this.workerPools = new Map
+        }
+        setProps(t) {
+            this.props = {
+                ...this.props,
+                ...t
+            };
+            for (let r of this.workerPools.values()) r.setProps(this._getWorkerPoolProps())
+        }
+        getWorkerPool(t) {
+            let {
+                name: r,
+                source: i,
+                url: n
+            } = t, s = this.workerPools.get(r);
+            return s || (s = new Ou({
+                name: r,
+                source: i,
+                url: n
+            }), s.setProps(this._getWorkerPoolProps()), this.workerPools.set(r, s)), s
+        }
+        _getWorkerPoolProps() {
+            return {
+                maxConcurrency: this.props.maxConcurrency,
+                maxMobileConcurrency: this.props.maxMobileConcurrency,
+                reuseWorkers: this.props.reuseWorkers,
+                onDebug: this.props.onDebug
+            }
+        }
+    };
+ks._workerFarm = void 0;
+
+function $b(e) {
+    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
+        r = t[e.id] || {},
+        i = Wr ? `${e.id}-worker.js` : `${e.id}-worker-node.js`,
+        n = r.workerUrl;
+    if (!n && e.id === "compression" && (n = t.workerUrl), t._workerType === "test" && (Wr ? n = `modules/${e.module}/dist/${i}` : n = `modules/${e.module}/src/workers/${e.id}-worker-node.ts`), !n) {
+        let s = e.version;
+        s === "latest" && (s = FE);
+        let o = s ? `@${s}` : "";
+        n = `https://unpkg.com/@loaders.gl/${e.module}${o}/dist/${i}`
+    }
+    return We(n), n
+}
+
+function Xb(e) {
+    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : zb;
+    We(e, "no worker provided");
+    let r = e.version;
+    return !(!t || !r)
+}
+
+function Yb(e, t) {
+    return !ks.isSupported() || !Wr && !(t != null && t._nodeWorkers) ? !1 : e.worker && t?.worker
+}
+async function qb(e, t, r, i, n) {
+    let s = e.id,
+        o = $b(e, r),
+        c = ks.getWorkerFarm(r).getWorkerPool({
+            name: s,
+            url: o
+        });
+    r = JSON.parse(JSON.stringify(r)), i = JSON.parse(JSON.stringify(i || {}));
+    let l = await c.startJob("process-on-worker", Qk.bind(null, n));
+    return l.postMessage("process", {
+        input: t,
+        options: r,
+        context: i
+    }), await (await l.result).result
+}
+async function Qk(e, t, r, i) {
+    switch (r) {
+        case "done":
+            t.done(i);
+            break;
+        case "error":
+            t.error(new Error(i.error));
+            break;
+        case "process":
+            let {
+                id: n, input: s, options: o
+            } = i;
+            try {
+                let a = await e(s, o);
+                t.postMessage("done", {
+                    id: n,
+                    result: a
+                })
+            } catch (a) {
+                let c = a instanceof Error ? a.message : "unknown error";
+                t.postMessage("error", {
+                    id: n,
+                    error: c
+                })
+            }
+            break;
+        default:
+            console.warn(`parse-with-worker unknown message ${r}`)
+    }
+}
+
+function Zb(e, t, r) {
+    if (r = r || e.byteLength, e.byteLength < r || t.byteLength < r) return !1;
+    let i = new Uint8Array(e),
+        n = new Uint8Array(t);
+    for (let s = 0; s < i.length; ++s)
+        if (i[s] !== n[s]) return !1;
+    return !0
+}
+
+function Kb() {
+    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
+    return zE(t)
+}
+
+function zE(e) {
+    let t = e.map(s => s instanceof ArrayBuffer ? new Uint8Array(s) : s),
+        r = t.reduce((s, o) => s + o.byteLength, 0),
+        i = new Uint8Array(r),
+        n = 0;
+    for (let s of t) i.set(s, n), n += s.byteLength;
+    return i.buffer
+}
+async function Gb(e) {
+    let t = [];
+    for await (let r of e) t.push(r);
+    return Kb(...t)
+}
+var tU = "",
+    WE = {};
+
+function Jb(e) {
+    for (let t in WE)
+        if (e.startsWith(t)) {
+            let r = WE[t];
+            e = e.replace(t, r)
+        } return !e.startsWith("http://") && !e.startsWith("https://") && (e = `${tU}${e}`), e
+}
+
+function jE(e) {
+    return e && typeof e == "object" && e.isBuffer
+}
+
+function Dp(e) {
+    if (jE(e)) return e;
+    if (e instanceof ArrayBuffer) return e;
+    if (ArrayBuffer.isView(e)) return e.byteOffset === 0 && e.byteLength === e.buffer.byteLength ? e.buffer : e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
+    if (typeof e == "string") {
+        let t = e;
+        return new TextEncoder().encode(t).buffer
+    }
+    if (e && typeof e == "object" && e._toArrayBuffer) return e._toArrayBuffer();
+    throw new Error("toArrayBuffer")
+}
+var zo = {};
+Ze(zo, {
+    dirname: () => rU,
+    filename: () => eU,
+    join: () => iU,
+    resolve: () => nU
+});
+
+function HE() {
+    var e;
+    if (typeof process < "u" && typeof process.cwd < "u") return process.cwd();
+    let t = (e = window.location) === null || e === void 0 ? void 0 : e.pathname;
+    return t?.slice(0, t.lastIndexOf("/") + 1) || ""
+}
+
+function eU(e) {
+    let t = e ? e.lastIndexOf("/") : -1;
+    return t >= 0 ? e.substr(t + 1) : ""
+}
+
+function rU(e) {
+    let t = e ? e.lastIndexOf("/") : -1;
+    return t >= 0 ? e.substr(0, t) : ""
+}
+
+function iU() {
+    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
+    let i = "/";
+    return t = t.map((n, s) => (s && (n = n.replace(new RegExp(`^${i}`), "")), s !== t.length - 1 && (n = n.replace(new RegExp(`${i}$`), "")), n)), t.join(i)
+}
+
+function nU() {
+    let e = [];
+    for (let n = 0; n < arguments.length; n++) e[n] = n < 0 || arguments.length <= n ? void 0 : arguments[n];
+    let t = "",
+        r = !1,
+        i;
+    for (let n = e.length - 1; n >= -1 && !r; n--) {
+        let s;
+        n >= 0 ? s = e[n] : (i === void 0 && (i = HE()), s = i), s.length !== 0 && (t = `${s}/${t}`, r = s.charCodeAt(0) === Nu)
+    }
+    return t = sU(t, !r), r ? `/${t}` : t.length > 0 ? t : "."
+}
+var Nu = 47,
+    Qb = 46;
+
+function sU(e, t) {
+    let r = "",
+        i = -1,
+        n = 0,
+        s, o = !1;
+    for (let a = 0; a <= e.length; ++a) {
+        if (a < e.length) s = e.charCodeAt(a);
+        else {
+            if (s === Nu) break;
+            s = Nu
+        }
+        if (s === Nu) {
+            if (!(i === a - 1 || n === 1))
+                if (i !== a - 1 && n === 2) {
+                    if (r.length < 2 || !o || r.charCodeAt(r.length - 1) !== Qb || r.charCodeAt(r.length - 2) !== Qb) {
+                        if (r.length > 2) {
+                            let c = r.length - 1,
+                                l = c;
+                            for (; l >= 0 && r.charCodeAt(l) !== Nu; --l);
+                            if (l !== c) {
+                                r = l === -1 ? "" : r.slice(0, l), i = a, n = 0, o = !1;
+                                continue
+                            }
+                        } else if (r.length === 2 || r.length === 1) {
+                            r = "", i = a, n = 0, o = !1;
+                            continue
+                        }
+                    }
+                    t && (r.length > 0 ? r += "/.." : r = "..", o = !0)
+                } else {
+                    let c = e.slice(i + 1, a);
+                    r.length > 0 ? r += `/${c}` : r = c, o = !1
+                } i = a, n = 0
+        } else s === Qb && n !== -1 ? ++n : n = -1
+    }
+    return r
+}
+var oU = e => typeof e == "boolean",
+    Bu = e => typeof e == "function",
+    Wo = e => e !== null && typeof e == "object",
+    tx = e => Wo(e) && e.constructor === {}.constructor;
+var $E = e => !!e && typeof e[Symbol.iterator] == "function",
+    XE = e => e && typeof e[Symbol.asyncIterator] == "function";
+var jr = e => typeof Response < "u" && e instanceof Response || e && e.arrayBuffer && e.text && e.json;
+var Hr = e => typeof Blob < "u" && e instanceof Blob,
+    YE = e => e && typeof e == "object" && e.isBuffer;
+var aU = e => typeof ReadableStream < "u" && e instanceof ReadableStream || Wo(e) && Bu(e.tee) && Bu(e.cancel) && Bu(e.getReader);
+var cU = e => Wo(e) && Bu(e.read) && Bu(e.pipe) && oU(e.readable),
+    Lp = e => aU(e) || cU(e);
+var lU = /^data:([-\w.]+\/[-\w.+]+)(;|,)/,
+    uU = /^([-\w.]+\/[-\w.+]+)/;
+
+function qE(e) {
+    let t = uU.exec(e);
+    return t ? t[1] : e
+}
+
+function ex(e) {
+    let t = lU.exec(e);
+    return t ? t[1] : ""
+}
+var ZE = /\?.*/;
+
+function KE(e) {
+    let t = e.match(ZE);
+    return t && t[0]
+}
+
+function lc(e) {
+    return e.replace(ZE, "")
+}
+
+function jo(e) {
+    return jr(e) ? e.url : Hr(e) ? e.name || "" : typeof e == "string" ? e : ""
+}
+
+function Fu(e) {
+    if (jr(e)) {
+        let t = e,
+            r = t.headers.get("content-type") || "",
+            i = lc(t.url);
+        return qE(r) || ex(i)
+    }
+    return Hr(e) ? e.type || "" : typeof e == "string" ? ex(e) : ""
+}
+
+function GE(e) {
+    return jr(e) ? e.headers["content-length"] || -1 : Hr(e) ? e.size : typeof e == "string" ? e.length : e instanceof ArrayBuffer || ArrayBuffer.isView(e) ? e.byteLength : -1
+}
+async function kp(e) {
+    if (jr(e)) return e;
+    let t = {},
+        r = GE(e);
+    r >= 0 && (t["content-length"] = String(r));
+    let i = jo(e),
+        n = Fu(e);
+    n && (t["content-type"] = n);
+    let s = await hU(e);
+    s && (t["x-first-bytes"] = s), typeof e == "string" && (e = new TextEncoder().encode(e));
+    let o = new Response(e, {
+        headers: t
+    });
+    return Object.defineProperty(o, "url", {
+        value: i
+    }), o
+}
+async function JE(e) {
+    if (!e.ok) {
+        let t = await fU(e);
+        throw new Error(t)
+    }
+}
+async function fU(e) {
+    let t = `Failed to fetch resource ${e.url} (${e.status}): `;
+    try {
+        let r = e.headers.get("Content-Type"),
+            i = e.statusText;
+        r != null && r.includes("application/json") && (i += ` ${await e.text()}`), t += i, t = t.length > 60 ? `${t.slice(0,60)}...` : t
+    } catch {}
+    return t
+}
+async function hU(e) {
+    if (typeof e == "string") return `data:,${e.slice(0,5)}`;
+    if (e instanceof Blob) {
+        let r = e.slice(0, 5);
+        return await new Promise(i => {
+            let n = new FileReader;
+            n.onload = s => {
+                var o;
+                return i(s == null || (o = s.target) === null || o === void 0 ? void 0 : o.result)
+            }, n.readAsDataURL(r)
+        })
+    }
+    if (e instanceof ArrayBuffer) {
+        let r = e.slice(0, 5);
+        return `data:base64,${dU(r)}`
+    }
+    return null
+}
+
+function dU(e) {
+    let t = "",
+        r = new Uint8Array(e);
+    for (let i = 0; i < r.byteLength; i++) t += String.fromCharCode(r[i]);
+    return btoa(t)
+}
+
+function pU(e) {
+    return !mU(e) && !gU(e)
+}
+
+function mU(e) {
+    return e.startsWith("http:") || e.startsWith("https:")
+}
+
+function gU(e) {
+    return e.startsWith("data:")
+}
+async function rx(e, t) {
+    if (typeof e == "string") {
+        let n = Jb(e);
+        if (pU(n)) {
+            var r;
+            if ((r = globalThis.loaders) !== null && r !== void 0 && r.fetchNode) {
+                var i;
+                return (i = globalThis.loaders) === null || i === void 0 ? void 0 : i.fetchNode(n, t)
+            }
+        }
+        return await fetch(n, t)
+    }
+    return await kp(e)
+}
+var ix = new ye({
+        id: "loaders.gl"
+    }),
+    Up = class {
+        log() {
+            return () => {}
+        }
+        info() {
+            return () => {}
+        }
+        warn() {
+            return () => {}
+        }
+        error() {
+            return () => {}
+        }
+    },
+    Vp = class {
+        constructor() {
+            this.console = void 0, this.console = console
+        }
+        log() {
+            for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];
+            return this.console.log.bind(this.console, ...r)
+        }
+        info() {
+            for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];
+            return this.console.info.bind(this.console, ...r)
+        }
+        warn() {
+            for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];
+            return this.console.warn.bind(this.console, ...r)
+        }
+        error() {
+            for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];
+            return this.console.error.bind(this.console, ...r)
+        }
+    };
+var nx = {
+        fetch: null,
+        mimeType: void 0,
+        nothrow: !1,
+        log: new Vp,
+        useLocalLibraries: !1,
+        CDN: "https://unpkg.com/@loaders.gl",
+        worker: !0,
+        maxConcurrency: 3,
+        maxMobileConcurrency: 1,
+        reuseWorkers: Pu,
+        _nodeWorkers: !1,
+        _workerType: "",
+        limit: 0,
+        _limitMB: 0,
+        batchSize: "auto",
+        batchDebounceMs: 0,
+        metadata: !1,
+        transforms: []
+    },
+    QE = {
+        throws: "nothrow",
+        dataType: "(no longer used)",
+        uri: "baseUri",
+        method: "fetch.method",
+        headers: "fetch.headers",
+        body: "fetch.body",
+        mode: "fetch.mode",
+        credentials: "fetch.credentials",
+        cache: "fetch.cache",
+        redirect: "fetch.redirect",
+        referrer: "fetch.referrer",
+        referrerPolicy: "fetch.referrerPolicy",
+        integrity: "fetch.integrity",
+        keepalive: "fetch.keepalive",
+        signal: "fetch.signal"
+    };
+
+function sx() {
+    globalThis.loaders = globalThis.loaders || {};
+    let {
+        loaders: e
+    } = globalThis;
+    return e._state = e._state || {}, e._state
+}
+
+function ox() {
+    let e = sx();
+    return e.globalOptions = e.globalOptions || {
+        ...nx
+    }, e.globalOptions
+}
+
+function rI(e, t, r, i) {
+    return r = r || [], r = Array.isArray(r) ? r : [r], _U(e, r), bU(t, e, i)
+}
+
+function _U(e, t) {
+    tI(e, null, nx, QE, t);
+    for (let r of t) {
+        let i = e && e[r.id] || {},
+            n = r.options && r.options[r.id] || {},
+            s = r.deprecatedOptions && r.deprecatedOptions[r.id] || {};
+        tI(i, r.id, n, s, t)
+    }
+}
+
+function tI(e, t, r, i, n) {
+    let s = t || "Top level",
+        o = t ? `${t}.` : "";
+    for (let a in e) {
+        let c = !t && Wo(e[a]),
+            l = a === "baseUri" && !t,
+            u = a === "workerUrl" && t;
+        if (!(a in r) && !l && !u) {
+            if (a in i) ix.warn(`${s} loader option '${o}${a}' no longer supported, use '${i[a]}'`)();
+            else if (!c) {
+                let f = yU(a, n);
+                ix.warn(`${s} loader option '${o}${a}' not recognized. ${f}`)()
+            }
+        }
+    }
+}
+
+function yU(e, t) {
+    let r = e.toLowerCase(),
+        i = "";
+    for (let n of t)
+        for (let s in n.options) {
+            if (e === s) return `Did you mean '${n.id}.${s}'?`;
+            let o = s.toLowerCase();
+            (r.startsWith(o) || o.startsWith(r)) && (i = i || `Did you mean '${n.id}.${s}'?`)
+        }
+    return i
+}
+
+function bU(e, t, r) {
+    let n = {
+        ...e.options || {}
+    };
+    return xU(n, r), n.log === null && (n.log = new Up), eI(n, ox()), eI(n, t), n
+}
+
+function eI(e, t) {
+    for (let r in t)
+        if (r in t) {
+            let i = t[r];
+            tx(i) && tx(e[r]) ? e[r] = {
+                ...e[r],
+                ...t[r]
+            } : e[r] = t[r]
+        }
+}
+
+function xU(e, t) {
+    t && !("baseUri" in e) && (e.baseUri = t)
+}
+
+function Du(e) {
+    var t;
+    return e ? (Array.isArray(e) && (e = e[0]), Array.isArray((t = e) === null || t === void 0 ? void 0 : t.extensions)) : !1
+}
+
+function ax(e) {
+    var t, r;
+    Fp(e, "null loader"), Fp(Du(e), "invalid loader");
+    let i;
+    return Array.isArray(e) && (i = e[1], e = e[0], e = {
+        ...e,
+        options: {
+            ...e.options,
+            ...i
+        }
+    }), ((t = e) !== null && t !== void 0 && t.parseTextSync || (r = e) !== null && r !== void 0 && r.parseText) && (e.text = !0), e.text || (e.binary = !0), e
+}
+var wU = () => {
+    let e = sx();
+    return e.loaderRegistry = e.loaderRegistry || [], e.loaderRegistry
+};
+
+function iI() {
+    return wU()
+}
+var nI = new ye({
+    id: "loaders.gl"
+});
+var TU = /\.([^.]+)$/;
+async function aI(e) {
+    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
+        r = arguments.length > 2 ? arguments[2] : void 0,
+        i = arguments.length > 3 ? arguments[3] : void 0;
+    if (!cI(e)) return null;
+    let n = sI(e, t, {
+        ...r,
+        nothrow: !0
+    }, i);
+    if (n) return n;
+    if (Hr(e) && (e = await e.slice(0, 10).arrayBuffer(), n = sI(e, t, r, i)), !n && !(r != null && r.nothrow)) throw new Error(lI(e));
+    return n
+}
+
+function sI(e) {
+    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
+        r = arguments.length > 2 ? arguments[2] : void 0,
+        i = arguments.length > 3 ? arguments[3] : void 0;
+    if (!cI(e)) return null;
+    if (t && !Array.isArray(t)) return ax(t);
+    let n = [];
+    t && (n = n.concat(t)), r != null && r.ignoreRegisteredLoaders || n.push(...iI()), SU(n);
+    let s = vU(e, n, r, i);
+    if (!s && !(r != null && r.nothrow)) throw new Error(lI(e));
+    return s
+}
+
+function vU(e, t, r, i) {
+    let n = jo(e),
+        s = Fu(e),
+        o = lc(n) || i?.url,
+        a = null,
+        c = "";
+    if (r != null && r.mimeType && (a = cx(t, r?.mimeType), c = `match forced by supplied MIME type ${r?.mimeType}`), a = a || AU(t, o), c = c || (a ? `matched url ${o}` : ""), a = a || cx(t, s), c = c || (a ? `matched MIME type ${s}` : ""), a = a || IU(t, e), c = c || (a ? `matched initial data ${uI(e)}` : ""), r != null && r.fallbackMimeType && (a = a || cx(t, r?.fallbackMimeType), c = c || (a ? `matched fallback MIME type ${s}` : "")), c) {
+        var l;
+        nI.log(1, `selectLoader selected ${(l=a)===null||l===void 0?void 0:l.name}: ${c}.`)
+    }
+    return a
+}
+
+function cI(e) {
+    return !(e instanceof Response && e.status === 204)
+}
+
+function lI(e) {
+    let t = jo(e),
+        r = Fu(e),
+        i = "No valid loader found (";
+    i += t ? `${zo.filename(t)}, ` : "no url provided, ", i += `MIME type: ${r?`"${r}"`:"not provided"}, `;
+    let n = e ? uI(e) : "";
+    return i += n ? ` first bytes: "${n}"` : "first bytes: not available", i += ")", i
+}
+
+function SU(e) {
+    for (let t of e) ax(t)
+}
+
+function AU(e, t) {
+    let r = t && TU.exec(t),
+        i = r && r[1];
+    return i ? EU(e, i) : null
+}
+
+function EU(e, t) {
+    t = t.toLowerCase();
+    for (let r of e)
+        for (let i of r.extensions)
+            if (i.toLowerCase() === t) return r;
+    return null
+}
+
+function cx(e, t) {
+    for (let r of e)
+        if (r.mimeTypes && r.mimeTypes.includes(t) || t === `application/x.${r.id}`) return r;
+    return null
+}
+
+function IU(e, t) {
+    if (!t) return null;
+    for (let r of e)
+        if (typeof t == "string") {
+            if (RU(t, r)) return r
+        } else if (ArrayBuffer.isView(t)) {
+        if (oI(t.buffer, t.byteOffset, r)) return r
+    } else if (t instanceof ArrayBuffer && oI(t, 0, r)) return r;
+    return null
+}
+
+function RU(e, t) {
+    return t.testText ? t.testText(e) : (Array.isArray(t.tests) ? t.tests : [t.tests]).some(i => e.startsWith(i))
+}
+
+function oI(e, t, r) {
+    return (Array.isArray(r.tests) ? r.tests : [r.tests]).some(n => MU(e, t, r, n))
+}
+
+function MU(e, t, r, i) {
+    if (i instanceof ArrayBuffer) return Zb(i, e, i.byteLength);
+    switch (typeof i) {
+        case "function":
+            return i(e);
+        case "string":
+            let n = lx(e, t, i.length);
+            return i === n;
+        default:
+            return !1
+    }
+}
+
+function uI(e) {
+    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
+    return typeof e == "string" ? e.slice(0, t) : ArrayBuffer.isView(e) ? lx(e.buffer, e.byteOffset, t) : e instanceof ArrayBuffer ? lx(e, 0, t) : ""
+}
+
+function lx(e, t, r) {
+    if (e.byteLength < t + r) return "";
+    let i = new DataView(e),
+        n = "";
+    for (let s = 0; s < r; s++) n += String.fromCharCode(i.getUint8(t + s));
+    return n
+}
+
+function* fI(e, t) {
+    let r = t?.chunkSize || 262144,
+        i = 0,
+        n = new TextEncoder;
+    for (; i < e.length;) {
+        let s = Math.min(e.length - i, r),
+            o = e.slice(i, i + s);
+        i += s, yield n.encode(o)
+    }
+}
+
+function hI(e) {
+    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
+    return function*() {
+        let {
+            chunkSize: r = 262144
+        } = t, i = 0;
+        for (; i < e.byteLength;) {
+            let n = Math.min(e.byteLength - i, r),
+                s = new ArrayBuffer(n),
+                o = new Uint8Array(e, i, n);
+            new Uint8Array(s).set(o), i += n, yield s
+        }
+    }()
+}
+async function* dI(e, t) {
+    let r = t?.chunkSize || 1048576,
+        i = 0;
+    for (; i < e.size;) {
+        let n = i + r,
+            s = await e.slice(i, n).arrayBuffer();
+        i = n, yield s
+    }
+}
+
+function ux(e, t) {
+    return Pu ? PU(e, t) : CU(e, t)
+}
+async function* PU(e, t) {
+    let r = e.getReader(),
+        i;
+    try {
+        for (;;) {
+            let n = i || r.read();
+            t != null && t._streamReadAhead && (i = r.read());
+            let {
+                done: s,
+                value: o
+            } = await n;
+            if (s) return;
+            yield Dp(o)
+        }
+    } catch {
+        r.releaseLock()
+    }
+}
+async function* CU(e, t) {
+    for await (let r of e) yield Dp(r)
+}
+
+function pI(e, t) {
+    if (typeof e == "string") return fI(e, t);
+    if (e instanceof ArrayBuffer) return hI(e, t);
+    if (Hr(e)) return dI(e, t);
+    if (Lp(e)) return ux(e, t);
+    if (jr(e)) return ux(e.body, t);
+    throw new Error("makeIterator")
+}
+var mI = "Cannot convert supplied data type";
+
+function OU(e, t, r) {
+    if (t.text && typeof e == "string") return e;
+    if (YE(e) && (e = e.buffer), e instanceof ArrayBuffer) {
+        let i = e;
+        return t.text && !t.binary ? new TextDecoder("utf8").decode(i) : i
+    }
+    if (ArrayBuffer.isView(e)) {
+        if (t.text && !t.binary) return new TextDecoder("utf8").decode(e);
+        let i = e.buffer,
+            n = e.byteLength || e.length;
+        return (e.byteOffset !== 0 || n !== i.byteLength) && (i = i.slice(e.byteOffset, e.byteOffset + n)), i
+    }
+    throw new Error(mI)
+}
+async function gI(e, t, r) {
+    let i = e instanceof ArrayBuffer || ArrayBuffer.isView(e);
+    if (typeof e == "string" || i) return OU(e, t, r);
+    if (Hr(e) && (e = await kp(e)), jr(e)) {
+        let n = e;
+        return await JE(n), t.binary ? await n.arrayBuffer() : await n.text()
+    }
+    if (Lp(e) && (e = pI(e, r)), $E(e) || XE(e)) return Gb(e);
+    throw new Error(mI)
+}
+
+function zp(e, t) {
+    let r = ox(),
+        i = e || r;
+    return typeof i.fetch == "function" ? i.fetch : Wo(i.fetch) ? n => rx(n, i.fetch) : t != null && t.fetch ? t?.fetch : rx
+}
+
+function _I(e, t, r) {
+    if (r) return r;
+    let i = {
+        fetch: zp(t, e),
+        ...e
+    };
+    if (i.url) {
+        let n = lc(i.url);
+        i.baseUrl = n, i.queryString = KE(i.url), i.filename = zo.filename(n), i.baseUrl = zo.dirname(n)
+    }
+    return Array.isArray(i.loaders) || (i.loaders = null), i
+}
+
+function yI(e, t) {
+    if (e && !Array.isArray(e)) return e;
+    let r;
+    if (e && (r = Array.isArray(e) ? e : [e]), t && t.loaders) {
+        let i = Array.isArray(t.loaders) ? t.loaders : [t.loaders];
+        r = r ? [...r, ...i] : i
+    }
+    return r && r.length ? r : void 0
+}
+async function Lu(e, t, r, i) {
+    t && !Array.isArray(t) && !Du(t) && (i = void 0, r = t, t = void 0), e = await e, r = r || {};
+    let n = jo(e),
+        o = yI(t, i),
+        a = await aI(e, o, r);
+    return a ? (r = rI(r, a, o, n), i = _I({
+        url: n,
+        _parse: Lu,
+        loaders: o
+    }, r, i || null), await NU(a, e, r, i)) : null
+}
+async function NU(e, t, r, i) {
+    if (Xb(e), r = Vb(e.options, r), jr(t)) {
+        let s = t,
+            {
+                ok: o,
+                redirected: a,
+                status: c,
+                statusText: l,
+                type: u,
+                url: f
+            } = s,
+            h = Object.fromEntries(s.headers.entries());
+        i.response = {
+            headers: h,
+            ok: o,
+            redirected: a,
+            status: c,
+            statusText: l,
+            type: u,
+            url: f
+        }
+    }
+    t = await gI(t, e, r);
+    let n = e;
+    if (n.parseTextSync && typeof t == "string") return n.parseTextSync(t, r, i);
+    if (Yb(e, r)) return await qb(e, t, r, i, Lu);
+    if (n.parseText && typeof t == "string") return await n.parseText(t, r, i);
+    if (n.parse) return await n.parse(t, r, i);
+    throw We(!n.parseSync), new Error(`${e.id} loader - no parser found and worker is disabled`)
+}
+async function uc(e, t, r, i) {
+    let n, s;
+    !Array.isArray(t) && !Du(t) ? (n = [], s = t, i = void 0) : (n = t, s = r);
+    let o = zp(s),
+        a = e;
+    return typeof e == "string" && (a = await o(e)), Hr(e) && (a = await o(e)), Array.isArray(n) ? await Lu(a, n, s) : await Lu(a, n, s)
+}
+var BU = 1024,
+    FU = 4,
+    bI = () => {},
+    xI = {
         minFilter: "linear",
         mipmapFilter: "linear",
         magFilter: "linear",
         addressModeU: "clamp-to-edge",
         addressModeV: "clamp-to-edge"
     },
-    z3 = {
+    DU = {
         x: 0,
         y: 0,
         width: 0,
         height: 0
     };
 
-function W3(e) {
+function LU(e) {
     return Math.pow(2, Math.ceil(Math.log2(e)))
 }
 
-function j3(e, t, r, i) {
-    let s = Math.min(r / t.width, i / t.height),
-        n = Math.floor(t.width * s),
-        o = Math.floor(t.height * s);
-    return s === 1 ? {
+function kU(e, t, r, i) {
+    let n = Math.min(r / t.width, i / t.height),
+        s = Math.floor(t.width * n),
+        o = Math.floor(t.height * n);
+    return n === 1 ? {
         data: t,
-        width: n,
+        width: s,
         height: o
-    } : (e.canvas.height = o, e.canvas.width = n, e.clearRect(0, 0, n, o), e.drawImage(t, 0, 0, t.width, t.height, 0, 0, n, o), {
+    } : (e.canvas.height = o, e.canvas.width = s, e.clearRect(0, 0, s, o), e.drawImage(t, 0, 0, t.width, t.height, 0, 0, s, o), {
         data: e.canvas,
-        width: n,
+        width: s,
         height: o
     })
 }
 
-function Uo(e) {
+function ku(e) {
     return e && (e.id || e.url)
 }
 
-function H3(e, t, r, i) {
+function UU(e, t, r, i) {
     let {
-        width: s,
-        height: n,
+        width: n,
+        height: s,
         device: o
     } = e, a = o.createTexture({
         format: "rgba8unorm",
         width: t,
         height: r,
         sampler: i
     }), c = o.createCommandEncoder();
     return c.copyTextureToTexture({
         source: e,
         destination: a,
-        width: s,
-        height: n
+        width: n,
+        height: s
     }), c.finish(), e.destroy(), a
 }
 
-function px(e, t, r) {
+function wI(e, t, r) {
     for (let i = 0; i < t.length; i++) {
         let {
-            icon: s,
-            xOffset: n
-        } = t[i], o = Uo(s);
+            icon: n,
+            xOffset: s
+        } = t[i], o = ku(n);
         e[o] = {
-            ...s,
-            x: n,
+            ...n,
+            x: s,
             y: r
         }
     }
 }
 
-function X3({
+function VU({
     icons: e,
     buffer: t,
     mapping: r = {},
     xOffset: i = 0,
-    yOffset: s = 0,
-    rowHeight: n = 0,
+    yOffset: n = 0,
+    rowHeight: s = 0,
     canvasWidth: o
 }) {
     let a = [];
     for (let c = 0; c < e.length; c++) {
         let l = e[c],
-            h = Uo(l);
-        if (!r[h]) {
+            u = ku(l);
+        if (!r[u]) {
             let {
                 height: f,
-                width: u
+                width: h
             } = l;
-            i + u + t > o && (px(r, a, s), i = 0, s = n + s + t, n = 0, a = []), a.push({
+            i + h + t > o && (wI(r, a, n), i = 0, n = s + n + t, s = 0, a = []), a.push({
                 icon: l,
                 xOffset: i
-            }), i = i + u + t, n = Math.max(n, f)
+            }), i = i + h + t, s = Math.max(s, f)
         }
     }
-    return a.length > 0 && px(r, a, s), {
+    return a.length > 0 && wI(r, a, n), {
         mapping: r,
-        rowHeight: n,
+        rowHeight: s,
         xOffset: i,
-        yOffset: s,
+        yOffset: n,
         canvasWidth: o,
-        canvasHeight: W3(n + s + t)
+        canvasHeight: LU(s + n + t)
     }
 }
 
-function $3(e, t, r) {
+function zU(e, t, r) {
     if (!e || !t) return null;
     r = r || {};
     let i = {},
         {
-            iterable: s,
-            objectInfo: n
-        } = tr(e);
-    for (let o of s) {
-        n.index++;
-        let a = t(o, n),
-            c = Uo(a);
+            iterable: n,
+            objectInfo: s
+        } = Zi(e);
+    for (let o of n) {
+        s.index++;
+        let a = t(o, s),
+            c = ku(a);
         if (!a) throw new Error("Icon is missing.");
         if (!a.url) throw new Error("Icon url is missing.");
         !i[c] && (!r[c] || a.url !== r[c].url) && (i[c] = {
             ...a,
             source: o,
-            sourceIndex: n.index
+            sourceIndex: s.index
         })
     }
     return i
 }
-var Vo = class {
+var Uu = class {
     constructor(t, {
-        onUpdate: r = ux,
-        onError: i = ux
+        onUpdate: r = bI,
+        onError: i = bI
     }) {
-        this._loadOptions = null, this._texture = null, this._externalTexture = null, this._mapping = {}, this._textureParameters = null, this._pendingCount = 0, this._autoPacking = !1, this._xOffset = 0, this._yOffset = 0, this._rowHeight = 0, this._buffer = V3, this._canvasWidth = U3, this._canvasHeight = 0, this._canvas = null, this.device = t, this.onUpdate = r, this.onError = i
+        this._loadOptions = null, this._texture = null, this._externalTexture = null, this._mapping = {}, this._textureParameters = null, this._pendingCount = 0, this._autoPacking = !1, this._xOffset = 0, this._yOffset = 0, this._rowHeight = 0, this._buffer = FU, this._canvasWidth = BU, this._canvasHeight = 0, this._canvas = null, this.device = t, this.onUpdate = r, this.onError = i
     }
     finalize() {
         this._texture?.delete()
     }
     getTexture() {
         return this._texture || this._externalTexture
     }
     getIconMapping(t) {
-        let r = this._autoPacking ? Uo(t) : t;
-        return this._mapping[r] || z3
+        let r = this._autoPacking ? ku(t) : t;
+        return this._mapping[r] || DU
     }
     setProps({
         loadOptions: t,
         autoPacking: r,
         iconAtlas: i,
-        iconMapping: s,
-        textureParameters: n
+        iconMapping: n,
+        textureParameters: s
     }) {
-        t && (this._loadOptions = t), r !== void 0 && (this._autoPacking = r), s && (this._mapping = s), i && (this._texture?.delete(), this._texture = null, this._externalTexture = i), n && (this._textureParameters = n)
+        t && (this._loadOptions = t), r !== void 0 && (this._autoPacking = r), n && (this._mapping = n), i && (this._texture?.delete(), this._texture = null, this._externalTexture = i), s && (this._textureParameters = s)
     }
     get isLoaded() {
         return this._pendingCount === 0
     }
     packIcons(t, r) {
         if (!this._autoPacking || typeof document > "u") return;
-        let i = Object.values($3(t, r, this._mapping) || {});
+        let i = Object.values(zU(t, r, this._mapping) || {});
         if (i.length > 0) {
             let {
-                mapping: s,
-                xOffset: n,
+                mapping: n,
+                xOffset: s,
                 yOffset: o,
                 rowHeight: a,
                 canvasHeight: c
-            } = X3({
+            } = VU({
                 icons: i,
                 buffer: this._buffer,
                 canvasWidth: this._canvasWidth,
                 mapping: this._mapping,
                 rowHeight: this._rowHeight,
                 xOffset: this._xOffset,
                 yOffset: this._yOffset
             });
-            this._rowHeight = a, this._mapping = s, this._xOffset = n, this._yOffset = o, this._canvasHeight = c, this._texture || (this._texture = this.device.createTexture({
+            this._rowHeight = a, this._mapping = n, this._xOffset = s, this._yOffset = o, this._canvasHeight = c, this._texture || (this._texture = this.device.createTexture({
                 format: "rgba8unorm",
                 width: this._canvasWidth,
                 height: this._canvasHeight,
-                sampler: this._textureParameters || dx
-            })), this._texture.height !== this._canvasHeight && (this._texture = H3(this._texture, this._canvasWidth, this._canvasHeight, this._textureParameters || dx)), this.onUpdate(), this._canvas = this._canvas || document.createElement("canvas"), this._loadIcons(i)
+                sampler: this._textureParameters || xI
+            })), this._texture.height !== this._canvasHeight && (this._texture = UU(this._texture, this._canvasWidth, this._canvasHeight, this._textureParameters || xI)), this.onUpdate(), this._canvas = this._canvas || document.createElement("canvas"), this._loadIcons(i)
         }
     }
     _loadIcons(t) {
         let r = this._canvas.getContext("2d", {
             willReadFrequently: !0
         });
-        for (let i of t) this._pendingCount++, kr(i.url, this._loadOptions).then(s => {
-            let n = Uo(i),
-                o = this._mapping[n],
+        for (let i of t) this._pendingCount++, uc(i.url, this._loadOptions).then(n => {
+            let s = ku(i),
+                o = this._mapping[s],
                 {
                     x: a,
                     y: c,
                     width: l,
-                    height: h
+                    height: u
                 } = o,
                 {
                     data: f,
-                    width: u,
+                    width: h,
                     height: d
-                } = j3(r, s, l, h);
+                } = kU(r, n, l, u);
             this._texture.setSubImageData({
                 data: f,
-                x: a + (l - u) / 2,
-                y: c + (h - d) / 2,
-                width: u,
+                x: a + (l - h) / 2,
+                y: c + (u - d) / 2,
+                width: h,
                 height: d
-            }), o.width = u, o.height = d, this._texture.generateMipmap(), this.onUpdate()
-        }).catch(s => {
+            }), o.width = h, o.height = d, this._texture.generateMipmap(), this.onUpdate()
+        }).catch(n => {
             this.onError({
                 url: i.url,
                 source: i.source,
                 sourceIndex: i.sourceIndex,
                 loadOptions: this._loadOptions,
-                error: s
+                error: n
             })
         }).finally(() => {
             this._pendingCount--
         })
     }
 };
-var gx = [0, 0, 0, 255],
-    Y3 = {
+var TI = [0, 0, 0, 255],
+    WU = {
         iconAtlas: {
             type: "image",
             value: null,
             async: !0
         },
         iconMapping: {
             type: "object",
@@ -26285,15 +27413,15 @@
         },
         getIcon: {
             type: "accessor",
             value: e => e.icon
         },
         getColor: {
             type: "accessor",
-            value: gx
+            value: TI
         },
         getSize: {
             type: "accessor",
             value: 1
         },
         getAngle: {
             type: "accessor",
@@ -26310,25 +27438,25 @@
         },
         textureParameters: {
             type: "object",
             ignore: !0,
             value: null
         }
     },
-    Ol = class Ol extends Et {
+    Wp = class Wp extends de {
         getShaders() {
             return super.getShaders({
-                vs: hx,
-                fs: fx,
-                modules: [Ut, zt]
+                vs: CE,
+                fs: OE,
+                modules: [ke, Ve]
             })
         }
         initializeState() {
             this.state = {
-                iconManager: new Vo(this.context.device, {
+                iconManager: new Uu(this.context.device, {
                     onUpdate: this._onUpdate.bind(this),
                     onError: this._onError.bind(this)
                 })
             }, this.getAttributeManager().addInstanced({
                 instancePositions: {
                     size: 3,
                     type: "float64",
@@ -26359,15 +27487,15 @@
                     transform: this.getInstanceColorMode
                 },
                 instanceColors: {
                     size: this.props.colorFormat.length,
                     type: "unorm8",
                     transition: !0,
                     accessor: "getColor",
-                    defaultValue: gx
+                    defaultValue: TI
                 },
                 instanceAngles: {
                     size: 1,
                     transition: !0,
                     accessor: "getAngle"
                 },
                 instancePixelOffset: {
@@ -26378,75 +27506,75 @@
             })
         }
         updateState(t) {
             super.updateState(t);
             let {
                 props: r,
                 oldProps: i,
-                changeFlags: s
-            } = t, n = this.getAttributeManager(), {
+                changeFlags: n
+            } = t, s = this.getAttributeManager(), {
                 iconAtlas: o,
                 iconMapping: a,
                 data: c,
                 getIcon: l,
-                textureParameters: h
+                textureParameters: u
             } = r, {
                 iconManager: f
             } = this.state;
             if (typeof o == "string") return;
-            let u = o || this.internalState.isAsyncPropLoading("iconAtlas");
+            let h = o || this.internalState.isAsyncPropLoading("iconAtlas");
             f.setProps({
                 loadOptions: r.loadOptions,
-                autoPacking: !u,
+                autoPacking: !h,
                 iconAtlas: o,
-                iconMapping: u ? a : null,
-                textureParameters: h
-            }), u ? i.iconMapping !== r.iconMapping && n.invalidate("getIcon") : (s.dataChanged || s.updateTriggersChanged && (s.updateTriggersChanged.all || s.updateTriggersChanged.getIcon)) && f.packIcons(c, l), s.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), n.invalidateAll())
+                iconMapping: h ? a : null,
+                textureParameters: u
+            }), h ? i.iconMapping !== r.iconMapping && s.invalidate("getIcon") : (n.dataChanged || n.updateTriggersChanged && (n.updateTriggersChanged.all || n.updateTriggersChanged.getIcon)) && f.packIcons(c, l), n.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), s.invalidateAll())
         }
         get isLoaded() {
             return super.isLoaded && this.state.iconManager.isLoaded
         }
         finalizeState(t) {
             super.finalizeState(t), this.state.iconManager.finalize()
         }
         draw({
             uniforms: t
         }) {
             let {
                 sizeScale: r,
                 sizeMinPixels: i,
-                sizeMaxPixels: s,
-                sizeUnits: n,
+                sizeMaxPixels: n,
+                sizeUnits: s,
                 billboard: o,
                 alphaCutoff: a
             } = this.props, {
                 iconManager: c
             } = this.state, l = c.getTexture();
             if (l) {
-                let h = this.state.model;
-                h.setBindings({
+                let u = this.state.model;
+                u.setBindings({
                     iconsTexture: l
-                }), h.setUniforms(t), h.setUniforms({
+                }), u.setUniforms(t), u.setUniforms({
                     iconsTextureDim: [l.width, l.height],
-                    sizeUnits: Kt[n],
+                    sizeUnits: tr[s],
                     sizeScale: r,
                     sizeMinPixels: i,
-                    sizeMaxPixels: s,
+                    sizeMaxPixels: n,
                     billboard: o,
                     alphaCutoff: a
-                }), h.draw(this.context.renderPass)
+                }), u.draw(this.context.renderPass)
             }
         }
         _getModel() {
             let t = [-1, -1, 1, -1, -1, 1, 1, 1];
-            return new bt(this.context.device, {
+            return new ce(this.context.device, {
                 ...this.getShaders(),
                 id: this.props.id,
                 bufferLayout: this.getAttributeManager().getBufferLayouts(),
-                geometry: new Qt({
+                geometry: new er({
                     topology: "triangle-strip",
                     attributes: {
                         positions: {
                             size: 2,
                             value: new Float32Array(t)
                         }
                     }
@@ -26455,41 +27583,41 @@
             })
         }
         _onUpdate() {
             this.setNeedsRedraw()
         }
         _onError(t) {
             let r = this.getCurrentLayer()?.props.onIconError;
-            r ? r(t) : j.error(t.error.message)()
+            r ? r(t) : Z.error(t.error.message)()
         }
         getInstanceOffset(t) {
             let {
                 width: r,
                 height: i,
-                anchorX: s = r / 2,
-                anchorY: n = i / 2
+                anchorX: n = r / 2,
+                anchorY: s = i / 2
             } = this.state.iconManager.getIconMapping(t);
-            return [r / 2 - s, i / 2 - n]
+            return [r / 2 - n, i / 2 - s]
         }
         getInstanceColorMode(t) {
             return this.state.iconManager.getIconMapping(t).mask ? 1 : 0
         }
         getInstanceIconFrame(t) {
             let {
                 x: r,
                 y: i,
-                width: s,
-                height: n
+                width: n,
+                height: s
             } = this.state.iconManager.getIconMapping(t);
-            return [r, i, s, n]
+            return [r, i, n, s]
         }
     };
-Ol.defaultProps = Y3, Ol.layerName = "IconLayer";
-var ii = Ol;
-var mx = `#version 300 es
+Wp.defaultProps = WU, Wp.layerName = "IconLayer";
+var Us = Wp;
+var vI = `#version 300 es
 #define SHADER_NAME scatterplot-layer-vertex-shader
 in vec3 positions;
 in vec3 instancePositions;
 in vec3 instancePositions64Low;
 in float instanceRadius;
 in float instanceLineWidths;
 in vec4 instanceFillColors;
@@ -26543,15 +27671,15 @@
 }
 vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);
 DECKGL_FILTER_COLOR(vFillColor, geometry);
 vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);
 DECKGL_FILTER_COLOR(vLineColor, geometry);
 }
 `;
-var _x = `#version 300 es
+var SI = `#version 300 es
 #define SHADER_NAME scatterplot-layer-fragment-shader
 precision highp float;
 uniform bool filled;
 uniform float stroked;
 uniform bool antialiasing;
 in vec4 vFillColor;
 in vec4 vLineColor;
@@ -26585,16 +27713,16 @@
 } else {
 fragColor = vFillColor;
 }
 fragColor.a *= inCircle;
 DECKGL_FILTER_COLOR(fragColor, geometry);
 }
 `;
-var yx = [0, 0, 0, 255],
-    q3 = {
+var AI = [0, 0, 0, 255],
+    jU = {
         radiusUnits: "meters",
         radiusScale: {
             type: "number",
             min: 0,
             value: 1
         },
         radiusMinPixels: {
@@ -26633,19 +27761,19 @@
         },
         getRadius: {
             type: "accessor",
             value: 1
         },
         getFillColor: {
             type: "accessor",
-            value: yx
+            value: AI
         },
         getLineColor: {
             type: "accessor",
-            value: yx
+            value: AI
         },
         getLineWidth: {
             type: "accessor",
             value: 1
         },
         strokeWidth: {
             deprecatedFor: "getLineWidth"
@@ -26653,20 +27781,20 @@
         outline: {
             deprecatedFor: "stroked"
         },
         getColor: {
             deprecatedFor: ["getFillColor", "getLineColor"]
         }
     },
-    Nl = class Nl extends Et {
+    jp = class jp extends de {
         getShaders() {
             return super.getShaders({
-                vs: mx,
-                fs: _x,
-                modules: [Ut, zt]
+                vs: vI,
+                fs: SI,
+                modules: [ke, Ve]
             })
         }
         initializeState() {
             this.getAttributeManager().addInstanced({
                 instancePositions: {
                     size: 3,
                     type: "float64",
@@ -26707,374 +27835,374 @@
         }
         draw({
             uniforms: t
         }) {
             let {
                 radiusUnits: r,
                 radiusScale: i,
-                radiusMinPixels: s,
-                radiusMaxPixels: n,
+                radiusMinPixels: n,
+                radiusMaxPixels: s,
                 stroked: o,
                 filled: a,
                 billboard: c,
                 antialiasing: l,
-                lineWidthUnits: h,
+                lineWidthUnits: u,
                 lineWidthScale: f,
-                lineWidthMinPixels: u,
+                lineWidthMinPixels: h,
                 lineWidthMaxPixels: d
-            } = this.props, m = this.state.model;
-            m.setUniforms(t), m.setUniforms({
+            } = this.props, p = this.state.model;
+            p.setUniforms(t), p.setUniforms({
                 stroked: o ? 1 : 0,
                 filled: a,
                 billboard: c,
                 antialiasing: l,
-                radiusUnits: Kt[r],
+                radiusUnits: tr[r],
                 radiusScale: i,
-                radiusMinPixels: s,
-                radiusMaxPixels: n,
-                lineWidthUnits: Kt[h],
+                radiusMinPixels: n,
+                radiusMaxPixels: s,
+                lineWidthUnits: tr[u],
                 lineWidthScale: f,
-                lineWidthMinPixels: u,
+                lineWidthMinPixels: h,
                 lineWidthMaxPixels: d
-            }), m.draw(this.context.renderPass)
+            }), p.draw(this.context.renderPass)
         }
         _getModel() {
             let t = [-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0];
-            return new bt(this.context.device, {
+            return new ce(this.context.device, {
                 ...this.getShaders(),
                 id: this.props.id,
                 bufferLayout: this.getAttributeManager().getBufferLayouts(),
-                geometry: new Qt({
+                geometry: new er({
                     topology: "triangle-strip",
                     attributes: {
                         positions: {
                             size: 3,
                             value: new Float32Array(t)
                         }
                     }
                 }),
                 isInstanced: !0
             })
         }
     };
-Nl.defaultProps = q3, Nl.layerName = "ScatterplotLayer";
-var Fe = Nl;
-var Fl = {
+jp.defaultProps = jU, jp.layerName = "ScatterplotLayer";
+var ui = jp;
+var Hp = {
     CLOCKWISE: 1,
     COUNTER_CLOCKWISE: -1
 };
 
-function zo(e, t, r = {}) {
-    return xx(e, r) !== t ? (Z3(e, r), !0) : !1
+function Vu(e, t, r = {}) {
+    return EI(e, r) !== t ? (HU(e, r), !0) : !1
 }
 
-function xx(e, t = {}) {
-    return Math.sign(Dl(e, t))
+function EI(e, t = {}) {
+    return Math.sign($p(e, t))
 }
-var Qd = {
+var fx = {
     x: 0,
     y: 1,
     z: 2
 };
 
-function Dl(e, t = {}) {
+function $p(e, t = {}) {
     let {
         start: r = 0,
         end: i = e.length,
-        plane: s = "xy"
-    } = t, n = t.size || 2, o = 0, a = Qd[s[0]], c = Qd[s[1]];
-    for (let l = r, h = i - n; l < i; l += n) o += (e[l + a] - e[h + a]) * (e[l + c] + e[h + c]), h = l;
+        plane: n = "xy"
+    } = t, s = t.size || 2, o = 0, a = fx[n[0]], c = fx[n[1]];
+    for (let l = r, u = i - s; l < i; l += s) o += (e[l + a] - e[u + a]) * (e[l + c] + e[u + c]), u = l;
     return o / 2
 }
 
-function Z3(e, t) {
+function HU(e, t) {
     let {
         start: r = 0,
         end: i = e.length,
-        size: s = 2
-    } = t, n = (i - r) / s, o = Math.floor(n / 2);
+        size: n = 2
+    } = t, s = (i - r) / n, o = Math.floor(s / 2);
     for (let a = 0; a < o; ++a) {
-        let c = r + a * s,
-            l = r + (n - 1 - a) * s;
-        for (let h = 0; h < s; ++h) {
-            let f = e[c + h];
-            e[c + h] = e[l + h], e[l + h] = f
+        let c = r + a * n,
+            l = r + (s - 1 - a) * n;
+        for (let u = 0; u < n; ++u) {
+            let f = e[c + u];
+            e[c + u] = e[l + u], e[l + u] = f
         }
     }
 }
 
-function te(e, t) {
+function nr(e, t) {
     let r = t.length,
         i = e.length;
     if (i > 0) {
-        let s = !0;
-        for (let n = 0; n < r; n++)
-            if (e[i - r + n] !== t[n]) {
-                s = !1;
+        let n = !0;
+        for (let s = 0; s < r; s++)
+            if (e[i - r + s] !== t[s]) {
+                n = !1;
                 break
-            } if (s) return !1
+            } if (n) return !1
     }
-    for (let s = 0; s < r; s++) e[i + s] = t[s];
+    for (let n = 0; n < r; n++) e[i + n] = t[n];
     return !0
 }
 
-function Wo(e, t) {
+function zu(e, t) {
     let r = t.length;
     for (let i = 0; i < r; i++) e[i] = t[i]
 }
 
-function si(e, t, r, i, s = []) {
-    let n = i + t * r;
-    for (let o = 0; o < r; o++) s[o] = e[n + o];
-    return s
+function Vs(e, t, r, i, n = []) {
+    let s = i + t * r;
+    for (let o = 0; o < r; o++) n[o] = e[s + o];
+    return n
 }
 
-function kl(e, t, r, i, s = []) {
-    let n, o;
-    if (r & 8) n = (i[3] - e[1]) / (t[1] - e[1]), o = 3;
-    else if (r & 4) n = (i[1] - e[1]) / (t[1] - e[1]), o = 1;
-    else if (r & 2) n = (i[2] - e[0]) / (t[0] - e[0]), o = 2;
-    else if (r & 1) n = (i[0] - e[0]) / (t[0] - e[0]), o = 0;
+function Xp(e, t, r, i, n = []) {
+    let s, o;
+    if (r & 8) s = (i[3] - e[1]) / (t[1] - e[1]), o = 3;
+    else if (r & 4) s = (i[1] - e[1]) / (t[1] - e[1]), o = 1;
+    else if (r & 2) s = (i[2] - e[0]) / (t[0] - e[0]), o = 2;
+    else if (r & 1) s = (i[0] - e[0]) / (t[0] - e[0]), o = 0;
     else return null;
-    for (let a = 0; a < e.length; a++) s[a] = (o & 1) === a ? i[o] : n * (t[a] - e[a]) + e[a];
-    return s
+    for (let a = 0; a < e.length; a++) n[a] = (o & 1) === a ? i[o] : s * (t[a] - e[a]) + e[a];
+    return n
 }
 
-function jo(e, t) {
+function Wu(e, t) {
     let r = 0;
     return e[0] < t[0] ? r |= 1 : e[0] > t[2] && (r |= 2), e[1] < t[1] ? r |= 4 : e[1] > t[3] && (r |= 8), r
 }
 
-function Ho(e, t) {
+function ju(e, t) {
     let {
         size: r = 2,
         broken: i = !1,
-        gridResolution: s = 10,
-        gridOffset: n = [0, 0],
+        gridResolution: n = 10,
+        gridOffset: s = [0, 0],
         startIndex: o = 0,
         endIndex: a = e.length
-    } = t || {}, c = (a - o) / r, l = [], h = [l], f = si(e, 0, r, o), u, d, m = Ax(f, s, n, []), y = [];
-    te(l, f);
-    for (let x = 1; x < c; x++) {
-        for (u = si(e, x, r, o, u), d = jo(u, m); d;) {
-            kl(f, u, d, m, y);
-            let A = jo(y, m);
-            A && (kl(f, y, A, m, y), d = A), te(l, y), Wo(f, y), G3(m, s, d), i && l.length > r && (l = [], h.push(l), te(l, f)), d = jo(u, m)
+    } = t || {}, c = (a - o) / r, l = [], u = [l], f = Vs(e, 0, r, o), h, d, p = MI(f, n, s, []), y = [];
+    nr(l, f);
+    for (let b = 1; b < c; b++) {
+        for (h = Vs(e, b, r, o, h), d = Wu(h, p); d;) {
+            Xp(f, h, d, p, y);
+            let T = Wu(y, p);
+            T && (Xp(f, y, T, p, y), d = T), nr(l, y), zu(f, y), YU(p, n, d), i && l.length > r && (l = [], u.push(l), nr(l, f)), d = Wu(h, p)
         }
-        te(l, u), Wo(f, u)
+        nr(l, h), zu(f, h)
     }
-    return i ? h : h[0]
+    return i ? u : u[0]
 }
-var Tx = 0,
-    Q3 = 1;
+var II = 0,
+    XU = 1;
 
-function Xo(e, t = null, r) {
+function Hu(e, t = null, r) {
     if (!e.length) return [];
     let {
         size: i = 2,
-        gridResolution: s = 10,
-        gridOffset: n = [0, 0],
+        gridResolution: n = 10,
+        gridOffset: s = [0, 0],
         edgeTypes: o = !1
     } = r || {}, a = [], c = [{
         pos: e,
-        types: o ? new Array(e.length / i).fill(Q3) : null,
+        types: o ? new Array(e.length / i).fill(XU) : null,
         holes: t || []
     }], l = [
         [],
         []
-    ], h = [];
+    ], u = [];
     for (; c.length;) {
         let {
             pos: f,
-            types: u,
+            types: h,
             holes: d
         } = c.shift();
-        J3(f, i, d[0] || f.length, l), h = Ax(l[0], s, n, h);
-        let m = jo(l[1], h);
-        if (m) {
-            let y = bx(f, u, i, 0, d[0] || f.length, h, m),
-                x = {
+        qU(f, i, d[0] || f.length, l), u = MI(l[0], n, s, u);
+        let p = Wu(l[1], u);
+        if (p) {
+            let y = RI(f, h, i, 0, d[0] || f.length, u, p),
+                b = {
                     pos: y[0].pos,
                     types: y[0].types,
                     holes: []
                 },
-                A = {
+                T = {
                     pos: y[1].pos,
                     types: y[1].types,
                     holes: []
                 };
-            c.push(x, A);
-            for (let v = 0; v < d.length; v++) y = bx(f, u, i, d[v], d[v + 1] || f.length, h, m), y[0] && (x.holes.push(x.pos.length), x.pos = Ll(x.pos, y[0].pos), o && (x.types = Ll(x.types, y[0].types))), y[1] && (A.holes.push(A.pos.length), A.pos = Ll(A.pos, y[1].pos), o && (A.types = Ll(A.types, y[1].types)))
+            c.push(b, T);
+            for (let I = 0; I < d.length; I++) y = RI(f, h, i, d[I], d[I + 1] || f.length, u, p), y[0] && (b.holes.push(b.pos.length), b.pos = Yp(b.pos, y[0].pos), o && (b.types = Yp(b.types, y[0].types))), y[1] && (T.holes.push(T.pos.length), T.pos = Yp(T.pos, y[1].pos), o && (T.types = Yp(T.types, y[1].types)))
         } else {
             let y = {
                 positions: f
             };
-            o && (y.edgeTypes = u), d.length && (y.holeIndices = d), a.push(y)
+            o && (y.edgeTypes = h), d.length && (y.holeIndices = d), a.push(y)
         }
     }
     return a
 }
 
-function bx(e, t, r, i, s, n, o) {
-    let a = (s - i) / r,
+function RI(e, t, r, i, n, s, o) {
+    let a = (n - i) / r,
         c = [],
         l = [],
-        h = [],
-        f = [],
         u = [],
-        d, m, y, x = si(e, a - 1, r, i),
-        A = Math.sign(o & 8 ? x[1] - n[3] : x[0] - n[2]),
-        v = t && t[a - 1],
-        E = 0,
+        f = [],
+        h = [],
+        d, p, y, b = Vs(e, a - 1, r, i),
+        T = Math.sign(o & 8 ? b[1] - s[3] : b[0] - s[2]),
+        I = t && t[a - 1],
+        S = 0,
         R = 0;
-    for (let M = 0; M < a; M++) d = si(e, M, r, i, d), m = Math.sign(o & 8 ? d[1] - n[3] : d[0] - n[2]), y = t && t[i / r + M], m && A && A !== m && (kl(x, d, o, n, u), te(c, u) && h.push(v), te(l, u) && f.push(v)), m <= 0 ? (te(c, d) && h.push(y), E -= m) : h.length && (h[h.length - 1] = Tx), m >= 0 ? (te(l, d) && f.push(y), R += m) : f.length && (f[f.length - 1] = Tx), Wo(x, d), A = m, v = y;
-    return [E ? {
+    for (let P = 0; P < a; P++) d = Vs(e, P, r, i, d), p = Math.sign(o & 8 ? d[1] - s[3] : d[0] - s[2]), y = t && t[i / r + P], p && T && T !== p && (Xp(b, d, o, s, h), nr(c, h) && u.push(I), nr(l, h) && f.push(I)), p <= 0 ? (nr(c, d) && u.push(y), S -= p) : u.length && (u[u.length - 1] = II), p >= 0 ? (nr(l, d) && f.push(y), R += p) : f.length && (f[f.length - 1] = II), zu(b, d), T = p, I = y;
+    return [S ? {
         pos: c,
-        types: t && h
+        types: t && u
     } : null, R ? {
         pos: l,
         types: t && f
     } : null]
 }
 
-function Ax(e, t, r, i) {
-    let s = Math.floor((e[0] - r[0]) / t) * t + r[0],
-        n = Math.floor((e[1] - r[1]) / t) * t + r[1];
-    return i[0] = s, i[1] = n, i[2] = s + t, i[3] = n + t, i
+function MI(e, t, r, i) {
+    let n = Math.floor((e[0] - r[0]) / t) * t + r[0],
+        s = Math.floor((e[1] - r[1]) / t) * t + r[1];
+    return i[0] = n, i[1] = s, i[2] = n + t, i[3] = s + t, i
 }
 
-function G3(e, t, r) {
+function YU(e, t, r) {
     r & 8 ? (e[1] += t, e[3] += t) : r & 4 ? (e[1] -= t, e[3] -= t) : r & 2 ? (e[0] += t, e[2] += t) : r & 1 && (e[0] -= t, e[2] -= t)
 }
 
-function J3(e, t, r, i) {
-    let s = 1 / 0,
-        n = -1 / 0,
+function qU(e, t, r, i) {
+    let n = 1 / 0,
+        s = -1 / 0,
         o = 1 / 0,
         a = -1 / 0;
     for (let c = 0; c < r; c += t) {
         let l = e[c],
-            h = e[c + 1];
-        s = l < s ? l : s, n = l > n ? l : n, o = h < o ? h : o, a = h > a ? h : a
+            u = e[c + 1];
+        n = l < n ? l : n, s = l > s ? l : s, o = u < o ? u : o, a = u > a ? u : a
     }
-    return i[0][0] = s, i[0][1] = o, i[1][0] = n, i[1][1] = a, i
+    return i[0][0] = n, i[0][1] = o, i[1][0] = s, i[1][1] = a, i
 }
 
-function Ll(e, t) {
+function Yp(e, t) {
     for (let r = 0; r < t.length; r++) e.push(t[r]);
     return e
 }
-var tM = 85.051129;
+var ZU = 85.051129;
 
-function Gd(e, t) {
+function hx(e, t) {
     let {
         size: r = 2,
         startIndex: i = 0,
-        endIndex: s = e.length,
-        normalize: n = !0
-    } = t || {}, o = e.slice(i, s);
-    Ex(o, r, 0, s - i);
-    let a = Ho(o, {
+        endIndex: n = e.length,
+        normalize: s = !0
+    } = t || {}, o = e.slice(i, n);
+    PI(o, r, 0, n - i);
+    let a = ju(o, {
         size: r,
         broken: !0,
         gridResolution: 360,
         gridOffset: [-180, -180]
     });
-    if (n)
-        for (let c of a) Sx(c, r);
+    if (s)
+        for (let c of a) CI(c, r);
     return a
 }
 
-function Jd(e, t = null, r) {
+function dx(e, t = null, r) {
     let {
         size: i = 2,
-        normalize: s = !0,
-        edgeTypes: n = !1
+        normalize: n = !0,
+        edgeTypes: s = !1
     } = r || {};
     t = t || [];
     let o = [],
         a = [],
         c = 0,
         l = 0;
     for (let f = 0; f <= t.length; f++) {
-        let u = t[f] || e.length,
+        let h = t[f] || e.length,
             d = l,
-            m = eM(e, i, c, u);
-        for (let y = m; y < u; y++) o[l++] = e[y];
-        for (let y = c; y < m; y++) o[l++] = e[y];
-        Ex(o, i, d, l), rM(o, i, d, l, r?.maxLatitude), c = u, a[f] = l
+            p = KU(e, i, c, h);
+        for (let y = p; y < h; y++) o[l++] = e[y];
+        for (let y = c; y < p; y++) o[l++] = e[y];
+        PI(o, i, d, l), GU(o, i, d, l, r?.maxLatitude), c = h, a[f] = l
     }
     a.pop();
-    let h = Xo(o, a, {
+    let u = Hu(o, a, {
         size: i,
         gridResolution: 360,
         gridOffset: [-180, -180],
-        edgeTypes: n
+        edgeTypes: s
     });
-    if (s)
-        for (let f of h) Sx(f.positions, i);
-    return h
+    if (n)
+        for (let f of u) CI(f.positions, i);
+    return u
 }
 
-function eM(e, t, r, i) {
-    let s = -1,
-        n = -1;
+function KU(e, t, r, i) {
+    let n = -1,
+        s = -1;
     for (let o = r + 1; o < i; o += t) {
         let a = Math.abs(e[o]);
-        a > s && (s = a, n = o - 1)
+        a > n && (n = a, s = o - 1)
     }
-    return n
+    return s
 }
 
-function rM(e, t, r, i, s = tM) {
-    let n = e[r],
+function GU(e, t, r, i, n = ZU) {
+    let s = e[r],
         o = e[i - t];
-    if (Math.abs(n - o) > 180) {
-        let a = si(e, 0, t, r);
-        a[0] += Math.round((o - n) / 360) * 360, te(e, a), a[1] = Math.sign(a[1]) * s, te(e, a), a[0] = n, te(e, a)
+    if (Math.abs(s - o) > 180) {
+        let a = Vs(e, 0, t, r);
+        a[0] += Math.round((o - s) / 360) * 360, nr(e, a), a[1] = Math.sign(a[1]) * n, nr(e, a), a[0] = s, nr(e, a)
     }
 }
 
-function Ex(e, t, r, i) {
-    let s = e[0],
-        n;
+function PI(e, t, r, i) {
+    let n = e[0],
+        s;
     for (let o = r; o < i; o += t) {
-        n = e[o];
-        let a = n - s;
-        (a > 180 || a < -180) && (n -= Math.round(a / 360) * 360), e[o] = s = n
+        s = e[o];
+        let a = s - n;
+        (a > 180 || a < -180) && (s -= Math.round(a / 360) * 360), e[o] = n = s
     }
 }
 
-function Sx(e, t) {
+function CI(e, t) {
     let r, i = e.length / t;
-    for (let n = 0; n < i && (r = e[n * t], (r + 180) % 360 === 0); n++);
-    let s = -Math.round(r / 360) * 360;
-    if (s !== 0)
-        for (let n = 0; n < i; n++) e[n * t] += s
+    for (let s = 0; s < i && (r = e[s * t], (r + 180) % 360 === 0); s++);
+    let n = -Math.round(r / 360) * 360;
+    if (n !== 0)
+        for (let s = 0; s < i; s++) e[s * t] += n
 }
 
-function wx(e, t, r, i) {
-    let s;
+function OI(e, t, r, i) {
+    let n;
     if (Array.isArray(e[0])) {
-        let n = e.length * t;
-        s = new Array(n);
+        let s = e.length * t;
+        n = new Array(s);
         for (let o = 0; o < e.length; o++)
-            for (let a = 0; a < t; a++) s[o * t + a] = e[o][a] || 0
-    } else s = e;
-    return r ? Ho(s, {
+            for (let a = 0; a < t; a++) n[o * t + a] = e[o][a] || 0
+    } else n = e;
+    return r ? ju(n, {
         size: t,
         gridResolution: r
-    }) : i ? Gd(s, {
+    }) : i ? hx(n, {
         size: t
-    }) : s
+    }) : n
 }
-var sM = 1,
-    nM = 2,
-    tp = 4,
-    $o = class extends xr {
+var QU = 1,
+    t4 = 2,
+    px = 4,
+    $u = class extends Rn {
         constructor(t) {
             super({
                 ...t,
                 attributes: {
                     positions: {
                         size: 3,
                         padding: 18,
@@ -27091,77 +28219,77 @@
         get(t) {
             return this.attributes[t]
         }
         getGeometryFromBuffer(t) {
             return this.normalize ? super.getGeometryFromBuffer(t) : null
         }
         normalizeGeometry(t) {
-            return this.normalize ? wx(t, this.positionSize, this.opts.resolution, this.opts.wrapLongitude) : t
+            return this.normalize ? OI(t, this.positionSize, this.opts.resolution, this.opts.wrapLongitude) : t
         }
         getGeometrySize(t) {
-            if (vx(t)) {
+            if (NI(t)) {
                 let i = 0;
-                for (let s of t) i += this.getGeometrySize(s);
+                for (let n of t) i += this.getGeometrySize(n);
                 return i
             }
             let r = this.getPathLength(t);
             return r < 2 ? 0 : this.isClosed(t) ? r < 3 ? 0 : r + 2 : r
         }
         updateGeometryAttributes(t, r) {
             if (r.geometrySize !== 0)
-                if (t && vx(t))
+                if (t && NI(t))
                     for (let i of t) {
-                        let s = this.getGeometrySize(i);
-                        r.geometrySize = s, this.updateGeometryAttributes(i, r), r.vertexStart += s
+                        let n = this.getGeometrySize(i);
+                        r.geometrySize = n, this.updateGeometryAttributes(i, r), r.vertexStart += n
                     } else this._updateSegmentTypes(t, r), this._updatePositions(t, r)
         }
         _updateSegmentTypes(t, r) {
             let i = this.attributes.segmentTypes,
-                s = t ? this.isClosed(t) : !1,
+                n = t ? this.isClosed(t) : !1,
                 {
-                    vertexStart: n,
+                    vertexStart: s,
                     geometrySize: o
                 } = r;
-            i.fill(0, n, n + o), s ? (i[n] = tp, i[n + o - 2] = tp) : (i[n] += sM, i[n + o - 2] += nM), i[n + o - 1] = tp
+            i.fill(0, s, s + o), n ? (i[s] = px, i[s + o - 2] = px) : (i[s] += QU, i[s + o - 2] += t4), i[s + o - 1] = px
         }
         _updatePositions(t, r) {
             let {
                 positions: i
             } = this.attributes;
             if (!i || !t) return;
             let {
-                vertexStart: s,
-                geometrySize: n
+                vertexStart: n,
+                geometrySize: s
             } = r, o = new Array(3);
-            for (let a = s, c = 0; c < n; a++, c++) this.getPointOnPath(t, c, o), i[a * 3] = o[0], i[a * 3 + 1] = o[1], i[a * 3 + 2] = o[2]
+            for (let a = n, c = 0; c < s; a++, c++) this.getPointOnPath(t, c, o), i[a * 3] = o[0], i[a * 3 + 1] = o[1], i[a * 3 + 2] = o[2]
         }
         getPathLength(t) {
             return t.length / this.positionSize
         }
         getPointOnPath(t, r, i = []) {
             let {
-                positionSize: s
+                positionSize: n
             } = this;
-            r * s >= t.length && (r += 1 - t.length / s);
-            let n = r * s;
-            return i[0] = t[n], i[1] = t[n + 1], i[2] = s === 3 && t[n + 2] || 0, i
+            r * n >= t.length && (r += 1 - t.length / n);
+            let s = r * n;
+            return i[0] = t[s], i[1] = t[s + 1], i[2] = n === 3 && t[s + 2] || 0, i
         }
         isClosed(t) {
             if (!this.normalize) return !!this.opts.loop;
             let {
                 positionSize: r
             } = this, i = t.length - r;
             return t[0] === t[i] && t[1] === t[i + 1] && (r === 2 || t[2] === t[i + 2])
         }
     };
 
-function vx(e) {
+function NI(e) {
     return Array.isArray(e[0])
 }
-var Rx = `#version 300 es
+var BI = `#version 300 es
 #define SHADER_NAME path-layer-vertex-shader
 in vec2 positions;
 in float instanceTypes;
 in vec3 instanceStartPositions;
 in vec3 instanceEndPositions;
 in vec3 instanceLeftPositions;
 in vec3 instanceRightPositions;
@@ -27307,15 +28435,15 @@
 geometry.position = vec4(currPosition + offset, 1.0);
 gl_Position = project_common_position_to_clipspace(geometry.position);
 DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
 }
 DECKGL_FILTER_COLOR(vColor, geometry);
 }
 `;
-var Px = `#version 300 es
+var FI = `#version 300 es
 #define SHADER_NAME path-layer-fragment-shader
 precision highp float;
 uniform float miterLimit;
 in vec4 vColor;
 in vec2 vCornerOffset;
 in float vMiterLength;
 in vec2 vPathPosition;
@@ -27332,16 +28460,16 @@
 discard;
 }
 }
 fragColor = vColor;
 DECKGL_FILTER_COLOR(fragColor, geometry);
 }
 `;
-var Mx = [0, 0, 0, 255],
-    oM = {
+var DI = [0, 0, 0, 255],
+    e4 = {
         widthUnits: "meters",
         widthScale: {
             type: "number",
             min: 0,
             value: 1
         },
         widthMinPixels: {
@@ -27365,33 +28493,33 @@
         _pathType: null,
         getPath: {
             type: "accessor",
             value: e => e.path
         },
         getColor: {
             type: "accessor",
-            value: Mx
+            value: DI
         },
         getWidth: {
             type: "accessor",
             value: 1
         },
         rounded: {
             deprecatedFor: ["jointRounded", "capRounded"]
         }
     },
-    ep = {
+    mx = {
         enter: (e, t) => t.length ? t.subarray(t.length - e.length) : e
     },
-    Bl = class Bl extends Et {
+    qp = class qp extends de {
         getShaders() {
             return super.getShaders({
-                vs: Rx,
-                fs: Px,
-                modules: [Ut, zt]
+                vs: BI,
+                fs: FI,
+                modules: [ke, Ve]
             })
         }
         get wrapLongitude() {
             return !1
         }
         getBounds() {
             return this.getAttributeManager()?.getBounds(["vertexPositions"])
@@ -27399,15 +28527,15 @@
         initializeState() {
             this.getAttributeManager().addInstanced({
                 vertexPositions: {
                     size: 3,
                     vertexOffset: 1,
                     type: "float64",
                     fp64: this.use64bitPositions(),
-                    transition: ep,
+                    transition: mx,
                     accessor: "getPath",
                     update: this.calculatePositions,
                     noAlloc: !0,
                     shaderAttributes: {
                         instanceLeftPositions: {
                             vertexOffset: 0
                         },
@@ -27427,44 +28555,44 @@
                     type: "uint8",
                     update: this.calculateSegmentTypes,
                     noAlloc: !0
                 },
                 instanceStrokeWidths: {
                     size: 1,
                     accessor: "getWidth",
-                    transition: ep,
+                    transition: mx,
                     defaultValue: 1
                 },
                 instanceColors: {
                     size: this.props.colorFormat.length,
                     type: "unorm8",
                     accessor: "getColor",
-                    transition: ep,
-                    defaultValue: Mx
+                    transition: mx,
+                    defaultValue: DI
                 },
                 instancePickingColors: {
                     size: 4,
                     type: "uint8",
                     accessor: (i, {
-                        index: s,
-                        target: n
-                    }) => this.encodePickingColor(i && i.__source ? i.__source.index : s, n)
+                        index: n,
+                        target: s
+                    }) => this.encodePickingColor(i && i.__source ? i.__source.index : n, s)
                 }
             }), this.setState({
-                pathTesselator: new $o({
+                pathTesselator: new $u({
                     fp64: this.use64bitPositions()
                 })
             })
         }
         updateState(t) {
             super.updateState(t);
             let {
                 props: r,
                 changeFlags: i
-            } = t, s = this.getAttributeManager();
+            } = t, n = this.getAttributeManager();
             if (i.dataChanged || i.updateTriggersChanged && (i.updateTriggersChanged.all || i.updateTriggersChanged.getPath)) {
                 let {
                     pathTesselator: o
                 } = this.state, a = r.data.attributes || {};
                 o.updateGeometry({
                     data: r.data,
                     geometryBuffer: a.getPath,
@@ -27475,64 +28603,64 @@
                     positionFormat: r.positionFormat,
                     wrapLongitude: r.wrapLongitude,
                     resolution: this.context.viewport.resolution,
                     dataChanged: i.dataChanged
                 }), this.setState({
                     numInstances: o.instanceCount,
                     startIndices: o.vertexStarts
-                }), i.dataChanged || s.invalidateAll()
+                }), i.dataChanged || n.invalidateAll()
             }
-            i.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), s.invalidateAll())
+            i.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), n.invalidateAll())
         }
         getPickingInfo(t) {
             let r = super.getPickingInfo(t),
                 {
                     index: i
                 } = r,
-                s = this.props.data;
-            return s[0] && s[0].__source && (r.object = s.find(n => n.__source.index === i)), r
+                n = this.props.data;
+            return n[0] && n[0].__source && (r.object = n.find(s => s.__source.index === i)), r
         }
         disablePickingIndex(t) {
             let r = this.props.data;
             if (r[0] && r[0].__source)
                 for (let i = 0; i < r.length; i++) r[i].__source.index === t && this._disablePickingIndex(i);
             else super.disablePickingIndex(t)
         }
         draw({
             uniforms: t
         }) {
             let {
                 jointRounded: r,
                 capRounded: i,
-                billboard: s,
-                miterLimit: n,
+                billboard: n,
+                miterLimit: s,
                 widthUnits: o,
                 widthScale: a,
                 widthMinPixels: c,
                 widthMaxPixels: l
-            } = this.props, h = this.state.model;
-            h.setUniforms(t), h.setUniforms({
+            } = this.props, u = this.state.model;
+            u.setUniforms(t), u.setUniforms({
                 jointType: Number(r),
                 capType: Number(i),
-                billboard: s,
-                widthUnits: Kt[o],
+                billboard: n,
+                widthUnits: tr[o],
                 widthScale: a,
-                miterLimit: n,
+                miterLimit: s,
                 widthMinPixels: c,
                 widthMaxPixels: l
-            }), h.draw(this.context.renderPass)
+            }), u.draw(this.context.renderPass)
         }
         _getModel() {
             let t = [0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4],
                 r = [0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0];
-            return new bt(this.context.device, {
+            return new ce(this.context.device, {
                 ...this.getShaders(),
                 id: this.props.id,
                 bufferLayout: this.getAttributeManager().getBufferLayouts(),
-                geometry: new Qt({
+                geometry: new er({
                     topology: "triangle-list",
                     attributes: {
                         indices: new Uint16Array(t),
                         positions: {
                             value: new Float32Array(r),
                             size: 2
                         }
@@ -27550,153 +28678,153 @@
         calculateSegmentTypes(t) {
             let {
                 pathTesselator: r
             } = this.state;
             t.startIndices = r.vertexStarts, t.value = r.get("segmentTypes")
         }
     };
-Bl.defaultProps = oM, Bl.layerName = "PathLayer";
-var rr = Bl;
-var Ux = Fp(Fx(), 1);
-var jl = Fl.CLOCKWISE,
-    Dx = Fl.COUNTER_CLOCKWISE,
-    ni = {
+qp.defaultProps = e4, qp.layerName = "PathLayer";
+var Qi = qp;
+var XI = eT(zI(), 1);
+var Qp = Hp.CLOCKWISE,
+    WI = Hp.COUNTER_CLOCKWISE,
+    zs = {
         isClosed: !0
     };
 
-function AM(e) {
+function _4(e) {
     if (e = e && e.positions || e, !Array.isArray(e) && !ArrayBuffer.isView(e)) throw new Error("invalid polygon")
 }
 
-function Hs(e) {
+function hc(e) {
     return "positions" in e ? e.positions : e
 }
 
-function Ko(e) {
+function Zu(e) {
     return "holeIndices" in e ? e.holeIndices : null
 }
 
-function EM(e) {
+function y4(e) {
     return Array.isArray(e[0])
 }
 
-function SM(e) {
+function b4(e) {
     return e.length >= 1 && e[0].length >= 2 && Number.isFinite(e[0][0])
 }
 
-function wM(e) {
+function x4(e) {
     let t = e[0],
         r = e[e.length - 1];
     return t[0] === r[0] && t[1] === r[1] && t[2] === r[2]
 }
 
-function vM(e, t, r, i) {
-    for (let s = 0; s < t; s++)
-        if (e[r + s] !== e[i - t + s]) return !1;
+function w4(e, t, r, i) {
+    for (let n = 0; n < t; n++)
+        if (e[r + n] !== e[i - t + n]) return !1;
     return !0
 }
 
-function kx(e, t, r, i, s) {
-    let n = t,
+function jI(e, t, r, i, n) {
+    let s = t,
         o = r.length;
     for (let a = 0; a < o; a++)
-        for (let c = 0; c < i; c++) e[n++] = r[a][c] || 0;
-    if (!wM(r))
-        for (let a = 0; a < i; a++) e[n++] = r[0][a] || 0;
-    return ni.start = t, ni.end = n, ni.size = i, zo(e, s, ni), n
+        for (let c = 0; c < i; c++) e[s++] = r[a][c] || 0;
+    if (!x4(r))
+        for (let a = 0; a < i; a++) e[s++] = r[0][a] || 0;
+    return zs.start = t, zs.end = s, zs.size = i, Vu(e, n, zs), s
 }
 
-function Lx(e, t, r, i, s = 0, n, o) {
-    n = n || r.length;
-    let a = n - s;
+function HI(e, t, r, i, n = 0, s, o) {
+    s = s || r.length;
+    let a = s - n;
     if (a <= 0) return t;
     let c = t;
-    for (let l = 0; l < a; l++) e[c++] = r[s + l];
-    if (!vM(r, i, s, n))
-        for (let l = 0; l < i; l++) e[c++] = r[s + l];
-    return ni.start = t, ni.end = c, ni.size = i, zo(e, o, ni), c
+    for (let l = 0; l < a; l++) e[c++] = r[n + l];
+    if (!w4(r, i, n, s))
+        for (let l = 0; l < i; l++) e[c++] = r[n + l];
+    return zs.start = t, zs.end = c, zs.size = i, Vu(e, o, zs), c
 }
 
-function Vx(e, t) {
-    AM(e);
+function YI(e, t) {
+    _4(e);
     let r = [],
         i = [];
     if ("positions" in e) {
         let {
-            positions: s,
-            holeIndices: n
+            positions: n,
+            holeIndices: s
         } = e;
-        if (n) {
+        if (s) {
             let o = 0;
-            for (let a = 0; a <= n.length; a++) o = Lx(r, o, s, t, n[a - 1], n[a], a === 0 ? jl : Dx), i.push(o);
+            for (let a = 0; a <= s.length; a++) o = HI(r, o, n, t, s[a - 1], s[a], a === 0 ? Qp : WI), i.push(o);
             return i.pop(), {
                 positions: r,
                 holeIndices: i
             }
         }
-        e = s
+        e = n
     }
-    if (!EM(e)) return Lx(r, 0, e, t, 0, r.length, jl), r;
-    if (!SM(e)) {
-        let s = 0;
-        for (let [n, o] of e.entries()) s = kx(r, s, o, t, n === 0 ? jl : Dx), i.push(s);
+    if (!y4(e)) return HI(r, 0, e, t, 0, r.length, Qp), r;
+    if (!b4(e)) {
+        let n = 0;
+        for (let [s, o] of e.entries()) n = jI(r, n, o, t, s === 0 ? Qp : WI), i.push(n);
         return i.pop(), {
             positions: r,
             holeIndices: i
         }
     }
-    return kx(r, 0, e, t, jl), r
+    return jI(r, 0, e, t, Qp), r
 }
 
-function op(e, t, r) {
+function xx(e, t, r) {
     let i = e.length / 3,
-        s = 0;
-    for (let n = 0; n < i; n++) {
-        let o = (n + 1) % i;
-        s += e[n * 3 + t] * e[o * 3 + r], s -= e[o * 3 + t] * e[n * 3 + r]
+        n = 0;
+    for (let s = 0; s < i; s++) {
+        let o = (s + 1) % i;
+        n += e[s * 3 + t] * e[o * 3 + r], n -= e[o * 3 + t] * e[s * 3 + r]
     }
-    return Math.abs(s / 2)
+    return Math.abs(n / 2)
 }
 
-function Bx(e, t, r, i) {
-    let s = e.length / 3;
-    for (let n = 0; n < s; n++) {
-        let o = n * 3,
+function $I(e, t, r, i) {
+    let n = e.length / 3;
+    for (let s = 0; s < n; s++) {
+        let o = s * 3,
             a = e[o + 0],
             c = e[o + 1],
             l = e[o + 2];
         e[o + t] = a, e[o + r] = c, e[o + i] = l
     }
 }
 
-function zx(e, t, r, i) {
-    let s = Ko(e);
-    s && (s = s.map(a => a / t));
-    let n = Hs(e),
+function qI(e, t, r, i) {
+    let n = Zu(e);
+    n && (n = n.map(a => a / t));
+    let s = hc(e),
         o = i && t === 3;
     if (r) {
-        let a = n.length;
-        n = n.slice();
+        let a = s.length;
+        s = s.slice();
         let c = [];
         for (let l = 0; l < a; l += t) {
-            c[0] = n[l], c[1] = n[l + 1], o && (c[2] = n[l + 2]);
-            let h = r(c);
-            n[l] = h[0], n[l + 1] = h[1], o && (n[l + 2] = h[2])
+            c[0] = s[l], c[1] = s[l + 1], o && (c[2] = s[l + 2]);
+            let u = r(c);
+            s[l] = u[0], s[l + 1] = u[1], o && (s[l + 2] = u[2])
         }
     }
     if (o) {
-        let a = op(n, 0, 1),
-            c = op(n, 0, 2),
-            l = op(n, 1, 2);
+        let a = xx(s, 0, 1),
+            c = xx(s, 0, 2),
+            l = xx(s, 1, 2);
         if (!a && !c && !l) return [];
-        a > c && a > l || (c > l ? (r || (n = n.slice()), Bx(n, 0, 2, 1)) : (r || (n = n.slice()), Bx(n, 2, 0, 1)))
+        a > c && a > l || (c > l ? (r || (s = s.slice()), $I(s, 0, 2, 1)) : (r || (s = s.slice()), $I(s, 2, 0, 1)))
     }
-    return (0, Ux.default)(n, s, t)
+    return (0, XI.default)(s, n, t)
 }
-var Qo = class extends xr {
+var Ku = class extends Rn {
     constructor(t) {
         let {
             fp64: r,
             IndexType: i = Uint32Array
         } = t;
         super({
             ...t,
@@ -27726,103 +28854,103 @@
         super.updateGeometry(t);
         let r = this.buffers.indices;
         if (r) this.vertexCount = (r.value || r).length;
         else if (this.data && !this.getGeometry) throw new Error("missing indices buffer")
     }
     normalizeGeometry(t) {
         if (this.normalize) {
-            let r = Vx(t, this.positionSize);
-            return this.opts.resolution ? Xo(Hs(r), Ko(r), {
+            let r = YI(t, this.positionSize);
+            return this.opts.resolution ? Hu(hc(r), Zu(r), {
                 size: this.positionSize,
                 gridResolution: this.opts.resolution,
                 edgeTypes: !0
-            }) : this.opts.wrapLongitude ? Jd(Hs(r), Ko(r), {
+            }) : this.opts.wrapLongitude ? dx(hc(r), Zu(r), {
                 size: this.positionSize,
                 maxLatitude: 86,
                 edgeTypes: !0
             }) : r
         }
         return t
     }
     getGeometrySize(t) {
-        if (Wx(t)) {
+        if (ZI(t)) {
             let r = 0;
             for (let i of t) r += this.getGeometrySize(i);
             return r
         }
-        return Hs(t).length / this.positionSize
+        return hc(t).length / this.positionSize
     }
     getGeometryFromBuffer(t) {
         return this.normalize || !this.buffers.indices ? super.getGeometryFromBuffer(t) : null
     }
     updateGeometryAttributes(t, r) {
-        if (t && Wx(t))
+        if (t && ZI(t))
             for (let i of t) {
-                let s = this.getGeometrySize(i);
-                r.geometrySize = s, this.updateGeometryAttributes(i, r), r.vertexStart += s, r.indexStart = this.indexStarts[r.geometryIndex + 1]
+                let n = this.getGeometrySize(i);
+                r.geometrySize = n, this.updateGeometryAttributes(i, r), r.vertexStart += n, r.indexStart = this.indexStarts[r.geometryIndex + 1]
             } else {
                 let i = t;
                 this._updateIndices(i, r), this._updatePositions(i, r), this._updateVertexValid(i, r)
             }
     }
     _updateIndices(t, {
         geometryIndex: r,
         vertexStart: i,
-        indexStart: s
+        indexStart: n
     }) {
         let {
-            attributes: n,
+            attributes: s,
             indexStarts: o,
             typedArrayManager: a
-        } = this, c = n.indices;
+        } = this, c = s.indices;
         if (!c || !t) return;
-        let l = s,
-            h = zx(t, this.positionSize, this.opts.preproject, this.opts.full3d);
-        c = a.allocate(c, s + h.length, {
+        let l = n,
+            u = qI(t, this.positionSize, this.opts.preproject, this.opts.full3d);
+        c = a.allocate(c, n + u.length, {
             copy: !0
         });
-        for (let f = 0; f < h.length; f++) c[l++] = h[f] + i;
-        o[r + 1] = s + h.length, n.indices = c
+        for (let f = 0; f < u.length; f++) c[l++] = u[f] + i;
+        o[r + 1] = n + u.length, s.indices = c
     }
     _updatePositions(t, {
         vertexStart: r,
         geometrySize: i
     }) {
         let {
             attributes: {
-                positions: s
+                positions: n
             },
-            positionSize: n
+            positionSize: s
         } = this;
-        if (!s || !t) return;
-        let o = Hs(t);
+        if (!n || !t) return;
+        let o = hc(t);
         for (let a = r, c = 0; c < i; a++, c++) {
-            let l = o[c * n],
-                h = o[c * n + 1],
-                f = n > 2 ? o[c * n + 2] : 0;
-            s[a * 3] = l, s[a * 3 + 1] = h, s[a * 3 + 2] = f
+            let l = o[c * s],
+                u = o[c * s + 1],
+                f = s > 2 ? o[c * s + 2] : 0;
+            n[a * 3] = l, n[a * 3 + 1] = u, n[a * 3 + 2] = f
         }
     }
     _updateVertexValid(t, {
         vertexStart: r,
         geometrySize: i
     }) {
         let {
-            positionSize: s
-        } = this, n = this.attributes.vertexValid, o = t && Ko(t);
-        if (t && t.edgeTypes ? n.set(t.edgeTypes, r) : n.fill(1, r, r + i), o)
-            for (let a = 0; a < o.length; a++) n[r + o[a] / s - 1] = 0;
-        n[r + i - 1] = 0
+            positionSize: n
+        } = this, s = this.attributes.vertexValid, o = t && Zu(t);
+        if (t && t.edgeTypes ? s.set(t.edgeTypes, r) : s.fill(1, r, r + i), o)
+            for (let a = 0; a < o.length; a++) s[r + o[a] / n - 1] = 0;
+        s[r + i - 1] = 0
     }
 };
 
-function Wx(e) {
+function ZI(e) {
     return Array.isArray(e) && e.length > 0 && !Number.isFinite(e[0])
 }
-var Hl = `uniform bool extruded;
+var tm = `uniform bool extruded;
 uniform bool isWireframe;
 uniform float elevationScale;
 uniform float opacity;
 out vec4 vColor;
 struct PolygonProps {
 vec4 fillColors;
 vec4 lineColors;
@@ -27862,49 +28990,49 @@
 vColor = vec4(lightColor, colors.a * opacity);
 } else {
 vColor = vec4(colors.rgb, colors.a * opacity);
 }
 DECKGL_FILTER_COLOR(vColor, geometry);
 }
 `;
-var jx = `#version 300 es
+var KI = `#version 300 es
 #define SHADER_NAME solid-polygon-layer-vertex-shader
 in vec3 vertexPositions;
 in vec3 vertexPositions64Low;
 in float elevations;
 in vec4 fillColors;
 in vec4 lineColors;
 in vec3 pickingColors;
-${Hl}
+${tm}
 void main(void) {
 PolygonProps props;
 props.positions = vertexPositions;
 props.positions64Low = vertexPositions64Low;
 props.elevations = elevations;
 props.fillColors = fillColors;
 props.lineColors = lineColors;
 props.pickingColors = pickingColors;
 props.normal = vec3(0.0, 0.0, 1.0);
 calculatePosition(props);
 }
 `;
-var Hx = `#version 300 es
+var GI = `#version 300 es
 #define SHADER_NAME solid-polygon-layer-vertex-shader-side
 #define IS_SIDE_VERTEX
 in vec2 positions;
 in vec3 instancePositions;
 in vec3 instanceNextPositions;
 in vec3 instancePositions64Low;
 in vec3 instanceNextPositions64Low;
 in float instanceElevations;
 in vec4 instanceFillColors;
 in vec4 instanceLineColors;
 in vec3 instancePickingColors;
 in float instanceVertexValid;
-${Hl}
+${tm}
 void main(void) {
 if(instanceVertexValid < 0.5){
 gl_Position = vec4(0.);
 return;
 }
 PolygonProps props;
 vec3 pos;
@@ -27931,26 +29059,26 @@
 props.elevations = instanceElevations * positions.y;
 props.fillColors = instanceFillColors;
 props.lineColors = instanceLineColors;
 props.pickingColors = instancePickingColors;
 calculatePosition(props);
 }
 `;
-var Xx = `#version 300 es
+var JI = `#version 300 es
 #define SHADER_NAME solid-polygon-layer-fragment-shader
 precision highp float;
 in vec4 vColor;
 out vec4 fragColor;
 void main(void) {
 fragColor = vColor;
 DECKGL_FILTER_COLOR(fragColor, geometry);
 }
 `;
-var $l = [0, 0, 0, 255],
-    PM = {
+var rm = [0, 0, 0, 255],
+    v4 = {
         filled: !0,
         extruded: !1,
         wireframe: !1,
         _normalize: !0,
         _windingOrder: "CW",
         _full3d: !1,
         elevationScale: {
@@ -27964,34 +29092,34 @@
         },
         getElevation: {
             type: "accessor",
             value: 1e3
         },
         getFillColor: {
             type: "accessor",
-            value: $l
+            value: rm
         },
         getLineColor: {
             type: "accessor",
-            value: $l
+            value: rm
         },
         material: !0
     },
-    Xl = {
+    em = {
         enter: (e, t) => t.length ? t.subarray(t.length - e.length) : e
     },
-    Yl = class Yl extends Et {
+    im = class im extends de {
         getShaders(t) {
             return super.getShaders({
-                vs: t === "top" ? jx : Hx,
-                fs: Xx,
+                vs: t === "top" ? KI : GI,
+                fs: JI,
                 defines: {
                     RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === "CCW" ? 0 : 1
                 },
-                modules: [Ut, ms, zt]
+                modules: [ke, Fa, Ve]
             })
         }
         get wrapLongitude() {
             return !1
         }
         getBounds() {
             return this.getAttributeManager()?.getBounds(["vertexPositions"])
@@ -28000,38 +29128,38 @@
             let {
                 viewport: t
             } = this.context, {
                 coordinateSystem: r
             } = this.props, {
                 _full3d: i
             } = this.props;
-            t.isGeospatial && r === K.DEFAULT && (r = K.LNGLAT);
-            let s;
-            r === K.LNGLAT && (i ? s = t.projectPosition.bind(t) : s = t.projectFlat.bind(t)), this.setState({
+            t.isGeospatial && r === gt.DEFAULT && (r = gt.LNGLAT);
+            let n;
+            r === gt.LNGLAT && (i ? n = t.projectPosition.bind(t) : n = t.projectFlat.bind(t)), this.setState({
                 numInstances: 0,
-                polygonTesselator: new Qo({
-                    preproject: s,
+                polygonTesselator: new Ku({
+                    preproject: n,
                     fp64: this.use64bitPositions(),
                     IndexType: Uint32Array
                 })
             });
-            let n = this.getAttributeManager(),
+            let s = this.getAttributeManager(),
                 o = !0;
-            n.remove(["instancePickingColors"]), n.add({
+            s.remove(["instancePickingColors"]), s.add({
                 indices: {
                     size: 1,
                     isIndexed: !0,
                     update: this.calculateIndices,
                     noAlloc: o
                 },
                 vertexPositions: {
                     size: 3,
                     type: "float64",
                     fp64: this.use64bitPositions(),
-                    transition: Xl,
+                    transition: em,
                     accessor: "getPolygon",
                     update: this.calculatePositions,
                     noAlloc: o,
                     shaderAttributes: {
                         instancePositions: {
                             vertexOffset: 0,
                             divisor: 1
@@ -28047,40 +29175,40 @@
                     type: "uint16",
                     divisor: 1,
                     update: this.calculateVertexValid,
                     noAlloc: o
                 },
                 elevations: {
                     size: 1,
-                    transition: Xl,
+                    transition: em,
                     accessor: "getElevation",
                     shaderAttributes: {
                         instanceElevations: {
                             divisor: 1
                         }
                     }
                 },
                 fillColors: {
                     size: this.props.colorFormat.length,
                     type: "unorm8",
-                    transition: Xl,
+                    transition: em,
                     accessor: "getFillColor",
-                    defaultValue: $l,
+                    defaultValue: rm,
                     shaderAttributes: {
                         instanceFillColors: {
                             divisor: 1
                         }
                     }
                 },
                 lineColors: {
                     size: this.props.colorFormat.length,
                     type: "unorm8",
-                    transition: Xl,
+                    transition: em,
                     accessor: "getLineColor",
-                    defaultValue: $l,
+                    defaultValue: rm,
                     shaderAttributes: {
                         instanceLineColors: {
                             divisor: 1
                         }
                     }
                 },
                 pickingColors: {
@@ -28099,88 +29227,88 @@
             })
         }
         getPickingInfo(t) {
             let r = super.getPickingInfo(t),
                 {
                     index: i
                 } = r,
-                s = this.props.data;
-            return s[0] && s[0].__source && (r.object = s.find(n => n.__source.index === i)), r
+                n = this.props.data;
+            return n[0] && n[0].__source && (r.object = n.find(s => s.__source.index === i)), r
         }
         disablePickingIndex(t) {
             let r = this.props.data;
             if (r[0] && r[0].__source)
                 for (let i = 0; i < r.length; i++) r[i].__source.index === t && this._disablePickingIndex(i);
             else super.disablePickingIndex(t)
         }
         draw({
             uniforms: t
         }) {
             let {
                 extruded: r,
                 filled: i,
-                wireframe: s,
-                elevationScale: n
+                wireframe: n,
+                elevationScale: s
             } = this.props, {
                 topModel: o,
                 sideModel: a,
                 wireframeModel: c,
                 polygonTesselator: l
-            } = this.state, h = {
+            } = this.state, u = {
                 ...t,
                 extruded: !!r,
-                elevationScale: n
+                elevationScale: s
             };
-            c && s && (c.setInstanceCount(l.instanceCount - 1), c.setUniforms(h), c.draw(this.context.renderPass)), a && i && (a.setInstanceCount(l.instanceCount - 1), a.setUniforms(h), a.draw(this.context.renderPass)), o && i && (o.setVertexCount(l.vertexCount), o.setUniforms(h), o.draw(this.context.renderPass))
+            c && n && (c.setInstanceCount(l.instanceCount - 1), c.setUniforms(u), c.draw(this.context.renderPass)), a && i && (a.setInstanceCount(l.instanceCount - 1), a.setUniforms(u), a.draw(this.context.renderPass)), o && i && (o.setVertexCount(l.vertexCount), o.setUniforms(u), o.draw(this.context.renderPass))
         }
         updateState(t) {
             super.updateState(t), this.updateGeometry(t);
             let {
                 props: r,
                 oldProps: i,
-                changeFlags: s
-            } = t, n = this.getAttributeManager();
-            (s.extensionsChanged || r.filled !== i.filled || r.extruded !== i.extruded) && (this.state.models?.forEach(a => a.destroy()), this.setState(this._getModels()), n.invalidateAll())
+                changeFlags: n
+            } = t, s = this.getAttributeManager();
+            (n.extensionsChanged || r.filled !== i.filled || r.extruded !== i.extruded) && (this.state.models?.forEach(a => a.destroy()), this.setState(this._getModels()), s.invalidateAll())
         }
         updateGeometry({
             props: t,
             oldProps: r,
             changeFlags: i
         }) {
             if (i.dataChanged || i.updateTriggersChanged && (i.updateTriggersChanged.all || i.updateTriggersChanged.getPolygon)) {
                 let {
-                    polygonTesselator: n
+                    polygonTesselator: s
                 } = this.state, o = t.data.attributes || {};
-                n.updateGeometry({
+                s.updateGeometry({
                     data: t.data,
                     normalize: t._normalize,
                     geometryBuffer: o.getPolygon,
                     buffers: o,
                     getGeometry: t.getPolygon,
                     positionFormat: t.positionFormat,
                     wrapLongitude: t.wrapLongitude,
                     resolution: this.context.viewport.resolution,
                     fp64: this.use64bitPositions(),
                     dataChanged: i.dataChanged,
                     full3d: t._full3d
                 }), this.setState({
-                    numInstances: n.instanceCount,
-                    startIndices: n.vertexStarts
+                    numInstances: s.instanceCount,
+                    startIndices: s.vertexStarts
                 }), i.dataChanged || this.getAttributeManager().invalidateAll()
             }
         }
         _getModels() {
             let {
                 id: t,
                 filled: r,
                 extruded: i
-            } = this.props, s, n, o, a = this.getAttributeManager().getBufferLayouts();
+            } = this.props, n, s, o, a = this.getAttributeManager().getBufferLayouts();
             if (r) {
                 let c = this.getShaders("top");
-                c.defines.NON_INSTANCED_MODEL = 1, s = new bt(this.context.device, {
+                c.defines.NON_INSTANCED_MODEL = 1, n = new ce(this.context.device, {
                     ...c,
                     id: `${t}-top`,
                     topology: "triangle-list",
                     uniforms: {
                         isWireframe: !1
                     },
                     bufferLayout: a,
@@ -28188,44 +29316,44 @@
                     userData: {
                         excludeAttributes: {
                             instanceVertexValid: !0
                         }
                     }
                 })
             }
-            return i && (n = new bt(this.context.device, {
+            return i && (s = new ce(this.context.device, {
                 ...this.getShaders("side"),
                 id: `${t}-side`,
                 bufferLayout: a,
                 uniforms: {
                     isWireframe: !1
                 },
-                geometry: new Qt({
+                geometry: new er({
                     topology: "triangle-strip",
                     attributes: {
                         positions: {
                             size: 2,
                             value: new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
                         }
                     }
                 }),
                 isInstanced: 1,
                 userData: {
                     excludeAttributes: {
                         indices: !0
                     }
                 }
-            }), o = new bt(this.context.device, {
+            }), o = new ce(this.context.device, {
                 ...this.getShaders("side"),
                 id: `${t}-wireframe`,
                 bufferLayout: a,
                 uniforms: {
                     isWireframe: !0
                 },
-                geometry: new Qt({
+                geometry: new er({
                     topology: "line-strip",
                     attributes: {
                         positions: {
                             size: 2,
                             value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
                         }
                     }
@@ -28233,17 +29361,17 @@
                 isInstanced: 1,
                 userData: {
                     excludeAttributes: {
                         indices: !0
                     }
                 }
             })), {
-                models: [n, o, s].filter(Boolean),
-                topModel: s,
-                sideModel: n,
+                models: [s, o, n].filter(Boolean),
+                topModel: n,
+                sideModel: s,
                 wireframeModel: o
             }
         }
         calculateIndices(t) {
             let {
                 polygonTesselator: r
             } = this.state;
@@ -28255,79 +29383,79 @@
             } = this.state;
             t.startIndices = r.vertexStarts, t.value = r.get("positions")
         }
         calculateVertexValid(t) {
             t.value = this.state.polygonTesselator.get("vertexValid")
         }
     };
-Yl.defaultProps = PM, Yl.layerName = "SolidPolygonLayer";
-var Xs = Yl;
+im.defaultProps = v4, im.layerName = "SolidPolygonLayer";
+var dc = im;
 
-function $x({
+function QI({
     data: e,
     getIndex: t,
     dataRange: r,
     replace: i
 }) {
     let {
-        startRow: s = 0,
-        endRow: n = 1 / 0
+        startRow: n = 0,
+        endRow: s = 1 / 0
     } = r, o = e.length, a = o, c = o;
-    for (let u = 0; u < o; u++) {
-        let d = t(e[u]);
-        if (a > u && d >= s && (a = u), d >= n) {
-            c = u;
+    for (let h = 0; h < o; h++) {
+        let d = t(e[h]);
+        if (a > h && d >= n && (a = h), d >= s) {
+            c = h;
             break
         }
     }
     let l = a,
         f = c - a !== i.length ? e.slice(c) : void 0;
-    for (let u = 0; u < i.length; u++) e[l++] = i[u];
+    for (let h = 0; h < i.length; h++) e[l++] = i[h];
     if (f) {
-        for (let u = 0; u < f.length; u++) e[l++] = f[u];
+        for (let h = 0; h < f.length; h++) e[l++] = f[h];
         e.length = l
     }
     return {
         startRow: a,
         endRow: a + i.length
     }
 }
 
-function Yx(e, t) {
+function tR(e, t) {
     if (!e) return null;
     let r = "startIndices" in e ? e.startIndices[t] : t,
         i = e.featureIds.value[r];
-    return r !== -1 ? MM(e, i, r) : null
+    return r !== -1 ? S4(e, i, r) : null
 }
 
-function MM(e, t, r) {
+function S4(e, t, r) {
     let i = {
         properties: {
             ...e.properties[t]
         }
     };
-    for (let s in e.numericProps) i.properties[s] = e.numericProps[s].value[r];
+    for (let n in e.numericProps) i.properties[n] = e.numericProps[n].value[r];
     return i
 }
 
-function qx(e, t) {
+function eR(e, t) {
     let r = {
         points: null,
         lines: null,
         polygons: null
     };
     for (let i in r) {
-        let s = e[i].globalFeatureIds.value;
-        r[i] = new Uint8ClampedArray(s.length * 3);
-        let n = [];
-        for (let o = 0; o < s.length; o++) t(s[o], n), r[i][o * 3 + 0] = n[0], r[i][o * 3 + 1] = n[1], r[i][o * 3 + 2] = n[2]
+        let n = e[i].globalFeatureIds.value;
+        r[i] = new Uint8ClampedArray(n.length * 3);
+        let s = [];
+        for (let o = 0; o < n.length; o++) t(n[o], s), r[i][o * 3 + 0] = s[0], r[i][o * 3 + 1] = s[1], r[i][o * 3 + 2] = s[2]
     }
     return r
 }
-var Zx = `#version 300 es
+var rR = `#version 300 es
 #define SHADER_NAME multi-icon-layer-fragment-shader
 precision highp float;
 uniform float opacity;
 uniform sampler2D iconsTexture;
 uniform float gamma;
 uniform bool sdf;
 uniform float alphaCutoff;
@@ -28358,354 +29486,354 @@
 discard;
 }
 fragColor = vec4(color.rgb, a * opacity);
 }
 DECKGL_FILTER_COLOR(fragColor, geometry);
 }
 `;
-var ap = 192 / 256,
-    Kx = [],
-    CM = {
+var wx = 192 / 256,
+    iR = [],
+    A4 = {
         getIconOffsets: {
             type: "accessor",
             value: e => e.offsets
         },
         alphaCutoff: .001,
         smoothing: .1,
         outlineWidth: 0,
         outlineColor: {
             type: "color",
             value: [0, 0, 0, 255]
         }
     },
-    ql = class ql extends ii {
+    nm = class nm extends Us {
         getShaders() {
             return {
                 ...super.getShaders(),
-                fs: Zx
+                fs: rR
             }
         }
         initializeState() {
             super.initializeState(), this.getAttributeManager().addInstanced({
                 instanceOffsets: {
                     size: 2,
                     accessor: "getIconOffsets"
                 },
                 instancePickingColors: {
                     type: "uint8",
                     size: 3,
                     accessor: (r, {
                         index: i,
-                        target: s
-                    }) => this.encodePickingColor(i, s)
+                        target: n
+                    }) => this.encodePickingColor(i, n)
                 }
             })
         }
         updateState(t) {
             super.updateState(t);
             let {
                 props: r,
                 oldProps: i
             } = t, {
-                outlineColor: s
+                outlineColor: n
             } = r;
-            s !== i.outlineColor && (s = s.map(n => n / 255), s[3] = Number.isFinite(s[3]) ? s[3] : 1, this.setState({
-                outlineColor: s
-            })), !r.sdf && r.outlineWidth && j.warn(`${this.id}: fontSettings.sdf is required to render outline`)()
+            n !== i.outlineColor && (n = n.map(s => s / 255), n[3] = Number.isFinite(n[3]) ? n[3] : 1, this.setState({
+                outlineColor: n
+            })), !r.sdf && r.outlineWidth && Z.warn(`${this.id}: fontSettings.sdf is required to render outline`)()
         }
         draw(t) {
             let {
                 sdf: r,
                 smoothing: i,
-                outlineWidth: s
+                outlineWidth: n
             } = this.props, {
-                outlineColor: n
-            } = this.state, o = s ? Math.max(i, ap * (1 - s)) : -1;
+                outlineColor: s
+            } = this.state, o = n ? Math.max(i, wx * (1 - n)) : -1;
             if (t.uniforms = {
                     ...t.uniforms,
-                    sdfBuffer: ap,
+                    sdfBuffer: wx,
                     outlineBuffer: o,
                     gamma: i,
                     sdf: !!r,
-                    outlineColor: n
-                }, super.draw(t), r && s) {
+                    outlineColor: s
+                }, super.draw(t), r && n) {
                 let {
                     iconManager: a
                 } = this.state, c = a.getTexture(), l = this.state.model;
                 c && (l.setUniforms({
-                    outlineBuffer: ap
+                    outlineBuffer: wx
                 }), l.draw(this.context.renderPass))
             }
         }
         getInstanceOffset(t) {
-            return t ? Array.from(t).flatMap(r => super.getInstanceOffset(r)) : Kx
+            return t ? Array.from(t).flatMap(r => super.getInstanceOffset(r)) : iR
         }
         getInstanceColorMode(t) {
             return 1
         }
         getInstanceIconFrame(t) {
-            return t ? Array.from(t).flatMap(r => super.getInstanceIconFrame(r)) : Kx
+            return t ? Array.from(t).flatMap(r => super.getInstanceIconFrame(r)) : iR
         }
     };
-ql.defaultProps = CM, ql.layerName = "MultiIconLayer";
-var Go = ql;
-var Jo = class {
+nm.defaultProps = A4, nm.layerName = "MultiIconLayer";
+var Gu = nm;
+var Ju = class {
     constructor({
         fontSize: t = 24,
         buffer: r = 3,
         radius: i = 8,
-        cutoff: s = .25,
-        fontFamily: n = "sans-serif",
+        cutoff: n = .25,
+        fontFamily: s = "sans-serif",
         fontWeight: o = "normal",
         fontStyle: a = "normal"
     } = {}) {
-        this.buffer = r, this.cutoff = s, this.radius = i;
+        this.buffer = r, this.cutoff = n, this.radius = i;
         let c = this.size = t + r * 4,
             l = this._createCanvas(c),
-            h = this.ctx = l.getContext("2d", {
+            u = this.ctx = l.getContext("2d", {
                 willReadFrequently: !0
             });
-        h.font = `${a} ${o} ${t}px ${n}`, h.textBaseline = "alphabetic", h.textAlign = "left", h.fillStyle = "black", this.gridOuter = new Float64Array(c * c), this.gridInner = new Float64Array(c * c), this.f = new Float64Array(c), this.z = new Float64Array(c + 1), this.v = new Uint16Array(c)
+        u.font = `${a} ${o} ${t}px ${s}`, u.textBaseline = "alphabetic", u.textAlign = "left", u.fillStyle = "black", this.gridOuter = new Float64Array(c * c), this.gridInner = new Float64Array(c * c), this.f = new Float64Array(c), this.z = new Float64Array(c + 1), this.v = new Uint16Array(c)
     }
     _createCanvas(t) {
         let r = document.createElement("canvas");
         return r.width = r.height = t, r
     }
     draw(t) {
         let {
             width: r,
             actualBoundingBoxAscent: i,
-            actualBoundingBoxDescent: s,
-            actualBoundingBoxLeft: n,
+            actualBoundingBoxDescent: n,
+            actualBoundingBoxLeft: s,
             actualBoundingBoxRight: o
-        } = this.ctx.measureText(t), a = Math.ceil(i), c = 0, l = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o - n))), h = Math.min(this.size - this.buffer, a + Math.ceil(s)), f = l + 2 * this.buffer, u = h + 2 * this.buffer, d = Math.max(f * u, 0), m = new Uint8ClampedArray(d), y = {
-            data: m,
+        } = this.ctx.measureText(t), a = Math.ceil(i), c = 0, l = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o - s))), u = Math.min(this.size - this.buffer, a + Math.ceil(n)), f = l + 2 * this.buffer, h = u + 2 * this.buffer, d = Math.max(f * h, 0), p = new Uint8ClampedArray(d), y = {
+            data: p,
             width: f,
-            height: u,
+            height: h,
             glyphWidth: l,
-            glyphHeight: h,
+            glyphHeight: u,
             glyphTop: a,
             glyphLeft: c,
             glyphAdvance: r
         };
-        if (l === 0 || h === 0) return y;
+        if (l === 0 || u === 0) return y;
         let {
-            ctx: x,
-            buffer: A,
-            gridInner: v,
-            gridOuter: E
+            ctx: b,
+            buffer: T,
+            gridInner: I,
+            gridOuter: S
         } = this;
-        x.clearRect(A, A, l, h), x.fillText(t, A, A + a);
-        let R = x.getImageData(A, A, l, h);
-        E.fill(1e20, 0, d), v.fill(0, 0, d);
-        for (let M = 0; M < h; M++)
+        b.clearRect(T, T, l, u), b.fillText(t, T, T + a);
+        let R = b.getImageData(T, T, l, u);
+        S.fill(1e20, 0, d), I.fill(0, 0, d);
+        for (let P = 0; P < u; P++)
             for (let C = 0; C < l; C++) {
-                let B = R.data[4 * (M * l + C) + 3] / 255;
-                if (B === 0) continue;
-                let L = (M + A) * f + C + A;
-                if (B === 1) E[L] = 0, v[L] = 1e20;
+                let V = R.data[4 * (P * l + C) + 3] / 255;
+                if (V === 0) continue;
+                let U = (P + T) * f + C + T;
+                if (V === 1) S[U] = 0, I[U] = 1e20;
                 else {
-                    let k = .5 - B;
-                    E[L] = k > 0 ? k * k : 0, v[L] = k < 0 ? k * k : 0
+                    let k = .5 - V;
+                    S[U] = k > 0 ? k * k : 0, I[U] = k < 0 ? k * k : 0
                 }
             }
-        Qx(E, 0, 0, f, u, f, this.f, this.v, this.z), Qx(v, A, A, l, h, f, this.f, this.v, this.z);
-        for (let M = 0; M < d; M++) {
-            let C = Math.sqrt(E[M]) - Math.sqrt(v[M]);
-            m[M] = Math.round(255 - 255 * (C / this.radius + this.cutoff))
+        nR(S, 0, 0, f, h, f, this.f, this.v, this.z), nR(I, T, T, l, u, f, this.f, this.v, this.z);
+        for (let P = 0; P < d; P++) {
+            let C = Math.sqrt(S[P]) - Math.sqrt(I[P]);
+            p[P] = Math.round(255 - 255 * (C / this.radius + this.cutoff))
         }
         return y
     }
 };
 
-function Qx(e, t, r, i, s, n, o, a, c) {
-    for (let l = t; l < t + i; l++) Gx(e, r * n + l, n, s, o, a, c);
-    for (let l = r; l < r + s; l++) Gx(e, l * n + t, 1, i, o, a, c)
+function nR(e, t, r, i, n, s, o, a, c) {
+    for (let l = t; l < t + i; l++) sR(e, r * s + l, s, n, o, a, c);
+    for (let l = r; l < r + n; l++) sR(e, l * s + t, 1, i, o, a, c)
 }
 
-function Gx(e, t, r, i, s, n, o) {
-    n[0] = 0, o[0] = -1e20, o[1] = 1e20, s[0] = e[t];
+function sR(e, t, r, i, n, s, o) {
+    s[0] = 0, o[0] = -1e20, o[1] = 1e20, n[0] = e[t];
     for (let a = 1, c = 0, l = 0; a < i; a++) {
-        s[a] = e[t + a * r];
-        let h = a * a;
+        n[a] = e[t + a * r];
+        let u = a * a;
         do {
-            let f = n[c];
-            l = (s[a] - s[f] + h - f * f) / (a - f) / 2
+            let f = s[c];
+            l = (n[a] - n[f] + u - f * f) / (a - f) / 2
         } while (l <= o[c] && --c > -1);
-        c++, n[c] = a, o[c] = l, o[c + 1] = 1e20
+        c++, s[c] = a, o[c] = l, o[c + 1] = 1e20
     }
     for (let a = 0, c = 0; a < i; a++) {
         for (; o[c + 1] < a;) c++;
-        let l = n[c],
-            h = a - l;
-        e[t + a * r] = s[l] + h * h
+        let l = s[c],
+            u = a - l;
+        e[t + a * r] = n[l] + u * u
     }
 }
-var IM = 32,
-    OM = [];
+var E4 = 32,
+    I4 = [];
 
-function NM(e) {
+function R4(e) {
     return Math.pow(2, Math.ceil(Math.log2(e)))
 }
 
-function Jx({
+function oR({
     characterSet: e,
     getFontWidth: t,
     fontHeight: r,
     buffer: i,
-    maxCanvasWidth: s,
-    mapping: n = {},
+    maxCanvasWidth: n,
+    mapping: s = {},
     xOffset: o = 0,
     yOffset: a = 0
 }) {
     let c = 0,
         l = o,
-        h = r + i * 2;
+        u = r + i * 2;
     for (let f of e)
-        if (!n[f]) {
-            let u = t(f);
-            l + u + i * 2 > s && (l = 0, c++), n[f] = {
+        if (!s[f]) {
+            let h = t(f);
+            l + h + i * 2 > n && (l = 0, c++), s[f] = {
                 x: l + i,
-                y: a + c * h + i,
-                width: u,
-                height: h,
-                layoutWidth: u,
+                y: a + c * u + i,
+                width: h,
+                height: u,
+                layoutWidth: h,
                 layoutHeight: r
-            }, l += u + i * 2
+            }, l += h + i * 2
         } return {
-        mapping: n,
+        mapping: s,
         xOffset: l,
-        yOffset: a + c * h,
-        canvasHeight: NM(a + (c + 1) * h)
+        yOffset: a + c * u,
+        canvasHeight: R4(a + (c + 1) * u)
     }
 }
 
-function tT(e, t, r, i) {
-    let s = 0;
-    for (let n = t; n < r; n++) {
-        let o = e[n];
-        s += i[o]?.layoutWidth || 0
+function aR(e, t, r, i) {
+    let n = 0;
+    for (let s = t; s < r; s++) {
+        let o = e[s];
+        n += i[o]?.layoutWidth || 0
     }
-    return s
+    return n
 }
 
-function eT(e, t, r, i, s, n) {
+function cR(e, t, r, i, n, s) {
     let o = t,
         a = 0;
     for (let c = t; c < r; c++) {
-        let l = tT(e, c, c + 1, s);
-        a + l > i && (o < c && n.push(c), o = c, a = 0), a += l
+        let l = aR(e, c, c + 1, n);
+        a + l > i && (o < c && s.push(c), o = c, a = 0), a += l
     }
     return a
 }
 
-function FM(e, t, r, i, s, n) {
+function M4(e, t, r, i, n, s) {
     let o = t,
         a = t,
         c = t,
         l = 0;
-    for (let h = t; h < r; h++)
-        if ((e[h] === " " || e[h + 1] === " " || h + 1 === r) && (c = h + 1), c > a) {
-            let f = tT(e, a, c, s);
-            l + f > i && (o < a && (n.push(a), o = a, l = 0), f > i && (f = eT(e, a, c, i, s, n), o = n[n.length - 1])), a = c, l += f
+    for (let u = t; u < r; u++)
+        if ((e[u] === " " || e[u + 1] === " " || u + 1 === r) && (c = u + 1), c > a) {
+            let f = aR(e, a, c, n);
+            l + f > i && (o < a && (s.push(a), o = a, l = 0), f > i && (f = cR(e, a, c, i, n, s), o = s[s.length - 1])), a = c, l += f
         } return l
 }
 
-function DM(e, t, r, i, s = 0, n) {
-    n === void 0 && (n = e.length);
+function P4(e, t, r, i, n = 0, s) {
+    s === void 0 && (s = e.length);
     let o = [];
-    return t === "break-all" ? eT(e, s, n, r, i, o) : FM(e, s, n, r, i, o), o
+    return t === "break-all" ? cR(e, n, s, r, i, o) : M4(e, n, s, r, i, o), o
 }
 
-function kM(e, t, r, i, s, n) {
+function C4(e, t, r, i, n, s) {
     let o = 0,
         a = 0;
     for (let c = t; c < r; c++) {
         let l = e[c],
-            h = i[l];
-        h ? (a || (a = h.layoutHeight), s[c] = o + h.layoutWidth / 2, o += h.layoutWidth) : (j.warn(`Missing character: ${l} (${l.codePointAt(0)})`)(), s[c] = o, o += IM)
+            u = i[l];
+        u ? (a || (a = u.layoutHeight), n[c] = o + u.layoutWidth / 2, o += u.layoutWidth) : (Z.warn(`Missing character: ${l} (${l.codePointAt(0)})`)(), n[c] = o, o += E4)
     }
-    n[0] = o, n[1] = a
+    s[0] = o, s[1] = a
 }
 
-function rT(e, t, r, i, s) {
-    let n = Array.from(e),
-        o = n.length,
+function lR(e, t, r, i, n) {
+    let s = Array.from(e),
+        o = s.length,
         a = new Array(o),
         c = new Array(o),
         l = new Array(o),
-        h = (r === "break-word" || r === "break-all") && isFinite(i) && i > 0,
+        u = (r === "break-word" || r === "break-all") && isFinite(i) && i > 0,
         f = [0, 0],
-        u = [0, 0],
+        h = [0, 0],
         d = 0,
-        m = 0,
+        p = 0,
         y = 0;
-    for (let x = 0; x <= o; x++) {
-        let A = n[x];
-        if ((A === `
-` || x === o) && (y = x), y > m) {
-            let v = h ? DM(n, r, i, s, m, y) : OM;
-            for (let E = 0; E <= v.length; E++) {
-                let R = E === 0 ? m : v[E - 1],
-                    M = E < v.length ? v[E] : y;
-                kM(n, R, M, s, a, u);
-                for (let C = R; C < M; C++) {
-                    let B = n[C],
-                        L = s[B]?.layoutOffsetY || 0;
-                    c[C] = d + u[1] / 2 + L, l[C] = u[0]
+    for (let b = 0; b <= o; b++) {
+        let T = s[b];
+        if ((T === `
+` || b === o) && (y = b), y > p) {
+            let I = u ? P4(s, r, i, n, p, y) : I4;
+            for (let S = 0; S <= I.length; S++) {
+                let R = S === 0 ? p : I[S - 1],
+                    P = S < I.length ? I[S] : y;
+                C4(s, R, P, n, a, h);
+                for (let C = R; C < P; C++) {
+                    let V = s[C],
+                        U = n[V]?.layoutOffsetY || 0;
+                    c[C] = d + h[1] / 2 + U, l[C] = h[0]
                 }
-                d = d + u[1] * t, f[0] = Math.max(f[0], u[0])
+                d = d + h[1] * t, f[0] = Math.max(f[0], h[0])
             }
-            m = y
+            p = y
         }
-        A === `
-` && (a[m] = 0, c[m] = 0, l[m] = 0, m++)
+        T === `
+` && (a[p] = 0, c[p] = 0, l[p] = 0, p++)
     }
     return f[1] = d, {
         x: a,
         y: c,
         rowWidth: l,
         size: f
     }
 }
 
-function iT({
+function uR({
     value: e,
     length: t,
     stride: r,
     offset: i,
-    startIndices: s,
-    characterSet: n
+    startIndices: n,
+    characterSet: s
 }) {
     let o = e.BYTES_PER_ELEMENT,
         a = r ? r / o : 1,
         c = i ? i / o : 0,
-        l = s[t] || Math.ceil((e.length - c) / a),
-        h = n && new Set,
+        l = n[t] || Math.ceil((e.length - c) / a),
+        u = s && new Set,
         f = new Array(t),
-        u = e;
+        h = e;
     if (a > 1 || c > 0) {
         let d = e.constructor;
-        u = new d(l);
-        for (let m = 0; m < l; m++) u[m] = e[m * a + c]
+        h = new d(l);
+        for (let p = 0; p < l; p++) h[p] = e[p * a + c]
     }
     for (let d = 0; d < t; d++) {
-        let m = s[d],
-            y = s[d + 1] || l,
-            x = u.subarray(m, y);
-        f[d] = String.fromCodePoint.apply(null, x), h && x.forEach(h.add, h)
+        let p = n[d],
+            y = n[d + 1] || l,
+            b = h.subarray(p, y);
+        f[d] = String.fromCodePoint.apply(null, b), u && b.forEach(u.add, u)
     }
-    if (h)
-        for (let d of h) n.add(String.fromCodePoint(d));
+    if (u)
+        for (let d of u) s.add(String.fromCodePoint(d));
     return {
         texts: f,
         characterCount: l
     }
 }
-var $s = class {
+var pc = class {
     constructor(t = 5) {
         this._cache = {}, this._order = [], this.limit = t
     }
     get(t) {
         let r = this._cache[t];
         return r && (this._deleteOrder(t), this._appendOrder(t)), r
     }
@@ -28720,167 +29848,167 @@
         r >= 0 && this._order.splice(r, 1)
     }
     _appendOrder(t) {
         this._order.push(t)
     }
 };
 
-function LM() {
+function O4() {
     let e = [];
     for (let t = 32; t < 128; t++) e.push(String.fromCharCode(t));
     return e
 }
-var Yi = {
+var $o = {
         fontFamily: "Monaco, monospace",
         fontWeight: "normal",
-        characterSet: LM(),
+        characterSet: O4(),
         fontSize: 64,
         buffer: 4,
         sdf: !1,
         cutoff: .25,
         radius: 12,
         smoothing: .1
     },
-    sT = 1024,
-    nT = .9,
-    oT = 1.2,
-    cT = 3,
-    Zl = new $s(cT);
+    fR = 1024,
+    hR = .9,
+    dR = 1.2,
+    mR = 3,
+    sm = new pc(mR);
 
-function BM(e, t) {
+function N4(e, t) {
     let r;
     typeof t == "string" ? r = new Set(Array.from(t)) : r = new Set(t);
-    let i = Zl.get(e);
+    let i = sm.get(e);
     if (!i) return r;
-    for (let s in i.mapping) r.has(s) && r.delete(s);
+    for (let n in i.mapping) r.has(n) && r.delete(n);
     return r
 }
 
-function UM(e, t) {
+function B4(e, t) {
     for (let r = 0; r < e.length; r++) t.data[4 * r + 3] = e[r]
 }
 
-function aT(e, t, r, i) {
+function pR(e, t, r, i) {
     e.font = `${i} ${r}px ${t}`, e.fillStyle = "#000", e.textBaseline = "alphabetic", e.textAlign = "left"
 }
 
-function lT(e) {
-    j.assert(Number.isFinite(e) && e >= cT, "Invalid cache limit"), Zl = new $s(e)
+function gR(e) {
+    Z.assert(Number.isFinite(e) && e >= mR, "Invalid cache limit"), sm = new pc(e)
 }
-var ta = class {
+var Qu = class {
     constructor() {
         this.props = {
-            ...Yi
+            ...$o
         }
     }
     get atlas() {
         return this._atlas
     }
     get mapping() {
         return this._atlas && this._atlas.mapping
     }
     get scale() {
         let {
             fontSize: t,
             buffer: r
         } = this.props;
-        return (t * oT + r * 2) / t
+        return (t * dR + r * 2) / t
     }
     setProps(t = {}) {
         Object.assign(this.props, t), this._key = this._getKey();
-        let r = BM(this._key, this.props.characterSet),
-            i = Zl.get(this._key);
+        let r = N4(this._key, this.props.characterSet),
+            i = sm.get(this._key);
         if (i && r.size === 0) {
             this._atlas !== i && (this._atlas = i);
             return
         }
-        let s = this._generateFontAtlas(r, i);
-        this._atlas = s, Zl.set(this._key, s)
+        let n = this._generateFontAtlas(r, i);
+        this._atlas = n, sm.set(this._key, n)
     }
     _generateFontAtlas(t, r) {
         let {
             fontFamily: i,
-            fontWeight: s,
-            fontSize: n,
+            fontWeight: n,
+            fontSize: s,
             buffer: o,
             sdf: a,
             radius: c,
             cutoff: l
-        } = this.props, h = r && r.data;
-        h || (h = document.createElement("canvas"), h.width = sT);
-        let f = h.getContext("2d", {
+        } = this.props, u = r && r.data;
+        u || (u = document.createElement("canvas"), u.width = fR);
+        let f = u.getContext("2d", {
             willReadFrequently: !0
         });
-        aT(f, i, n, s);
+        pR(f, i, s, n);
         let {
-            mapping: u,
+            mapping: h,
             canvasHeight: d,
-            xOffset: m,
+            xOffset: p,
             yOffset: y
-        } = Jx({
-            getFontWidth: x => f.measureText(x).width,
-            fontHeight: n * oT,
+        } = oR({
+            getFontWidth: b => f.measureText(b).width,
+            fontHeight: s * dR,
             buffer: o,
             characterSet: t,
-            maxCanvasWidth: sT,
+            maxCanvasWidth: fR,
             ...r && {
                 mapping: r.mapping,
                 xOffset: r.xOffset,
                 yOffset: r.yOffset
             }
         });
-        if (h.height !== d) {
-            let x = f.getImageData(0, 0, h.width, h.height);
-            h.height = d, f.putImageData(x, 0, 0)
-        }
-        if (aT(f, i, n, s), a) {
-            let x = new Jo({
-                fontSize: n,
+        if (u.height !== d) {
+            let b = f.getImageData(0, 0, u.width, u.height);
+            u.height = d, f.putImageData(b, 0, 0)
+        }
+        if (pR(f, i, s, n), a) {
+            let b = new Ju({
+                fontSize: s,
                 buffer: o,
                 radius: c,
                 cutoff: l,
                 fontFamily: i,
-                fontWeight: `${s}`
+                fontWeight: `${n}`
             });
-            for (let A of t) {
+            for (let T of t) {
                 let {
-                    data: v,
-                    width: E,
+                    data: I,
+                    width: S,
                     height: R,
-                    glyphTop: M
-                } = x.draw(A);
-                u[A].width = E, u[A].layoutOffsetY = n * nT - M;
-                let C = f.createImageData(E, R);
-                UM(v, C), f.putImageData(C, u[A].x, u[A].y)
+                    glyphTop: P
+                } = b.draw(T);
+                h[T].width = S, h[T].layoutOffsetY = s * hR - P;
+                let C = f.createImageData(S, R);
+                B4(I, C), f.putImageData(C, h[T].x, h[T].y)
             }
         } else
-            for (let x of t) f.fillText(x, u[x].x, u[x].y + o + n * nT);
+            for (let b of t) f.fillText(b, h[b].x, h[b].y + o + s * hR);
         return {
-            xOffset: m,
+            xOffset: p,
             yOffset: y,
-            mapping: u,
-            data: h,
-            width: h.width,
-            height: h.height
+            mapping: h,
+            data: u,
+            width: u.width,
+            height: u.height
         }
     }
     _getKey() {
         let {
             fontFamily: t,
             fontWeight: r,
             fontSize: i,
-            buffer: s,
-            sdf: n,
+            buffer: n,
+            sdf: s,
             radius: o,
             cutoff: a
         } = this.props;
-        return n ? `${t} ${r} ${i} ${s} ${o} ${a}` : `${t} ${r} ${i} ${s}`
+        return s ? `${t} ${r} ${i} ${n} ${o} ${a}` : `${t} ${r} ${i} ${n}`
     }
 };
-var hT = `#version 300 es
+var _R = `#version 300 es
 #define SHADER_NAME text-background-layer-vertex-shader
 in vec2 positions;
 in vec3 instancePositions;
 in vec3 instancePositions64Low;
 in vec4 instanceRects;
 in float instanceSizes;
 in float instanceAngles;
@@ -28937,15 +30065,15 @@
 }
 vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);
 DECKGL_FILTER_COLOR(vFillColor, geometry);
 vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);
 DECKGL_FILTER_COLOR(vLineColor, geometry);
 }
 `;
-var fT = `#version 300 es
+var yR = `#version 300 es
 #define SHADER_NAME text-background-layer-fragment-shader
 precision highp float;
 uniform bool stroked;
 in vec4 vFillColor;
 in vec4 vLineColor;
 in float vLineWidth;
 in vec2 uv;
@@ -28963,15 +30091,15 @@
 fragColor = mix(vFillColor, vLineColor, isBorder);
 } else {
 fragColor = vFillColor;
 }
 DECKGL_FILTER_COLOR(fragColor, geometry);
 }
 `;
-var VM = {
+var F4 = {
         billboard: !0,
         sizeScale: 1,
         sizeUnits: "pixels",
         sizeMinPixels: 0,
         sizeMaxPixels: Number.MAX_SAFE_INTEGER,
         padding: {
             type: "array",
@@ -29006,20 +30134,20 @@
             value: [0, 0, 0, 255]
         },
         getLineWidth: {
             type: "accessor",
             value: 1
         }
     },
-    Kl = class Kl extends Et {
+    om = class om extends de {
         getShaders() {
             return super.getShaders({
-                vs: hT,
-                fs: fT,
-                modules: [Ut, zt]
+                vs: _R,
+                fs: yR,
+                modules: [ke, Ve]
             })
         }
         initializeState() {
             this.getAttributeManager().addInstanced({
                 instancePositions: {
                     size: 3,
                     type: "float64",
@@ -29078,105 +30206,105 @@
         }
         draw({
             uniforms: t
         }) {
             let {
                 billboard: r,
                 sizeScale: i,
-                sizeUnits: s,
-                sizeMinPixels: n,
+                sizeUnits: n,
+                sizeMinPixels: s,
                 sizeMaxPixels: o,
                 getLineWidth: a
             } = this.props, {
                 padding: c
             } = this.props;
             c.length < 4 && (c = [c[0], c[1], c[0], c[1]]);
             let l = this.state.model;
             l.setUniforms(t), l.setUniforms({
                 billboard: r,
                 stroked: !!a,
                 padding: c,
-                sizeUnits: Kt[s],
+                sizeUnits: tr[n],
                 sizeScale: i,
-                sizeMinPixels: n,
+                sizeMinPixels: s,
                 sizeMaxPixels: o
             }), l.draw(this.context.renderPass)
         }
         _getModel() {
             let t = [0, 0, 1, 0, 1, 1, 0, 1];
-            return new bt(this.context.device, {
+            return new ce(this.context.device, {
                 ...this.getShaders(),
                 id: this.props.id,
                 bufferLayout: this.getAttributeManager().getBufferLayouts(),
-                geometry: new Qt({
+                geometry: new er({
                     topology: "triangle-fan-webgl",
                     vertexCount: 4,
                     attributes: {
                         positions: {
                             size: 2,
                             value: new Float32Array(t)
                         }
                     }
                 }),
                 isInstanced: !0
             })
         }
     };
-Kl.defaultProps = VM, Kl.layerName = "TextBackgroundLayer";
-var ea = Kl;
-var uT = {
+om.defaultProps = F4, om.layerName = "TextBackgroundLayer";
+var tf = om;
+var bR = {
         start: 1,
         middle: 0,
         end: -1
     },
-    dT = {
+    xR = {
         top: 1,
         center: 0,
         bottom: -1
     },
-    cp = [0, 0, 0, 255],
-    zM = 1,
-    WM = {
+    Tx = [0, 0, 0, 255],
+    D4 = 1,
+    L4 = {
         billboard: !0,
         sizeScale: 1,
         sizeUnits: "pixels",
         sizeMinPixels: 0,
         sizeMaxPixels: Number.MAX_SAFE_INTEGER,
         background: !1,
         getBackgroundColor: {
             type: "accessor",
             value: [255, 255, 255, 255]
         },
         getBorderColor: {
             type: "accessor",
-            value: cp
+            value: Tx
         },
         getBorderWidth: {
             type: "accessor",
             value: 0
         },
         backgroundPadding: {
             type: "array",
             value: [0, 0, 0, 0]
         },
         characterSet: {
             type: "object",
-            value: Yi.characterSet
+            value: $o.characterSet
         },
-        fontFamily: Yi.fontFamily,
-        fontWeight: Yi.fontWeight,
-        lineHeight: zM,
+        fontFamily: $o.fontFamily,
+        fontWeight: $o.fontWeight,
+        lineHeight: D4,
         outlineWidth: {
             type: "number",
             value: 0,
             min: 0
         },
         outlineColor: {
             type: "color",
-            value: cp
+            value: Tx
         },
         fontSettings: {
             type: "object",
             value: {},
             compare: 1
         },
         wordBreak: "break-word",
@@ -29190,15 +30318,15 @@
         },
         getPosition: {
             type: "accessor",
             value: e => e.position
         },
         getColor: {
             type: "accessor",
-            value: cp
+            value: Tx
         },
         getSize: {
             type: "accessor",
             value: 32
         },
         getAngle: {
             type: "accessor",
@@ -29216,276 +30344,276 @@
             type: "accessor",
             value: [0, 0]
         },
         backgroundColor: {
             deprecatedFor: ["background", "getBackgroundColor"]
         }
     },
-    Ql = class Ql extends Ne {
+    am = class am extends li {
         constructor() {
             super(...arguments), this.getBoundingRect = (t, r) => {
                 let {
-                    size: [i, s]
+                    size: [i, n]
                 } = this.transformParagraph(t, r), {
-                    fontSize: n
+                    fontSize: s
                 } = this.state.fontAtlasManager.props;
-                i /= n, s /= n;
+                i /= s, n /= s;
                 let {
                     getTextAnchor: o,
                     getAlignmentBaseline: a
-                } = this.props, c = uT[typeof o == "function" ? o(t, r) : o], l = dT[typeof a == "function" ? a(t, r) : a];
-                return [(c - 1) * i / 2, (l - 1) * s / 2, i, s]
+                } = this.props, c = bR[typeof o == "function" ? o(t, r) : o], l = xR[typeof a == "function" ? a(t, r) : a];
+                return [(c - 1) * i / 2, (l - 1) * n / 2, i, n]
             }, this.getIconOffsets = (t, r) => {
                 let {
                     getTextAnchor: i,
-                    getAlignmentBaseline: s
+                    getAlignmentBaseline: n
                 } = this.props, {
-                    x: n,
+                    x: s,
                     y: o,
                     rowWidth: a,
                     size: [c, l]
-                } = this.transformParagraph(t, r), h = uT[typeof i == "function" ? i(t, r) : i], f = dT[typeof s == "function" ? s(t, r) : s], u = n.length, d = new Array(u * 2), m = 0;
-                for (let y = 0; y < u; y++) {
-                    let x = (1 - h) * (c - a[y]) / 2;
-                    d[m++] = (h - 1) * c / 2 + x + n[y], d[m++] = (f - 1) * l / 2 + o[y]
+                } = this.transformParagraph(t, r), u = bR[typeof i == "function" ? i(t, r) : i], f = xR[typeof n == "function" ? n(t, r) : n], h = s.length, d = new Array(h * 2), p = 0;
+                for (let y = 0; y < h; y++) {
+                    let b = (1 - u) * (c - a[y]) / 2;
+                    d[p++] = (u - 1) * c / 2 + b + s[y], d[p++] = (f - 1) * l / 2 + o[y]
                 }
                 return d
             }
         }
         initializeState() {
             this.state = {
                 styleVersion: 0,
-                fontAtlasManager: new ta
-            }, this.props.maxWidth > 0 && j.warn("v8.9 breaking change: TextLayer maxWidth is now relative to text size")()
+                fontAtlasManager: new Qu
+            }, this.props.maxWidth > 0 && Z.warn("v8.9 breaking change: TextLayer maxWidth is now relative to text size")()
         }
         updateState(t) {
             let {
                 props: r,
                 oldProps: i,
-                changeFlags: s
+                changeFlags: n
             } = t;
-            (s.dataChanged || s.updateTriggersChanged && (s.updateTriggersChanged.all || s.updateTriggersChanged.getText)) && this._updateText(), (this._updateFontAtlas() || r.lineHeight !== i.lineHeight || r.wordBreak !== i.wordBreak || r.maxWidth !== i.maxWidth) && this.setState({
+            (n.dataChanged || n.updateTriggersChanged && (n.updateTriggersChanged.all || n.updateTriggersChanged.getText)) && this._updateText(), (this._updateFontAtlas() || r.lineHeight !== i.lineHeight || r.wordBreak !== i.wordBreak || r.maxWidth !== i.maxWidth) && this.setState({
                 styleVersion: this.state.styleVersion + 1
             })
         }
         getPickingInfo({
             info: t
         }) {
             return t.object = t.index >= 0 ? this.props.data[t.index] : null, t
         }
         _updateFontAtlas() {
             let {
                 fontSettings: t,
                 fontFamily: r,
                 fontWeight: i
             } = this.props, {
-                fontAtlasManager: s,
-                characterSet: n
+                fontAtlasManager: n,
+                characterSet: s
             } = this.state, o = {
                 ...t,
-                characterSet: n,
+                characterSet: s,
                 fontFamily: r,
                 fontWeight: i
             };
-            if (!s.mapping) return s.setProps(o), !0;
+            if (!n.mapping) return n.setProps(o), !0;
             for (let a in o)
-                if (o[a] !== s.props[a]) return s.setProps(o), !0;
+                if (o[a] !== n.props[a]) return n.setProps(o), !0;
             return !1
         }
         _updateText() {
             let {
                 data: t,
                 characterSet: r
             } = this.props, i = t.attributes?.getText, {
-                getText: s
-            } = this.props, n = t.startIndices, o, a = r === "auto" && new Set;
-            if (i && n) {
+                getText: n
+            } = this.props, s = t.startIndices, o, a = r === "auto" && new Set;
+            if (i && s) {
                 let {
                     texts: c,
                     characterCount: l
-                } = iT({
+                } = uR({
                     ...ArrayBuffer.isView(i) ? {
                         value: i
                     } : i,
                     length: t.length,
-                    startIndices: n,
+                    startIndices: s,
                     characterSet: a
                 });
-                o = l, s = (h, {
+                o = l, n = (u, {
                     index: f
                 }) => c[f]
             } else {
                 let {
                     iterable: c,
                     objectInfo: l
-                } = tr(t);
-                n = [0], o = 0;
-                for (let h of c) {
+                } = Zi(t);
+                s = [0], o = 0;
+                for (let u of c) {
                     l.index++;
-                    let f = Array.from(s(h, l) || "");
-                    a && f.forEach(a.add, a), o += f.length, n.push(o)
+                    let f = Array.from(n(u, l) || "");
+                    a && f.forEach(a.add, a), o += f.length, s.push(o)
                 }
             }
             this.setState({
-                getText: s,
-                startIndices: n,
+                getText: n,
+                startIndices: s,
                 numInstances: o,
                 characterSet: a || r
             })
         }
         transformParagraph(t, r) {
             let {
                 fontAtlasManager: i
-            } = this.state, s = i.mapping, n = this.state.getText, {
+            } = this.state, n = i.mapping, s = this.state.getText, {
                 wordBreak: o,
                 lineHeight: a,
                 maxWidth: c
-            } = this.props, l = n(t, r) || "";
-            return rT(l, a, o, c * i.props.fontSize, s)
+            } = this.props, l = s(t, r) || "";
+            return lR(l, a, o, c * i.props.fontSize, n)
         }
         renderLayers() {
             let {
                 startIndices: t,
                 numInstances: r,
                 getText: i,
                 fontAtlasManager: {
-                    scale: s,
-                    atlas: n,
+                    scale: n,
+                    atlas: s,
                     mapping: o
                 },
                 styleVersion: a
             } = this.state, {
                 data: c,
                 _dataDiff: l,
-                getPosition: h,
+                getPosition: u,
                 getColor: f,
-                getSize: u,
+                getSize: h,
                 getAngle: d,
-                getPixelOffset: m,
+                getPixelOffset: p,
                 getBackgroundColor: y,
-                getBorderColor: x,
-                getBorderWidth: A,
-                backgroundPadding: v,
-                background: E,
+                getBorderColor: b,
+                getBorderWidth: T,
+                backgroundPadding: I,
+                background: S,
                 billboard: R,
-                fontSettings: M,
+                fontSettings: P,
                 outlineWidth: C,
-                outlineColor: B,
-                sizeScale: L,
+                outlineColor: V,
+                sizeScale: U,
                 sizeUnits: k,
-                sizeMinPixels: N,
-                sizeMaxPixels: H,
-                transitions: $,
-                updateTriggers: X
-            } = this.props, J = this.getSubLayerClass("characters", Go), xt = this.getSubLayerClass("background", ea);
-            return [E && new xt({
+                sizeMinPixels: B,
+                sizeMaxPixels: K,
+                transitions: st,
+                updateTriggers: G
+            } = this.props, Tt = this.getSubLayerClass("characters", Gu), oe = this.getSubLayerClass("background", tf);
+            return [S && new oe({
                 getFillColor: y,
-                getLineColor: x,
-                getLineWidth: A,
-                padding: v,
-                getPosition: h,
-                getSize: u,
+                getLineColor: b,
+                getLineWidth: T,
+                padding: I,
+                getPosition: u,
+                getSize: h,
                 getAngle: d,
-                getPixelOffset: m,
+                getPixelOffset: p,
                 billboard: R,
-                sizeScale: L,
+                sizeScale: U,
                 sizeUnits: k,
-                sizeMinPixels: N,
-                sizeMaxPixels: H,
-                transitions: $ && {
-                    getPosition: $.getPosition,
-                    getAngle: $.getAngle,
-                    getSize: $.getSize,
-                    getFillColor: $.getBackgroundColor,
-                    getLineColor: $.getBorderColor,
-                    getLineWidth: $.getBorderWidth,
-                    getPixelOffset: $.getPixelOffset
+                sizeMinPixels: B,
+                sizeMaxPixels: K,
+                transitions: st && {
+                    getPosition: st.getPosition,
+                    getAngle: st.getAngle,
+                    getSize: st.getSize,
+                    getFillColor: st.getBackgroundColor,
+                    getLineColor: st.getBorderColor,
+                    getLineWidth: st.getBorderWidth,
+                    getPixelOffset: st.getPixelOffset
                 }
             }, this.getSubLayerProps({
                 id: "background",
                 updateTriggers: {
-                    getPosition: X.getPosition,
-                    getAngle: X.getAngle,
-                    getSize: X.getSize,
-                    getFillColor: X.getBackgroundColor,
-                    getLineColor: X.getBorderColor,
-                    getLineWidth: X.getBorderWidth,
-                    getPixelOffset: X.getPixelOffset,
+                    getPosition: G.getPosition,
+                    getAngle: G.getAngle,
+                    getSize: G.getSize,
+                    getFillColor: G.getBackgroundColor,
+                    getLineColor: G.getBorderColor,
+                    getLineWidth: G.getBorderWidth,
+                    getPixelOffset: G.getPixelOffset,
                     getBoundingRect: {
-                        getText: X.getText,
-                        getTextAnchor: X.getTextAnchor,
-                        getAlignmentBaseline: X.getAlignmentBaseline,
+                        getText: G.getText,
+                        getTextAnchor: G.getTextAnchor,
+                        getAlignmentBaseline: G.getAlignmentBaseline,
                         styleVersion: a
                     }
                 }
             }), {
                 data: c.attributes && c.attributes.background ? {
                     length: c.length,
                     attributes: c.attributes.background
                 } : c,
                 _dataDiff: l,
                 autoHighlight: !1,
                 getBoundingRect: this.getBoundingRect
-            }), new J({
-                sdf: M.sdf,
-                smoothing: Number.isFinite(M.smoothing) ? M.smoothing : Yi.smoothing,
-                outlineWidth: C / (M.radius || Yi.radius),
-                outlineColor: B,
-                iconAtlas: n,
+            }), new Tt({
+                sdf: P.sdf,
+                smoothing: Number.isFinite(P.smoothing) ? P.smoothing : $o.smoothing,
+                outlineWidth: C / (P.radius || $o.radius),
+                outlineColor: V,
+                iconAtlas: s,
                 iconMapping: o,
-                getPosition: h,
+                getPosition: u,
                 getColor: f,
-                getSize: u,
+                getSize: h,
                 getAngle: d,
-                getPixelOffset: m,
+                getPixelOffset: p,
                 billboard: R,
-                sizeScale: L * s,
+                sizeScale: U * n,
                 sizeUnits: k,
-                sizeMinPixels: N * s,
-                sizeMaxPixels: H * s,
-                transitions: $ && {
-                    getPosition: $.getPosition,
-                    getAngle: $.getAngle,
-                    getColor: $.getColor,
-                    getSize: $.getSize,
-                    getPixelOffset: $.getPixelOffset
+                sizeMinPixels: B * n,
+                sizeMaxPixels: K * n,
+                transitions: st && {
+                    getPosition: st.getPosition,
+                    getAngle: st.getAngle,
+                    getColor: st.getColor,
+                    getSize: st.getSize,
+                    getPixelOffset: st.getPixelOffset
                 }
             }, this.getSubLayerProps({
                 id: "characters",
                 updateTriggers: {
-                    all: X.getText,
-                    getPosition: X.getPosition,
-                    getAngle: X.getAngle,
-                    getColor: X.getColor,
-                    getSize: X.getSize,
-                    getPixelOffset: X.getPixelOffset,
+                    all: G.getText,
+                    getPosition: G.getPosition,
+                    getAngle: G.getAngle,
+                    getColor: G.getColor,
+                    getSize: G.getSize,
+                    getPixelOffset: G.getPixelOffset,
                     getIconOffsets: {
-                        getTextAnchor: X.getTextAnchor,
-                        getAlignmentBaseline: X.getAlignmentBaseline,
+                        getTextAnchor: G.getTextAnchor,
+                        getAlignmentBaseline: G.getAlignmentBaseline,
                         styleVersion: a
                     }
                 }
             }), {
                 data: c,
                 _dataDiff: l,
                 startIndices: t,
                 numInstances: r,
                 getIconOffsets: this.getIconOffsets,
                 getIcon: i
             })]
         }
         static set fontAtlasCacheLimit(t) {
-            lT(t)
+            gR(t)
         }
     };
-Ql.defaultProps = WM, Ql.layerName = "TextLayer";
-var Ys = Ql;
-var ra = {
+am.defaultProps = L4, am.layerName = "TextLayer";
+var mc = am;
+var ef = {
         circle: {
-            type: Fe,
+            type: ui,
             props: {
                 filled: "filled",
                 stroked: "stroked",
                 lineWidthMaxPixels: "lineWidthMaxPixels",
                 lineWidthMinPixels: "lineWidthMinPixels",
                 lineWidthScale: "lineWidthScale",
                 lineWidthUnits: "lineWidthUnits",
@@ -29498,15 +30626,15 @@
                 getFillColor: "getFillColor",
                 getLineColor: "getLineColor",
                 getLineWidth: "getLineWidth",
                 getPointRadius: "getRadius"
             }
         },
         icon: {
-            type: ii,
+            type: Us,
             props: {
                 iconAtlas: "iconAtlas",
                 iconMapping: "iconMapping",
                 iconSizeMaxPixels: "sizeMaxPixels",
                 iconSizeMinPixels: "sizeMinPixels",
                 iconSizeScale: "sizeScale",
                 iconSizeUnits: "sizeUnits",
@@ -29516,15 +30644,15 @@
                 getIconAngle: "getAngle",
                 getIconColor: "getColor",
                 getIconPixelOffset: "getPixelOffset",
                 getIconSize: "getSize"
             }
         },
         text: {
-            type: Ys,
+            type: mc,
             props: {
                 textSizeMaxPixels: "sizeMaxPixels",
                 textSizeMinPixels: "sizeMinPixels",
                 textSizeScale: "sizeScale",
                 textSizeUnits: "sizeUnits",
                 textBackground: "background",
                 textBackgroundPadding: "backgroundPadding",
@@ -29547,304 +30675,304 @@
                 getTextAlignmentBaseline: "getAlignmentBaseline",
                 getTextBackgroundColor: "getBackgroundColor",
                 getTextBorderColor: "getBorderColor",
                 getTextBorderWidth: "getBorderWidth"
             }
         }
     },
-    ia = {
-        type: rr,
+    rf = {
+        type: Qi,
         props: {
             lineWidthUnits: "widthUnits",
             lineWidthScale: "widthScale",
             lineWidthMinPixels: "widthMinPixels",
             lineWidthMaxPixels: "widthMaxPixels",
             lineJointRounded: "jointRounded",
             lineCapRounded: "capRounded",
             lineMiterLimit: "miterLimit",
             lineBillboard: "billboard",
             getLineColor: "getColor",
             getLineWidth: "getWidth"
         }
     },
-    Gl = {
-        type: Xs,
+    cm = {
+        type: dc,
         props: {
             extruded: "extruded",
             filled: "filled",
             wireframe: "wireframe",
             elevationScale: "elevationScale",
             material: "material",
             _full3d: "_full3d",
             getElevation: "getElevation",
             getFillColor: "getFillColor",
             getLineColor: "getLineColor"
         }
     };
 
-function qs({
+function gc({
     type: e,
     props: t
 }) {
     let r = {};
     for (let i in t) r[i] = e.defaultProps[t[i]];
     return r
 }
 
-function Jl(e, t) {
+function lm(e, t) {
     let {
         transitions: r,
         updateTriggers: i
-    } = e.props, s = {
+    } = e.props, n = {
         updateTriggers: {},
         transitions: r && {
             getPosition: r.geometry
         }
     };
-    for (let n in t) {
-        let o = t[n],
-            a = e.props[n];
-        n.startsWith("get") && (a = e.getSubLayerAccessor(a), s.updateTriggers[o] = i[n], r && (s.transitions[o] = r[n])), s[o] = a
+    for (let s in t) {
+        let o = t[s],
+            a = e.props[s];
+        s.startsWith("get") && (a = e.getSubLayerAccessor(a), n.updateTriggers[o] = i[s], r && (n.transitions[o] = r[s])), n[o] = a
     }
-    return s
+    return n
 }
 
-function gT(e) {
+function TR(e) {
     if (Array.isArray(e)) return e;
-    switch (j.assert(e.type, "GeoJSON does not have type"), e.type) {
+    switch (Z.assert(e.type, "GeoJSON does not have type"), e.type) {
         case "Feature":
             return [e];
         case "FeatureCollection":
-            return j.assert(Array.isArray(e.features), "GeoJSON does not have features array"), e.features;
+            return Z.assert(Array.isArray(e.features), "GeoJSON does not have features array"), e.features;
         default:
             return [{
                 geometry: e
             }]
     }
 }
 
-function lp(e, t, r = {}) {
+function vx(e, t, r = {}) {
     let i = {
             pointFeatures: [],
             lineFeatures: [],
             polygonFeatures: [],
             polygonOutlineFeatures: []
         },
         {
-            startRow: s = 0,
-            endRow: n = e.length
+            startRow: n = 0,
+            endRow: s = e.length
         } = r;
-    for (let o = s; o < n; o++) {
+    for (let o = n; o < s; o++) {
         let a = e[o],
             {
                 geometry: c
             } = a;
         if (c)
             if (c.type === "GeometryCollection") {
-                j.assert(Array.isArray(c.geometries), "GeoJSON does not have geometries array");
+                Z.assert(Array.isArray(c.geometries), "GeoJSON does not have geometries array");
                 let {
                     geometries: l
                 } = c;
-                for (let h = 0; h < l.length; h++) {
-                    let f = l[h];
-                    pT(f, i, t, a, o)
+                for (let u = 0; u < l.length; u++) {
+                    let f = l[u];
+                    wR(f, i, t, a, o)
                 }
-            } else pT(c, i, t, a, o)
+            } else wR(c, i, t, a, o)
     }
     return i
 }
 
-function pT(e, t, r, i, s) {
+function wR(e, t, r, i, n) {
     let {
-        type: n,
+        type: s,
         coordinates: o
     } = e, {
         pointFeatures: a,
         lineFeatures: c,
         polygonFeatures: l,
-        polygonOutlineFeatures: h
+        polygonOutlineFeatures: u
     } = t;
-    if (!HM(n, o)) {
-        j.warn(`${n} coordinates are malformed`)();
+    if (!U4(s, o)) {
+        Z.warn(`${s} coordinates are malformed`)();
         return
     }
-    switch (n) {
+    switch (s) {
         case "Point":
             a.push(r({
                 geometry: e
-            }, i, s));
+            }, i, n));
             break;
         case "MultiPoint":
             o.forEach(f => {
                 a.push(r({
                     geometry: {
                         type: "Point",
                         coordinates: f
                     }
-                }, i, s))
+                }, i, n))
             });
             break;
         case "LineString":
             c.push(r({
                 geometry: e
-            }, i, s));
+            }, i, n));
             break;
         case "MultiLineString":
             o.forEach(f => {
                 c.push(r({
                     geometry: {
                         type: "LineString",
                         coordinates: f
                     }
-                }, i, s))
+                }, i, n))
             });
             break;
         case "Polygon":
             l.push(r({
                 geometry: e
-            }, i, s)), o.forEach(f => {
-                h.push(r({
+            }, i, n)), o.forEach(f => {
+                u.push(r({
                     geometry: {
                         type: "LineString",
                         coordinates: f
                     }
-                }, i, s))
+                }, i, n))
             });
             break;
         case "MultiPolygon":
             o.forEach(f => {
                 l.push(r({
                     geometry: {
                         type: "Polygon",
                         coordinates: f
                     }
-                }, i, s)), f.forEach(u => {
-                    h.push(r({
+                }, i, n)), f.forEach(h => {
+                    u.push(r({
                         geometry: {
                             type: "LineString",
-                            coordinates: u
+                            coordinates: h
                         }
-                    }, i, s))
+                    }, i, n))
                 })
             });
             break;
         default:
     }
 }
-var jM = {
+var k4 = {
     Point: 1,
     MultiPoint: 2,
     LineString: 2,
     MultiLineString: 3,
     Polygon: 3,
     MultiPolygon: 4
 };
 
-function HM(e, t) {
-    let r = jM[e];
-    for (j.assert(r, `Unknown GeoJSON type ${e}`); t && --r > 0;) t = t[0];
+function U4(e, t) {
+    let r = k4[e];
+    for (Z.assert(r, `Unknown GeoJSON type ${e}`); t && --r > 0;) t = t[0];
     return t && Number.isFinite(t[0])
 }
 
-function mT() {
+function vR() {
     return {
         points: {},
         lines: {},
         polygons: {},
         polygonsOutline: {}
     }
 }
 
-function th(e) {
+function um(e) {
     return e.geometry.coordinates
 }
 
-function _T(e, t) {
-    let r = mT(),
+function SR(e, t) {
+    let r = vR(),
         {
             pointFeatures: i,
-            lineFeatures: s,
-            polygonFeatures: n,
+            lineFeatures: n,
+            polygonFeatures: s,
             polygonOutlineFeatures: o
         } = e;
-    return r.points.data = i, r.points._dataDiff = t.pointFeatures && (() => t.pointFeatures), r.points.getPosition = th, r.lines.data = s, r.lines._dataDiff = t.lineFeatures && (() => t.lineFeatures), r.lines.getPath = th, r.polygons.data = n, r.polygons._dataDiff = t.polygonFeatures && (() => t.polygonFeatures), r.polygons.getPolygon = th, r.polygonsOutline.data = o, r.polygonsOutline._dataDiff = t.polygonOutlineFeatures && (() => t.polygonOutlineFeatures), r.polygonsOutline.getPath = th, r
+    return r.points.data = i, r.points._dataDiff = t.pointFeatures && (() => t.pointFeatures), r.points.getPosition = um, r.lines.data = n, r.lines._dataDiff = t.lineFeatures && (() => t.lineFeatures), r.lines.getPath = um, r.polygons.data = s, r.polygons._dataDiff = t.polygonFeatures && (() => t.polygonFeatures), r.polygons.getPolygon = um, r.polygonsOutline.data = o, r.polygonsOutline._dataDiff = t.polygonOutlineFeatures && (() => t.polygonOutlineFeatures), r.polygonsOutline.getPath = um, r
 }
 
-function yT(e, t) {
-    let r = mT(),
+function AR(e, t) {
+    let r = vR(),
         {
             points: i,
-            lines: s,
-            polygons: n
+            lines: n,
+            polygons: s
         } = e,
-        o = qx(e, t);
+        o = eR(e, t);
     return r.points.data = {
         length: i.positions.value.length / i.positions.size,
         attributes: {
             ...i.attributes,
             getPosition: i.positions,
             instancePickingColors: {
                 size: 3,
                 value: o.points
             }
         },
         properties: i.properties,
         numericProps: i.numericProps,
         featureIds: i.featureIds
     }, r.lines.data = {
-        length: s.pathIndices.value.length - 1,
-        startIndices: s.pathIndices.value,
+        length: n.pathIndices.value.length - 1,
+        startIndices: n.pathIndices.value,
         attributes: {
-            ...s.attributes,
-            getPath: s.positions,
+            ...n.attributes,
+            getPath: n.positions,
             instancePickingColors: {
                 size: 3,
                 value: o.lines
             }
         },
-        properties: s.properties,
-        numericProps: s.numericProps,
-        featureIds: s.featureIds
+        properties: n.properties,
+        numericProps: n.numericProps,
+        featureIds: n.featureIds
     }, r.lines._pathType = "open", r.polygons.data = {
-        length: n.polygonIndices.value.length - 1,
-        startIndices: n.polygonIndices.value,
+        length: s.polygonIndices.value.length - 1,
+        startIndices: s.polygonIndices.value,
         attributes: {
-            ...n.attributes,
-            getPolygon: n.positions,
+            ...s.attributes,
+            getPolygon: s.positions,
             pickingColors: {
                 size: 3,
                 value: o.polygons
             }
         },
-        properties: n.properties,
-        numericProps: n.numericProps,
-        featureIds: n.featureIds
-    }, r.polygons._normalize = !1, n.triangles && (r.polygons.data.attributes.indices = n.triangles.value), r.polygonsOutline.data = {
-        length: n.primitivePolygonIndices.value.length - 1,
-        startIndices: n.primitivePolygonIndices.value,
+        properties: s.properties,
+        numericProps: s.numericProps,
+        featureIds: s.featureIds
+    }, r.polygons._normalize = !1, s.triangles && (r.polygons.data.attributes.indices = s.triangles.value), r.polygonsOutline.data = {
+        length: s.primitivePolygonIndices.value.length - 1,
+        startIndices: s.primitivePolygonIndices.value,
         attributes: {
-            ...n.attributes,
-            getPath: n.positions,
+            ...s.attributes,
+            getPath: s.positions,
             instancePickingColors: {
                 size: 3,
                 value: o.polygons
             }
         },
-        properties: n.properties,
-        numericProps: n.numericProps,
-        featureIds: n.featureIds
+        properties: s.properties,
+        numericProps: s.numericProps,
+        featureIds: s.featureIds
     }, r.polygonsOutline._pathType = "open", r
 }
-var XM = ["points", "linestrings", "polygons"],
-    $M = {
-        ...qs(ra.circle),
-        ...qs(ra.icon),
-        ...qs(ra.text),
-        ...qs(ia),
-        ...qs(Gl),
+var V4 = ["points", "linestrings", "polygons"],
+    z4 = {
+        ...gc(ef.circle),
+        ...gc(ef.icon),
+        ...gc(ef.text),
+        ...gc(rf),
+        ...gc(cm),
         stroked: !0,
         filled: !0,
         extruded: !1,
         wireframe: !1,
         _full3d: !1,
         iconAtlas: {
             type: "object",
@@ -29863,189 +30991,189 @@
             value: e => e.properties.text
         },
         pointType: "circle",
         getRadius: {
             deprecatedFor: "getPointRadius"
         }
     },
-    eh = class eh extends Ne {
+    fm = class fm extends li {
         initializeState() {
             this.state = {
                 layerProps: {},
                 features: {},
                 featuresDiff: {}
             }
         }
         updateState({
             props: t,
             changeFlags: r
         }) {
             if (!r.dataChanged) return;
             let {
                 data: i
-            } = this.props, s = i && "points" in i && "polygons" in i && "lines" in i;
+            } = this.props, n = i && "points" in i && "polygons" in i && "lines" in i;
             this.setState({
-                binary: s
-            }), s ? this._updateStateBinary({
+                binary: n
+            }), n ? this._updateStateBinary({
                 props: t,
                 changeFlags: r
             }) : this._updateStateJSON({
                 props: t,
                 changeFlags: r
             })
         }
         _updateStateBinary({
             props: t,
             changeFlags: r
         }) {
-            let i = yT(t.data, this.encodePickingColor);
+            let i = AR(t.data, this.encodePickingColor);
             this.setState({
                 layerProps: i
             })
         }
         _updateStateJSON({
             props: t,
             changeFlags: r
         }) {
-            let i = gT(t.data),
-                s = this.getSubLayerRow.bind(this),
-                n = {},
+            let i = TR(t.data),
+                n = this.getSubLayerRow.bind(this),
+                s = {},
                 o = {};
             if (Array.isArray(r.dataChanged)) {
                 let c = this.state.features;
-                for (let l in c) n[l] = c[l].slice(), o[l] = [];
+                for (let l in c) s[l] = c[l].slice(), o[l] = [];
                 for (let l of r.dataChanged) {
-                    let h = lp(i, s, l);
-                    for (let f in c) o[f].push($x({
-                        data: n[f],
-                        getIndex: u => u.__source.index,
+                    let u = vx(i, n, l);
+                    for (let f in c) o[f].push(QI({
+                        data: s[f],
+                        getIndex: h => h.__source.index,
                         dataRange: l,
-                        replace: h[f]
+                        replace: u[f]
                     }))
                 }
-            } else n = lp(i, s);
-            let a = _T(n, o);
+            } else s = vx(i, n);
+            let a = SR(s, o);
             this.setState({
-                features: n,
+                features: s,
                 featuresDiff: o,
                 layerProps: a
             })
         }
         getPickingInfo(t) {
             let r = super.getPickingInfo(t),
                 {
                     index: i,
-                    sourceLayer: s
+                    sourceLayer: n
                 } = r;
-            return r.featureType = XM.find(n => s.id.startsWith(`${this.id}-${n}-`)), i >= 0 && s.id.startsWith(`${this.id}-points-text`) && this.state.binary && (r.index = this.props.data.points.globalFeatureIds.value[i]), r
+            return r.featureType = V4.find(s => n.id.startsWith(`${this.id}-${s}-`)), i >= 0 && n.id.startsWith(`${this.id}-points-text`) && this.state.binary && (r.index = this.props.data.points.globalFeatureIds.value[i]), r
         }
         _updateAutoHighlight(t) {
             let r = `${this.id}-points-`,
                 i = t.featureType === "points";
-            for (let s of this.getSubLayers()) s.id.startsWith(r) === i && s.updateAutoHighlight(t)
+            for (let n of this.getSubLayers()) n.id.startsWith(r) === i && n.updateAutoHighlight(t)
         }
         _renderPolygonLayer() {
             let {
                 extruded: t,
                 wireframe: r
             } = this.props, {
                 layerProps: i
-            } = this.state, s = "polygons-fill", n = this.shouldRenderSubLayer(s, i.polygons?.data) && this.getSubLayerClass(s, Gl.type);
-            if (n) {
-                let o = Jl(this, Gl.props),
+            } = this.state, n = "polygons-fill", s = this.shouldRenderSubLayer(n, i.polygons?.data) && this.getSubLayerClass(n, cm.type);
+            if (s) {
+                let o = lm(this, cm.props),
                     a = t && r;
-                return a || delete o.getLineColor, o.updateTriggers.lineColors = a, new n(o, this.getSubLayerProps({
-                    id: s,
+                return a || delete o.getLineColor, o.updateTriggers.lineColors = a, new s(o, this.getSubLayerProps({
+                    id: n,
                     updateTriggers: o.updateTriggers
                 }), i.polygons)
             }
             return null
         }
         _renderLineLayers() {
             let {
                 extruded: t,
                 stroked: r
             } = this.props, {
                 layerProps: i
-            } = this.state, s = "polygons-stroke", n = "linestrings", o = !t && r && this.shouldRenderSubLayer(s, i.polygonsOutline?.data) && this.getSubLayerClass(s, ia.type), a = this.shouldRenderSubLayer(n, i.lines?.data) && this.getSubLayerClass(n, ia.type);
+            } = this.state, n = "polygons-stroke", s = "linestrings", o = !t && r && this.shouldRenderSubLayer(n, i.polygonsOutline?.data) && this.getSubLayerClass(n, rf.type), a = this.shouldRenderSubLayer(s, i.lines?.data) && this.getSubLayerClass(s, rf.type);
             if (o || a) {
-                let c = Jl(this, ia.props);
+                let c = lm(this, rf.props);
                 return [o && new o(c, this.getSubLayerProps({
-                    id: s,
+                    id: n,
                     updateTriggers: c.updateTriggers
                 }), i.polygonsOutline), a && new a(c, this.getSubLayerProps({
-                    id: n,
+                    id: s,
                     updateTriggers: c.updateTriggers
                 }), i.lines)]
             }
             return null
         }
         _renderPointLayers() {
             let {
                 pointType: t
             } = this.props, {
                 layerProps: r,
                 binary: i
             } = this.state, {
-                highlightedObjectIndex: s
+                highlightedObjectIndex: n
             } = this.props;
-            !i && Number.isFinite(s) && (s = r.points.data.findIndex(a => a.__source.index === s));
-            let n = new Set(t.split("+")),
+            !i && Number.isFinite(n) && (n = r.points.data.findIndex(a => a.__source.index === n));
+            let s = new Set(t.split("+")),
                 o = [];
-            for (let a of n) {
+            for (let a of s) {
                 let c = `points-${a}`,
-                    l = ra[a],
-                    h = l && this.shouldRenderSubLayer(c, r.points?.data) && this.getSubLayerClass(c, l.type);
-                if (h) {
-                    let f = Jl(this, l.props),
-                        u = r.points;
+                    l = ef[a],
+                    u = l && this.shouldRenderSubLayer(c, r.points?.data) && this.getSubLayerClass(c, l.type);
+                if (u) {
+                    let f = lm(this, l.props),
+                        h = r.points;
                     if (a === "text" && i) {
                         let {
                             instancePickingColors: d,
-                            ...m
-                        } = u.data.attributes;
-                        u = {
-                            ...u,
+                            ...p
+                        } = h.data.attributes;
+                        h = {
+                            ...h,
                             data: {
-                                ...u.data,
-                                attributes: m
+                                ...h.data,
+                                attributes: p
                             }
                         }
                     }
-                    o.push(new h(f, this.getSubLayerProps({
+                    o.push(new u(f, this.getSubLayerProps({
                         id: c,
                         updateTriggers: f.updateTriggers,
-                        highlightedObjectIndex: s
-                    }), u))
+                        highlightedObjectIndex: n
+                    }), h))
                 }
             }
             return o
         }
         renderLayers() {
             let {
                 extruded: t
-            } = this.props, r = this._renderPolygonLayer(), i = this._renderLineLayers(), s = this._renderPointLayers();
-            return [!t && r, i, s, t && r]
+            } = this.props, r = this._renderPolygonLayer(), i = this._renderLineLayers(), n = this._renderPointLayers();
+            return [!t && r, i, n, t && r]
         }
         getSubLayerAccessor(t) {
             let {
                 binary: r
             } = this.state;
-            return !r || typeof t != "function" ? super.getSubLayerAccessor(t) : (i, s) => {
+            return !r || typeof t != "function" ? super.getSubLayerAccessor(t) : (i, n) => {
                 let {
-                    data: n,
+                    data: s,
                     index: o
-                } = s, a = Yx(n, o);
-                return t(a, s)
+                } = n, a = tR(s, o);
+                return t(a, n)
             }
         }
     };
-eh.layerName = "GeoJsonLayer", eh.defaultProps = $M;
-var qi = eh;
-var rh = class {
+fm.layerName = "GeoJsonLayer", fm.defaultProps = z4;
+var Xo = fm;
+var hm = class {
     constructor(t) {
         this.index = t, this.isVisible = !1, this.isSelected = !1, this.parent = null, this.children = [], this.content = null, this._loader = void 0, this._abortController = null, this._loaderId = 0, this._isLoaded = !1, this._isCancelled = !1, this._needsReload = !1
     }
     get bbox() {
         return this._bbox
     }
     set bbox(t) {
@@ -30073,502 +31201,502 @@
         let t = this.content ? this.content.byteLength : 0;
         return Number.isFinite(t) || console.error("byteLength not defined in tile data"), t
     }
     async _loadData({
         getData: t,
         requestScheduler: r,
         onLoad: i,
-        onError: s
+        onError: n
     }) {
         let {
-            index: n,
+            index: s,
             id: o,
             bbox: a,
             userData: c,
             zoom: l
-        } = this, h = this._loaderId;
+        } = this, u = this._loaderId;
         this._abortController = new AbortController;
         let {
             signal: f
-        } = this._abortController, u = await r.scheduleRequest(this, y => y.isSelected ? 1 : -1);
-        if (!u) {
+        } = this._abortController, h = await r.scheduleRequest(this, y => y.isSelected ? 1 : -1);
+        if (!h) {
             this._isCancelled = !0;
             return
         }
         if (this._isCancelled) {
-            u.done();
+            h.done();
             return
         }
         let d = null,
-            m;
+            p;
         try {
             d = await t({
-                index: n,
+                index: s,
                 id: o,
                 bbox: a,
                 userData: c,
                 zoom: l,
                 signal: f
             })
         } catch (y) {
-            m = y || !0
+            p = y || !0
         } finally {
-            u.done()
+            h.done()
         }
-        if (h === this._loaderId) {
+        if (u === this._loaderId) {
             if (this._loader = void 0, this.content = d, this._isCancelled && !d) {
                 this._isLoaded = !1;
                 return
             }
-            this._isLoaded = !0, this._isCancelled = !1, m ? s(m, this) : i(this)
+            this._isLoaded = !0, this._isCancelled = !1, p ? n(p, this) : i(this)
         }
     }
     loadData(t) {
         return this._isLoaded = !1, this._isCancelled = !1, this._needsReload = !1, this._loaderId++, this._loader = this._loadData(t), this._loader
     }
     setNeedsReload() {
         this.isLoading && (this.abort(), this._loader = void 0), this._needsReload = !0
     }
     abort() {
         this.isLoaded || (this._isCancelled = !0, this._abortController?.abort())
     }
 };
-var yt = {
+var ne = {
     OUTSIDE: -1,
     INTERSECTING: 0,
     INSIDE: 1
 };
-var xT = new U,
-    YM = new U,
-    Zs = class e {
+var ER = new z,
+    W4 = new z,
+    _c = class e {
         constructor(t = [0, 0, 0], r = [0, 0, 0], i) {
-            i = i || xT.copy(t).add(r).scale(.5), this.center = new U(i), this.halfDiagonal = new U(r).subtract(this.center), this.minimum = new U(t), this.maximum = new U(r)
+            i = i || ER.copy(t).add(r).scale(.5), this.center = new z(i), this.halfDiagonal = new z(r).subtract(this.center), this.minimum = new z(t), this.maximum = new z(r)
         }
         clone() {
             return new e(this.minimum, this.maximum, this.center)
         }
         equals(t) {
             return this === t || !!t && this.minimum.equals(t.minimum) && this.maximum.equals(t.maximum)
         }
         transform(t) {
             return this.center.transformAsPoint(t), this.halfDiagonal.transform(t), this.minimum.transform(t), this.maximum.transform(t), this
         }
         intersectPlane(t) {
             let {
                 halfDiagonal: r
-            } = this, i = YM.from(t.normal), s = r.x * Math.abs(i.x) + r.y * Math.abs(i.y) + r.z * Math.abs(i.z), n = this.center.dot(i) + t.distance;
-            return n - s > 0 ? yt.INSIDE : n + s < 0 ? yt.OUTSIDE : yt.INTERSECTING
+            } = this, i = W4.from(t.normal), n = r.x * Math.abs(i.x) + r.y * Math.abs(i.y) + r.z * Math.abs(i.z), s = this.center.dot(i) + t.distance;
+            return s - n > 0 ? ne.INSIDE : s + n < 0 ? ne.OUTSIDE : ne.INTERSECTING
         }
         distanceTo(t) {
             return Math.sqrt(this.distanceSquaredTo(t))
         }
         distanceSquaredTo(t) {
-            let r = xT.from(t).subtract(this.center),
+            let r = ER.from(t).subtract(this.center),
                 {
                     halfDiagonal: i
                 } = this,
-                s = 0,
-                n;
-            return n = Math.abs(r.x) - i.x, n > 0 && (s += n * n), n = Math.abs(r.y) - i.y, n > 0 && (s += n * n), n = Math.abs(r.z) - i.z, n > 0 && (s += n * n), s
+                n = 0,
+                s;
+            return s = Math.abs(r.x) - i.x, s > 0 && (n += s * s), s = Math.abs(r.y) - i.y, s > 0 && (n += s * s), s = Math.abs(r.z) - i.z, s > 0 && (n += s * s), n
         }
     };
-var sa = new U,
-    TT = new U,
-    Ks = class e {
+var nf = new z,
+    IR = new z,
+    yc = class e {
         constructor(t = [0, 0, 0], r = 0) {
-            this.radius = -0, this.center = new U, this.fromCenterRadius(t, r)
+            this.radius = -0, this.center = new z, this.fromCenterRadius(t, r)
         }
         fromCenterRadius(t, r) {
             return this.center.from(t), this.radius = r, this
         }
         fromCornerPoints(t, r) {
-            return r = sa.from(r), this.center = new U().from(t).add(r).scale(.5), this.radius = this.center.distance(r), this
+            return r = nf.from(r), this.center = new z().from(t).add(r).scale(.5), this.radius = this.center.distance(r), this
         }
         equals(t) {
             return this === t || !!t && this.center.equals(t.center) && this.radius === t.radius
         }
         clone() {
             return new e(this.center, this.radius)
         }
         union(t) {
             let r = this.center,
                 i = this.radius,
-                s = t.center,
-                n = t.radius,
-                o = sa.copy(s).subtract(r),
+                n = t.center,
+                s = t.radius,
+                o = nf.copy(n).subtract(r),
                 a = o.magnitude();
-            if (i >= a + n) return this.clone();
-            if (n >= a + i) return t.clone();
-            let c = (i + a + n) * .5;
-            return TT.copy(o).scale((-i + c) / a).add(r), this.center.copy(TT), this.radius = c, this
+            if (i >= a + s) return this.clone();
+            if (s >= a + i) return t.clone();
+            let c = (i + a + s) * .5;
+            return IR.copy(o).scale((-i + c) / a).add(r), this.center.copy(IR), this.radius = c, this
         }
         expand(t) {
-            let i = sa.from(t).subtract(this.center).magnitude();
+            let i = nf.from(t).subtract(this.center).magnitude();
             return i > this.radius && (this.radius = i), this
         }
         transform(t) {
             this.center.transform(t);
-            let r = _t.getScaling(sa, t);
+            let r = ie.getScaling(nf, t);
             return this.radius = Math.max(r[0], Math.max(r[1], r[2])) * this.radius, this
         }
         distanceSquaredTo(t) {
             let r = this.distanceTo(t);
             return r * r
         }
         distanceTo(t) {
-            let i = sa.from(t).subtract(this.center);
+            let i = nf.from(t).subtract(this.center);
             return Math.max(0, i.len() - this.radius)
         }
         intersectPlane(t) {
             let r = this.center,
                 i = this.radius,
-                n = t.normal.dot(r) + t.distance;
-            return n < -i ? yt.OUTSIDE : n < i ? yt.INTERSECTING : yt.INSIDE
+                s = t.normal.dot(r) + t.distance;
+            return s < -i ? ne.OUTSIDE : s < i ? ne.INTERSECTING : ne.INSIDE
         }
     };
-var qM = new U,
-    ZM = new U,
-    ih = new U,
-    sh = new U,
-    nh = new U,
-    KM = new U,
-    QM = new U,
-    Tr = {
+var j4 = new z,
+    H4 = new z,
+    dm = new z,
+    pm = new z,
+    mm = new z,
+    $4 = new z,
+    X4 = new z,
+    Mn = {
         COLUMN0ROW0: 0,
         COLUMN0ROW1: 1,
         COLUMN0ROW2: 2,
         COLUMN1ROW0: 3,
         COLUMN1ROW1: 4,
         COLUMN1ROW2: 5,
         COLUMN2ROW0: 6,
         COLUMN2ROW1: 7,
         COLUMN2ROW2: 8
     },
-    na = class e {
+    sf = class e {
         constructor(t = [0, 0, 0], r = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
-            this.center = new U().from(t), this.halfAxes = new ft(r)
+            this.center = new z().from(t), this.halfAxes = new qt(r)
         }
         get halfSize() {
             let t = this.halfAxes.getColumn(0),
                 r = this.halfAxes.getColumn(1),
                 i = this.halfAxes.getColumn(2);
-            return [new U(t).len(), new U(r).len(), new U(i).len()]
+            return [new z(t).len(), new z(r).len(), new z(i).len()]
         }
         get quaternion() {
             let t = this.halfAxes.getColumn(0),
                 r = this.halfAxes.getColumn(1),
                 i = this.halfAxes.getColumn(2),
-                s = new U(t).normalize(),
-                n = new U(r).normalize(),
-                o = new U(i).normalize();
-            return new gs().fromMatrix3(new ft([...s, ...n, ...o]))
+                n = new z(t).normalize(),
+                s = new z(r).normalize(),
+                o = new z(i).normalize();
+            return new Ba().fromMatrix3(new qt([...n, ...s, ...o]))
         }
         fromCenterHalfSizeQuaternion(t, r, i) {
-            let s = new gs(i),
-                n = new ft().fromQuaternion(s);
-            return n[0] = n[0] * r[0], n[1] = n[1] * r[0], n[2] = n[2] * r[0], n[3] = n[3] * r[1], n[4] = n[4] * r[1], n[5] = n[5] * r[1], n[6] = n[6] * r[2], n[7] = n[7] * r[2], n[8] = n[8] * r[2], this.center = new U().from(t), this.halfAxes = n, this
+            let n = new Ba(i),
+                s = new qt().fromQuaternion(n);
+            return s[0] = s[0] * r[0], s[1] = s[1] * r[0], s[2] = s[2] * r[0], s[3] = s[3] * r[1], s[4] = s[4] * r[1], s[5] = s[5] * r[1], s[6] = s[6] * r[2], s[7] = s[7] * r[2], s[8] = s[8] * r[2], this.center = new z().from(t), this.halfAxes = s, this
         }
         clone() {
             return new e(this.center, this.halfAxes)
         }
         equals(t) {
             return this === t || !!t && this.center.equals(t.center) && this.halfAxes.equals(t.halfAxes)
         }
-        getBoundingSphere(t = new Ks) {
+        getBoundingSphere(t = new yc) {
             let r = this.halfAxes,
-                i = r.getColumn(0, ih),
-                s = r.getColumn(1, sh),
-                n = r.getColumn(2, nh),
-                o = qM.copy(i).add(s).add(n);
+                i = r.getColumn(0, dm),
+                n = r.getColumn(1, pm),
+                s = r.getColumn(2, mm),
+                o = j4.copy(i).add(n).add(s);
             return t.center.copy(this.center), t.radius = o.magnitude(), t
         }
         intersectPlane(t) {
             let r = this.center,
                 i = t.normal,
-                s = this.halfAxes,
-                n = i.x,
+                n = this.halfAxes,
+                s = i.x,
                 o = i.y,
                 a = i.z,
-                c = Math.abs(n * s[Tr.COLUMN0ROW0] + o * s[Tr.COLUMN0ROW1] + a * s[Tr.COLUMN0ROW2]) + Math.abs(n * s[Tr.COLUMN1ROW0] + o * s[Tr.COLUMN1ROW1] + a * s[Tr.COLUMN1ROW2]) + Math.abs(n * s[Tr.COLUMN2ROW0] + o * s[Tr.COLUMN2ROW1] + a * s[Tr.COLUMN2ROW2]),
+                c = Math.abs(s * n[Mn.COLUMN0ROW0] + o * n[Mn.COLUMN0ROW1] + a * n[Mn.COLUMN0ROW2]) + Math.abs(s * n[Mn.COLUMN1ROW0] + o * n[Mn.COLUMN1ROW1] + a * n[Mn.COLUMN1ROW2]) + Math.abs(s * n[Mn.COLUMN2ROW0] + o * n[Mn.COLUMN2ROW1] + a * n[Mn.COLUMN2ROW2]),
                 l = i.dot(r) + t.distance;
-            return l <= -c ? yt.OUTSIDE : l >= c ? yt.INSIDE : yt.INTERSECTING
+            return l <= -c ? ne.OUTSIDE : l >= c ? ne.INSIDE : ne.INTERSECTING
         }
         distanceTo(t) {
             return Math.sqrt(this.distanceSquaredTo(t))
         }
         distanceSquaredTo(t) {
-            let r = ZM.from(t).subtract(this.center),
+            let r = H4.from(t).subtract(this.center),
                 i = this.halfAxes,
-                s = i.getColumn(0, ih),
-                n = i.getColumn(1, sh),
-                o = i.getColumn(2, nh),
-                a = s.magnitude(),
-                c = n.magnitude(),
+                n = i.getColumn(0, dm),
+                s = i.getColumn(1, pm),
+                o = i.getColumn(2, mm),
+                a = n.magnitude(),
+                c = s.magnitude(),
                 l = o.magnitude();
-            s.normalize(), n.normalize(), o.normalize();
-            let h = 0,
+            n.normalize(), s.normalize(), o.normalize();
+            let u = 0,
                 f;
-            return f = Math.abs(r.dot(s)) - a, f > 0 && (h += f * f), f = Math.abs(r.dot(n)) - c, f > 0 && (h += f * f), f = Math.abs(r.dot(o)) - l, f > 0 && (h += f * f), h
+            return f = Math.abs(r.dot(n)) - a, f > 0 && (u += f * f), f = Math.abs(r.dot(s)) - c, f > 0 && (u += f * f), f = Math.abs(r.dot(o)) - l, f > 0 && (u += f * f), u
         }
         computePlaneDistances(t, r, i = [-0, -0]) {
-            let s = Number.POSITIVE_INFINITY,
-                n = Number.NEGATIVE_INFINITY,
+            let n = Number.POSITIVE_INFINITY,
+                s = Number.NEGATIVE_INFINITY,
                 o = this.center,
                 a = this.halfAxes,
-                c = a.getColumn(0, ih),
-                l = a.getColumn(1, sh),
-                h = a.getColumn(2, nh),
-                f = KM.copy(c).add(l).add(h).add(o),
-                u = QM.copy(f).subtract(t),
-                d = r.dot(u);
-            return s = Math.min(d, s), n = Math.max(d, n), f.copy(o).add(c).add(l).subtract(h), u.copy(f).subtract(t), d = r.dot(u), s = Math.min(d, s), n = Math.max(d, n), f.copy(o).add(c).subtract(l).add(h), u.copy(f).subtract(t), d = r.dot(u), s = Math.min(d, s), n = Math.max(d, n), f.copy(o).add(c).subtract(l).subtract(h), u.copy(f).subtract(t), d = r.dot(u), s = Math.min(d, s), n = Math.max(d, n), o.copy(f).subtract(c).add(l).add(h), u.copy(f).subtract(t), d = r.dot(u), s = Math.min(d, s), n = Math.max(d, n), o.copy(f).subtract(c).add(l).subtract(h), u.copy(f).subtract(t), d = r.dot(u), s = Math.min(d, s), n = Math.max(d, n), o.copy(f).subtract(c).subtract(l).add(h), u.copy(f).subtract(t), d = r.dot(u), s = Math.min(d, s), n = Math.max(d, n), o.copy(f).subtract(c).subtract(l).subtract(h), u.copy(f).subtract(t), d = r.dot(u), s = Math.min(d, s), n = Math.max(d, n), i[0] = s, i[1] = n, i
+                c = a.getColumn(0, dm),
+                l = a.getColumn(1, pm),
+                u = a.getColumn(2, mm),
+                f = $4.copy(c).add(l).add(u).add(o),
+                h = X4.copy(f).subtract(t),
+                d = r.dot(h);
+            return n = Math.min(d, n), s = Math.max(d, s), f.copy(o).add(c).add(l).subtract(u), h.copy(f).subtract(t), d = r.dot(h), n = Math.min(d, n), s = Math.max(d, s), f.copy(o).add(c).subtract(l).add(u), h.copy(f).subtract(t), d = r.dot(h), n = Math.min(d, n), s = Math.max(d, s), f.copy(o).add(c).subtract(l).subtract(u), h.copy(f).subtract(t), d = r.dot(h), n = Math.min(d, n), s = Math.max(d, s), o.copy(f).subtract(c).add(l).add(u), h.copy(f).subtract(t), d = r.dot(h), n = Math.min(d, n), s = Math.max(d, s), o.copy(f).subtract(c).add(l).subtract(u), h.copy(f).subtract(t), d = r.dot(h), n = Math.min(d, n), s = Math.max(d, s), o.copy(f).subtract(c).subtract(l).add(u), h.copy(f).subtract(t), d = r.dot(h), n = Math.min(d, n), s = Math.max(d, s), o.copy(f).subtract(c).subtract(l).subtract(u), h.copy(f).subtract(t), d = r.dot(h), n = Math.min(d, n), s = Math.max(d, s), i[0] = n, i[1] = s, i
         }
         transform(t) {
             this.center.transformAsPoint(t);
-            let r = this.halfAxes.getColumn(0, ih);
+            let r = this.halfAxes.getColumn(0, dm);
             r.transformAsPoint(t);
-            let i = this.halfAxes.getColumn(1, sh);
+            let i = this.halfAxes.getColumn(1, pm);
             i.transformAsPoint(t);
-            let s = this.halfAxes.getColumn(2, nh);
-            return s.transformAsPoint(t), this.halfAxes = new ft([...r, ...i, ...s]), this
+            let n = this.halfAxes.getColumn(2, mm);
+            return n.transformAsPoint(t), this.halfAxes = new qt([...r, ...i, ...n]), this
         }
         getTransform() {
             throw new Error("not implemented")
         }
     };
-var bT = new U,
-    AT = new U,
-    br = class e {
+var RR = new z,
+    MR = new z,
+    Pn = class e {
         constructor(t = [0, 0, 1], r = 0) {
-            this.normal = new U, this.distance = -0, this.fromNormalDistance(t, r)
+            this.normal = new z, this.distance = -0, this.fromNormalDistance(t, r)
         }
         fromNormalDistance(t, r) {
-            return Xe(Number.isFinite(r)), this.normal.from(t).normalize(), this.distance = r, this
+            return Vi(Number.isFinite(r)), this.normal.from(t).normalize(), this.distance = r, this
         }
         fromPointNormal(t, r) {
-            t = bT.from(t), this.normal.from(r).normalize();
+            t = RR.from(t), this.normal.from(r).normalize();
             let i = -this.normal.dot(t);
             return this.distance = i, this
         }
-        fromCoefficients(t, r, i, s) {
-            return this.normal.set(t, r, i), Xe(Bt(this.normal.len(), 1)), this.distance = s, this
+        fromCoefficients(t, r, i, n) {
+            return this.normal.set(t, r, i), Vi(Le(this.normal.len(), 1)), this.distance = n, this
         }
         clone() {
             return new e(this.normal, this.distance)
         }
         equals(t) {
-            return Bt(this.distance, t.distance) && Bt(this.normal, t.normal)
+            return Le(this.distance, t.distance) && Le(this.normal, t.normal)
         }
         getPointDistance(t) {
             return this.normal.dot(t) + this.distance
         }
         transform(t) {
-            let r = AT.copy(this.normal).transformAsVector(t).normalize(),
+            let r = MR.copy(this.normal).transformAsVector(t).normalize(),
                 i = this.normal.scale(-this.distance).transform(t);
             return this.fromPointNormal(i, r)
         }
         projectPointOntoPlane(t, r = [0, 0, 0]) {
-            let i = bT.from(t),
-                s = this.getPointDistance(i),
-                n = AT.copy(this.normal).scale(s);
-            return i.subtract(n).to(r)
+            let i = RR.from(t),
+                n = this.getPointDistance(i),
+                s = MR.copy(this.normal).scale(n);
+            return i.subtract(s).to(r)
         }
     };
-var ET = [new U([1, 0, 0]), new U([0, 1, 0]), new U([0, 0, 1])],
-    ST = new U,
-    GM = new U,
-    Ar = class e {
+var PR = [new z([1, 0, 0]), new z([0, 1, 0]), new z([0, 0, 1])],
+    CR = new z,
+    Y4 = new z,
+    Cn = class e {
         constructor(t = []) {
             this.planes = t
         }
         fromBoundingSphere(t) {
-            this.planes.length = 2 * ET.length;
+            this.planes.length = 2 * PR.length;
             let r = t.center,
                 i = t.radius,
-                s = 0;
-            for (let n of ET) {
-                let o = this.planes[s],
-                    a = this.planes[s + 1];
-                o || (o = this.planes[s] = new br), a || (a = this.planes[s + 1] = new br);
-                let c = ST.copy(n).scale(-i).add(r);
-                o.fromPointNormal(c, n);
-                let l = ST.copy(n).scale(i).add(r),
-                    h = GM.copy(n).negate();
-                a.fromPointNormal(l, h), s += 2
+                n = 0;
+            for (let s of PR) {
+                let o = this.planes[n],
+                    a = this.planes[n + 1];
+                o || (o = this.planes[n] = new Pn), a || (a = this.planes[n + 1] = new Pn);
+                let c = CR.copy(s).scale(-i).add(r);
+                o.fromPointNormal(c, s);
+                let l = CR.copy(s).scale(i).add(r),
+                    u = Y4.copy(s).negate();
+                a.fromPointNormal(l, u), n += 2
             }
             return this
         }
         computeVisibility(t) {
-            let r = yt.INSIDE;
+            let r = ne.INSIDE;
             for (let i of this.planes) switch (t.intersectPlane(i)) {
-                case yt.OUTSIDE:
-                    return yt.OUTSIDE;
-                case yt.INTERSECTING:
-                    r = yt.INTERSECTING;
+                case ne.OUTSIDE:
+                    return ne.OUTSIDE;
+                case ne.INTERSECTING:
+                    r = ne.INTERSECTING;
                     break;
                 default:
             }
             return r
         }
         computeVisibilityWithPlaneMask(t, r) {
-            if (Xe(Number.isFinite(r), "parentPlaneMask is required."), r === e.MASK_OUTSIDE || r === e.MASK_INSIDE) return r;
+            if (Vi(Number.isFinite(r), "parentPlaneMask is required."), r === e.MASK_OUTSIDE || r === e.MASK_INSIDE) return r;
             let i = e.MASK_INSIDE,
-                s = this.planes;
-            for (let n = 0; n < this.planes.length; ++n) {
-                let o = n < 31 ? 1 << n : 0;
-                if (n < 31 && !(r & o)) continue;
-                let a = s[n],
+                n = this.planes;
+            for (let s = 0; s < this.planes.length; ++s) {
+                let o = s < 31 ? 1 << s : 0;
+                if (s < 31 && !(r & o)) continue;
+                let a = n[s],
                     c = t.intersectPlane(a);
-                if (c === yt.OUTSIDE) return e.MASK_OUTSIDE;
-                c === yt.INTERSECTING && (i |= o)
+                if (c === ne.OUTSIDE) return e.MASK_OUTSIDE;
+                c === ne.INTERSECTING && (i |= o)
             }
             return i
         }
     };
-Ar.MASK_OUTSIDE = 4294967295;
-Ar.MASK_INSIDE = 0;
-Ar.MASK_INDETERMINATE = 2147483647;
-var hY = new U,
-    fY = new U,
-    uY = new U,
-    dY = new U,
-    pY = new U;
-var TY = new U,
-    bY = new U,
-    AY = new U,
-    EY = new U,
-    SY = new U,
-    wY = new U,
-    vY = new U,
-    RY = new U,
-    PY = new U,
-    MY = new U,
-    CY = new U,
-    IY = new U;
-var ir = new ft,
-    tC = new ft,
-    eC = new ft,
-    oh = new ft,
-    wT = new ft;
+Cn.MASK_OUTSIDE = 4294967295;
+Cn.MASK_INSIDE = 0;
+Cn.MASK_INDETERMINATE = 2147483647;
+var Out = new z,
+    Nut = new z,
+    But = new z,
+    Fut = new z,
+    Dut = new z;
+var Wut = new z,
+    jut = new z,
+    Hut = new z,
+    $ut = new z,
+    Xut = new z,
+    Yut = new z,
+    qut = new z,
+    Zut = new z,
+    Kut = new z,
+    Gut = new z,
+    Jut = new z,
+    Qut = new z;
+var tn = new qt,
+    Z4 = new qt,
+    K4 = new qt,
+    gm = new qt,
+    OR = new qt;
 
-function up(e, t = {}) {
-    let r = Hn.EPSILON20,
+function Ex(e, t = {}) {
+    let r = Dl.EPSILON20,
         i = 10,
-        s = 0,
         n = 0,
-        o = tC,
-        a = eC;
+        s = 0,
+        o = Z4,
+        a = K4;
     o.identity(), a.copy(e);
-    let c = r * rC(a);
-    for (; n < i && iC(a) > c;) sC(a, oh), wT.copy(oh).transpose(), a.multiplyRight(oh), a.multiplyLeft(wT), o.multiplyRight(oh), ++s > 2 && (++n, s = 0);
+    let c = r * G4(a);
+    for (; s < i && J4(a) > c;) Q4(a, gm), OR.copy(gm).transpose(), a.multiplyRight(gm), a.multiplyLeft(OR), o.multiplyRight(gm), ++n > 2 && (++s, n = 0);
     return t.unitary = o.toTarget(t.unitary), t.diagonal = a.toTarget(t.diagonal), t
 }
 
-function rC(e) {
+function G4(e) {
     let t = 0;
     for (let r = 0; r < 9; ++r) {
         let i = e[r];
         t += i * i
     }
     return Math.sqrt(t)
 }
-var hp = [1, 0, 0],
-    fp = [2, 2, 1];
+var Sx = [1, 0, 0],
+    Ax = [2, 2, 1];
 
-function iC(e) {
+function J4(e) {
     let t = 0;
     for (let r = 0; r < 3; ++r) {
-        let i = e[ir.getElementIndex(fp[r], hp[r])];
+        let i = e[tn.getElementIndex(Ax[r], Sx[r])];
         t += 2 * i * i
     }
     return Math.sqrt(t)
 }
 
-function sC(e, t) {
-    let r = Hn.EPSILON15,
+function Q4(e, t) {
+    let r = Dl.EPSILON15,
         i = 0,
-        s = 1;
+        n = 1;
     for (let l = 0; l < 3; ++l) {
-        let h = Math.abs(e[ir.getElementIndex(fp[l], hp[l])]);
-        h > i && (s = l, i = h)
+        let u = Math.abs(e[tn.getElementIndex(Ax[l], Sx[l])]);
+        u > i && (n = l, i = u)
     }
-    let n = hp[s],
-        o = fp[s],
+    let s = Sx[n],
+        o = Ax[n],
         a = 1,
         c = 0;
-    if (Math.abs(e[ir.getElementIndex(o, n)]) > r) {
-        let l = e[ir.getElementIndex(o, o)],
-            h = e[ir.getElementIndex(n, n)],
-            f = e[ir.getElementIndex(o, n)],
-            u = (l - h) / 2 / f,
+    if (Math.abs(e[tn.getElementIndex(o, s)]) > r) {
+        let l = e[tn.getElementIndex(o, o)],
+            u = e[tn.getElementIndex(s, s)],
+            f = e[tn.getElementIndex(o, s)],
+            h = (l - u) / 2 / f,
             d;
-        u < 0 ? d = -1 / (-u + Math.sqrt(1 + u * u)) : d = 1 / (u + Math.sqrt(1 + u * u)), a = 1 / Math.sqrt(1 + d * d), c = d * a
+        h < 0 ? d = -1 / (-h + Math.sqrt(1 + h * h)) : d = 1 / (h + Math.sqrt(1 + h * h)), a = 1 / Math.sqrt(1 + d * d), c = d * a
     }
-    return ft.IDENTITY.to(t), t[ir.getElementIndex(n, n)] = t[ir.getElementIndex(o, o)] = a, t[ir.getElementIndex(o, n)] = c, t[ir.getElementIndex(n, o)] = -c, t
+    return qt.IDENTITY.to(t), t[tn.getElementIndex(s, s)] = t[tn.getElementIndex(o, o)] = a, t[tn.getElementIndex(o, s)] = c, t[tn.getElementIndex(s, o)] = -c, t
 }
-var oi = new U,
-    nC = new U,
-    oC = new U,
-    aC = new U,
-    cC = new U,
-    lC = new ft,
-    hC = {
-        diagonal: new ft,
-        unitary: new ft
+var Ws = new z,
+    t6 = new z,
+    e6 = new z,
+    r6 = new z,
+    i6 = new z,
+    n6 = new qt,
+    s6 = {
+        diagonal: new qt,
+        unitary: new qt
     };
 
-function dp(e, t = new na) {
-    if (!e || e.length === 0) return t.halfAxes = new ft([0, 0, 0, 0, 0, 0, 0, 0, 0]), t.center = new U, t;
+function Ix(e, t = new sf) {
+    if (!e || e.length === 0) return t.halfAxes = new qt([0, 0, 0, 0, 0, 0, 0, 0, 0]), t.center = new z, t;
     let r = e.length,
-        i = new U(0, 0, 0);
+        i = new z(0, 0, 0);
     for (let k of e) i.add(k);
-    let s = 1 / r;
-    i.multiplyByScalar(s);
-    let n = 0,
+    let n = 1 / r;
+    i.multiplyByScalar(n);
+    let s = 0,
         o = 0,
         a = 0,
         c = 0,
         l = 0,
-        h = 0;
+        u = 0;
     for (let k of e) {
-        let N = oi.copy(k).subtract(i);
-        n += N.x * N.x, o += N.x * N.y, a += N.x * N.z, c += N.y * N.y, l += N.y * N.z, h += N.z * N.z
+        let B = Ws.copy(k).subtract(i);
+        s += B.x * B.x, o += B.x * B.y, a += B.x * B.z, c += B.y * B.y, l += B.y * B.z, u += B.z * B.z
     }
-    n *= s, o *= s, a *= s, c *= s, l *= s, h *= s;
-    let f = lC;
-    f[0] = n, f[1] = o, f[2] = a, f[3] = o, f[4] = c, f[5] = l, f[6] = a, f[7] = l, f[8] = h;
+    s *= n, o *= n, a *= n, c *= n, l *= n, u *= n;
+    let f = n6;
+    f[0] = s, f[1] = o, f[2] = a, f[3] = o, f[4] = c, f[5] = l, f[6] = a, f[7] = l, f[8] = u;
     let {
-        unitary: u
-    } = up(f, hC), d = t.halfAxes.copy(u), m = d.getColumn(0, oC), y = d.getColumn(1, aC), x = d.getColumn(2, cC), A = -Number.MAX_VALUE, v = -Number.MAX_VALUE, E = -Number.MAX_VALUE, R = Number.MAX_VALUE, M = Number.MAX_VALUE, C = Number.MAX_VALUE;
-    for (let k of e) oi.copy(k), A = Math.max(oi.dot(m), A), v = Math.max(oi.dot(y), v), E = Math.max(oi.dot(x), E), R = Math.min(oi.dot(m), R), M = Math.min(oi.dot(y), M), C = Math.min(oi.dot(x), C);
-    m = m.multiplyByScalar(.5 * (R + A)), y = y.multiplyByScalar(.5 * (M + v)), x = x.multiplyByScalar(.5 * (C + E)), t.center.copy(m).add(y).add(x);
-    let B = nC.set(A - R, v - M, E - C).multiplyByScalar(.5),
-        L = new ft([B[0], 0, 0, 0, B[1], 0, 0, 0, B[2]]);
-    return t.halfAxes.multiplyRight(L), t
-}
-var Qs = 512,
-    vT = 3,
-    RT = [
+        unitary: h
+    } = Ex(f, s6), d = t.halfAxes.copy(h), p = d.getColumn(0, e6), y = d.getColumn(1, r6), b = d.getColumn(2, i6), T = -Number.MAX_VALUE, I = -Number.MAX_VALUE, S = -Number.MAX_VALUE, R = Number.MAX_VALUE, P = Number.MAX_VALUE, C = Number.MAX_VALUE;
+    for (let k of e) Ws.copy(k), T = Math.max(Ws.dot(p), T), I = Math.max(Ws.dot(y), I), S = Math.max(Ws.dot(b), S), R = Math.min(Ws.dot(p), R), P = Math.min(Ws.dot(y), P), C = Math.min(Ws.dot(b), C);
+    p = p.multiplyByScalar(.5 * (R + T)), y = y.multiplyByScalar(.5 * (P + I)), b = b.multiplyByScalar(.5 * (C + S)), t.center.copy(p).add(y).add(b);
+    let V = t6.set(T - R, I - P, S - C).multiplyByScalar(.5),
+        U = new qt([V[0], 0, 0, 0, V[1], 0, 0, 0, V[2]]);
+    return t.halfAxes.multiplyRight(U), t
+}
+var bc = 512,
+    NR = 3,
+    BR = [
         [.5, .5],
         [0, 0],
         [0, 1],
         [1, 0],
         [1, 1]
     ],
-    PT = RT.concat([
+    FR = BR.concat([
         [0, .5],
         [.5, 0],
         [1, .5],
         [.5, 1]
     ]),
-    fC = PT.concat([
+    o6 = FR.concat([
         [.25, .5],
         [.75, .5]
     ]),
-    pp = class e {
+    Rx = class e {
         constructor(t, r, i) {
             this.x = t, this.y = r, this.z = i
         }
         get children() {
             if (!this._children) {
                 let t = this.x * 2,
                     r = this.y * 2,
@@ -30577,293 +31705,293 @@
             }
             return this._children
         }
         update(t) {
             let {
                 viewport: r,
                 cullingVolume: i,
-                elevationBounds: s,
-                minZ: n,
+                elevationBounds: n,
+                minZ: s,
                 maxZ: o,
                 bounds: a,
                 offset: c,
                 project: l
-            } = t, h = this.getBoundingVolume(s, c, l);
-            if (a && !this.insideBounds(a) || i.computeVisibility(h) < 0) return !1;
+            } = t, u = this.getBoundingVolume(n, c, l);
+            if (a && !this.insideBounds(a) || i.computeVisibility(u) < 0) return !1;
             if (!this.childVisible) {
                 let {
-                    z: u
+                    z: h
                 } = this;
-                if (u < o && u >= n) {
-                    let d = h.distanceTo(r.cameraPosition) * r.scale / r.height;
-                    u += Math.floor(Math.log2(d))
+                if (h < o && h >= s) {
+                    let d = u.distanceTo(r.cameraPosition) * r.scale / r.height;
+                    h += Math.floor(Math.log2(d))
                 }
-                if (u >= o) return this.selected = !0, !0
+                if (h >= o) return this.selected = !0, !0
             }
             this.selected = !1, this.childVisible = !0;
-            for (let u of this.children) u.update(t);
+            for (let h of this.children) h.update(t);
             return !0
         }
         getSelected(t = []) {
             if (this.selected && t.push(this), this._children)
                 for (let r of this._children) r.getSelected(t);
             return t
         }
-        insideBounds([t, r, i, s]) {
-            let n = Math.pow(2, this.z),
-                o = Qs / n;
-            return this.x * o < i && this.y * o < s && (this.x + 1) * o > t && (this.y + 1) * o > r
+        insideBounds([t, r, i, n]) {
+            let s = Math.pow(2, this.z),
+                o = bc / s;
+            return this.x * o < i && this.y * o < n && (this.x + 1) * o > t && (this.y + 1) * o > r
         }
         getBoundingVolume(t, r, i) {
             if (i) {
-                let c = this.z < 1 ? fC : this.z < 2 ? PT : RT,
+                let c = this.z < 1 ? o6 : this.z < 2 ? FR : BR,
                     l = [];
-                for (let h of c) {
-                    let f = ah(this.x + h[0], this.y + h[1], this.z);
+                for (let u of c) {
+                    let f = _m(this.x + u[0], this.y + u[1], this.z);
                     f[2] = t[0], l.push(i(f)), t[0] !== t[1] && (f[2] = t[1], l.push(i(f)))
                 }
-                return dp(l)
+                return Ix(l)
             }
-            let s = Math.pow(2, this.z),
-                n = Qs / s,
-                o = this.x * n + r * Qs,
-                a = Qs - (this.y + 1) * n;
-            return new Zs([o, a, t[0]], [o + n, a + n, t[1]])
+            let n = Math.pow(2, this.z),
+                s = bc / n,
+                o = this.x * s + r * bc,
+                a = bc - (this.y + 1) * s;
+            return new _c([o, a, t[0]], [o + s, a + s, t[1]])
         }
     };
 
-function MT(e, t, r, i) {
-    let s = e instanceof Hi && e.resolution ? e.projectPosition : null,
-        n = Object.values(e.getFrustumPlanes()).map(({
+function DR(e, t, r, i) {
+    let n = e instanceof Uo && e.resolution ? e.projectPosition : null,
+        s = Object.values(e.getFrustumPlanes()).map(({
             normal: d,
-            distance: m
-        }) => new br(d.clone().negate(), m)),
-        o = new Ar(n),
+            distance: p
+        }) => new Pn(d.clone().negate(), p)),
+        o = new Cn(s),
         a = e.distanceScales.unitsPerMeter[2],
         c = r && r[0] * a || 0,
         l = r && r[1] * a || 0,
-        h = e instanceof _e && e.pitch <= 60 ? t : 0;
+        u = e instanceof kr && e.pitch <= 60 ? t : 0;
     if (i) {
-        let [d, m, y, x] = i, A = Vt([d, x]), v = Vt([y, m]);
-        i = [A[0], Qs - A[1], v[0], Qs - v[1]]
+        let [d, p, y, b] = i, T = Ue([d, b]), I = Ue([y, p]);
+        i = [T[0], bc - T[1], I[0], bc - I[1]]
     }
-    let f = new pp(0, 0, 0),
-        u = {
+    let f = new Rx(0, 0, 0),
+        h = {
             viewport: e,
-            project: s,
+            project: n,
             cullingVolume: o,
             elevationBounds: [c, l],
-            minZ: h,
+            minZ: u,
             maxZ: t,
             bounds: i,
             offset: 0
         };
-    if (f.update(u), e instanceof _e && e.subViewports && e.subViewports.length > 1) {
-        for (u.offset = -1; f.update(u) && !(--u.offset < -vT););
-        for (u.offset = 1; f.update(u) && !(++u.offset > vT););
+    if (f.update(h), e instanceof kr && e.subViewports && e.subViewports.length > 1) {
+        for (h.offset = -1; f.update(h) && !(--h.offset < -NR););
+        for (h.offset = 1; f.update(h) && !(++h.offset > NR););
     }
     return f.getSelected()
 }
-var Er = 512,
-    uC = [-1 / 0, -1 / 0, 1 / 0, 1 / 0],
-    mp = {
+var On = 512,
+    a6 = [-1 / 0, -1 / 0, 1 / 0, 1 / 0],
+    Px = {
         type: "object",
         value: null,
         validate: (e, t) => t.optional && e === null || typeof e == "string" || Array.isArray(e) && e.every(r => typeof r == "string"),
         equal: (e, t) => {
             if (e === t) return !0;
             if (!Array.isArray(e) || !Array.isArray(t)) return !1;
             let r = e.length;
             if (r !== t.length) return !1;
             for (let i = 0; i < r; i++)
                 if (e[i] !== t[i]) return !1;
             return !0
         }
     };
 
-function IT(e, t) {
+function kR(e, t) {
     let r = [t.transformAsPoint([e[0], e[1]]), t.transformAsPoint([e[2], e[1]]), t.transformAsPoint([e[0], e[3]]), t.transformAsPoint([e[2], e[3]])];
-    return [Math.min(...r.map(s => s[0])), Math.min(...r.map(s => s[1])), Math.max(...r.map(s => s[0])), Math.max(...r.map(s => s[1]))]
+    return [Math.min(...r.map(n => n[0])), Math.min(...r.map(n => n[1])), Math.max(...r.map(n => n[0])), Math.max(...r.map(n => n[1]))]
 }
 
-function dC(e) {
+function c6(e) {
     return Math.abs(e.split("").reduce((t, r) => (t << 5) - t + r.charCodeAt(0) | 0, 0))
 }
 
-function _p(e, t) {
+function Cx(e, t) {
     if (!e || !e.length) return null;
     let {
         index: r,
         id: i
     } = t;
     if (Array.isArray(e)) {
-        let n = dC(i) % e.length;
-        e = e[n]
+        let s = c6(i) % e.length;
+        e = e[s]
     }
-    let s = e;
-    for (let n of Object.keys(r)) {
-        let o = new RegExp(`{${n}}`, "g");
-        s = s.replace(o, String(r[n]))
+    let n = e;
+    for (let s of Object.keys(r)) {
+        let o = new RegExp(`{${s}}`, "g");
+        n = n.replace(o, String(r[s]))
     }
-    return Number.isInteger(r.y) && Number.isInteger(r.z) && (s = s.replace(/\{-y\}/g, String(Math.pow(2, r.z) - r.y - 1))), s
+    return Number.isInteger(r.y) && Number.isInteger(r.z) && (n = n.replace(/\{-y\}/g, String(Math.pow(2, r.z) - r.y - 1))), n
 }
 
-function pC(e, t, r) {
+function l6(e, t, r) {
     let i;
     if (t && t.length === 2) {
-        let [s, n] = t, o = e.getBounds({
-            z: s
-        }), a = e.getBounds({
+        let [n, s] = t, o = e.getBounds({
             z: n
+        }), a = e.getBounds({
+            z: s
         });
         i = [Math.min(o[0], a[0]), Math.min(o[1], a[1]), Math.max(o[2], a[2]), Math.max(o[3], a[3])]
     } else i = e.getBounds();
     return e.isGeospatial ? [Math.max(i[0], r[0]), Math.max(i[1], r[1]), Math.min(i[2], r[2]), Math.min(i[3], r[3])] : [Math.max(Math.min(i[0], r[2]), r[0]), Math.max(Math.min(i[1], r[3]), r[1]), Math.min(Math.max(i[2], r[0]), r[2]), Math.min(Math.max(i[3], r[1]), r[3])]
 }
 
-function OT({
+function UR({
     viewport: e,
     z: t,
     cullRect: r
 }) {
-    return (e.subViewports || [e]).map(s => gp(s, t || 0, r))
+    return (e.subViewports || [e]).map(n => Mx(n, t || 0, r))
 }
 
-function gp(e, t, r) {
+function Mx(e, t, r) {
     if (!Array.isArray(t)) {
-        let n = r.x - e.x,
+        let s = r.x - e.x,
             o = r.y - e.y,
             {
                 width: a,
                 height: c
             } = r,
             l = {
                 targetZ: t
             },
-            h = e.unproject([n, o], l),
-            f = e.unproject([n + a, o], l),
-            u = e.unproject([n, o + c], l),
-            d = e.unproject([n + a, o + c], l);
-        return [Math.min(h[0], f[0], u[0], d[0]), Math.min(h[1], f[1], u[1], d[1]), Math.max(h[0], f[0], u[0], d[0]), Math.max(h[1], f[1], u[1], d[1])]
+            u = e.unproject([s, o], l),
+            f = e.unproject([s + a, o], l),
+            h = e.unproject([s, o + c], l),
+            d = e.unproject([s + a, o + c], l);
+        return [Math.min(u[0], f[0], h[0], d[0]), Math.min(u[1], f[1], h[1], d[1]), Math.max(u[0], f[0], h[0], d[0]), Math.max(u[1], f[1], h[1], d[1])]
     }
-    let i = gp(e, t[0], r),
-        s = gp(e, t[1], r);
-    return [Math.min(i[0], s[0]), Math.min(i[1], s[1]), Math.max(i[2], s[2]), Math.max(i[3], s[3])]
+    let i = Mx(e, t[0], r),
+        n = Mx(e, t[1], r);
+    return [Math.min(i[0], n[0]), Math.min(i[1], n[1]), Math.max(i[2], n[2]), Math.max(i[3], n[3])]
 }
 
-function gC(e, t, r) {
-    return r ? IT(e, r).map(s => s * t / Er) : e.map(i => i * t / Er)
+function u6(e, t, r) {
+    return r ? kR(e, r).map(n => n * t / On) : e.map(i => i * t / On)
 }
 
-function yp(e, t) {
-    return Math.pow(2, e) * Er / t
+function Ox(e, t) {
+    return Math.pow(2, e) * On / t
 }
 
-function ah(e, t, r) {
-    let i = yp(r, Er),
-        s = e / i * 360 - 180,
-        n = Math.PI - 2 * Math.PI * t / i,
-        o = 180 / Math.PI * Math.atan(.5 * (Math.exp(n) - Math.exp(-n)));
-    return [s, o]
+function _m(e, t, r) {
+    let i = Ox(r, On),
+        n = e / i * 360 - 180,
+        s = Math.PI - 2 * Math.PI * t / i,
+        o = 180 / Math.PI * Math.atan(.5 * (Math.exp(s) - Math.exp(-s)));
+    return [n, o]
 }
 
-function CT(e, t, r, i) {
-    let s = yp(r, i);
-    return [e / s * Er, t / s * Er]
+function LR(e, t, r, i) {
+    let n = Ox(r, i);
+    return [e / n * On, t / n * On]
 }
 
-function xp(e, t, r, i, s = Er) {
+function Nx(e, t, r, i, n = On) {
     if (e.isGeospatial) {
-        let [l, h] = ah(t, r, i), [f, u] = ah(t + 1, r + 1, i);
+        let [l, u] = _m(t, r, i), [f, h] = _m(t + 1, r + 1, i);
         return {
             west: l,
-            north: h,
+            north: u,
             east: f,
-            south: u
+            south: h
         }
     }
-    let [n, o] = CT(t, r, i, s), [a, c] = CT(t + 1, r + 1, i, s);
+    let [s, o] = LR(t, r, i, n), [a, c] = LR(t + 1, r + 1, i, n);
     return {
-        left: n,
+        left: s,
         top: o,
         right: a,
         bottom: c
     }
 }
 
-function mC(e, t, r, i, s) {
-    let n = pC(e, null, i),
-        o = yp(t, r),
-        [a, c, l, h] = gC(n, o, s),
+function f6(e, t, r, i, n) {
+    let s = l6(e, null, i),
+        o = Ox(t, r),
+        [a, c, l, u] = u6(s, o, n),
         f = [];
-    for (let u = Math.floor(a); u < l; u++)
-        for (let d = Math.floor(c); d < h; d++) f.push({
-            x: u,
+    for (let h = Math.floor(a); h < l; h++)
+        for (let d = Math.floor(c); d < u; d++) f.push({
+            x: h,
             y: d,
             z: t
         });
     return f
 }
 
-function Tp({
+function Bx({
     viewport: e,
     maxZoom: t,
     minZoom: r,
     zRange: i,
-    extent: s,
-    tileSize: n = Er,
+    extent: n,
+    tileSize: s = On,
     modelMatrix: o,
     modelMatrixInverse: a,
     zoomOffset: c = 0
 }) {
-    let l = e.isGeospatial ? Math.round(e.zoom + Math.log2(Er / n)) + c : Math.ceil(e.zoom) + c;
+    let l = e.isGeospatial ? Math.round(e.zoom + Math.log2(On / s)) + c : Math.ceil(e.zoom) + c;
     if (typeof r == "number" && Number.isFinite(r) && l < r) {
-        if (!s) return [];
+        if (!n) return [];
         l = r
     }
     typeof t == "number" && Number.isFinite(t) && l > t && (l = t);
-    let h = s;
-    return o && a && s && !e.isGeospatial && (h = IT(s, o)), e.isGeospatial ? MT(e, l, i, s) : mC(e, l, n, h || uC, a)
+    let u = n;
+    return o && a && n && !e.isGeospatial && (u = kR(n, o)), e.isGeospatial ? DR(e, l, i, n) : f6(e, l, s, u || a6, a)
 }
 
-function NT(e) {
+function VR(e) {
     let t = {},
         r;
     return i => {
-        for (let s in i)
-            if (!_C(i[s], t[s])) {
+        for (let n in i)
+            if (!h6(i[n], t[n])) {
                 r = e(i), t = i;
                 break
             } return r
     }
 }
 
-function _C(e, t) {
+function h6(e, t) {
     if (e === t) return !0;
     if (Array.isArray(e)) {
         let r = e.length;
         if (!t || t.length !== r) return !1;
         for (let i = 0; i < r; i++)
             if (e[i] !== t[i]) return !1;
         return !0
     }
     return !1
 }
-var FT = 1,
-    ch = 2,
-    yC = "never",
-    xC = "no-overlap",
-    oa = "best-available",
-    TC = 5,
-    bC = {
-        [oa]: EC,
-        [xC]: SC,
-        [yC]: () => {}
+var zR = 1,
+    ym = 2,
+    d6 = "never",
+    p6 = "no-overlap",
+    of = "best-available",
+    m6 = 5,
+    g6 = {
+        [of]: y6,
+        [p6]: b6,
+        [d6]: () => {}
     },
-    AC = {
+    _6 = {
         extent: null,
         tileSize: 512,
         maxZoom: null,
         minZoom: null,
         maxCacheSize: null,
         maxCacheByteSize: null,
         refinementStrategy: "best-available",
@@ -30871,26 +31999,26 @@
         maxRequests: 6,
         debounceTime: 0,
         zoomOffset: 0,
         onTileLoad: () => {},
         onTileUnload: () => {},
         onTileError: () => {}
     },
-    Gs = class {
+    xc = class {
         constructor(t) {
-            this._getCullBounds = NT(OT), this.opts = {
-                ...AC,
+            this._getCullBounds = VR(UR), this.opts = {
+                ..._6,
                 ...t
             }, this.setOptions(this.opts), this.onTileLoad = r => {
                 this.opts.onTileLoad?.(r), this.opts.maxCacheByteSize && (this._cacheByteSize += r.byteLength, this._resizeCache())
-            }, this._requestScheduler = new es({
+            }, this._requestScheduler = new ba({
                 throttleRequests: this.opts.maxRequests > 0 || this.opts.debounceTime > 0,
                 maxRequests: this.opts.maxRequests,
                 debounceTime: this.opts.debounceTime
-            }), this._cache = new Map, this._tiles = [], this._dirty = !1, this._cacheByteSize = 0, this._viewport = null, this._zRange = null, this._selectedTiles = null, this._frameNumber = 0, this._modelMatrix = new ot, this._modelMatrixInverse = new ot
+            }), this._cache = new Map, this._tiles = [], this._dirty = !1, this._cacheByteSize = 0, this._viewport = null, this._zRange = null, this._selectedTiles = null, this._frameNumber = 0, this._modelMatrix = new Dt, this._modelMatrixInverse = new Dt
         }
         get tiles() {
             return this._tiles
         }
         get selectedTiles() {
             return this._selectedTiles
         }
@@ -30916,18 +32044,18 @@
         update(t, {
             zRange: r,
             modelMatrix: i
         } = {
             zRange: null,
             modelMatrix: null
         }) {
-            let s = i ? new ot(i) : new ot,
-                n = !s.equals(this._modelMatrix);
-            if (!this._viewport || !t.equals(this._viewport) || !Bt(this._zRange, r) || n) {
-                n && (this._modelMatrixInverse = s.clone().invert(), this._modelMatrix = s), this._viewport = t, this._zRange = r;
+            let n = i ? new Dt(i) : new Dt,
+                s = !n.equals(this._modelMatrix);
+            if (!this._viewport || !t.equals(this._viewport) || !Le(this._zRange, r) || s) {
+                s && (this._modelMatrixInverse = n.clone().invert(), this._modelMatrix = n), this._viewport = t, this._zRange = r;
                 let a = this.getTileIndices({
                     viewport: t,
                     maxZoom: this._maxZoom,
                     minZoom: this._minZoom,
                     zRange: r,
                     modelMatrix: this._modelMatrix,
                     modelMatrixInverse: this._modelMatrixInverse
@@ -30942,51 +32070,51 @@
             if (r && this._viewport) {
                 let i = this._getCullBounds({
                         viewport: this._viewport,
                         z: this._zRange,
                         cullRect: r
                     }),
                     {
-                        bbox: s
+                        bbox: n
                     } = t;
-                for (let [n, o, a, c] of i) {
+                for (let [s, o, a, c] of i) {
                     let l;
-                    if ("west" in s) l = s.west < a && s.east > n && s.south < c && s.north > o;
+                    if ("west" in n) l = n.west < a && n.east > s && n.south < c && n.north > o;
                     else {
-                        let h = Math.min(s.top, s.bottom),
-                            f = Math.max(s.top, s.bottom);
-                        l = s.left < a && s.right > n && h < c && f > o
+                        let u = Math.min(n.top, n.bottom),
+                            f = Math.max(n.top, n.bottom);
+                        l = n.left < a && n.right > s && u < c && f > o
                     }
                     if (l) return !0
                 }
                 return !1
             }
             return !0
         }
         getTileIndices({
             viewport: t,
             maxZoom: r,
             minZoom: i,
-            zRange: s,
-            modelMatrix: n,
+            zRange: n,
+            modelMatrix: s,
             modelMatrixInverse: o
         }) {
             let {
                 tileSize: a,
                 extent: c,
                 zoomOffset: l
             } = this.opts;
-            return Tp({
+            return Bx({
                 viewport: t,
                 maxZoom: r,
                 minZoom: i,
-                zRange: s,
+                zRange: n,
                 tileSize: a,
                 extent: c,
-                modelMatrix: n,
+                modelMatrix: s,
                 modelMatrixInverse: o,
                 zoomOffset: l
             })
         }
         getTileId(t) {
             return `${t.x}-${t.y}-${t.z}`
         }
@@ -30994,43 +32122,43 @@
             return t.z
         }
         getTileMetadata(t) {
             let {
                 tileSize: r
             } = this.opts;
             return {
-                bbox: xp(this._viewport, t.x, t.y, t.z, r)
+                bbox: Nx(this._viewport, t.x, t.y, t.z, r)
             }
         }
         getParentIndex(t) {
             let r = Math.floor(t.x / 2),
                 i = Math.floor(t.y / 2),
-                s = t.z - 1;
+                n = t.z - 1;
             return {
                 x: r,
                 y: i,
-                z: s
+                z: n
             }
         }
         updateTileStates() {
-            let t = this.opts.refinementStrategy || oa,
+            let t = this.opts.refinementStrategy || of,
                 r = new Array(this._cache.size),
                 i = 0;
-            for (let s of this._cache.values()) r[i++] = s.isVisible, s.isSelected = !1, s.isVisible = !1;
-            for (let s of this._selectedTiles) s.isSelected = !0, s.isVisible = !0;
-            (typeof t == "function" ? t : bC[t])(Array.from(this._cache.values())), i = 0;
-            for (let s of this._cache.values())
-                if (r[i++] !== s.isVisible) return !0;
+            for (let n of this._cache.values()) r[i++] = n.isVisible, n.isSelected = !1, n.isVisible = !1;
+            for (let n of this._selectedTiles) n.isSelected = !0, n.isVisible = !0;
+            (typeof t == "function" ? t : g6[t])(Array.from(this._cache.values())), i = 0;
+            for (let n of this._cache.values())
+                if (r[i++] !== n.isVisible) return !0;
             return !1
         }
         _pruneRequests() {
             let {
                 maxRequests: t = 0
             } = this.opts, r = [], i = 0;
-            for (let s of this._cache.values()) s.isLoading && (i++, !s.isSelected && !s.isVisible && r.push(s));
+            for (let n of this._cache.values()) n.isLoading && (i++, !n.isSelected && !n.isVisible && r.push(n));
             for (; t > 0 && i > t && r.length > 0;) r.shift().abort(), i--
         }
         _rebuildTree() {
             let {
                 _cache: t
             } = this;
             for (let r of t.values()) r.parent = null, r.children && (r.children.length = 0);
@@ -31039,87 +32167,87 @@
                 r.parent = i, i?.children && i.children.push(r)
             }
         }
         _resizeCache() {
             let {
                 _cache: t,
                 opts: r
-            } = this, i = r.maxCacheSize || (r.maxCacheByteSize ? 1 / 0 : TC * this.selectedTiles.length), s = r.maxCacheByteSize || 1 / 0;
-            if (t.size > i || this._cacheByteSize > s) {
+            } = this, i = r.maxCacheSize || (r.maxCacheByteSize ? 1 / 0 : m6 * this.selectedTiles.length), n = r.maxCacheByteSize || 1 / 0;
+            if (t.size > i || this._cacheByteSize > n) {
                 for (let [o, a] of t)
-                    if (!a.isVisible && !a.isSelected && (this._cacheByteSize -= r.maxCacheByteSize ? a.byteLength : 0, t.delete(o), this.opts.onTileUnload?.(a)), t.size <= i && this._cacheByteSize <= s) break;
+                    if (!a.isVisible && !a.isSelected && (this._cacheByteSize -= r.maxCacheByteSize ? a.byteLength : 0, t.delete(o), this.opts.onTileUnload?.(a)), t.size <= i && this._cacheByteSize <= n) break;
                 this._rebuildTree(), this._dirty = !0
             }
             this._dirty && (this._tiles = Array.from(this._cache.values()).sort((o, a) => o.zoom - a.zoom), this._dirty = !1)
         }
         _getTile(t, r) {
             let i = this.getTileId(t),
-                s = this._cache.get(i),
-                n = !1;
-            return !s && r ? (s = new rh(t), Object.assign(s, this.getTileMetadata(s.index)), Object.assign(s, {
+                n = this._cache.get(i),
+                s = !1;
+            return !n && r ? (n = new hm(t), Object.assign(n, this.getTileMetadata(n.index)), Object.assign(n, {
                 id: i,
-                zoom: this.getTileZoom(s.index)
-            }), n = !0, this._cache.set(i, s), this._dirty = !0) : s && s.needsReload && (n = !0), s && n && s.loadData({
+                zoom: this.getTileZoom(n.index)
+            }), s = !0, this._cache.set(i, n), this._dirty = !0) : n && n.needsReload && (s = !0), n && s && n.loadData({
                 getData: this.opts.getTileData,
                 requestScheduler: this._requestScheduler,
                 onLoad: this.onTileLoad,
                 onError: this.opts.onTileError
-            }), s
+            }), n
         }
         _getNearestAncestor(t) {
             let {
                 _minZoom: r = 0
             } = this, i = t.index;
             for (; this.getTileZoom(i) > r;) {
                 i = this.getParentIndex(i);
-                let s = this._getTile(i);
-                if (s) return s
+                let n = this._getTile(i);
+                if (n) return n
             }
             return null
         }
     };
 
-function EC(e) {
+function y6(e) {
     for (let t of e) t.state = 0;
-    for (let t of e) t.isSelected && !DT(t) && bp(t);
-    for (let t of e) t.isVisible = !!(t.state & ch)
+    for (let t of e) t.isSelected && !WR(t) && Fx(t);
+    for (let t of e) t.isVisible = !!(t.state & ym)
 }
 
-function SC(e) {
+function b6(e) {
     for (let r of e) r.state = 0;
-    for (let r of e) r.isSelected && DT(r);
+    for (let r of e) r.isSelected && WR(r);
     let t = Array.from(e).sort((r, i) => r.zoom - i.zoom);
     for (let r of t)
-        if (r.isVisible = !!(r.state & ch), r.children && (r.isVisible || r.state & FT))
-            for (let i of r.children) i.state = FT;
-        else r.isSelected && bp(r)
+        if (r.isVisible = !!(r.state & ym), r.children && (r.isVisible || r.state & zR))
+            for (let i of r.children) i.state = zR;
+        else r.isSelected && Fx(r)
 }
 
-function DT(e) {
+function WR(e) {
     let t = e;
     for (; t;) {
-        if (t.isLoaded || t.content) return t.state |= ch, !0;
+        if (t.isLoaded || t.content) return t.state |= ym, !0;
         t = t.parent
     }
     return !1
 }
 
-function bp(e) {
-    for (let t of e.children) t.isLoaded || t.content ? t.state |= ch : bp(t)
+function Fx(e) {
+    for (let t of e.children) t.isLoaded || t.content ? t.state |= ym : Fx(t)
 }
-var wC = {
-        TilesetClass: Gs,
+var x6 = {
+        TilesetClass: xc,
         data: {
             type: "data",
             value: []
         },
-        dataComparator: mp.equal,
+        dataComparator: Px.equal,
         renderSubLayers: {
             type: "function",
-            value: e => new qi(e)
+            value: e => new Xo(e)
         },
         getTileData: {
             type: "function",
             optional: !0,
             value: null
         },
         onViewportLoad: {
@@ -31146,21 +32274,21 @@
             compare: !0
         },
         tileSize: 512,
         maxZoom: null,
         minZoom: 0,
         maxCacheSize: null,
         maxCacheByteSize: null,
-        refinementStrategy: oa,
+        refinementStrategy: of,
         zRange: null,
         maxRequests: 6,
         debounceTime: 0,
         zoomOffset: 0
     },
-    lh = class lh extends Ne {
+    bm = class bm extends li {
         initializeState() {
             this.state = {
                 tileset: null,
                 isLoaded: !1
             }
         }
         finalizeState() {
@@ -31175,69 +32303,69 @@
             return t.somethingChanged
         }
         updateState({
             changeFlags: t
         }) {
             let {
                 tileset: r
-            } = this.state, i = t.propsOrDataChanged || t.updateTriggersChanged, s = t.dataChanged || t.updateTriggersChanged && (t.updateTriggersChanged.all || t.updateTriggersChanged.getTileData);
-            r ? i && (r.setOptions(this._getTilesetOptions()), s ? r.reloadAll() : r.tiles.forEach(n => {
-                n.layers = null
+            } = this.state, i = t.propsOrDataChanged || t.updateTriggersChanged, n = t.dataChanged || t.updateTriggersChanged && (t.updateTriggersChanged.all || t.updateTriggersChanged.getTileData);
+            r ? i && (r.setOptions(this._getTilesetOptions()), n ? r.reloadAll() : r.tiles.forEach(s => {
+                s.layers = null
             })) : (r = new this.props.TilesetClass(this._getTilesetOptions()), this.setState({
                 tileset: r
             })), this._updateTileset()
         }
         _getTilesetOptions() {
             let {
                 tileSize: t,
                 maxCacheSize: r,
                 maxCacheByteSize: i,
-                refinementStrategy: s,
-                extent: n,
+                refinementStrategy: n,
+                extent: s,
                 maxZoom: o,
                 minZoom: a,
                 maxRequests: c,
                 debounceTime: l,
-                zoomOffset: h
+                zoomOffset: u
             } = this.props;
             return {
                 maxCacheSize: r,
                 maxCacheByteSize: i,
                 maxZoom: o,
                 minZoom: a,
                 tileSize: t,
-                refinementStrategy: s,
-                extent: n,
+                refinementStrategy: n,
+                extent: s,
                 maxRequests: c,
                 debounceTime: l,
-                zoomOffset: h,
+                zoomOffset: u,
                 getTileData: this.getTileData.bind(this),
                 onTileLoad: this._onTileLoad.bind(this),
                 onTileError: this._onTileError.bind(this),
                 onTileUnload: this._onTileUnload.bind(this)
             }
         }
         _updateTileset() {
             let t = this.state.tileset,
                 {
                     zRange: r,
                     modelMatrix: i
                 } = this.props,
-                s = t.update(this.context.viewport, {
+                n = t.update(this.context.viewport, {
                     zRange: r,
                     modelMatrix: i
                 }),
                 {
-                    isLoaded: n
+                    isLoaded: s
                 } = t,
-                o = this.state.isLoaded !== n,
-                a = this.state.frameNumber !== s;
-            n && (o || a) && this._onViewportLoad(), a && this.setState({
-                frameNumber: s
-            }), this.state.isLoaded = n
+                o = this.state.isLoaded !== s,
+                a = this.state.frameNumber !== n;
+            s && (o || a) && this._onViewportLoad(), a && this.setState({
+                frameNumber: n
+            }), this.state.isLoaded = s
         }
         _onViewportLoad() {
             let {
                 tileset: t
             } = this.state, {
                 onViewportLoad: r
             } = this.props;
@@ -31252,22 +32380,22 @@
         _onTileUnload(t) {
             this.props.onTileUnload(t)
         }
         getTileData(t) {
             let {
                 data: r,
                 getTileData: i,
-                fetch: s
+                fetch: n
             } = this.props, {
-                signal: n
+                signal: s
             } = t;
-            return t.url = typeof r == "string" || Array.isArray(r) ? _p(r, t) : null, i ? i(t) : s && t.url ? s(t.url, {
+            return t.url = typeof r == "string" || Array.isArray(r) ? Cx(r, t) : null, i ? i(t) : n && t.url ? n(t.url, {
                 propName: "data",
                 layer: this,
-                signal: n
+                signal: s
             }) : null
         }
         renderSubLayers(t) {
             return this.props.renderSubLayers(t)
         }
         getSubLayerPropsByTile(t) {
             return null
@@ -31294,15 +32422,15 @@
                                 id: t.id,
                                 updateTriggers: this.props.updateTriggers
                             }),
                             data: t.content,
                             _offset: 0,
                             tile: t
                         });
-                        t.layers = gr(i, Boolean).map(s => s.clone({
+                        t.layers = Sn(i, Boolean).map(n => n.clone({
                             tile: t,
                             ...r
                         }))
                     } return t.layers
             })
         }
         filterSubLayer({
@@ -31311,442 +32439,10491 @@
         }) {
             let {
                 tile: i
             } = t.props;
             return this.state.tileset.isTileVisible(i, r)
         }
     };
-lh.defaultProps = wC, lh.layerName = "TileLayer";
-var ai = lh;
-import * as hh from "https://unpkg.com/parquet-wasm@0.4.0-beta.5/esm/arrow2.js";
-import * as LT from "https://esm.sh/@apache-arrow/es5-cjs";
-import * as Sr from "https://cdn.skypack.dev/math.gl@2.3.3";
-import {
-    load as kT
-} from "https://esm.sh/@loaders.gl/core@4.1.1";
-async function vC({
+bm.defaultProps = x6, bm.layerName = "TileLayer";
+var js = bm;
+
+function HR(e, t) {
+    var r = {};
+    for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (r[i] = e[i]);
+    if (e != null && typeof Object.getOwnPropertySymbols == "function")
+        for (var n = 0, i = Object.getOwnPropertySymbols(e); n < i.length; n++) t.indexOf(i[n]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[n]) && (r[i[n]] = e[i[n]]);
+    return r
+}
+
+function H(e, t, r, i) {
+    function n(s) {
+        return s instanceof r ? s : new r(function(o) {
+            o(s)
+        })
+    }
+    return new(r || (r = Promise))(function(s, o) {
+        function a(u) {
+            try {
+                l(i.next(u))
+            } catch (f) {
+                o(f)
+            }
+        }
+
+        function c(u) {
+            try {
+                l(i.throw(u))
+            } catch (f) {
+                o(f)
+            }
+        }
+
+        function l(u) {
+            u.done ? s(u.value) : n(u.value).then(a, c)
+        }
+        l((i = i.apply(e, t || [])).next())
+    })
+}
+
+function jR(e) {
+    var t = typeof Symbol == "function" && Symbol.iterator,
+        r = t && e[t],
+        i = 0;
+    if (r) return r.call(e);
+    if (e && typeof e.length == "number") return {
+        next: function() {
+            return e && i >= e.length && (e = void 0), {
+                value: e && e[i++],
+                done: !e
+            }
+        }
+    };
+    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
+}
+
+function pt(e) {
+    return this instanceof pt ? (this.v = e, this) : new pt(e)
+}
+
+function _r(e, t, r) {
+    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
+    var i = r.apply(e, t || []),
+        n, s = [];
+    return n = {}, o("next"), o("throw"), o("return"), n[Symbol.asyncIterator] = function() {
+        return this
+    }, n;
+
+    function o(h) {
+        i[h] && (n[h] = function(d) {
+            return new Promise(function(p, y) {
+                s.push([h, d, p, y]) > 1 || a(h, d)
+            })
+        })
+    }
+
+    function a(h, d) {
+        try {
+            c(i[h](d))
+        } catch (p) {
+            f(s[0][3], p)
+        }
+    }
+
+    function c(h) {
+        h.value instanceof pt ? Promise.resolve(h.value.v).then(l, u) : f(s[0][2], h)
+    }
+
+    function l(h) {
+        a("next", h)
+    }
+
+    function u(h) {
+        a("throw", h)
+    }
+
+    function f(h, d) {
+        h(d), s.shift(), s.length && a(s[0][0], s[0][1])
+    }
+}
+
+function wc(e) {
+    var t, r;
+    return t = {}, i("next"), i("throw", function(n) {
+        throw n
+    }), i("return"), t[Symbol.iterator] = function() {
+        return this
+    }, t;
+
+    function i(n, s) {
+        t[n] = e[n] ? function(o) {
+            return (r = !r) ? {
+                value: pt(e[n](o)),
+                done: !1
+            } : s ? s(o) : o
+        } : s
+    }
+}
+
+function fi(e) {
+    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
+    var t = e[Symbol.asyncIterator],
+        r;
+    return t ? t.call(e) : (e = typeof jR == "function" ? jR(e) : e[Symbol.iterator](), r = {}, i("next"), i("throw"), i("return"), r[Symbol.asyncIterator] = function() {
+        return this
+    }, r);
+
+    function i(s) {
+        r[s] = e[s] && function(o) {
+            return new Promise(function(a, c) {
+                o = e[s](o), n(a, c, o.done, o.value)
+            })
+        }
+    }
+
+    function n(s, o, a, c) {
+        Promise.resolve(c).then(function(l) {
+            s({
+                value: l,
+                done: a
+            })
+        }, o)
+    }
+}
+var zx = {};
+Ze(zx, {
+    compareArrayLike: () => Vx,
+    joinUint8Arrays: () => br,
+    memcpy: () => lf,
+    rebaseValueOffsets: () => Im,
+    toArrayBufferView: () => yt,
+    toArrayBufferViewAsyncIterator: () => di,
+    toArrayBufferViewIterator: () => rn,
+    toBigInt64Array: () => Em,
+    toBigUint64Array: () => M6,
+    toFloat32Array: () => P6,
+    toFloat32ArrayAsyncIterator: () => X6,
+    toFloat32ArrayIterator: () => k6,
+    toFloat64Array: () => C6,
+    toFloat64ArrayAsyncIterator: () => Y6,
+    toFloat64ArrayIterator: () => U6,
+    toInt16Array: () => E6,
+    toInt16ArrayAsyncIterator: () => W6,
+    toInt16ArrayIterator: () => B6,
+    toInt32Array: () => Yo,
+    toInt32ArrayAsyncIterator: () => j6,
+    toInt32ArrayIterator: () => F6,
+    toInt8Array: () => A6,
+    toInt8ArrayAsyncIterator: () => z6,
+    toInt8ArrayIterator: () => N6,
+    toUint16Array: () => I6,
+    toUint16ArrayAsyncIterator: () => H6,
+    toUint16ArrayIterator: () => D6,
+    toUint32Array: () => R6,
+    toUint32ArrayAsyncIterator: () => $6,
+    toUint32ArrayIterator: () => L6,
+    toUint8Array: () => at,
+    toUint8ArrayAsyncIterator: () => Ux,
+    toUint8ArrayIterator: () => kx,
+    toUint8ClampedArray: () => O6,
+    toUint8ClampedArrayAsyncIterator: () => q6,
+    toUint8ClampedArrayIterator: () => V6
+});
+var w6 = new TextDecoder("utf-8"),
+    af = e => w6.decode(e),
+    T6 = new TextEncoder,
+    en = e => T6.encode(e);
+var v6 = e => typeof e == "number",
+    $R = e => typeof e == "boolean",
+    pe = e => typeof e == "function",
+    je = e => e != null && Object(e) === e,
+    yr = e => je(e) && pe(e.then);
+var hi = e => je(e) && pe(e[Symbol.iterator]),
+    $r = e => je(e) && pe(e[Symbol.asyncIterator]),
+    xm = e => je(e) && je(e.schema);
+var wm = e => je(e) && "done" in e && "value" in e;
+var Tm = e => je(e) && pe(e.stat) && v6(e.fd);
+var vm = e => je(e) && cf(e.body),
+    Sm = e => "_getDOMStream" in e && "_getNodeStream" in e,
+    XR = e => je(e) && pe(e.abort) && pe(e.getWriter) && !Sm(e),
+    cf = e => je(e) && pe(e.cancel) && pe(e.getReader) && !Sm(e),
+    YR = e => je(e) && pe(e.end) && pe(e.write) && $R(e.writable) && !Sm(e),
+    Am = e => je(e) && pe(e.read) && pe(e.pipe) && $R(e.readable) && !Sm(e),
+    qR = e => je(e) && pe(e.clear) && pe(e.bytes) && pe(e.position) && pe(e.setPosition) && pe(e.capacity) && pe(e.getBufferIdentifier) && pe(e.createLong);
+var Lx = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : ArrayBuffer;
+
+function S6(e) {
+    let t = e[0] ? [e[0]] : [],
+        r, i, n, s;
+    for (let o, a, c = 0, l = 0, u = e.length; ++c < u;) {
+        if (o = t[l], a = e[c], !o || !a || o.buffer !== a.buffer || a.byteOffset < o.byteOffset) {
+            a && (t[++l] = a);
+            continue
+        }
+        if ({
+                byteOffset: r,
+                byteLength: n
+            } = o, {
+                byteOffset: i,
+                byteLength: s
+            } = a, r + n < i || i + s < r) {
+            a && (t[++l] = a);
+            continue
+        }
+        t[l] = new Uint8Array(o.buffer, r, i - r + s)
+    }
+    return t
+}
+
+function lf(e, t, r = 0, i = t.byteLength) {
+    let n = e.byteLength,
+        s = new Uint8Array(e.buffer, e.byteOffset, n),
+        o = new Uint8Array(t.buffer, t.byteOffset, Math.min(i, n));
+    return s.set(o, r), e
+}
+
+function br(e, t) {
+    let r = S6(e),
+        i = r.reduce((u, f) => u + f.byteLength, 0),
+        n, s, o, a = 0,
+        c = -1,
+        l = Math.min(t || Number.POSITIVE_INFINITY, i);
+    for (let u = r.length; ++c < u;) {
+        if (n = r[c], s = n.subarray(0, Math.min(n.length, l - a)), l <= a + s.length) {
+            s.length < n.length ? r[c] = n.subarray(s.length) : s.length === n.length && c++, o ? lf(o, s, a) : o = s;
+            break
+        }
+        lf(o || (o = new Uint8Array(l)), s, a), a += s.length
+    }
+    return [o || new Uint8Array(0), r.slice(c), i - (o ? o.byteLength : 0)]
+}
+
+function yt(e, t) {
+    let r = wm(t) ? t.value : t;
+    return r instanceof e ? e === Uint8Array ? new e(r.buffer, r.byteOffset, r.byteLength) : r : r ? (typeof r == "string" && (r = en(r)), r instanceof ArrayBuffer ? new e(r) : r instanceof Lx ? new e(r) : qR(r) ? yt(e, r.bytes()) : ArrayBuffer.isView(r) ? r.byteLength <= 0 ? new e(0) : new e(r.buffer, r.byteOffset, r.byteLength / e.BYTES_PER_ELEMENT) : e.from(r)) : new e(0)
+}
+var A6 = e => yt(Int8Array, e),
+    E6 = e => yt(Int16Array, e),
+    Yo = e => yt(Int32Array, e),
+    Em = e => yt(BigInt64Array, e),
+    at = e => yt(Uint8Array, e),
+    I6 = e => yt(Uint16Array, e),
+    R6 = e => yt(Uint32Array, e),
+    M6 = e => yt(BigUint64Array, e),
+    P6 = e => yt(Float32Array, e),
+    C6 = e => yt(Float64Array, e),
+    O6 = e => yt(Uint8ClampedArray, e),
+    Dx = e => (e.next(), e);
+
+function* rn(e, t) {
+    let r = function*(n) {
+            yield n
+        },
+        i = typeof t == "string" || ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof Lx ? r(t) : hi(t) ? t : r(t);
+    return yield* Dx(function*(n) {
+        let s = null;
+        do s = n.next(yield yt(e, s)); while (!s.done)
+    }(i[Symbol.iterator]())), new e
+}
+var N6 = e => rn(Int8Array, e),
+    B6 = e => rn(Int16Array, e),
+    F6 = e => rn(Int32Array, e),
+    kx = e => rn(Uint8Array, e),
+    D6 = e => rn(Uint16Array, e),
+    L6 = e => rn(Uint32Array, e),
+    k6 = e => rn(Float32Array, e),
+    U6 = e => rn(Float64Array, e),
+    V6 = e => rn(Uint8ClampedArray, e);
+
+function di(e, t) {
+    return _r(this, arguments, function*() {
+        if (yr(t)) return yield pt(yield pt(yield* wc(fi(di(e, yield pt(t))))));
+        let i = function(o) {
+                return _r(this, arguments, function*() {
+                    yield yield pt(yield pt(o))
+                })
+            },
+            n = function(o) {
+                return _r(this, arguments, function*() {
+                    yield pt(yield* wc(fi(Dx(function*(a) {
+                        let c = null;
+                        do c = a.next(yield c?.value); while (!c.done)
+                    }(o[Symbol.iterator]())))))
+                })
+            },
+            s = typeof t == "string" || ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof Lx ? i(t) : hi(t) ? n(t) : $r(t) ? t : i(t);
+        return yield pt(yield* wc(fi(Dx(function(o) {
+            return _r(this, arguments, function*() {
+                let a = null;
+                do a = yield pt(o.next(yield yield pt(yt(e, a)))); while (!a.done)
+            })
+        }(s[Symbol.asyncIterator]()))))), yield pt(new e)
+    })
+}
+var z6 = e => di(Int8Array, e),
+    W6 = e => di(Int16Array, e),
+    j6 = e => di(Int32Array, e),
+    Ux = e => di(Uint8Array, e),
+    H6 = e => di(Uint16Array, e),
+    $6 = e => di(Uint32Array, e),
+    X6 = e => di(Float32Array, e),
+    Y6 = e => di(Float64Array, e),
+    q6 = e => di(Uint8ClampedArray, e);
+
+function Im(e, t, r) {
+    if (e !== 0) {
+        r = r.slice(0, t);
+        for (let i = -1, n = r.length; ++i < n;) r[i] += e
+    }
+    return r.subarray(0, t)
+}
+
+function Vx(e, t) {
+    let r = 0,
+        i = e.length;
+    if (i !== t.length) return !1;
+    if (i > 0)
+        do
+            if (e[r] !== t[r]) return !1; while (++r < i);
+    return !0
+}
+var Ae = {
+        fromIterable(e) {
+            return Rm(Z6(e))
+        },
+        fromAsyncIterable(e) {
+            return Rm(K6(e))
+        },
+        fromDOMStream(e) {
+            return Rm(G6(e))
+        },
+        fromNodeStream(e) {
+            return Rm(J6(e))
+        },
+        toDOMStream(e, t) {
+            throw new Error('"toDOMStream" not available in this environment')
+        },
+        toNodeStream(e, t) {
+            throw new Error('"toNodeStream" not available in this environment')
+        }
+    },
+    Rm = e => (e.next(), e);
+
+function* Z6(e) {
+    let t, r = !1,
+        i = [],
+        n, s, o, a = 0;
+
+    function c() {
+        return s === "peek" ? br(i, o)[0] : ([n, i, a] = br(i, o), n)
+    }({
+        cmd: s,
+        size: o
+    } = (yield null) || {
+        cmd: "read",
+        size: 0
+    });
+    let l = kx(e)[Symbol.iterator]();
+    try {
+        do
+            if ({
+                    done: t,
+                    value: n
+                } = Number.isNaN(o - a) ? l.next() : l.next(o - a), !t && n.byteLength > 0 && (i.push(n), a += n.byteLength), t || o <= a)
+                do({
+                    cmd: s,
+                    size: o
+                } = yield c()); while (o < a); while (!t)
+    } catch (u) {
+        (r = !0) && typeof l.throw == "function" && l.throw(u)
+    } finally {
+        r === !1 && typeof l.return == "function" && l.return(null)
+    }
+    return null
+}
+
+function K6(e) {
+    return _r(this, arguments, function*() {
+        let r, i = !1,
+            n = [],
+            s, o, a, c = 0;
+
+        function l() {
+            return o === "peek" ? br(n, a)[0] : ([s, n, c] = br(n, a), s)
+        }({
+            cmd: o,
+            size: a
+        } = (yield yield pt(null)) || {
+            cmd: "read",
+            size: 0
+        });
+        let u = Ux(e)[Symbol.asyncIterator]();
+        try {
+            do
+                if ({
+                        done: r,
+                        value: s
+                    } = Number.isNaN(a - c) ? yield pt(u.next()): yield pt(u.next(a - c)), !r && s.byteLength > 0 && (n.push(s), c += s.byteLength), r || a <= c)
+                    do({
+                        cmd: o,
+                        size: a
+                    } = yield yield pt(l())); while (a < c); while (!r)
+        } catch (f) {
+            (i = !0) && typeof u.throw == "function" && (yield pt(u.throw(f)))
+        } finally {
+            i === !1 && typeof u.return == "function" && (yield pt(u.return(new Uint8Array(0))))
+        }
+        return yield pt(null)
+    })
+}
+
+function G6(e) {
+    return _r(this, arguments, function*() {
+        let r = !1,
+            i = !1,
+            n = [],
+            s, o, a, c = 0;
+
+        function l() {
+            return o === "peek" ? br(n, a)[0] : ([s, n, c] = br(n, a), s)
+        }({
+            cmd: o,
+            size: a
+        } = (yield yield pt(null)) || {
+            cmd: "read",
+            size: 0
+        });
+        let u = new jx(e);
+        try {
+            do
+                if ({
+                        done: r,
+                        value: s
+                    } = Number.isNaN(a - c) ? yield pt(u.read()): yield pt(u.read(a - c)), !r && s.byteLength > 0 && (n.push(at(s)), c += s.byteLength), r || a <= c)
+                    do({
+                        cmd: o,
+                        size: a
+                    } = yield yield pt(l())); while (a < c); while (!r)
+        } catch (f) {
+            (i = !0) && (yield pt(u.cancel(f)))
+        } finally {
+            i === !1 ? yield pt(u.cancel()): e.locked && u.releaseLock()
+        }
+        return yield pt(null)
+    })
+}
+var jx = class {
+        constructor(t) {
+            this.source = t, this.reader = null, this.reader = this.source.getReader(), this.reader.closed.catch(() => {})
+        }
+        get closed() {
+            return this.reader ? this.reader.closed.catch(() => {}) : Promise.resolve()
+        }
+        releaseLock() {
+            this.reader && this.reader.releaseLock(), this.reader = null
+        }
+        cancel(t) {
+            return H(this, void 0, void 0, function*() {
+                let {
+                    reader: r,
+                    source: i
+                } = this;
+                r && (yield r.cancel(t).catch(() => {})), i && i.locked && this.releaseLock()
+            })
+        }
+        read(t) {
+            return H(this, void 0, void 0, function*() {
+                if (t === 0) return {
+                    done: this.reader == null,
+                    value: new Uint8Array(0)
+                };
+                let r = yield this.reader.read();
+                return !r.done && (r.value = at(r)), r
+            })
+        }
+    },
+    Wx = (e, t) => {
+        let r = n => i([t, n]),
+            i;
+        return [t, r, new Promise(n => (i = n) && e.once(t, r))]
+    };
+
+function J6(e) {
+    return _r(this, arguments, function*() {
+        let r = [],
+            i = "error",
+            n = !1,
+            s = null,
+            o, a, c = 0,
+            l = [],
+            u;
+
+        function f() {
+            return o === "peek" ? br(l, a)[0] : ([u, l, c] = br(l, a), u)
+        }
+        if ({
+                cmd: o,
+                size: a
+            } = (yield yield pt(null)) || {
+                cmd: "read",
+                size: 0
+            }, e.isTTY) return yield yield pt(new Uint8Array(0)), yield pt(null);
+        try {
+            r[0] = Wx(e, "end"), r[1] = Wx(e, "error");
+            do {
+                if (r[2] = Wx(e, "readable"), [i, s] = yield pt(Promise.race(r.map(d => d[2]))), i === "error") break;
+                if ((n = i === "end") || (Number.isFinite(a - c) ? (u = at(e.read(a - c)), u.byteLength < a - c && (u = at(e.read()))) : u = at(e.read()), u.byteLength > 0 && (l.push(u), c += u.byteLength)), n || a <= c)
+                    do({
+                        cmd: o,
+                        size: a
+                    } = yield yield pt(f())); while (a < c)
+            } while (!n)
+        } finally {
+            yield pt(h(r, i === "error" ? s : null))
+        }
+        return yield pt(null);
+
+        function h(d, p) {
+            return u = l = null, new Promise((y, b) => {
+                for (let [T, I] of d) e.off(T, I);
+                try {
+                    let T = e.destroy;
+                    T && T.call(e, p), p = void 0
+                } catch (T) {
+                    p = T || p
+                } finally {
+                    p != null ? b(p) : y()
+                }
+            })
+        }
+    })
+}
+var Bt;
+(function(e) {
+    e[e.V1 = 0] = "V1", e[e.V2 = 1] = "V2", e[e.V3 = 2] = "V3", e[e.V4 = 3] = "V4", e[e.V5 = 4] = "V5"
+})(Bt || (Bt = {}));
+var Vt;
+(function(e) {
+    e[e.Sparse = 0] = "Sparse", e[e.Dense = 1] = "Dense"
+})(Vt || (Vt = {}));
+var kt;
+(function(e) {
+    e[e.HALF = 0] = "HALF", e[e.SINGLE = 1] = "SINGLE", e[e.DOUBLE = 2] = "DOUBLE"
+})(kt || (kt = {}));
+var ue;
+(function(e) {
+    e[e.DAY = 0] = "DAY", e[e.MILLISECOND = 1] = "MILLISECOND"
+})(ue || (ue = {}));
+var Y;
+(function(e) {
+    e[e.SECOND = 0] = "SECOND", e[e.MILLISECOND = 1] = "MILLISECOND", e[e.MICROSECOND = 2] = "MICROSECOND", e[e.NANOSECOND = 3] = "NANOSECOND"
+})(Y || (Y = {}));
+var xe;
+(function(e) {
+    e[e.YEAR_MONTH = 0] = "YEAR_MONTH", e[e.DAY_TIME = 1] = "DAY_TIME", e[e.MONTH_DAY_NANO = 2] = "MONTH_DAY_NANO"
+})(xe || (xe = {}));
+var nn = new Int32Array(2),
+    Mm = new Float32Array(nn.buffer),
+    Pm = new Float64Array(nn.buffer),
+    Tc = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
+var uf;
+(function(e) {
+    e[e.UTF8_BYTES = 1] = "UTF8_BYTES", e[e.UTF16_STRING = 2] = "UTF16_STRING"
+})(uf || (uf = {}));
+var xr = class e {
+    constructor(t) {
+        this.bytes_ = t, this.position_ = 0, this.text_decoder_ = new TextDecoder
+    }
+    static allocate(t) {
+        return new e(new Uint8Array(t))
+    }
+    clear() {
+        this.position_ = 0
+    }
+    bytes() {
+        return this.bytes_
+    }
+    position() {
+        return this.position_
+    }
+    setPosition(t) {
+        this.position_ = t
+    }
+    capacity() {
+        return this.bytes_.length
+    }
+    readInt8(t) {
+        return this.readUint8(t) << 24 >> 24
+    }
+    readUint8(t) {
+        return this.bytes_[t]
+    }
+    readInt16(t) {
+        return this.readUint16(t) << 16 >> 16
+    }
+    readUint16(t) {
+        return this.bytes_[t] | this.bytes_[t + 1] << 8
+    }
+    readInt32(t) {
+        return this.bytes_[t] | this.bytes_[t + 1] << 8 | this.bytes_[t + 2] << 16 | this.bytes_[t + 3] << 24
+    }
+    readUint32(t) {
+        return this.readInt32(t) >>> 0
+    }
+    readInt64(t) {
+        return BigInt.asIntN(64, BigInt(this.readUint32(t)) + (BigInt(this.readUint32(t + 4)) << BigInt(32)))
+    }
+    readUint64(t) {
+        return BigInt.asUintN(64, BigInt(this.readUint32(t)) + (BigInt(this.readUint32(t + 4)) << BigInt(32)))
+    }
+    readFloat32(t) {
+        return nn[0] = this.readInt32(t), Mm[0]
+    }
+    readFloat64(t) {
+        return nn[Tc ? 0 : 1] = this.readInt32(t), nn[Tc ? 1 : 0] = this.readInt32(t + 4), Pm[0]
+    }
+    writeInt8(t, r) {
+        this.bytes_[t] = r
+    }
+    writeUint8(t, r) {
+        this.bytes_[t] = r
+    }
+    writeInt16(t, r) {
+        this.bytes_[t] = r, this.bytes_[t + 1] = r >> 8
+    }
+    writeUint16(t, r) {
+        this.bytes_[t] = r, this.bytes_[t + 1] = r >> 8
+    }
+    writeInt32(t, r) {
+        this.bytes_[t] = r, this.bytes_[t + 1] = r >> 8, this.bytes_[t + 2] = r >> 16, this.bytes_[t + 3] = r >> 24
+    }
+    writeUint32(t, r) {
+        this.bytes_[t] = r, this.bytes_[t + 1] = r >> 8, this.bytes_[t + 2] = r >> 16, this.bytes_[t + 3] = r >> 24
+    }
+    writeInt64(t, r) {
+        this.writeInt32(t, Number(BigInt.asIntN(32, r))), this.writeInt32(t + 4, Number(BigInt.asIntN(32, r >> BigInt(32))))
+    }
+    writeUint64(t, r) {
+        this.writeUint32(t, Number(BigInt.asUintN(32, r))), this.writeUint32(t + 4, Number(BigInt.asUintN(32, r >> BigInt(32))))
+    }
+    writeFloat32(t, r) {
+        Mm[0] = r, this.writeInt32(t, nn[0])
+    }
+    writeFloat64(t, r) {
+        Pm[0] = r, this.writeInt32(t, nn[Tc ? 0 : 1]), this.writeInt32(t + 4, nn[Tc ? 1 : 0])
+    }
+    getBufferIdentifier() {
+        if (this.bytes_.length < this.position_ + 4 + 4) throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
+        let t = "";
+        for (let r = 0; r < 4; r++) t += String.fromCharCode(this.readInt8(this.position_ + 4 + r));
+        return t
+    }
+    __offset(t, r) {
+        let i = t - this.readInt32(t);
+        return r < this.readInt16(i) ? this.readInt16(i + r) : 0
+    }
+    __union(t, r) {
+        return t.bb_pos = r + this.readInt32(r), t.bb = this, t
+    }
+    __string(t, r) {
+        t += this.readInt32(t);
+        let i = this.readInt32(t);
+        t += 4;
+        let n = this.bytes_.subarray(t, t + i);
+        return r === uf.UTF8_BYTES ? n : this.text_decoder_.decode(n)
+    }
+    __union_with_string(t, r) {
+        return typeof t == "string" ? this.__string(r) : this.__union(t, r)
+    }
+    __indirect(t) {
+        return t + this.readInt32(t)
+    }
+    __vector(t) {
+        return t + this.readInt32(t) + 4
+    }
+    __vector_len(t) {
+        return this.readInt32(t + this.readInt32(t))
+    }
+    __has_identifier(t) {
+        if (t.length != 4) throw new Error("FlatBuffers: file identifier must be length " + 4);
+        for (let r = 0; r < 4; r++)
+            if (t.charCodeAt(r) != this.readInt8(this.position() + 4 + r)) return !1;
+        return !0
+    }
+    createScalarList(t, r) {
+        let i = [];
+        for (let n = 0; n < r; ++n) {
+            let s = t(n);
+            s !== null && i.push(s)
+        }
+        return i
+    }
+    createObjList(t, r) {
+        let i = [];
+        for (let n = 0; n < r; ++n) {
+            let s = t(n);
+            s !== null && i.push(s.unpack())
+        }
+        return i
+    }
+};
+var qo = class e {
+    constructor(t) {
+        this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null, this.text_encoder = new TextEncoder;
+        let r;
+        t ? r = t : r = 1024, this.bb = xr.allocate(r), this.space = r
+    }
+    clear() {
+        this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null
+    }
+    forceDefaults(t) {
+        this.force_defaults = t
+    }
+    dataBuffer() {
+        return this.bb
+    }
+    asUint8Array() {
+        return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset())
+    }
+    prep(t, r) {
+        t > this.minalign && (this.minalign = t);
+        let i = ~(this.bb.capacity() - this.space + r) + 1 & t - 1;
+        for (; this.space < i + t + r;) {
+            let n = this.bb.capacity();
+            this.bb = e.growByteBuffer(this.bb), this.space += this.bb.capacity() - n
+        }
+        this.pad(i)
+    }
+    pad(t) {
+        for (let r = 0; r < t; r++) this.bb.writeInt8(--this.space, 0)
+    }
+    writeInt8(t) {
+        this.bb.writeInt8(this.space -= 1, t)
+    }
+    writeInt16(t) {
+        this.bb.writeInt16(this.space -= 2, t)
+    }
+    writeInt32(t) {
+        this.bb.writeInt32(this.space -= 4, t)
+    }
+    writeInt64(t) {
+        this.bb.writeInt64(this.space -= 8, t)
+    }
+    writeFloat32(t) {
+        this.bb.writeFloat32(this.space -= 4, t)
+    }
+    writeFloat64(t) {
+        this.bb.writeFloat64(this.space -= 8, t)
+    }
+    addInt8(t) {
+        this.prep(1, 0), this.writeInt8(t)
+    }
+    addInt16(t) {
+        this.prep(2, 0), this.writeInt16(t)
+    }
+    addInt32(t) {
+        this.prep(4, 0), this.writeInt32(t)
+    }
+    addInt64(t) {
+        this.prep(8, 0), this.writeInt64(t)
+    }
+    addFloat32(t) {
+        this.prep(4, 0), this.writeFloat32(t)
+    }
+    addFloat64(t) {
+        this.prep(8, 0), this.writeFloat64(t)
+    }
+    addFieldInt8(t, r, i) {
+        (this.force_defaults || r != i) && (this.addInt8(r), this.slot(t))
+    }
+    addFieldInt16(t, r, i) {
+        (this.force_defaults || r != i) && (this.addInt16(r), this.slot(t))
+    }
+    addFieldInt32(t, r, i) {
+        (this.force_defaults || r != i) && (this.addInt32(r), this.slot(t))
+    }
+    addFieldInt64(t, r, i) {
+        (this.force_defaults || r !== i) && (this.addInt64(r), this.slot(t))
+    }
+    addFieldFloat32(t, r, i) {
+        (this.force_defaults || r != i) && (this.addFloat32(r), this.slot(t))
+    }
+    addFieldFloat64(t, r, i) {
+        (this.force_defaults || r != i) && (this.addFloat64(r), this.slot(t))
+    }
+    addFieldOffset(t, r, i) {
+        (this.force_defaults || r != i) && (this.addOffset(r), this.slot(t))
+    }
+    addFieldStruct(t, r, i) {
+        r != i && (this.nested(r), this.slot(t))
+    }
+    nested(t) {
+        if (t != this.offset()) throw new TypeError("FlatBuffers: struct must be serialized inline.")
+    }
+    notNested() {
+        if (this.isNested) throw new TypeError("FlatBuffers: object serialization must not be nested.")
+    }
+    slot(t) {
+        this.vtable !== null && (this.vtable[t] = this.offset())
+    }
+    offset() {
+        return this.bb.capacity() - this.space
+    }
+    static growByteBuffer(t) {
+        let r = t.capacity();
+        if (r & 3221225472) throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
+        let i = r << 1,
+            n = xr.allocate(i);
+        return n.setPosition(i - r), n.bytes().set(t.bytes(), i - r), n
+    }
+    addOffset(t) {
+        this.prep(4, 0), this.writeInt32(this.offset() - t + 4)
+    }
+    startObject(t) {
+        this.notNested(), this.vtable == null && (this.vtable = []), this.vtable_in_use = t;
+        for (let r = 0; r < t; r++) this.vtable[r] = 0;
+        this.isNested = !0, this.object_start = this.offset()
+    }
+    endObject() {
+        if (this.vtable == null || !this.isNested) throw new Error("FlatBuffers: endObject called without startObject");
+        this.addInt32(0);
+        let t = this.offset(),
+            r = this.vtable_in_use - 1;
+        for (; r >= 0 && this.vtable[r] == 0; r--);
+        let i = r + 1;
+        for (; r >= 0; r--) this.addInt16(this.vtable[r] != 0 ? t - this.vtable[r] : 0);
+        let n = 2;
+        this.addInt16(t - this.object_start);
+        let s = (i + n) * 2;
+        this.addInt16(s);
+        let o = 0,
+            a = this.space;
+        t: for (r = 0; r < this.vtables.length; r++) {
+            let c = this.bb.capacity() - this.vtables[r];
+            if (s == this.bb.readInt16(c)) {
+                for (let l = 2; l < s; l += 2)
+                    if (this.bb.readInt16(a + l) != this.bb.readInt16(c + l)) continue t;
+                o = this.vtables[r];
+                break
+            }
+        }
+        return o ? (this.space = this.bb.capacity() - t, this.bb.writeInt32(this.space, o - t)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - t, this.offset() - t)), this.isNested = !1, t
+    }
+    finish(t, r, i) {
+        let n = i ? 4 : 0;
+        if (r) {
+            let s = r;
+            if (this.prep(this.minalign, 8 + n), s.length != 4) throw new TypeError("FlatBuffers: file identifier must be length " + 4);
+            for (let o = 3; o >= 0; o--) this.writeInt8(s.charCodeAt(o))
+        }
+        this.prep(this.minalign, 4 + n), this.addOffset(t), n && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space)
+    }
+    finishSizePrefixed(t, r) {
+        this.finish(t, r, !0)
+    }
+    requiredField(t, r) {
+        let i = this.bb.capacity() - t,
+            n = i - this.bb.readInt32(i);
+        if (!(r < this.bb.readInt16(n) && this.bb.readInt16(n + r) != 0)) throw new TypeError("FlatBuffers: field " + r + " must be set")
+    }
+    startVector(t, r, i) {
+        this.notNested(), this.vector_num_elems = r, this.prep(4, t * r), this.prep(i, t * r)
+    }
+    endVector() {
+        return this.writeInt32(this.vector_num_elems), this.offset()
+    }
+    createSharedString(t) {
+        if (!t) return 0;
+        if (this.string_maps || (this.string_maps = new Map), this.string_maps.has(t)) return this.string_maps.get(t);
+        let r = this.createString(t);
+        return this.string_maps.set(t, r), r
+    }
+    createString(t) {
+        if (t == null) return 0;
+        let r;
+        t instanceof Uint8Array ? r = t : r = this.text_encoder.encode(t), this.addInt8(0), this.startVector(1, r.length, 1), this.bb.setPosition(this.space -= r.length);
+        for (let i = 0, n = this.space, s = this.bb.bytes(); i < r.length; i++) s[n++] = r[i];
+        return this.endVector()
+    }
+    createObjectOffset(t) {
+        return t === null ? 0 : typeof t == "string" ? this.createString(t) : t.pack(this)
+    }
+    createObjectOffsetList(t) {
+        let r = [];
+        for (let i = 0; i < t.length; ++i) {
+            let n = t[i];
+            if (n !== null) r.push(this.createObjectOffset(n));
+            else throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.")
+        }
+        return r
+    }
+    createStructOffsetList(t, r) {
+        return r(this, t.length), this.createObjectOffsetList(t.slice().reverse()), this.endVector()
+    }
+};
+var ff;
+(function(e) {
+    e[e.BUFFER = 0] = "BUFFER"
+})(ff || (ff = {}));
+var hf;
+(function(e) {
+    e[e.LZ4_FRAME = 0] = "LZ4_FRAME", e[e.ZSTD = 1] = "ZSTD"
+})(hf || (hf = {}));
+var Om = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsBodyCompression(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsBodyCompression(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    codec() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt8(this.bb_pos + t) : hf.LZ4_FRAME
+    }
+    method() {
+        let t = this.bb.__offset(this.bb_pos, 6);
+        return t ? this.bb.readInt8(this.bb_pos + t) : ff.BUFFER
+    }
+    static startBodyCompression(t) {
+        t.startObject(2)
+    }
+    static addCodec(t, r) {
+        t.addFieldInt8(0, r, hf.LZ4_FRAME)
+    }
+    static addMethod(t, r) {
+        t.addFieldInt8(1, r, ff.BUFFER)
+    }
+    static endBodyCompression(t) {
+        return t.endObject()
+    }
+    static createBodyCompression(t, r, i) {
+        return e.startBodyCompression(t), e.addCodec(t, r), e.addMethod(t, i), e.endBodyCompression(t)
+    }
+};
+var vc = class {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    offset() {
+        return this.bb.readInt64(this.bb_pos)
+    }
+    length() {
+        return this.bb.readInt64(this.bb_pos + 8)
+    }
+    static sizeOf() {
+        return 16
+    }
+    static createBuffer(t, r, i) {
+        return t.prep(8, 16), t.writeInt64(BigInt(i ?? 0)), t.writeInt64(BigInt(r ?? 0)), t.offset()
+    }
+};
+var Sc = class {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    length() {
+        return this.bb.readInt64(this.bb_pos)
+    }
+    nullCount() {
+        return this.bb.readInt64(this.bb_pos + 8)
+    }
+    static sizeOf() {
+        return 16
+    }
+    static createFieldNode(t, r, i) {
+        return t.prep(8, 16), t.writeInt64(BigInt(i ?? 0)), t.writeInt64(BigInt(r ?? 0)), t.offset()
+    }
+};
+var wr = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsRecordBatch(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsRecordBatch(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    length() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0")
+    }
+    nodes(t, r) {
+        let i = this.bb.__offset(this.bb_pos, 6);
+        return i ? (r || new Sc).__init(this.bb.__vector(this.bb_pos + i) + t * 16, this.bb) : null
+    }
+    nodesLength() {
+        let t = this.bb.__offset(this.bb_pos, 6);
+        return t ? this.bb.__vector_len(this.bb_pos + t) : 0
+    }
+    buffers(t, r) {
+        let i = this.bb.__offset(this.bb_pos, 8);
+        return i ? (r || new vc).__init(this.bb.__vector(this.bb_pos + i) + t * 16, this.bb) : null
+    }
+    buffersLength() {
+        let t = this.bb.__offset(this.bb_pos, 8);
+        return t ? this.bb.__vector_len(this.bb_pos + t) : 0
+    }
+    compression(t) {
+        let r = this.bb.__offset(this.bb_pos, 10);
+        return r ? (t || new Om).__init(this.bb.__indirect(this.bb_pos + r), this.bb) : null
+    }
+    static startRecordBatch(t) {
+        t.startObject(4)
+    }
+    static addLength(t, r) {
+        t.addFieldInt64(0, r, BigInt("0"))
+    }
+    static addNodes(t, r) {
+        t.addFieldOffset(1, r, 0)
+    }
+    static startNodesVector(t, r) {
+        t.startVector(16, r, 8)
+    }
+    static addBuffers(t, r) {
+        t.addFieldOffset(2, r, 0)
+    }
+    static startBuffersVector(t, r) {
+        t.startVector(16, r, 8)
+    }
+    static addCompression(t, r) {
+        t.addFieldOffset(3, r, 0)
+    }
+    static endRecordBatch(t) {
+        return t.endObject()
+    }
+};
+var Nn = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsDictionaryBatch(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsDictionaryBatch(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    id() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0")
+    }
+    data(t) {
+        let r = this.bb.__offset(this.bb_pos, 6);
+        return r ? (t || new wr).__init(this.bb.__indirect(this.bb_pos + r), this.bb) : null
+    }
+    isDelta() {
+        let t = this.bb.__offset(this.bb_pos, 8);
+        return t ? !!this.bb.readInt8(this.bb_pos + t) : !1
+    }
+    static startDictionaryBatch(t) {
+        t.startObject(3)
+    }
+    static addId(t, r) {
+        t.addFieldInt64(0, r, BigInt("0"))
+    }
+    static addData(t, r) {
+        t.addFieldOffset(1, r, 0)
+    }
+    static addIsDelta(t, r) {
+        t.addFieldInt8(2, +r, 0)
+    }
+    static endDictionaryBatch(t) {
+        return t.endObject()
+    }
+};
+var Hs;
+(function(e) {
+    e[e.Little = 0] = "Little", e[e.Big = 1] = "Big"
+})(Hs || (Hs = {}));
+var df;
+(function(e) {
+    e[e.DenseArray = 0] = "DenseArray"
+})(df || (df = {}));
+var mi = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsInt(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsInt(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    bitWidth() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt32(this.bb_pos + t) : 0
+    }
+    isSigned() {
+        let t = this.bb.__offset(this.bb_pos, 6);
+        return t ? !!this.bb.readInt8(this.bb_pos + t) : !1
+    }
+    static startInt(t) {
+        t.startObject(2)
+    }
+    static addBitWidth(t, r) {
+        t.addFieldInt32(0, r, 0)
+    }
+    static addIsSigned(t, r) {
+        t.addFieldInt8(1, +r, 0)
+    }
+    static endInt(t) {
+        return t.endObject()
+    }
+    static createInt(t, r, i) {
+        return e.startInt(t), e.addBitWidth(t, r), e.addIsSigned(t, i), e.endInt(t)
+    }
+};
+var sn = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsDictionaryEncoding(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsDictionaryEncoding(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    id() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0")
+    }
+    indexType(t) {
+        let r = this.bb.__offset(this.bb_pos, 6);
+        return r ? (t || new mi).__init(this.bb.__indirect(this.bb_pos + r), this.bb) : null
+    }
+    isOrdered() {
+        let t = this.bb.__offset(this.bb_pos, 8);
+        return t ? !!this.bb.readInt8(this.bb_pos + t) : !1
+    }
+    dictionaryKind() {
+        let t = this.bb.__offset(this.bb_pos, 10);
+        return t ? this.bb.readInt16(this.bb_pos + t) : df.DenseArray
+    }
+    static startDictionaryEncoding(t) {
+        t.startObject(4)
+    }
+    static addId(t, r) {
+        t.addFieldInt64(0, r, BigInt("0"))
+    }
+    static addIndexType(t, r) {
+        t.addFieldOffset(1, r, 0)
+    }
+    static addIsOrdered(t, r) {
+        t.addFieldInt8(2, +r, 0)
+    }
+    static addDictionaryKind(t, r) {
+        t.addFieldInt16(3, r, df.DenseArray)
+    }
+    static endDictionaryEncoding(t) {
+        return t.endObject()
+    }
+};
+var me = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsKeyValue(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsKeyValue(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    key(t) {
+        let r = this.bb.__offset(this.bb_pos, 4);
+        return r ? this.bb.__string(this.bb_pos + r, t) : null
+    }
+    value(t) {
+        let r = this.bb.__offset(this.bb_pos, 6);
+        return r ? this.bb.__string(this.bb_pos + r, t) : null
+    }
+    static startKeyValue(t) {
+        t.startObject(2)
+    }
+    static addKey(t, r) {
+        t.addFieldOffset(0, r, 0)
+    }
+    static addValue(t, r) {
+        t.addFieldOffset(1, r, 0)
+    }
+    static endKeyValue(t) {
+        return t.endObject()
+    }
+    static createKeyValue(t, r, i) {
+        return e.startKeyValue(t), e.addKey(t, r), e.addValue(t, i), e.endKeyValue(t)
+    }
+};
+var pf = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsBinary(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsBinary(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static startBinary(t) {
+        t.startObject(0)
+    }
+    static endBinary(t) {
+        return t.endObject()
+    }
+    static createBinary(t) {
+        return e.startBinary(t), e.endBinary(t)
+    }
+};
+var mf = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsBool(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsBool(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static startBool(t) {
+        t.startObject(0)
+    }
+    static endBool(t) {
+        return t.endObject()
+    }
+    static createBool(t) {
+        return e.startBool(t), e.endBool(t)
+    }
+};
+var $s = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsDate(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsDate(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    unit() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt16(this.bb_pos + t) : ue.MILLISECOND
+    }
+    static startDate(t) {
+        t.startObject(1)
+    }
+    static addUnit(t, r) {
+        t.addFieldInt16(0, r, ue.MILLISECOND)
+    }
+    static endDate(t) {
+        return t.endObject()
+    }
+    static createDate(t, r) {
+        return e.startDate(t), e.addUnit(t, r), e.endDate(t)
+    }
+};
+var on = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsDecimal(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsDecimal(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    precision() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt32(this.bb_pos + t) : 0
+    }
+    scale() {
+        let t = this.bb.__offset(this.bb_pos, 6);
+        return t ? this.bb.readInt32(this.bb_pos + t) : 0
+    }
+    bitWidth() {
+        let t = this.bb.__offset(this.bb_pos, 8);
+        return t ? this.bb.readInt32(this.bb_pos + t) : 128
+    }
+    static startDecimal(t) {
+        t.startObject(3)
+    }
+    static addPrecision(t, r) {
+        t.addFieldInt32(0, r, 0)
+    }
+    static addScale(t, r) {
+        t.addFieldInt32(1, r, 0)
+    }
+    static addBitWidth(t, r) {
+        t.addFieldInt32(2, r, 128)
+    }
+    static endDecimal(t) {
+        return t.endObject()
+    }
+    static createDecimal(t, r, i, n) {
+        return e.startDecimal(t), e.addPrecision(t, r), e.addScale(t, i), e.addBitWidth(t, n), e.endDecimal(t)
+    }
+};
+var Xs = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsDuration(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsDuration(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    unit() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt16(this.bb_pos + t) : Y.MILLISECOND
+    }
+    static startDuration(t) {
+        t.startObject(1)
+    }
+    static addUnit(t, r) {
+        t.addFieldInt16(0, r, Y.MILLISECOND)
+    }
+    static endDuration(t) {
+        return t.endObject()
+    }
+    static createDuration(t, r) {
+        return e.startDuration(t), e.addUnit(t, r), e.endDuration(t)
+    }
+};
+var Ys = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsFixedSizeBinary(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsFixedSizeBinary(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    byteWidth() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt32(this.bb_pos + t) : 0
+    }
+    static startFixedSizeBinary(t) {
+        t.startObject(1)
+    }
+    static addByteWidth(t, r) {
+        t.addFieldInt32(0, r, 0)
+    }
+    static endFixedSizeBinary(t) {
+        return t.endObject()
+    }
+    static createFixedSizeBinary(t, r) {
+        return e.startFixedSizeBinary(t), e.addByteWidth(t, r), e.endFixedSizeBinary(t)
+    }
+};
+var qs = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsFixedSizeList(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsFixedSizeList(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    listSize() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt32(this.bb_pos + t) : 0
+    }
+    static startFixedSizeList(t) {
+        t.startObject(1)
+    }
+    static addListSize(t, r) {
+        t.addFieldInt32(0, r, 0)
+    }
+    static endFixedSizeList(t) {
+        return t.endObject()
+    }
+    static createFixedSizeList(t, r) {
+        return e.startFixedSizeList(t), e.addListSize(t, r), e.endFixedSizeList(t)
+    }
+};
+var Zs = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsFloatingPoint(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsFloatingPoint(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    precision() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt16(this.bb_pos + t) : kt.HALF
+    }
+    static startFloatingPoint(t) {
+        t.startObject(1)
+    }
+    static addPrecision(t, r) {
+        t.addFieldInt16(0, r, kt.HALF)
+    }
+    static endFloatingPoint(t) {
+        return t.endObject()
+    }
+    static createFloatingPoint(t, r) {
+        return e.startFloatingPoint(t), e.addPrecision(t, r), e.endFloatingPoint(t)
+    }
+};
+var Ks = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsInterval(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsInterval(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    unit() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt16(this.bb_pos + t) : xe.YEAR_MONTH
+    }
+    static startInterval(t) {
+        t.startObject(1)
+    }
+    static addUnit(t, r) {
+        t.addFieldInt16(0, r, xe.YEAR_MONTH)
+    }
+    static endInterval(t) {
+        return t.endObject()
+    }
+    static createInterval(t, r) {
+        return e.startInterval(t), e.addUnit(t, r), e.endInterval(t)
+    }
+};
+var gf = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsLargeBinary(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsLargeBinary(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static startLargeBinary(t) {
+        t.startObject(0)
+    }
+    static endLargeBinary(t) {
+        return t.endObject()
+    }
+    static createLargeBinary(t) {
+        return e.startLargeBinary(t), e.endLargeBinary(t)
+    }
+};
+var _f = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsLargeUtf8(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsLargeUtf8(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static startLargeUtf8(t) {
+        t.startObject(0)
+    }
+    static endLargeUtf8(t) {
+        return t.endObject()
+    }
+    static createLargeUtf8(t) {
+        return e.startLargeUtf8(t), e.endLargeUtf8(t)
+    }
+};
+var yf = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsList(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsList(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static startList(t) {
+        t.startObject(0)
+    }
+    static endList(t) {
+        return t.endObject()
+    }
+    static createList(t) {
+        return e.startList(t), e.endList(t)
+    }
+};
+var Gs = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsMap(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsMap(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    keysSorted() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? !!this.bb.readInt8(this.bb_pos + t) : !1
+    }
+    static startMap(t) {
+        t.startObject(1)
+    }
+    static addKeysSorted(t, r) {
+        t.addFieldInt8(0, +r, 0)
+    }
+    static endMap(t) {
+        return t.endObject()
+    }
+    static createMap(t, r) {
+        return e.startMap(t), e.addKeysSorted(t, r), e.endMap(t)
+    }
+};
+var bf = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsNull(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsNull(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static startNull(t) {
+        t.startObject(0)
+    }
+    static endNull(t) {
+        return t.endObject()
+    }
+    static createNull(t) {
+        return e.startNull(t), e.endNull(t)
+    }
+};
+var xf = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsStruct_(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsStruct_(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static startStruct_(t) {
+        t.startObject(0)
+    }
+    static endStruct_(t) {
+        return t.endObject()
+    }
+    static createStruct_(t) {
+        return e.startStruct_(t), e.endStruct_(t)
+    }
+};
+var Bn = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsTime(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsTime(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    unit() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt16(this.bb_pos + t) : Y.MILLISECOND
+    }
+    bitWidth() {
+        let t = this.bb.__offset(this.bb_pos, 6);
+        return t ? this.bb.readInt32(this.bb_pos + t) : 32
+    }
+    static startTime(t) {
+        t.startObject(2)
+    }
+    static addUnit(t, r) {
+        t.addFieldInt16(0, r, Y.MILLISECOND)
+    }
+    static addBitWidth(t, r) {
+        t.addFieldInt32(1, r, 32)
+    }
+    static endTime(t) {
+        return t.endObject()
+    }
+    static createTime(t, r, i) {
+        return e.startTime(t), e.addUnit(t, r), e.addBitWidth(t, i), e.endTime(t)
+    }
+};
+var Fn = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsTimestamp(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsTimestamp(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    unit() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt16(this.bb_pos + t) : Y.SECOND
+    }
+    timezone(t) {
+        let r = this.bb.__offset(this.bb_pos, 6);
+        return r ? this.bb.__string(this.bb_pos + r, t) : null
+    }
+    static startTimestamp(t) {
+        t.startObject(2)
+    }
+    static addUnit(t, r) {
+        t.addFieldInt16(0, r, Y.SECOND)
+    }
+    static addTimezone(t, r) {
+        t.addFieldOffset(1, r, 0)
+    }
+    static endTimestamp(t) {
+        return t.endObject()
+    }
+    static createTimestamp(t, r, i) {
+        return e.startTimestamp(t), e.addUnit(t, r), e.addTimezone(t, i), e.endTimestamp(t)
+    }
+};
+var gi = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsUnion(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsUnion(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    mode() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt16(this.bb_pos + t) : Vt.Sparse
+    }
+    typeIds(t) {
+        let r = this.bb.__offset(this.bb_pos, 6);
+        return r ? this.bb.readInt32(this.bb.__vector(this.bb_pos + r) + t * 4) : 0
+    }
+    typeIdsLength() {
+        let t = this.bb.__offset(this.bb_pos, 6);
+        return t ? this.bb.__vector_len(this.bb_pos + t) : 0
+    }
+    typeIdsArray() {
+        let t = this.bb.__offset(this.bb_pos, 6);
+        return t ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null
+    }
+    static startUnion(t) {
+        t.startObject(2)
+    }
+    static addMode(t, r) {
+        t.addFieldInt16(0, r, Vt.Sparse)
+    }
+    static addTypeIds(t, r) {
+        t.addFieldOffset(1, r, 0)
+    }
+    static createTypeIdsVector(t, r) {
+        t.startVector(4, r.length, 4);
+        for (let i = r.length - 1; i >= 0; i--) t.addInt32(r[i]);
+        return t.endVector()
+    }
+    static startTypeIdsVector(t, r) {
+        t.startVector(4, r, 4)
+    }
+    static endUnion(t) {
+        return t.endObject()
+    }
+    static createUnion(t, r, i) {
+        return e.startUnion(t), e.addMode(t, r), e.addTypeIds(t, i), e.endUnion(t)
+    }
+};
+var wf = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsUtf8(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsUtf8(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static startUtf8(t) {
+        t.startObject(0)
+    }
+    static endUtf8(t) {
+        return t.endObject()
+    }
+    static createUtf8(t) {
+        return e.startUtf8(t), e.endUtf8(t)
+    }
+};
+var Ut;
+(function(e) {
+    e[e.NONE = 0] = "NONE", e[e.Null = 1] = "Null", e[e.Int = 2] = "Int", e[e.FloatingPoint = 3] = "FloatingPoint", e[e.Binary = 4] = "Binary", e[e.Utf8 = 5] = "Utf8", e[e.Bool = 6] = "Bool", e[e.Decimal = 7] = "Decimal", e[e.Date = 8] = "Date", e[e.Time = 9] = "Time", e[e.Timestamp = 10] = "Timestamp", e[e.Interval = 11] = "Interval", e[e.List = 12] = "List", e[e.Struct_ = 13] = "Struct_", e[e.Union = 14] = "Union", e[e.FixedSizeBinary = 15] = "FixedSizeBinary", e[e.FixedSizeList = 16] = "FixedSizeList", e[e.Map = 17] = "Map", e[e.Duration = 18] = "Duration", e[e.LargeBinary = 19] = "LargeBinary", e[e.LargeUtf8 = 20] = "LargeUtf8", e[e.LargeList = 21] = "LargeList", e[e.RunEndEncoded = 22] = "RunEndEncoded"
+})(Ut || (Ut = {}));
+var Oe = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsField(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsField(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    name(t) {
+        let r = this.bb.__offset(this.bb_pos, 4);
+        return r ? this.bb.__string(this.bb_pos + r, t) : null
+    }
+    nullable() {
+        let t = this.bb.__offset(this.bb_pos, 6);
+        return t ? !!this.bb.readInt8(this.bb_pos + t) : !1
+    }
+    typeType() {
+        let t = this.bb.__offset(this.bb_pos, 8);
+        return t ? this.bb.readUint8(this.bb_pos + t) : Ut.NONE
+    }
+    type(t) {
+        let r = this.bb.__offset(this.bb_pos, 10);
+        return r ? this.bb.__union(t, this.bb_pos + r) : null
+    }
+    dictionary(t) {
+        let r = this.bb.__offset(this.bb_pos, 12);
+        return r ? (t || new sn).__init(this.bb.__indirect(this.bb_pos + r), this.bb) : null
+    }
+    children(t, r) {
+        let i = this.bb.__offset(this.bb_pos, 14);
+        return i ? (r || new e).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null
+    }
+    childrenLength() {
+        let t = this.bb.__offset(this.bb_pos, 14);
+        return t ? this.bb.__vector_len(this.bb_pos + t) : 0
+    }
+    customMetadata(t, r) {
+        let i = this.bb.__offset(this.bb_pos, 16);
+        return i ? (r || new me).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null
+    }
+    customMetadataLength() {
+        let t = this.bb.__offset(this.bb_pos, 16);
+        return t ? this.bb.__vector_len(this.bb_pos + t) : 0
+    }
+    static startField(t) {
+        t.startObject(7)
+    }
+    static addName(t, r) {
+        t.addFieldOffset(0, r, 0)
+    }
+    static addNullable(t, r) {
+        t.addFieldInt8(1, +r, 0)
+    }
+    static addTypeType(t, r) {
+        t.addFieldInt8(2, r, Ut.NONE)
+    }
+    static addType(t, r) {
+        t.addFieldOffset(3, r, 0)
+    }
+    static addDictionary(t, r) {
+        t.addFieldOffset(4, r, 0)
+    }
+    static addChildren(t, r) {
+        t.addFieldOffset(5, r, 0)
+    }
+    static createChildrenVector(t, r) {
+        t.startVector(4, r.length, 4);
+        for (let i = r.length - 1; i >= 0; i--) t.addOffset(r[i]);
+        return t.endVector()
+    }
+    static startChildrenVector(t, r) {
+        t.startVector(4, r, 4)
+    }
+    static addCustomMetadata(t, r) {
+        t.addFieldOffset(6, r, 0)
+    }
+    static createCustomMetadataVector(t, r) {
+        t.startVector(4, r.length, 4);
+        for (let i = r.length - 1; i >= 0; i--) t.addOffset(r[i]);
+        return t.endVector()
+    }
+    static startCustomMetadataVector(t, r) {
+        t.startVector(4, r, 4)
+    }
+    static endField(t) {
+        return t.endObject()
+    }
+};
+var sr = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsSchema(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsSchema(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    endianness() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt16(this.bb_pos + t) : Hs.Little
+    }
+    fields(t, r) {
+        let i = this.bb.__offset(this.bb_pos, 6);
+        return i ? (r || new Oe).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null
+    }
+    fieldsLength() {
+        let t = this.bb.__offset(this.bb_pos, 6);
+        return t ? this.bb.__vector_len(this.bb_pos + t) : 0
+    }
+    customMetadata(t, r) {
+        let i = this.bb.__offset(this.bb_pos, 8);
+        return i ? (r || new me).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null
+    }
+    customMetadataLength() {
+        let t = this.bb.__offset(this.bb_pos, 8);
+        return t ? this.bb.__vector_len(this.bb_pos + t) : 0
+    }
+    features(t) {
+        let r = this.bb.__offset(this.bb_pos, 10);
+        return r ? this.bb.readInt64(this.bb.__vector(this.bb_pos + r) + t * 8) : BigInt(0)
+    }
+    featuresLength() {
+        let t = this.bb.__offset(this.bb_pos, 10);
+        return t ? this.bb.__vector_len(this.bb_pos + t) : 0
+    }
+    static startSchema(t) {
+        t.startObject(4)
+    }
+    static addEndianness(t, r) {
+        t.addFieldInt16(0, r, Hs.Little)
+    }
+    static addFields(t, r) {
+        t.addFieldOffset(1, r, 0)
+    }
+    static createFieldsVector(t, r) {
+        t.startVector(4, r.length, 4);
+        for (let i = r.length - 1; i >= 0; i--) t.addOffset(r[i]);
+        return t.endVector()
+    }
+    static startFieldsVector(t, r) {
+        t.startVector(4, r, 4)
+    }
+    static addCustomMetadata(t, r) {
+        t.addFieldOffset(2, r, 0)
+    }
+    static createCustomMetadataVector(t, r) {
+        t.startVector(4, r.length, 4);
+        for (let i = r.length - 1; i >= 0; i--) t.addOffset(r[i]);
+        return t.endVector()
+    }
+    static startCustomMetadataVector(t, r) {
+        t.startVector(4, r, 4)
+    }
+    static addFeatures(t, r) {
+        t.addFieldOffset(3, r, 0)
+    }
+    static createFeaturesVector(t, r) {
+        t.startVector(8, r.length, 8);
+        for (let i = r.length - 1; i >= 0; i--) t.addInt64(r[i]);
+        return t.endVector()
+    }
+    static startFeaturesVector(t, r) {
+        t.startVector(8, r, 8)
+    }
+    static endSchema(t) {
+        return t.endObject()
+    }
+    static finishSchemaBuffer(t, r) {
+        t.finish(r)
+    }
+    static finishSizePrefixedSchemaBuffer(t, r) {
+        t.finish(r, void 0, !0)
+    }
+    static createSchema(t, r, i, n, s) {
+        return e.startSchema(t), e.addEndianness(t, r), e.addFields(t, i), e.addCustomMetadata(t, n), e.addFeatures(t, s), e.endSchema(t)
+    }
+};
+var vt;
+(function(e) {
+    e[e.NONE = 0] = "NONE", e[e.Schema = 1] = "Schema", e[e.DictionaryBatch = 2] = "DictionaryBatch", e[e.RecordBatch = 3] = "RecordBatch", e[e.Tensor = 4] = "Tensor", e[e.SparseTensor = 5] = "SparseTensor"
+})(vt || (vt = {}));
+var v;
+(function(e) {
+    e[e.NONE = 0] = "NONE", e[e.Null = 1] = "Null", e[e.Int = 2] = "Int", e[e.Float = 3] = "Float", e[e.Binary = 4] = "Binary", e[e.Utf8 = 5] = "Utf8", e[e.Bool = 6] = "Bool", e[e.Decimal = 7] = "Decimal", e[e.Date = 8] = "Date", e[e.Time = 9] = "Time", e[e.Timestamp = 10] = "Timestamp", e[e.Interval = 11] = "Interval", e[e.List = 12] = "List", e[e.Struct = 13] = "Struct", e[e.Union = 14] = "Union", e[e.FixedSizeBinary = 15] = "FixedSizeBinary", e[e.FixedSizeList = 16] = "FixedSizeList", e[e.Map = 17] = "Map", e[e.Duration = 18] = "Duration", e[e.LargeBinary = 19] = "LargeBinary", e[e.LargeUtf8 = 20] = "LargeUtf8", e[e.Dictionary = -1] = "Dictionary", e[e.Int8 = -2] = "Int8", e[e.Int16 = -3] = "Int16", e[e.Int32 = -4] = "Int32", e[e.Int64 = -5] = "Int64", e[e.Uint8 = -6] = "Uint8", e[e.Uint16 = -7] = "Uint16", e[e.Uint32 = -8] = "Uint32", e[e.Uint64 = -9] = "Uint64", e[e.Float16 = -10] = "Float16", e[e.Float32 = -11] = "Float32", e[e.Float64 = -12] = "Float64", e[e.DateDay = -13] = "DateDay", e[e.DateMillisecond = -14] = "DateMillisecond", e[e.TimestampSecond = -15] = "TimestampSecond", e[e.TimestampMillisecond = -16] = "TimestampMillisecond", e[e.TimestampMicrosecond = -17] = "TimestampMicrosecond", e[e.TimestampNanosecond = -18] = "TimestampNanosecond", e[e.TimeSecond = -19] = "TimeSecond", e[e.TimeMillisecond = -20] = "TimeMillisecond", e[e.TimeMicrosecond = -21] = "TimeMicrosecond", e[e.TimeNanosecond = -22] = "TimeNanosecond", e[e.DenseUnion = -23] = "DenseUnion", e[e.SparseUnion = -24] = "SparseUnion", e[e.IntervalDayTime = -25] = "IntervalDayTime", e[e.IntervalYearMonth = -26] = "IntervalYearMonth", e[e.DurationSecond = -27] = "DurationSecond", e[e.DurationMillisecond = -28] = "DurationMillisecond", e[e.DurationMicrosecond = -29] = "DurationMicrosecond", e[e.DurationNanosecond = -30] = "DurationNanosecond"
+})(v || (v = {}));
+var _i;
+(function(e) {
+    e[e.OFFSET = 0] = "OFFSET", e[e.DATA = 1] = "DATA", e[e.VALIDITY = 2] = "VALIDITY", e[e.TYPE = 3] = "TYPE"
+})(_i || (_i = {}));
+var cw = {};
+Ze(cw, {
+    clampIndex: () => U8,
+    clampRange: () => Af,
+    createElementComparator: () => to
+});
+var Hx = {};
+Ze(Hx, {
+    valueToString: () => yi
+});
+
+function yi(e) {
+    if (e === null) return "null";
+    if (e === void 0) return "undefined";
+    switch (typeof e) {
+        case "number":
+            return `${e}`;
+        case "bigint":
+            return `${e}`;
+        case "string":
+            return `"${e}"`
+    }
+    return typeof e[Symbol.toPrimitive] == "function" ? e[Symbol.toPrimitive]("string") : ArrayBuffer.isView(e) ? e instanceof BigInt64Array || e instanceof BigUint64Array ? `[${[...e].map(t=>yi(t))}]` : `[${e}]` : ArrayBuffer.isView(e) ? `[${e}]` : JSON.stringify(e, (t, r) => typeof r == "bigint" ? `${r}` : r)
+}
+var Xx = {};
+Ze(Xx, {
+    BN: () => vf,
+    bigNumToBigInt: () => GR,
+    bigNumToString: () => Ic,
+    isArrowBigNumSymbol: () => ZR
+});
+var ZR = Symbol.for("isArrowBigNum");
+
+function bi(e, ...t) {
+    return t.length === 0 ? Object.setPrototypeOf(yt(this.TypedArray, e), this.constructor.prototype) : Object.setPrototypeOf(new this.TypedArray(e, ...t), this.constructor.prototype)
+}
+bi.prototype[ZR] = !0;
+bi.prototype.toJSON = function() {
+    return `"${Ic(this)}"`
+};
+bi.prototype.valueOf = function() {
+    return KR(this)
+};
+bi.prototype.toString = function() {
+    return Ic(this)
+};
+bi.prototype[Symbol.toPrimitive] = function(e = "default") {
+    switch (e) {
+        case "number":
+            return KR(this);
+        case "string":
+            return Ic(this);
+        case "default":
+            return GR(this)
+    }
+    return Ic(this)
+};
+
+function Ac(...e) {
+    return bi.apply(this, e)
+}
+
+function Ec(...e) {
+    return bi.apply(this, e)
+}
+
+function Tf(...e) {
+    return bi.apply(this, e)
+}
+Object.setPrototypeOf(Ac.prototype, Object.create(Int32Array.prototype));
+Object.setPrototypeOf(Ec.prototype, Object.create(Uint32Array.prototype));
+Object.setPrototypeOf(Tf.prototype, Object.create(Uint32Array.prototype));
+Object.assign(Ac.prototype, bi.prototype, {
+    constructor: Ac,
+    signed: !0,
+    TypedArray: Int32Array,
+    BigIntArray: BigInt64Array
+});
+Object.assign(Ec.prototype, bi.prototype, {
+    constructor: Ec,
+    signed: !1,
+    TypedArray: Uint32Array,
+    BigIntArray: BigUint64Array
+});
+Object.assign(Tf.prototype, bi.prototype, {
+    constructor: Tf,
+    signed: !0,
+    TypedArray: Uint32Array,
+    BigIntArray: BigUint64Array
+});
+
+function KR(e) {
+    let {
+        buffer: t,
+        byteOffset: r,
+        length: i,
+        signed: n
+    } = e, s = new BigUint64Array(t, r, i), o = n && s.at(-1) & BigInt(1) << BigInt(63), a = BigInt(o ? 1 : 0), c = BigInt(0);
+    if (o) {
+        for (let l of s) a += ~l * (BigInt(1) << BigInt(32) * c++);
+        a *= BigInt(-1)
+    } else
+        for (let l of s) a += l * (BigInt(1) << BigInt(32) * c++);
+    return a
+}
+var Ic = e => {
+        if (e.byteLength === 8) return `${new e.BigIntArray(e.buffer,e.byteOffset,1)[0]}`;
+        if (!e.signed) return $x(e);
+        let t = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2);
+        if (new Int16Array([t.at(-1)])[0] >= 0) return $x(e);
+        t = t.slice();
+        let i = 1;
+        for (let s = 0; s < t.length; s++) {
+            let o = t[s],
+                a = ~o + i;
+            t[s] = a, i &= o === 0 ? 1 : 0
+        }
+        return `-${$x(t)}`
+    },
+    GR = e => e.byteLength === 8 ? new e.BigIntArray(e.buffer, e.byteOffset, 1)[0] : Ic(e);
+
+function $x(e) {
+    let t = "",
+        r = new Uint32Array(2),
+        i = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2),
+        n = new Uint32Array((i = new Uint16Array(i).reverse()).buffer),
+        s = -1,
+        o = i.length - 1;
+    do {
+        for (r[0] = i[s = 0]; s < o;) i[s++] = r[1] = r[0] / 10, r[0] = (r[0] - r[1] * 10 << 16) + i[s];
+        i[s] = r[1] = r[0] / 10, r[0] = r[0] - r[1] * 10, t = `${r[0]}${t}`
+    } while (n[0] || n[1] || n[2] || n[3]);
+    return t ?? "0"
+}
+var vf = class e {
+    static new(t, r) {
+        switch (r) {
+            case !0:
+                return new Ac(t);
+            case !1:
+                return new Ec(t)
+        }
+        switch (t.constructor) {
+            case Int8Array:
+            case Int16Array:
+            case Int32Array:
+            case BigInt64Array:
+                return new Ac(t)
+        }
+        return t.byteLength === 16 ? new Tf(t) : new Ec(t)
+    }
+    static signed(t) {
+        return new Ac(t)
+    }
+    static unsigned(t) {
+        return new Ec(t)
+    }
+    static decimal(t) {
+        return new Tf(t)
+    }
+    constructor(t, r) {
+        return e.new(t, r)
+    }
+};
+
+function Kt(e) {
+    if (typeof e == "bigint" && (e < Number.MIN_SAFE_INTEGER || e > Number.MAX_SAFE_INTEGER)) throw new TypeError(`${e} is not safe to convert to a number.`);
+    return Number(e)
+}
+var JR, QR, tM, eM, rM, iM, nM, sM, oM, aM, cM, lM, uM, fM, hM, dM, pM, mM, gM, _M, yM, bM, X = class e {
+    static isNull(t) {
+        return t?.typeId === v.Null
+    }
+    static isInt(t) {
+        return t?.typeId === v.Int
+    }
+    static isFloat(t) {
+        return t?.typeId === v.Float
+    }
+    static isBinary(t) {
+        return t?.typeId === v.Binary
+    }
+    static isLargeBinary(t) {
+        return t?.typeId === v.LargeBinary
+    }
+    static isUtf8(t) {
+        return t?.typeId === v.Utf8
+    }
+    static isLargeUtf8(t) {
+        return t?.typeId === v.LargeUtf8
+    }
+    static isBool(t) {
+        return t?.typeId === v.Bool
+    }
+    static isDecimal(t) {
+        return t?.typeId === v.Decimal
+    }
+    static isDate(t) {
+        return t?.typeId === v.Date
+    }
+    static isTime(t) {
+        return t?.typeId === v.Time
+    }
+    static isTimestamp(t) {
+        return t?.typeId === v.Timestamp
+    }
+    static isInterval(t) {
+        return t?.typeId === v.Interval
+    }
+    static isDuration(t) {
+        return t?.typeId === v.Duration
+    }
+    static isList(t) {
+        return t?.typeId === v.List
+    }
+    static isStruct(t) {
+        return t?.typeId === v.Struct
+    }
+    static isUnion(t) {
+        return t?.typeId === v.Union
+    }
+    static isFixedSizeBinary(t) {
+        return t?.typeId === v.FixedSizeBinary
+    }
+    static isFixedSizeList(t) {
+        return t?.typeId === v.FixedSizeList
+    }
+    static isMap(t) {
+        return t?.typeId === v.Map
+    }
+    static isDictionary(t) {
+        return t?.typeId === v.Dictionary
+    }
+    static isDenseUnion(t) {
+        return e.isUnion(t) && t.mode === Vt.Dense
+    }
+    static isSparseUnion(t) {
+        return e.isUnion(t) && t.mode === Vt.Sparse
+    }
+    constructor(t) {
+        this.typeId = t
+    }
+};
+JR = Symbol.toStringTag;
+X[JR] = (e => (e.children = null, e.ArrayType = Array, e.OffsetArrayType = Int32Array, e[Symbol.toStringTag] = "DataType"))(X.prototype);
+var He = class extends X {
+    constructor() {
+        super(v.Null)
+    }
+    toString() {
+        return "Null"
+    }
+};
+QR = Symbol.toStringTag;
+He[QR] = (e => e[Symbol.toStringTag] = "Null")(He.prototype);
+var se = class extends X {
+    constructor(t, r) {
+        super(v.Int), this.isSigned = t, this.bitWidth = r
+    }
+    get ArrayType() {
+        switch (this.bitWidth) {
+            case 8:
+                return this.isSigned ? Int8Array : Uint8Array;
+            case 16:
+                return this.isSigned ? Int16Array : Uint16Array;
+            case 32:
+                return this.isSigned ? Int32Array : Uint32Array;
+            case 64:
+                return this.isSigned ? BigInt64Array : BigUint64Array
+        }
+        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`)
+    }
+    toString() {
+        return `${this.isSigned?"I":"Ui"}nt${this.bitWidth}`
+    }
+};
+tM = Symbol.toStringTag;
+se[tM] = (e => (e.isSigned = null, e.bitWidth = null, e[Symbol.toStringTag] = "Int"))(se.prototype);
+var Nm = class extends se {
+        constructor() {
+            super(!0, 8)
+        }
+        get ArrayType() {
+            return Int8Array
+        }
+    },
+    Bm = class extends se {
+        constructor() {
+            super(!0, 16)
+        }
+        get ArrayType() {
+            return Int16Array
+        }
+    },
+    an = class extends se {
+        constructor() {
+            super(!0, 32)
+        }
+        get ArrayType() {
+            return Int32Array
+        }
+    },
+    Fm = class extends se {
+        constructor() {
+            super(!0, 64)
+        }
+        get ArrayType() {
+            return BigInt64Array
+        }
+    },
+    Dm = class extends se {
+        constructor() {
+            super(!1, 8)
+        }
+        get ArrayType() {
+            return Uint8Array
+        }
+    },
+    Lm = class extends se {
+        constructor() {
+            super(!1, 16)
+        }
+        get ArrayType() {
+            return Uint16Array
+        }
+    },
+    km = class extends se {
+        constructor() {
+            super(!1, 32)
+        }
+        get ArrayType() {
+            return Uint32Array
+        }
+    },
+    Um = class extends se {
+        constructor() {
+            super(!1, 64)
+        }
+        get ArrayType() {
+            return BigUint64Array
+        }
+    };
+Object.defineProperty(Nm.prototype, "ArrayType", {
+    value: Int8Array
+});
+Object.defineProperty(Bm.prototype, "ArrayType", {
+    value: Int16Array
+});
+Object.defineProperty(an.prototype, "ArrayType", {
+    value: Int32Array
+});
+Object.defineProperty(Fm.prototype, "ArrayType", {
+    value: BigInt64Array
+});
+Object.defineProperty(Dm.prototype, "ArrayType", {
+    value: Uint8Array
+});
+Object.defineProperty(Lm.prototype, "ArrayType", {
+    value: Uint16Array
+});
+Object.defineProperty(km.prototype, "ArrayType", {
+    value: Uint32Array
+});
+Object.defineProperty(Um.prototype, "ArrayType", {
+    value: BigUint64Array
+});
+var or = class extends X {
+    constructor(t) {
+        super(v.Float), this.precision = t
+    }
+    get ArrayType() {
+        switch (this.precision) {
+            case kt.HALF:
+                return Uint16Array;
+            case kt.SINGLE:
+                return Float32Array;
+            case kt.DOUBLE:
+                return Float64Array
+        }
+        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`)
+    }
+    toString() {
+        return `Float${this.precision<<5||16}`
+    }
+};
+eM = Symbol.toStringTag;
+or[eM] = (e => (e.precision = null, e[Symbol.toStringTag] = "Float"))(or.prototype);
+var Vm = class extends or {
+        constructor() {
+            super(kt.HALF)
+        }
+    },
+    zm = class extends or {
+        constructor() {
+            super(kt.SINGLE)
+        }
+    },
+    Wm = class extends or {
+        constructor() {
+            super(kt.DOUBLE)
+        }
+    };
+Object.defineProperty(Vm.prototype, "ArrayType", {
+    value: Uint16Array
+});
+Object.defineProperty(zm.prototype, "ArrayType", {
+    value: Float32Array
+});
+Object.defineProperty(Wm.prototype, "ArrayType", {
+    value: Float64Array
+});
+var Dn = class extends X {
+    constructor() {
+        super(v.Binary)
+    }
+    toString() {
+        return "Binary"
+    }
+};
+rM = Symbol.toStringTag;
+Dn[rM] = (e => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Binary"))(Dn.prototype);
+var Ln = class extends X {
+    constructor() {
+        super(v.LargeBinary)
+    }
+    toString() {
+        return "LargeBinary"
+    }
+};
+iM = Symbol.toStringTag;
+Ln[iM] = (e => (e.ArrayType = Uint8Array, e.OffsetArrayType = BigInt64Array, e[Symbol.toStringTag] = "LargeBinary"))(Ln.prototype);
+var kn = class extends X {
+    constructor() {
+        super(v.Utf8)
+    }
+    toString() {
+        return "Utf8"
+    }
+};
+nM = Symbol.toStringTag;
+kn[nM] = (e => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Utf8"))(kn.prototype);
+var Un = class extends X {
+    constructor() {
+        super(v.LargeUtf8)
+    }
+    toString() {
+        return "LargeUtf8"
+    }
+};
+sM = Symbol.toStringTag;
+Un[sM] = (e => (e.ArrayType = Uint8Array, e.OffsetArrayType = BigInt64Array, e[Symbol.toStringTag] = "LargeUtf8"))(Un.prototype);
+var Vn = class extends X {
+    constructor() {
+        super(v.Bool)
+    }
+    toString() {
+        return "Bool"
+    }
+};
+oM = Symbol.toStringTag;
+Vn[oM] = (e => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Bool"))(Vn.prototype);
+var zn = class extends X {
+    constructor(t, r, i = 128) {
+        super(v.Decimal), this.scale = t, this.precision = r, this.bitWidth = i
+    }
+    toString() {
+        return `Decimal[${this.precision}e${this.scale>0?"+":""}${this.scale}]`
+    }
+};
+aM = Symbol.toStringTag;
+zn[aM] = (e => (e.scale = null, e.precision = null, e.ArrayType = Uint32Array, e[Symbol.toStringTag] = "Decimal"))(zn.prototype);
+var Wn = class extends X {
+    constructor(t) {
+        super(v.Date), this.unit = t
+    }
+    toString() {
+        return `Date${(this.unit+1)*32}<${ue[this.unit]}>`
+    }
+};
+cM = Symbol.toStringTag;
+Wn[cM] = (e => (e.unit = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Date"))(Wn.prototype);
+var xi = class extends X {
+    constructor(t, r) {
+        super(v.Time), this.unit = t, this.bitWidth = r
+    }
+    toString() {
+        return `Time${this.bitWidth}<${Y[this.unit]}>`
+    }
+    get ArrayType() {
+        switch (this.bitWidth) {
+            case 32:
+                return Int32Array;
+            case 64:
+                return BigInt64Array
+        }
+        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`)
+    }
+};
+lM = Symbol.toStringTag;
+xi[lM] = (e => (e.unit = null, e.bitWidth = null, e[Symbol.toStringTag] = "Time"))(xi.prototype);
+var jn = class extends X {
+    constructor(t, r) {
+        super(v.Timestamp), this.unit = t, this.timezone = r
+    }
+    toString() {
+        return `Timestamp<${Y[this.unit]}${this.timezone?`, ${this.timezone}`:""}>`
+    }
+};
+uM = Symbol.toStringTag;
+jn[uM] = (e => (e.unit = null, e.timezone = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Timestamp"))(jn.prototype);
+var Hn = class extends X {
+    constructor(t) {
+        super(v.Interval), this.unit = t
+    }
+    toString() {
+        return `Interval<${xe[this.unit]}>`
+    }
+};
+fM = Symbol.toStringTag;
+Hn[fM] = (e => (e.unit = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Interval"))(Hn.prototype);
+var $n = class extends X {
+    constructor(t) {
+        super(v.Duration), this.unit = t
+    }
+    toString() {
+        return `Duration<${Y[this.unit]}>`
+    }
+};
+hM = Symbol.toStringTag;
+$n[hM] = (e => (e.unit = null, e.ArrayType = BigInt64Array, e[Symbol.toStringTag] = "Duration"))($n.prototype);
+var wi = class extends X {
+    constructor(t) {
+        super(v.List), this.children = [t]
+    }
+    toString() {
+        return `List<${this.valueType}>`
+    }
+    get valueType() {
+        return this.children[0].type
+    }
+    get valueField() {
+        return this.children[0]
+    }
+    get ArrayType() {
+        return this.valueType.ArrayType
+    }
+};
+dM = Symbol.toStringTag;
+wi[dM] = (e => (e.children = null, e[Symbol.toStringTag] = "List"))(wi.prototype);
+var zt = class extends X {
+    constructor(t) {
+        super(v.Struct), this.children = t
+    }
+    toString() {
+        return `Struct<{${this.children.map(t=>`${t.name}:${t.type}`).join(", ")}}>`
+    }
+};
+pM = Symbol.toStringTag;
+zt[pM] = (e => (e.children = null, e[Symbol.toStringTag] = "Struct"))(zt.prototype);
+var Ti = class extends X {
+    constructor(t, r, i) {
+        super(v.Union), this.mode = t, this.children = i, this.typeIds = r = Int32Array.from(r), this.typeIdToChildIndex = r.reduce((n, s, o) => (n[s] = o) && n || n, Object.create(null))
+    }
+    toString() {
+        return `${this[Symbol.toStringTag]}<${this.children.map(t=>`${t.type}`).join(" | ")}>`
+    }
+};
+mM = Symbol.toStringTag;
+Ti[mM] = (e => (e.mode = null, e.typeIds = null, e.children = null, e.typeIdToChildIndex = null, e.ArrayType = Int8Array, e[Symbol.toStringTag] = "Union"))(Ti.prototype);
+var Xn = class extends X {
+    constructor(t) {
+        super(v.FixedSizeBinary), this.byteWidth = t
+    }
+    toString() {
+        return `FixedSizeBinary[${this.byteWidth}]`
+    }
+};
+gM = Symbol.toStringTag;
+Xn[gM] = (e => (e.byteWidth = null, e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "FixedSizeBinary"))(Xn.prototype);
+var vi = class extends X {
+    constructor(t, r) {
+        super(v.FixedSizeList), this.listSize = t, this.children = [r]
+    }
+    get valueType() {
+        return this.children[0].type
+    }
+    get valueField() {
+        return this.children[0]
+    }
+    get ArrayType() {
+        return this.valueType.ArrayType
+    }
+    toString() {
+        return `FixedSizeList[${this.listSize}]<${this.valueType}>`
+    }
+};
+_M = Symbol.toStringTag;
+vi[_M] = (e => (e.children = null, e.listSize = null, e[Symbol.toStringTag] = "FixedSizeList"))(vi.prototype);
+var Si = class extends X {
+    constructor(t, r = !1) {
+        var i, n, s;
+        if (super(v.Map), this.children = [t], this.keysSorted = r, t && (t.name = "entries", !((i = t?.type) === null || i === void 0) && i.children)) {
+            let o = (n = t?.type) === null || n === void 0 ? void 0 : n.children[0];
+            o && (o.name = "key");
+            let a = (s = t?.type) === null || s === void 0 ? void 0 : s.children[1];
+            a && (a.name = "value")
+        }
+    }
+    get keyType() {
+        return this.children[0].type.children[0].type
+    }
+    get valueType() {
+        return this.children[0].type.children[1].type
+    }
+    get childType() {
+        return this.children[0].type
+    }
+    toString() {
+        return `Map<{${this.children[0].type.children.map(t=>`${t.name}:${t.type}`).join(", ")}}>`
+    }
+};
+yM = Symbol.toStringTag;
+Si[yM] = (e => (e.children = null, e.keysSorted = null, e[Symbol.toStringTag] = "Map_"))(Si.prototype);
+var Q6 = (e => () => ++e)(-1),
+    Tr = class extends X {
+        constructor(t, r, i, n) {
+            super(v.Dictionary), this.indices = r, this.dictionary = t, this.isOrdered = n || !1, this.id = i == null ? Q6() : Kt(i)
+        }
+        get children() {
+            return this.dictionary.children
+        }
+        get valueType() {
+            return this.dictionary
+        }
+        get ArrayType() {
+            return this.dictionary.ArrayType
+        }
+        toString() {
+            return `Dictionary<${this.indices}, ${this.dictionary}>`
+        }
+    };
+bM = Symbol.toStringTag;
+Tr[bM] = (e => (e.id = null, e.indices = null, e.isOrdered = null, e.dictionary = null, e[Symbol.toStringTag] = "Dictionary"))(Tr.prototype);
+
+function vr(e) {
+    let t = e;
+    switch (e.typeId) {
+        case v.Decimal:
+            return e.bitWidth / 32;
+        case v.Timestamp:
+            return 2;
+        case v.Date:
+            return 1 + t.unit;
+        case v.Interval:
+            return 1 + t.unit;
+        case v.FixedSizeList:
+            return t.listSize;
+        case v.FixedSizeBinary:
+            return t.byteWidth;
+        default:
+            return 1
+    }
+}
+var J = class {
+    visitMany(t, ...r) {
+        return t.map((i, n) => this.visit(i, ...r.map(s => s[n])))
+    }
+    visit(...t) {
+        return this.getVisitFn(t[0], !1).apply(this, t)
+    }
+    getVisitFn(t, r = !0) {
+        return t8(this, t, r)
+    }
+    getVisitFnByTypeId(t, r = !0) {
+        return Rc(this, t, r)
+    }
+    visitNull(t, ...r) {
+        return null
+    }
+    visitBool(t, ...r) {
+        return null
+    }
+    visitInt(t, ...r) {
+        return null
+    }
+    visitFloat(t, ...r) {
+        return null
+    }
+    visitUtf8(t, ...r) {
+        return null
+    }
+    visitLargeUtf8(t, ...r) {
+        return null
+    }
+    visitBinary(t, ...r) {
+        return null
+    }
+    visitLargeBinary(t, ...r) {
+        return null
+    }
+    visitFixedSizeBinary(t, ...r) {
+        return null
+    }
+    visitDate(t, ...r) {
+        return null
+    }
+    visitTimestamp(t, ...r) {
+        return null
+    }
+    visitTime(t, ...r) {
+        return null
+    }
+    visitDecimal(t, ...r) {
+        return null
+    }
+    visitList(t, ...r) {
+        return null
+    }
+    visitStruct(t, ...r) {
+        return null
+    }
+    visitUnion(t, ...r) {
+        return null
+    }
+    visitDictionary(t, ...r) {
+        return null
+    }
+    visitInterval(t, ...r) {
+        return null
+    }
+    visitDuration(t, ...r) {
+        return null
+    }
+    visitFixedSizeList(t, ...r) {
+        return null
+    }
+    visitMap(t, ...r) {
+        return null
+    }
+};
+
+function t8(e, t, r = !0) {
+    return typeof t == "number" ? Rc(e, t, r) : typeof t == "string" && t in v ? Rc(e, v[t], r) : t && t instanceof X ? Rc(e, xM(t), r) : t?.type && t.type instanceof X ? Rc(e, xM(t.type), r) : Rc(e, v.NONE, r)
+}
+
+function Rc(e, t, r = !0) {
+    let i = null;
+    switch (t) {
+        case v.Null:
+            i = e.visitNull;
+            break;
+        case v.Bool:
+            i = e.visitBool;
+            break;
+        case v.Int:
+            i = e.visitInt;
+            break;
+        case v.Int8:
+            i = e.visitInt8 || e.visitInt;
+            break;
+        case v.Int16:
+            i = e.visitInt16 || e.visitInt;
+            break;
+        case v.Int32:
+            i = e.visitInt32 || e.visitInt;
+            break;
+        case v.Int64:
+            i = e.visitInt64 || e.visitInt;
+            break;
+        case v.Uint8:
+            i = e.visitUint8 || e.visitInt;
+            break;
+        case v.Uint16:
+            i = e.visitUint16 || e.visitInt;
+            break;
+        case v.Uint32:
+            i = e.visitUint32 || e.visitInt;
+            break;
+        case v.Uint64:
+            i = e.visitUint64 || e.visitInt;
+            break;
+        case v.Float:
+            i = e.visitFloat;
+            break;
+        case v.Float16:
+            i = e.visitFloat16 || e.visitFloat;
+            break;
+        case v.Float32:
+            i = e.visitFloat32 || e.visitFloat;
+            break;
+        case v.Float64:
+            i = e.visitFloat64 || e.visitFloat;
+            break;
+        case v.Utf8:
+            i = e.visitUtf8;
+            break;
+        case v.LargeUtf8:
+            i = e.visitLargeUtf8;
+            break;
+        case v.Binary:
+            i = e.visitBinary;
+            break;
+        case v.LargeBinary:
+            i = e.visitLargeBinary;
+            break;
+        case v.FixedSizeBinary:
+            i = e.visitFixedSizeBinary;
+            break;
+        case v.Date:
+            i = e.visitDate;
+            break;
+        case v.DateDay:
+            i = e.visitDateDay || e.visitDate;
+            break;
+        case v.DateMillisecond:
+            i = e.visitDateMillisecond || e.visitDate;
+            break;
+        case v.Timestamp:
+            i = e.visitTimestamp;
+            break;
+        case v.TimestampSecond:
+            i = e.visitTimestampSecond || e.visitTimestamp;
+            break;
+        case v.TimestampMillisecond:
+            i = e.visitTimestampMillisecond || e.visitTimestamp;
+            break;
+        case v.TimestampMicrosecond:
+            i = e.visitTimestampMicrosecond || e.visitTimestamp;
+            break;
+        case v.TimestampNanosecond:
+            i = e.visitTimestampNanosecond || e.visitTimestamp;
+            break;
+        case v.Time:
+            i = e.visitTime;
+            break;
+        case v.TimeSecond:
+            i = e.visitTimeSecond || e.visitTime;
+            break;
+        case v.TimeMillisecond:
+            i = e.visitTimeMillisecond || e.visitTime;
+            break;
+        case v.TimeMicrosecond:
+            i = e.visitTimeMicrosecond || e.visitTime;
+            break;
+        case v.TimeNanosecond:
+            i = e.visitTimeNanosecond || e.visitTime;
+            break;
+        case v.Decimal:
+            i = e.visitDecimal;
+            break;
+        case v.List:
+            i = e.visitList;
+            break;
+        case v.Struct:
+            i = e.visitStruct;
+            break;
+        case v.Union:
+            i = e.visitUnion;
+            break;
+        case v.DenseUnion:
+            i = e.visitDenseUnion || e.visitUnion;
+            break;
+        case v.SparseUnion:
+            i = e.visitSparseUnion || e.visitUnion;
+            break;
+        case v.Dictionary:
+            i = e.visitDictionary;
+            break;
+        case v.Interval:
+            i = e.visitInterval;
+            break;
+        case v.IntervalDayTime:
+            i = e.visitIntervalDayTime || e.visitInterval;
+            break;
+        case v.IntervalYearMonth:
+            i = e.visitIntervalYearMonth || e.visitInterval;
+            break;
+        case v.Duration:
+            i = e.visitDuration;
+            break;
+        case v.DurationSecond:
+            i = e.visitDurationSecond || e.visitDuration;
+            break;
+        case v.DurationMillisecond:
+            i = e.visitDurationMillisecond || e.visitDuration;
+            break;
+        case v.DurationMicrosecond:
+            i = e.visitDurationMicrosecond || e.visitDuration;
+            break;
+        case v.DurationNanosecond:
+            i = e.visitDurationNanosecond || e.visitDuration;
+            break;
+        case v.FixedSizeList:
+            i = e.visitFixedSizeList;
+            break;
+        case v.Map:
+            i = e.visitMap;
+            break
+    }
+    if (typeof i == "function") return i;
+    if (!r) return () => null;
+    throw new Error(`Unrecognized type '${v[t]}'`)
+}
+
+function xM(e) {
+    switch (e.typeId) {
+        case v.Null:
+            return v.Null;
+        case v.Int: {
+            let {
+                bitWidth: t,
+                isSigned: r
+            } = e;
+            switch (t) {
+                case 8:
+                    return r ? v.Int8 : v.Uint8;
+                case 16:
+                    return r ? v.Int16 : v.Uint16;
+                case 32:
+                    return r ? v.Int32 : v.Uint32;
+                case 64:
+                    return r ? v.Int64 : v.Uint64
+            }
+            return v.Int
+        }
+        case v.Float:
+            switch (e.precision) {
+                case kt.HALF:
+                    return v.Float16;
+                case kt.SINGLE:
+                    return v.Float32;
+                case kt.DOUBLE:
+                    return v.Float64
+            }
+            return v.Float;
+        case v.Binary:
+            return v.Binary;
+        case v.LargeBinary:
+            return v.LargeBinary;
+        case v.Utf8:
+            return v.Utf8;
+        case v.LargeUtf8:
+            return v.LargeUtf8;
+        case v.Bool:
+            return v.Bool;
+        case v.Decimal:
+            return v.Decimal;
+        case v.Time:
+            switch (e.unit) {
+                case Y.SECOND:
+                    return v.TimeSecond;
+                case Y.MILLISECOND:
+                    return v.TimeMillisecond;
+                case Y.MICROSECOND:
+                    return v.TimeMicrosecond;
+                case Y.NANOSECOND:
+                    return v.TimeNanosecond
+            }
+            return v.Time;
+        case v.Timestamp:
+            switch (e.unit) {
+                case Y.SECOND:
+                    return v.TimestampSecond;
+                case Y.MILLISECOND:
+                    return v.TimestampMillisecond;
+                case Y.MICROSECOND:
+                    return v.TimestampMicrosecond;
+                case Y.NANOSECOND:
+                    return v.TimestampNanosecond
+            }
+            return v.Timestamp;
+        case v.Date:
+            switch (e.unit) {
+                case ue.DAY:
+                    return v.DateDay;
+                case ue.MILLISECOND:
+                    return v.DateMillisecond
+            }
+            return v.Date;
+        case v.Interval:
+            switch (e.unit) {
+                case xe.DAY_TIME:
+                    return v.IntervalDayTime;
+                case xe.YEAR_MONTH:
+                    return v.IntervalYearMonth
+            }
+            return v.Interval;
+        case v.Duration:
+            switch (e.unit) {
+                case Y.SECOND:
+                    return v.DurationSecond;
+                case Y.MILLISECOND:
+                    return v.DurationMillisecond;
+                case Y.MICROSECOND:
+                    return v.DurationMicrosecond;
+                case Y.NANOSECOND:
+                    return v.DurationNanosecond
+            }
+            return v.Duration;
+        case v.Map:
+            return v.Map;
+        case v.List:
+            return v.List;
+        case v.Struct:
+            return v.Struct;
+        case v.Union:
+            switch (e.mode) {
+                case Vt.Dense:
+                    return v.DenseUnion;
+                case Vt.Sparse:
+                    return v.SparseUnion
+            }
+            return v.Union;
+        case v.FixedSizeBinary:
+            return v.FixedSizeBinary;
+        case v.FixedSizeList:
+            return v.FixedSizeList;
+        case v.Dictionary:
+            return v.Dictionary
+    }
+    throw new Error(`Unrecognized type '${v[e.typeId]}'`)
+}
+J.prototype.visitInt8 = null;
+J.prototype.visitInt16 = null;
+J.prototype.visitInt32 = null;
+J.prototype.visitInt64 = null;
+J.prototype.visitUint8 = null;
+J.prototype.visitUint16 = null;
+J.prototype.visitUint32 = null;
+J.prototype.visitUint64 = null;
+J.prototype.visitFloat16 = null;
+J.prototype.visitFloat32 = null;
+J.prototype.visitFloat64 = null;
+J.prototype.visitDateDay = null;
+J.prototype.visitDateMillisecond = null;
+J.prototype.visitTimestampSecond = null;
+J.prototype.visitTimestampMillisecond = null;
+J.prototype.visitTimestampMicrosecond = null;
+J.prototype.visitTimestampNanosecond = null;
+J.prototype.visitTimeSecond = null;
+J.prototype.visitTimeMillisecond = null;
+J.prototype.visitTimeMicrosecond = null;
+J.prototype.visitTimeNanosecond = null;
+J.prototype.visitDenseUnion = null;
+J.prototype.visitSparseUnion = null;
+J.prototype.visitIntervalDayTime = null;
+J.prototype.visitIntervalYearMonth = null;
+J.prototype.visitDuration = null;
+J.prototype.visitDurationSecond = null;
+J.prototype.visitDurationMillisecond = null;
+J.prototype.visitDurationMicrosecond = null;
+J.prototype.visitDurationNanosecond = null;
+var Yx = {};
+Ze(Yx, {
+    float64ToUint16: () => Sf,
+    uint16ToFloat64: () => jm
+});
+var wM = new Float64Array(1),
+    Mc = new Uint32Array(wM.buffer);
+
+function jm(e) {
+    let t = (e & 31744) >> 10,
+        r = (e & 1023) / 1024,
+        i = Math.pow(-1, (e & 32768) >> 15);
+    switch (t) {
+        case 31:
+            return i * (r ? Number.NaN : 1 / 0);
+        case 0:
+            return i * (r ? 6103515625e-14 * r : 0)
+    }
+    return i * Math.pow(2, t - 15) * (1 + r)
+}
+
+function Sf(e) {
+    if (e !== e) return 32256;
+    wM[0] = e;
+    let t = (Mc[1] & 2147483648) >> 16 & 65535,
+        r = Mc[1] & 2146435072,
+        i = 0;
+    return r >= 1089470464 ? Mc[0] > 0 ? r = 31744 : (r = (r & 2080374784) >> 16, i = (Mc[1] & 1048575) >> 10) : r <= 1056964608 ? (i = 1048576 + (Mc[1] & 1048575), i = 1048576 + (i << (r >> 20) - 998) >> 21, r = 0) : (r = r - 1056964608 >> 10, i = (Mc[1] & 1048575) + 512 >> 10), t | r | i & 65535
+}
+var nt = class extends J {};
+
+function ut(e) {
+    return (t, r, i) => {
+        if (t.setValid(r, i != null)) return e(t, r, i)
+    }
+}
+var e8 = (e, t, r) => {
+        e[t] = Math.trunc(r / 864e5)
+    },
+    qx = (e, t, r) => {
+        e[t] = Math.trunc(r % 4294967296), e[t + 1] = Math.trunc(r / 4294967296)
+    },
+    r8 = (e, t, r) => {
+        e[t] = Math.trunc(r * 1e3 % 4294967296), e[t + 1] = Math.trunc(r * 1e3 / 4294967296)
+    },
+    i8 = (e, t, r) => {
+        e[t] = Math.trunc(r * 1e6 % 4294967296), e[t + 1] = Math.trunc(r * 1e6 / 4294967296)
+    },
+    TM = (e, t, r, i) => {
+        if (r + 1 < t.length) {
+            let n = Kt(t[r]),
+                s = Kt(t[r + 1]);
+            e.set(i.subarray(0, s - n), n)
+        }
+    },
+    n8 = ({
+        offset: e,
+        values: t
+    }, r, i) => {
+        let n = e + r;
+        i ? t[n >> 3] |= 1 << n % 8 : t[n >> 3] &= ~(1 << n % 8)
+    },
+    Yn = ({
+        values: e
+    }, t, r) => {
+        e[t] = r
+    },
+    Zx = ({
+        values: e
+    }, t, r) => {
+        e[t] = r
+    },
+    vM = ({
+        values: e
+    }, t, r) => {
+        e[t] = Sf(r)
+    },
+    s8 = (e, t, r) => {
+        switch (e.type.precision) {
+            case kt.HALF:
+                return vM(e, t, r);
+            case kt.SINGLE:
+            case kt.DOUBLE:
+                return Zx(e, t, r)
+        }
+    },
+    Hm = ({
+        values: e
+    }, t, r) => {
+        e8(e, t, r.valueOf())
+    },
+    $m = ({
+        values: e
+    }, t, r) => {
+        qx(e, t * 2, r.valueOf())
+    },
+    Kx = ({
+        stride: e,
+        values: t
+    }, r, i) => {
+        t.set(i.subarray(0, e), e * r)
+    },
+    SM = ({
+        values: e,
+        valueOffsets: t
+    }, r, i) => TM(e, t, r, i),
+    AM = ({
+        values: e,
+        valueOffsets: t
+    }, r, i) => TM(e, t, r, en(i)),
+    Gx = (e, t, r) => {
+        e.type.unit === ue.DAY ? Hm(e, t, r) : $m(e, t, r)
+    },
+    Xm = ({
+        values: e
+    }, t, r) => qx(e, t * 2, r / 1e3),
+    Ym = ({
+        values: e
+    }, t, r) => qx(e, t * 2, r),
+    qm = ({
+        values: e
+    }, t, r) => r8(e, t * 2, r),
+    Zm = ({
+        values: e
+    }, t, r) => i8(e, t * 2, r),
+    Jx = (e, t, r) => {
+        switch (e.type.unit) {
+            case Y.SECOND:
+                return Xm(e, t, r);
+            case Y.MILLISECOND:
+                return Ym(e, t, r);
+            case Y.MICROSECOND:
+                return qm(e, t, r);
+            case Y.NANOSECOND:
+                return Zm(e, t, r)
+        }
+    },
+    Km = ({
+        values: e
+    }, t, r) => {
+        e[t] = r
+    },
+    Gm = ({
+        values: e
+    }, t, r) => {
+        e[t] = r
+    },
+    Jm = ({
+        values: e
+    }, t, r) => {
+        e[t] = r
+    },
+    Qm = ({
+        values: e
+    }, t, r) => {
+        e[t] = r
+    },
+    Qx = (e, t, r) => {
+        switch (e.type.unit) {
+            case Y.SECOND:
+                return Km(e, t, r);
+            case Y.MILLISECOND:
+                return Gm(e, t, r);
+            case Y.MICROSECOND:
+                return Jm(e, t, r);
+            case Y.NANOSECOND:
+                return Qm(e, t, r)
+        }
+    },
+    tw = ({
+        values: e,
+        stride: t
+    }, r, i) => {
+        e.set(i.subarray(0, t), t * r)
+    },
+    o8 = (e, t, r) => {
+        let i = e.children[0],
+            n = e.valueOffsets,
+            s = Ee.getVisitFn(i);
+        if (Array.isArray(r))
+            for (let o = -1, a = n[t], c = n[t + 1]; a < c;) s(i, a++, r[++o]);
+        else
+            for (let o = -1, a = n[t], c = n[t + 1]; a < c;) s(i, a++, r.get(++o))
+    },
+    a8 = (e, t, r) => {
+        let i = e.children[0],
+            {
+                valueOffsets: n
+            } = e,
+            s = Ee.getVisitFn(i),
+            {
+                [t]: o,
+                [t + 1]: a
+            } = n,
+            c = r instanceof Map ? r.entries() : Object.entries(r);
+        for (let l of c)
+            if (s(i, o, l), ++o >= a) break
+    },
+    c8 = (e, t) => (r, i, n, s) => i && r(i, e, t[s]),
+    l8 = (e, t) => (r, i, n, s) => i && r(i, e, t.get(s)),
+    u8 = (e, t) => (r, i, n, s) => i && r(i, e, t.get(n.name)),
+    f8 = (e, t) => (r, i, n, s) => i && r(i, e, t[n.name]),
+    h8 = (e, t, r) => {
+        let i = e.type.children.map(s => Ee.getVisitFn(s.type)),
+            n = r instanceof Map ? u8(t, r) : r instanceof St ? l8(t, r) : Array.isArray(r) ? c8(t, r) : f8(t, r);
+        e.type.children.forEach((s, o) => n(i[o], e.children[o], s, o))
+    },
+    d8 = (e, t, r) => {
+        e.type.mode === Vt.Dense ? EM(e, t, r) : IM(e, t, r)
+    },
+    EM = (e, t, r) => {
+        let i = e.type.typeIdToChildIndex[e.typeIds[t]],
+            n = e.children[i];
+        Ee.visit(n, e.valueOffsets[t], r)
+    },
+    IM = (e, t, r) => {
+        let i = e.type.typeIdToChildIndex[e.typeIds[t]],
+            n = e.children[i];
+        Ee.visit(n, t, r)
+    },
+    p8 = (e, t, r) => {
+        var i;
+        (i = e.dictionary) === null || i === void 0 || i.set(e.values[t], r)
+    },
+    ew = (e, t, r) => {
+        e.type.unit === xe.DAY_TIME ? tg(e, t, r) : eg(e, t, r)
+    },
+    tg = ({
+        values: e
+    }, t, r) => {
+        e.set(r.subarray(0, 2), 2 * t)
+    },
+    eg = ({
+        values: e
+    }, t, r) => {
+        e[t] = r[0] * 12 + r[1] % 12
+    },
+    rg = ({
+        values: e
+    }, t, r) => {
+        e[t] = r
+    },
+    ig = ({
+        values: e
+    }, t, r) => {
+        e[t] = r
+    },
+    ng = ({
+        values: e
+    }, t, r) => {
+        e[t] = r
+    },
+    sg = ({
+        values: e
+    }, t, r) => {
+        e[t] = r
+    },
+    rw = (e, t, r) => {
+        switch (e.type.unit) {
+            case Y.SECOND:
+                return rg(e, t, r);
+            case Y.MILLISECOND:
+                return ig(e, t, r);
+            case Y.MICROSECOND:
+                return ng(e, t, r);
+            case Y.NANOSECOND:
+                return sg(e, t, r)
+        }
+    },
+    m8 = (e, t, r) => {
+        let {
+            stride: i
+        } = e, n = e.children[0], s = Ee.getVisitFn(n);
+        if (Array.isArray(r))
+            for (let o = -1, a = t * i; ++o < i;) s(n, a + o, r[o]);
+        else
+            for (let o = -1, a = t * i; ++o < i;) s(n, a + o, r.get(o))
+    };
+nt.prototype.visitBool = ut(n8);
+nt.prototype.visitInt = ut(Yn);
+nt.prototype.visitInt8 = ut(Yn);
+nt.prototype.visitInt16 = ut(Yn);
+nt.prototype.visitInt32 = ut(Yn);
+nt.prototype.visitInt64 = ut(Yn);
+nt.prototype.visitUint8 = ut(Yn);
+nt.prototype.visitUint16 = ut(Yn);
+nt.prototype.visitUint32 = ut(Yn);
+nt.prototype.visitUint64 = ut(Yn);
+nt.prototype.visitFloat = ut(s8);
+nt.prototype.visitFloat16 = ut(vM);
+nt.prototype.visitFloat32 = ut(Zx);
+nt.prototype.visitFloat64 = ut(Zx);
+nt.prototype.visitUtf8 = ut(AM);
+nt.prototype.visitLargeUtf8 = ut(AM);
+nt.prototype.visitBinary = ut(SM);
+nt.prototype.visitLargeBinary = ut(SM);
+nt.prototype.visitFixedSizeBinary = ut(Kx);
+nt.prototype.visitDate = ut(Gx);
+nt.prototype.visitDateDay = ut(Hm);
+nt.prototype.visitDateMillisecond = ut($m);
+nt.prototype.visitTimestamp = ut(Jx);
+nt.prototype.visitTimestampSecond = ut(Xm);
+nt.prototype.visitTimestampMillisecond = ut(Ym);
+nt.prototype.visitTimestampMicrosecond = ut(qm);
+nt.prototype.visitTimestampNanosecond = ut(Zm);
+nt.prototype.visitTime = ut(Qx);
+nt.prototype.visitTimeSecond = ut(Km);
+nt.prototype.visitTimeMillisecond = ut(Gm);
+nt.prototype.visitTimeMicrosecond = ut(Jm);
+nt.prototype.visitTimeNanosecond = ut(Qm);
+nt.prototype.visitDecimal = ut(tw);
+nt.prototype.visitList = ut(o8);
+nt.prototype.visitStruct = ut(h8);
+nt.prototype.visitUnion = ut(d8);
+nt.prototype.visitDenseUnion = ut(EM);
+nt.prototype.visitSparseUnion = ut(IM);
+nt.prototype.visitDictionary = ut(p8);
+nt.prototype.visitInterval = ut(ew);
+nt.prototype.visitIntervalDayTime = ut(tg);
+nt.prototype.visitIntervalYearMonth = ut(eg);
+nt.prototype.visitDuration = ut(rw);
+nt.prototype.visitDurationSecond = ut(rg);
+nt.prototype.visitDurationMillisecond = ut(ig);
+nt.prototype.visitDurationMicrosecond = ut(ng);
+nt.prototype.visitDurationNanosecond = ut(sg);
+nt.prototype.visitFixedSizeList = ut(m8);
+nt.prototype.visitMap = ut(a8);
+var Ee = new nt;
+var Ai = Symbol.for("parent"),
+    Pc = Symbol.for("rowIndex"),
+    Js = class {
+        constructor(t, r) {
+            return this[Ai] = t, this[Pc] = r, new Proxy(this, new nw)
+        }
+        toArray() {
+            return Object.values(this.toJSON())
+        }
+        toJSON() {
+            let t = this[Pc],
+                r = this[Ai],
+                i = r.type.children,
+                n = {};
+            for (let s = -1, o = i.length; ++s < o;) n[i[s].name] = fe.visit(r.children[s], t);
+            return n
+        }
+        toString() {
+            return `{${[...this].map(([t,r])=>`${yi(t)}: ${yi(r)}`).join(", ")}}`
+        } [Symbol.for("nodejs.util.inspect.custom")]() {
+            return this.toString()
+        } [Symbol.iterator]() {
+            return new iw(this[Ai], this[Pc])
+        }
+    },
+    iw = class {
+        constructor(t, r) {
+            this.childIndex = 0, this.children = t.children, this.rowIndex = r, this.childFields = t.type.children, this.numChildren = this.childFields.length
+        } [Symbol.iterator]() {
+            return this
+        }
+        next() {
+            let t = this.childIndex;
+            return t < this.numChildren ? (this.childIndex = t + 1, {
+                done: !1,
+                value: [this.childFields[t].name, fe.visit(this.children[t], this.rowIndex)]
+            }) : {
+                done: !0,
+                value: null
+            }
+        }
+    };
+Object.defineProperties(Js.prototype, {
+    [Symbol.toStringTag]: {
+        enumerable: !1,
+        configurable: !1,
+        value: "Row"
+    },
+    [Ai]: {
+        writable: !0,
+        enumerable: !1,
+        configurable: !1,
+        value: null
+    },
+    [Pc]: {
+        writable: !0,
+        enumerable: !1,
+        configurable: !1,
+        value: -1
+    }
+});
+var nw = class {
+    isExtensible() {
+        return !1
+    }
+    deleteProperty() {
+        return !1
+    }
+    preventExtensions() {
+        return !0
+    }
+    ownKeys(t) {
+        return t[Ai].type.children.map(r => r.name)
+    }
+    has(t, r) {
+        return t[Ai].type.children.findIndex(i => i.name === r) !== -1
+    }
+    getOwnPropertyDescriptor(t, r) {
+        if (t[Ai].type.children.findIndex(i => i.name === r) !== -1) return {
+            writable: !0,
+            enumerable: !0,
+            configurable: !0
+        }
+    }
+    get(t, r) {
+        if (Reflect.has(t, r)) return t[r];
+        let i = t[Ai].type.children.findIndex(n => n.name === r);
+        if (i !== -1) {
+            let n = fe.visit(t[Ai].children[i], t[Pc]);
+            return Reflect.set(t, r, n), n
+        }
+    }
+    set(t, r, i) {
+        let n = t[Ai].type.children.findIndex(s => s.name === r);
+        return n !== -1 ? (Ee.visit(t[Ai].children[n], t[Pc], i), Reflect.set(t, r, i)) : Reflect.has(t, r) || typeof r == "symbol" ? Reflect.set(t, r, i) : !1
+    }
+};
+var Q = class extends J {};
+
+function ct(e) {
+    return (t, r) => t.getValid(r) ? e(t, r) : null
+}
+var g8 = (e, t) => 864e5 * e[t],
+    sw = (e, t) => 4294967296 * e[t + 1] + (e[t] >>> 0),
+    _8 = (e, t) => 4294967296 * (e[t + 1] / 1e3) + (e[t] >>> 0) / 1e3,
+    y8 = (e, t) => 4294967296 * (e[t + 1] / 1e6) + (e[t] >>> 0) / 1e6,
+    RM = e => new Date(e),
+    b8 = (e, t) => RM(g8(e, t)),
+    x8 = (e, t) => RM(sw(e, t)),
+    w8 = (e, t) => null,
+    MM = (e, t, r) => {
+        if (r + 1 >= t.length) return null;
+        let i = Kt(t[r]),
+            n = Kt(t[r + 1]);
+        return e.subarray(i, n)
+    },
+    T8 = ({
+        offset: e,
+        values: t
+    }, r) => {
+        let i = e + r;
+        return (t[i >> 3] & 1 << i % 8) !== 0
+    },
+    PM = ({
+        values: e
+    }, t) => b8(e, t),
+    CM = ({
+        values: e
+    }, t) => x8(e, t * 2),
+    Qs = ({
+        stride: e,
+        values: t
+    }, r) => t[e * r],
+    v8 = ({
+        stride: e,
+        values: t
+    }, r) => jm(t[e * r]),
+    OM = ({
+        values: e
+    }, t) => e[t],
+    S8 = ({
+        stride: e,
+        values: t
+    }, r) => t.subarray(e * r, e * (r + 1)),
+    NM = ({
+        values: e,
+        valueOffsets: t
+    }, r) => MM(e, t, r),
+    BM = ({
+        values: e,
+        valueOffsets: t
+    }, r) => {
+        let i = MM(e, t, r);
+        return i !== null ? af(i) : null
+    },
+    A8 = ({
+        values: e
+    }, t) => e[t],
+    E8 = ({
+        type: e,
+        values: t
+    }, r) => e.precision !== kt.HALF ? t[r] : jm(t[r]),
+    I8 = (e, t) => e.type.unit === ue.DAY ? PM(e, t) : CM(e, t),
+    FM = ({
+        values: e
+    }, t) => 1e3 * sw(e, t * 2),
+    DM = ({
+        values: e
+    }, t) => sw(e, t * 2),
+    LM = ({
+        values: e
+    }, t) => _8(e, t * 2),
+    kM = ({
+        values: e
+    }, t) => y8(e, t * 2),
+    R8 = (e, t) => {
+        switch (e.type.unit) {
+            case Y.SECOND:
+                return FM(e, t);
+            case Y.MILLISECOND:
+                return DM(e, t);
+            case Y.MICROSECOND:
+                return LM(e, t);
+            case Y.NANOSECOND:
+                return kM(e, t)
+        }
+    },
+    UM = ({
+        values: e
+    }, t) => e[t],
+    VM = ({
+        values: e
+    }, t) => e[t],
+    zM = ({
+        values: e
+    }, t) => e[t],
+    WM = ({
+        values: e
+    }, t) => e[t],
+    M8 = (e, t) => {
+        switch (e.type.unit) {
+            case Y.SECOND:
+                return UM(e, t);
+            case Y.MILLISECOND:
+                return VM(e, t);
+            case Y.MICROSECOND:
+                return zM(e, t);
+            case Y.NANOSECOND:
+                return WM(e, t)
+        }
+    },
+    P8 = ({
+        values: e,
+        stride: t
+    }, r) => vf.decimal(e.subarray(t * r, t * (r + 1))),
+    C8 = (e, t) => {
+        let {
+            valueOffsets: r,
+            stride: i,
+            children: n
+        } = e, {
+            [t * i]: s,
+            [t * i + 1]: o
+        } = r, c = n[0].slice(s, o - s);
+        return new St([c])
+    },
+    O8 = (e, t) => {
+        let {
+            valueOffsets: r,
+            children: i
+        } = e, {
+            [t]: n,
+            [t + 1]: s
+        } = r, o = i[0];
+        return new cn(o.slice(n, s - n))
+    },
+    N8 = (e, t) => new Js(e, t),
+    B8 = (e, t) => e.type.mode === Vt.Dense ? jM(e, t) : HM(e, t),
+    jM = (e, t) => {
+        let r = e.type.typeIdToChildIndex[e.typeIds[t]],
+            i = e.children[r];
+        return fe.visit(i, e.valueOffsets[t])
+    },
+    HM = (e, t) => {
+        let r = e.type.typeIdToChildIndex[e.typeIds[t]],
+            i = e.children[r];
+        return fe.visit(i, t)
+    },
+    F8 = (e, t) => {
+        var r;
+        return (r = e.dictionary) === null || r === void 0 ? void 0 : r.get(e.values[t])
+    },
+    D8 = (e, t) => e.type.unit === xe.DAY_TIME ? $M(e, t) : XM(e, t),
+    $M = ({
+        values: e
+    }, t) => e.subarray(2 * t, 2 * (t + 1)),
+    XM = ({
+        values: e
+    }, t) => {
+        let r = e[t],
+            i = new Int32Array(2);
+        return i[0] = Math.trunc(r / 12), i[1] = Math.trunc(r % 12), i
+    },
+    YM = ({
+        values: e
+    }, t) => e[t],
+    qM = ({
+        values: e
+    }, t) => e[t],
+    ZM = ({
+        values: e
+    }, t) => e[t],
+    KM = ({
+        values: e
+    }, t) => e[t],
+    L8 = (e, t) => {
+        switch (e.type.unit) {
+            case Y.SECOND:
+                return YM(e, t);
+            case Y.MILLISECOND:
+                return qM(e, t);
+            case Y.MICROSECOND:
+                return ZM(e, t);
+            case Y.NANOSECOND:
+                return KM(e, t)
+        }
+    },
+    k8 = (e, t) => {
+        let {
+            stride: r,
+            children: i
+        } = e, s = i[0].slice(t * r, r);
+        return new St([s])
+    };
+Q.prototype.visitNull = ct(w8);
+Q.prototype.visitBool = ct(T8);
+Q.prototype.visitInt = ct(A8);
+Q.prototype.visitInt8 = ct(Qs);
+Q.prototype.visitInt16 = ct(Qs);
+Q.prototype.visitInt32 = ct(Qs);
+Q.prototype.visitInt64 = ct(OM);
+Q.prototype.visitUint8 = ct(Qs);
+Q.prototype.visitUint16 = ct(Qs);
+Q.prototype.visitUint32 = ct(Qs);
+Q.prototype.visitUint64 = ct(OM);
+Q.prototype.visitFloat = ct(E8);
+Q.prototype.visitFloat16 = ct(v8);
+Q.prototype.visitFloat32 = ct(Qs);
+Q.prototype.visitFloat64 = ct(Qs);
+Q.prototype.visitUtf8 = ct(BM);
+Q.prototype.visitLargeUtf8 = ct(BM);
+Q.prototype.visitBinary = ct(NM);
+Q.prototype.visitLargeBinary = ct(NM);
+Q.prototype.visitFixedSizeBinary = ct(S8);
+Q.prototype.visitDate = ct(I8);
+Q.prototype.visitDateDay = ct(PM);
+Q.prototype.visitDateMillisecond = ct(CM);
+Q.prototype.visitTimestamp = ct(R8);
+Q.prototype.visitTimestampSecond = ct(FM);
+Q.prototype.visitTimestampMillisecond = ct(DM);
+Q.prototype.visitTimestampMicrosecond = ct(LM);
+Q.prototype.visitTimestampNanosecond = ct(kM);
+Q.prototype.visitTime = ct(M8);
+Q.prototype.visitTimeSecond = ct(UM);
+Q.prototype.visitTimeMillisecond = ct(VM);
+Q.prototype.visitTimeMicrosecond = ct(zM);
+Q.prototype.visitTimeNanosecond = ct(WM);
+Q.prototype.visitDecimal = ct(P8);
+Q.prototype.visitList = ct(C8);
+Q.prototype.visitStruct = ct(N8);
+Q.prototype.visitUnion = ct(B8);
+Q.prototype.visitDenseUnion = ct(jM);
+Q.prototype.visitSparseUnion = ct(HM);
+Q.prototype.visitDictionary = ct(F8);
+Q.prototype.visitInterval = ct(D8);
+Q.prototype.visitIntervalDayTime = ct($M);
+Q.prototype.visitIntervalYearMonth = ct(XM);
+Q.prototype.visitDuration = ct(L8);
+Q.prototype.visitDurationSecond = ct(YM);
+Q.prototype.visitDurationMillisecond = ct(qM);
+Q.prototype.visitDurationMicrosecond = ct(ZM);
+Q.prototype.visitDurationNanosecond = ct(KM);
+Q.prototype.visitFixedSizeList = ct(k8);
+Q.prototype.visitMap = ct(O8);
+var fe = new Q;
+var Yr = Symbol.for("keys"),
+    Cc = Symbol.for("vals"),
+    cn = class {
+        constructor(t) {
+            return this[Yr] = new St([t.children[0]]).memoize(), this[Cc] = t.children[1], new Proxy(this, new aw)
+        } [Symbol.iterator]() {
+            return new ow(this[Yr], this[Cc])
+        }
+        get size() {
+            return this[Yr].length
+        }
+        toArray() {
+            return Object.values(this.toJSON())
+        }
+        toJSON() {
+            let t = this[Yr],
+                r = this[Cc],
+                i = {};
+            for (let n = -1, s = t.length; ++n < s;) i[t.get(n)] = fe.visit(r, n);
+            return i
+        }
+        toString() {
+            return `{${[...this].map(([t,r])=>`${yi(t)}: ${yi(r)}`).join(", ")}}`
+        } [Symbol.for("nodejs.util.inspect.custom")]() {
+            return this.toString()
+        }
+    },
+    ow = class {
+        constructor(t, r) {
+            this.keys = t, this.vals = r, this.keyIndex = 0, this.numKeys = t.length
+        } [Symbol.iterator]() {
+            return this
+        }
+        next() {
+            let t = this.keyIndex;
+            return t === this.numKeys ? {
+                done: !0,
+                value: null
+            } : (this.keyIndex++, {
+                done: !1,
+                value: [this.keys.get(t), fe.visit(this.vals, t)]
+            })
+        }
+    },
+    aw = class {
+        isExtensible() {
+            return !1
+        }
+        deleteProperty() {
+            return !1
+        }
+        preventExtensions() {
+            return !0
+        }
+        ownKeys(t) {
+            return t[Yr].toArray().map(String)
+        }
+        has(t, r) {
+            return t[Yr].includes(r)
+        }
+        getOwnPropertyDescriptor(t, r) {
+            if (t[Yr].indexOf(r) !== -1) return {
+                writable: !0,
+                enumerable: !0,
+                configurable: !0
+            }
+        }
+        get(t, r) {
+            if (Reflect.has(t, r)) return t[r];
+            let i = t[Yr].indexOf(r);
+            if (i !== -1) {
+                let n = fe.visit(Reflect.get(t, Cc), i);
+                return Reflect.set(t, r, n), n
+            }
+        }
+        set(t, r, i) {
+            let n = t[Yr].indexOf(r);
+            return n !== -1 ? (Ee.visit(Reflect.get(t, Cc), n, i), Reflect.set(t, r, i)) : Reflect.has(t, r) ? Reflect.set(t, r, i) : !1
+        }
+    };
+Object.defineProperties(cn.prototype, {
+    [Symbol.toStringTag]: {
+        enumerable: !1,
+        configurable: !1,
+        value: "Row"
+    },
+    [Yr]: {
+        writable: !0,
+        enumerable: !1,
+        configurable: !1,
+        value: null
+    },
+    [Cc]: {
+        writable: !0,
+        enumerable: !1,
+        configurable: !1,
+        value: null
+    }
+});
+
+function U8(e, t, r) {
+    let i = e.length,
+        n = t > -1 ? t : i + t % i;
+    return r ? r(e, n) : n
+}
+var GM;
+
+function Af(e, t, r, i) {
+    let {
+        length: n = 0
+    } = e, s = typeof t != "number" ? 0 : t, o = typeof r != "number" ? n : r;
+    return s < 0 && (s = (s % n + n) % n), o < 0 && (o = (o % n + n) % n), o < s && (GM = s, s = o, o = GM), o > n && (o = n), i ? i(e, s, o) : [s, o]
+}
+var JM = e => e !== e;
+
+function to(e) {
+    if (typeof e !== "object" || e === null) return JM(e) ? JM : r => r === e;
+    if (e instanceof Date) {
+        let r = e.valueOf();
+        return i => i instanceof Date ? i.valueOf() === r : !1
+    }
+    return ArrayBuffer.isView(e) ? r => r ? Vx(e, r) : !1 : e instanceof Map ? z8(e) : Array.isArray(e) ? V8(e) : e instanceof St ? W8(e) : j8(e, !0)
+}
+
+function V8(e) {
+    let t = [];
+    for (let r = -1, i = e.length; ++r < i;) t[r] = to(e[r]);
+    return og(t)
+}
+
+function z8(e) {
+    let t = -1,
+        r = [];
+    for (let i of e.values()) r[++t] = to(i);
+    return og(r)
+}
+
+function W8(e) {
+    let t = [];
+    for (let r = -1, i = e.length; ++r < i;) t[r] = to(e.get(r));
+    return og(t)
+}
+
+function j8(e, t = !1) {
+    let r = Object.keys(e);
+    if (!t && r.length === 0) return () => !1;
+    let i = [];
+    for (let n = -1, s = r.length; ++n < s;) i[n] = to(e[r[n]]);
+    return og(i, r)
+}
+
+function og(e, t) {
+    return r => {
+        if (!r || typeof r != "object") return !1;
+        switch (r.constructor) {
+            case Array:
+                return H8(e, r);
+            case Map:
+                return QM(e, r, r.keys());
+            case cn:
+            case Js:
+            case Object:
+            case void 0:
+                return QM(e, r, t || Object.keys(r))
+        }
+        return r instanceof St ? $8(e, r) : !1
+    }
+}
+
+function H8(e, t) {
+    let r = e.length;
+    if (t.length !== r) return !1;
+    for (let i = -1; ++i < r;)
+        if (!e[i](t[i])) return !1;
+    return !0
+}
+
+function $8(e, t) {
+    let r = e.length;
+    if (t.length !== r) return !1;
+    for (let i = -1; ++i < r;)
+        if (!e[i](t.get(i))) return !1;
+    return !0
+}
+
+function QM(e, t, r) {
+    let i = r[Symbol.iterator](),
+        n = t instanceof Map ? t.keys() : Object.keys(t)[Symbol.iterator](),
+        s = t instanceof Map ? t.values() : Object.values(t)[Symbol.iterator](),
+        o = 0,
+        a = e.length,
+        c = s.next(),
+        l = i.next(),
+        u = n.next();
+    for (; o < a && !l.done && !u.done && !c.done && !(l.value !== u.value || !e[o](c.value)); ++o, l = i.next(), u = n.next(), c = s.next());
+    return o === a && l.done && u.done && c.done ? !0 : (i.return && i.return(), n.return && n.return(), s.return && s.return(), !1)
+}
+var lw = {};
+Ze(lw, {
+    BitIterator: () => Zo,
+    getBit: () => tP,
+    getBool: () => cg,
+    packBools: () => Go,
+    popcnt_array: () => eP,
+    popcnt_bit_range: () => Ef,
+    popcnt_uint32: () => ag,
+    setBool: () => X8,
+    truncateBitmap: () => Ko
+});
+
+function cg(e, t, r, i) {
+    return (r & 1 << i) !== 0
+}
+
+function tP(e, t, r, i) {
+    return (r & 1 << i) >> i
+}
+
+function X8(e, t, r) {
+    return r ? !!(e[t >> 3] |= 1 << t % 8) || !0 : !(e[t >> 3] &= ~(1 << t % 8)) && !1
+}
+
+function Ko(e, t, r) {
+    let i = r.byteLength + 7 & -8;
+    if (e > 0 || r.byteLength < i) {
+        let n = new Uint8Array(i);
+        return n.set(e % 8 === 0 ? r.subarray(e >> 3) : Go(new Zo(r, e, t, null, cg)).subarray(0, i)), n
+    }
+    return r
+}
+
+function Go(e) {
+    let t = [],
+        r = 0,
+        i = 0,
+        n = 0;
+    for (let o of e) o && (n |= 1 << i), ++i === 8 && (t[r++] = n, n = i = 0);
+    (r === 0 || i > 0) && (t[r++] = n);
+    let s = new Uint8Array(t.length + 7 & -8);
+    return s.set(t), s
+}
+var Zo = class {
+    constructor(t, r, i, n, s) {
+        this.bytes = t, this.length = i, this.context = n, this.get = s, this.bit = r % 8, this.byteIndex = r >> 3, this.byte = t[this.byteIndex++], this.index = 0
+    }
+    next() {
+        return this.index < this.length ? (this.bit === 8 && (this.bit = 0, this.byte = this.bytes[this.byteIndex++]), {
+            value: this.get(this.context, this.index++, this.byte, this.bit++)
+        }) : {
+            done: !0,
+            value: null
+        }
+    } [Symbol.iterator]() {
+        return this
+    }
+};
+
+function Ef(e, t, r) {
+    if (r - t <= 0) return 0;
+    if (r - t < 8) {
+        let s = 0;
+        for (let o of new Zo(e, t, r - t, e, tP)) s += o;
+        return s
+    }
+    let i = r >> 3 << 3,
+        n = t + (t % 8 === 0 ? 0 : 8 - t % 8);
+    return Ef(e, t, n) + Ef(e, i, r) + eP(e, n >> 3, i - n >> 3)
+}
+
+function eP(e, t, r) {
+    let i = 0,
+        n = Math.trunc(t),
+        s = new DataView(e.buffer, e.byteOffset, e.byteLength),
+        o = r === void 0 ? e.byteLength : n + r;
+    for (; o - n >= 4;) i += ag(s.getUint32(n)), n += 4;
+    for (; o - n >= 2;) i += ag(s.getUint16(n)), n += 2;
+    for (; o - n >= 1;) i += ag(s.getUint8(n)), n += 1;
+    return i
+}
+
+function ag(e) {
+    let t = Math.trunc(e);
+    return t = t - (t >>> 1 & 1431655765), t = (t & 858993459) + (t >>> 2 & 858993459), (t + (t >>> 4) & 252645135) * 16843009 >>> 24
+}
+var Y8 = -1,
+    Ct = class e {
+        get typeId() {
+            return this.type.typeId
+        }
+        get ArrayType() {
+            return this.type.ArrayType
+        }
+        get buffers() {
+            return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds]
+        }
+        get nullable() {
+            if (this._nullCount !== 0) {
+                let {
+                    type: t
+                } = this;
+                return X.isSparseUnion(t) ? this.children.some(r => r.nullable) : X.isDenseUnion(t) ? this.children.some(r => r.nullable) : this.nullBitmap && this.nullBitmap.byteLength > 0
+            }
+            return !0
+        }
+        get byteLength() {
+            let t = 0,
+                {
+                    valueOffsets: r,
+                    values: i,
+                    nullBitmap: n,
+                    typeIds: s
+                } = this;
+            return r && (t += r.byteLength), i && (t += i.byteLength), n && (t += n.byteLength), s && (t += s.byteLength), this.children.reduce((o, a) => o + a.byteLength, t)
+        }
+        get nullCount() {
+            if (X.isUnion(this.type)) return this.children.reduce((i, n) => i + n.nullCount, 0);
+            let t = this._nullCount,
+                r;
+            return t <= Y8 && (r = this.nullBitmap) && (this._nullCount = t = this.length - Ef(r, this.offset, this.offset + this.length)), t
+        }
+        constructor(t, r, i, n, s, o = [], a) {
+            this.type = t, this.children = o, this.dictionary = a, this.offset = Math.floor(Math.max(r || 0, 0)), this.length = Math.floor(Math.max(i || 0, 0)), this._nullCount = Math.floor(Math.max(n || 0, -1));
+            let c;
+            s instanceof e ? (this.stride = s.stride, this.values = s.values, this.typeIds = s.typeIds, this.nullBitmap = s.nullBitmap, this.valueOffsets = s.valueOffsets) : (this.stride = vr(t), s && ((c = s[0]) && (this.valueOffsets = c), (c = s[1]) && (this.values = c), (c = s[2]) && (this.nullBitmap = c), (c = s[3]) && (this.typeIds = c)))
+        }
+        getValid(t) {
+            let {
+                type: r
+            } = this;
+            if (X.isUnion(r)) {
+                let i = r,
+                    n = this.children[i.typeIdToChildIndex[this.typeIds[t]]],
+                    s = i.mode === Vt.Dense ? this.valueOffsets[t] : t;
+                return n.getValid(s)
+            }
+            if (this.nullable && this.nullCount > 0) {
+                let i = this.offset + t;
+                return (this.nullBitmap[i >> 3] & 1 << i % 8) !== 0
+            }
+            return !0
+        }
+        setValid(t, r) {
+            let i, {
+                type: n
+            } = this;
+            if (X.isUnion(n)) {
+                let s = n,
+                    o = this.children[s.typeIdToChildIndex[this.typeIds[t]]],
+                    a = s.mode === Vt.Dense ? this.valueOffsets[t] : t;
+                i = o.getValid(a), o.setValid(a, r)
+            } else {
+                let {
+                    nullBitmap: s
+                } = this, {
+                    offset: o,
+                    length: a
+                } = this, c = o + t, l = 1 << c % 8, u = c >> 3;
+                (!s || s.byteLength <= u) && (s = new Uint8Array((o + a + 63 & -64) >> 3).fill(255), this.nullCount > 0 && s.set(Ko(o, a, this.nullBitmap), 0), Object.assign(this, {
+                    nullBitmap: s,
+                    _nullCount: -1
+                }));
+                let f = s[u];
+                i = (f & l) !== 0, r ? s[u] = f | l : s[u] = f & ~l
+            }
+            return i !== !!r && (this._nullCount = this.nullCount + (r ? -1 : 1)), r
+        }
+        clone(t = this.type, r = this.offset, i = this.length, n = this._nullCount, s = this, o = this.children) {
+            return new e(t, r, i, n, s, o, this.dictionary)
+        }
+        slice(t, r) {
+            let {
+                stride: i,
+                typeId: n,
+                children: s
+            } = this, o = +(this._nullCount === 0) - 1, a = n === 16 ? i : 1, c = this._sliceBuffers(t, r, i, n);
+            return this.clone(this.type, this.offset + t, r, o, c, s.length === 0 || this.valueOffsets ? s : this._sliceChildren(s, a * t, a * r))
+        }
+        _changeLengthAndBackfillNullBitmap(t) {
+            if (this.typeId === v.Null) return this.clone(this.type, 0, t, 0);
+            let {
+                length: r,
+                nullCount: i
+            } = this, n = new Uint8Array((t + 63 & -64) >> 3).fill(255, 0, r >> 3);
+            n[r >> 3] = (1 << r - (r & -8)) - 1, i > 0 && n.set(Ko(this.offset, r, this.nullBitmap), 0);
+            let s = this.buffers;
+            return s[_i.VALIDITY] = n, this.clone(this.type, 0, t, i + (t - r), s)
+        }
+        _sliceBuffers(t, r, i, n) {
+            let s, {
+                buffers: o
+            } = this;
+            return (s = o[_i.TYPE]) && (o[_i.TYPE] = s.subarray(t, t + r)), (s = o[_i.OFFSET]) && (o[_i.OFFSET] = s.subarray(t, t + r + 1)) || (s = o[_i.DATA]) && (o[_i.DATA] = n === 6 ? s : s.subarray(i * t, i * (t + r))), o
+        }
+        _sliceChildren(t, r, i) {
+            return t.map(n => n.slice(r, i))
+        }
+    };
+Ct.prototype.children = Object.freeze([]);
+var uw = class e extends J {
+        visit(t) {
+            return this.getVisitFn(t.type).call(this, t)
+        }
+        visitNull(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0, ["length"]: n = 0
+            } = t;
+            return new Ct(r, i, n, n)
+        }
+        visitBool(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0
+            } = t, n = at(t.nullBitmap), s = yt(r.ArrayType, t.data), {
+                ["length"]: o = s.length >> 3,
+                ["nullCount"]: a = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, o, a, [void 0, s, n])
+        }
+        visitInt(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0
+            } = t, n = at(t.nullBitmap), s = yt(r.ArrayType, t.data), {
+                ["length"]: o = s.length,
+                ["nullCount"]: a = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, o, a, [void 0, s, n])
+        }
+        visitFloat(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0
+            } = t, n = at(t.nullBitmap), s = yt(r.ArrayType, t.data), {
+                ["length"]: o = s.length,
+                ["nullCount"]: a = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, o, a, [void 0, s, n])
+        }
+        visitUtf8(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0
+            } = t, n = at(t.data), s = at(t.nullBitmap), o = Yo(t.valueOffsets), {
+                ["length"]: a = o.length - 1,
+                ["nullCount"]: c = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, a, c, [o, n, s])
+        }
+        visitLargeUtf8(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0
+            } = t, n = at(t.data), s = at(t.nullBitmap), o = Em(t.valueOffsets), {
+                ["length"]: a = o.length - 1,
+                ["nullCount"]: c = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, a, c, [o, n, s])
+        }
+        visitBinary(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0
+            } = t, n = at(t.data), s = at(t.nullBitmap), o = Yo(t.valueOffsets), {
+                ["length"]: a = o.length - 1,
+                ["nullCount"]: c = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, a, c, [o, n, s])
+        }
+        visitLargeBinary(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0
+            } = t, n = at(t.data), s = at(t.nullBitmap), o = Em(t.valueOffsets), {
+                ["length"]: a = o.length - 1,
+                ["nullCount"]: c = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, a, c, [o, n, s])
+        }
+        visitFixedSizeBinary(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0
+            } = t, n = at(t.nullBitmap), s = yt(r.ArrayType, t.data), {
+                ["length"]: o = s.length / vr(r),
+                ["nullCount"]: a = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, o, a, [void 0, s, n])
+        }
+        visitDate(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0
+            } = t, n = at(t.nullBitmap), s = yt(r.ArrayType, t.data), {
+                ["length"]: o = s.length / vr(r),
+                ["nullCount"]: a = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, o, a, [void 0, s, n])
+        }
+        visitTimestamp(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0
+            } = t, n = at(t.nullBitmap), s = yt(r.ArrayType, t.data), {
+                ["length"]: o = s.length / vr(r),
+                ["nullCount"]: a = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, o, a, [void 0, s, n])
+        }
+        visitTime(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0
+            } = t, n = at(t.nullBitmap), s = yt(r.ArrayType, t.data), {
+                ["length"]: o = s.length / vr(r),
+                ["nullCount"]: a = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, o, a, [void 0, s, n])
+        }
+        visitDecimal(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0
+            } = t, n = at(t.nullBitmap), s = yt(r.ArrayType, t.data), {
+                ["length"]: o = s.length / vr(r),
+                ["nullCount"]: a = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, o, a, [void 0, s, n])
+        }
+        visitList(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0, ["child"]: n
+            } = t, s = at(t.nullBitmap), o = Yo(t.valueOffsets), {
+                ["length"]: a = o.length - 1,
+                ["nullCount"]: c = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, a, c, [o, void 0, s], [n])
+        }
+        visitStruct(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0, ["children"]: n = []
+            } = t, s = at(t.nullBitmap), {
+                length: o = n.reduce((c, {
+                    length: l
+                }) => Math.max(c, l), 0),
+                nullCount: a = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, o, a, [void 0, void 0, s], n)
+        }
+        visitUnion(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0, ["children"]: n = []
+            } = t, s = yt(r.ArrayType, t.typeIds), {
+                ["length"]: o = s.length,
+                ["nullCount"]: a = -1
+            } = t;
+            if (X.isSparseUnion(r)) return new Ct(r, i, o, a, [void 0, void 0, void 0, s], n);
+            let c = Yo(t.valueOffsets);
+            return new Ct(r, i, o, a, [c, void 0, void 0, s], n)
+        }
+        visitDictionary(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0
+            } = t, n = at(t.nullBitmap), s = yt(r.indices.ArrayType, t.data), {
+                ["dictionary"]: o = new St([new e().visit({
+                    type: r.dictionary
+                })])
+            } = t, {
+                ["length"]: a = s.length,
+                ["nullCount"]: c = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, a, c, [void 0, s, n], [], o)
+        }
+        visitInterval(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0
+            } = t, n = at(t.nullBitmap), s = yt(r.ArrayType, t.data), {
+                ["length"]: o = s.length / vr(r),
+                ["nullCount"]: a = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, o, a, [void 0, s, n])
+        }
+        visitDuration(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0
+            } = t, n = at(t.nullBitmap), s = yt(r.ArrayType, t.data), {
+                ["length"]: o = s.length,
+                ["nullCount"]: a = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, o, a, [void 0, s, n])
+        }
+        visitFixedSizeList(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0, ["child"]: n = new e().visit({
+                    type: r.valueType
+                })
+            } = t, s = at(t.nullBitmap), {
+                ["length"]: o = n.length / vr(r),
+                ["nullCount"]: a = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, o, a, [void 0, void 0, s], [n])
+        }
+        visitMap(t) {
+            let {
+                ["type"]: r, ["offset"]: i = 0, ["child"]: n = new e().visit({
+                    type: r.childType
+                })
+            } = t, s = at(t.nullBitmap), o = Yo(t.valueOffsets), {
+                ["length"]: a = o.length - 1,
+                ["nullCount"]: c = t.nullBitmap ? -1 : 0
+            } = t;
+            return new Ct(r, i, a, c, [o, void 0, s], [n])
+        }
+    },
+    q8 = new uw;
+
+function ft(e) {
+    return q8.visit(e)
+}
+var If = class {
+    constructor(t = 0, r) {
+        this.numChunks = t, this.getChunkIterator = r, this.chunkIndex = 0, this.chunkIterator = this.getChunkIterator(0)
+    }
+    next() {
+        for (; this.chunkIndex < this.numChunks;) {
+            let t = this.chunkIterator.next();
+            if (!t.done) return t;
+            ++this.chunkIndex < this.numChunks && (this.chunkIterator = this.getChunkIterator(this.chunkIndex))
+        }
+        return {
+            done: !0,
+            value: null
+        }
+    } [Symbol.iterator]() {
+        return this
+    }
+};
+
+function rP(e) {
+    return e.some(t => t.nullable)
+}
+
+function lg(e) {
+    return e.reduce((t, r) => t + r.nullCount, 0)
+}
+
+function ug(e) {
+    return e.reduce((t, r, i) => (t[i + 1] = t[i] + r.length, t), new Uint32Array(e.length + 1))
+}
+
+function fg(e, t, r, i) {
+    let n = [];
+    for (let s = -1, o = e.length; ++s < o;) {
+        let a = e[s],
+            c = t[s],
+            {
+                length: l
+            } = a;
+        if (c >= i) break;
+        if (r >= c + l) continue;
+        if (c >= r && c + l <= i) {
+            n.push(a);
+            continue
+        }
+        let u = Math.max(0, r - c),
+            f = Math.min(i - c, l);
+        n.push(a.slice(u, f - u))
+    }
+    return n.length === 0 && n.push(e[0].slice(0, 0)), n
+}
+
+function fw(e, t, r, i) {
+    let n = 0,
+        s = 0,
+        o = t.length - 1;
+    do {
+        if (n >= o - 1) return r < t[o] ? i(e, n, r - t[n]) : null;
+        s = n + Math.trunc((o - n) * .5), r < t[s] ? o = s : n = s
+    } while (n < o)
+}
+
+function Rf(e, t) {
+    return e.getValid(t)
+}
+
+function Oc(e) {
+    function t(r, i, n) {
+        return e(r[i], n)
+    }
+    return function(r) {
+        let i = this.data;
+        return fw(i, this._offsets, r, t)
+    }
+}
+
+function hg(e) {
+    let t;
+
+    function r(i, n, s) {
+        return e(i[n], s, t)
+    }
+    return function(i, n) {
+        let s = this.data;
+        t = n;
+        let o = fw(s, this._offsets, i, r);
+        return t = void 0, o
+    }
+}
+
+function dg(e) {
+    let t;
+
+    function r(i, n, s) {
+        let o = s,
+            a = 0,
+            c = 0;
+        for (let l = n - 1, u = i.length; ++l < u;) {
+            let f = i[l];
+            if (~(a = e(f, t, o))) return c + a;
+            o = 0, c += f.length
+        }
+        return -1
+    }
+    return function(i, n) {
+        t = i;
+        let s = this.data,
+            o = typeof n != "number" ? r(s, 0, 0) : fw(s, this._offsets, n, r);
+        return t = void 0, o
+    }
+}
+var tt = class extends J {};
+
+function Z8(e, t) {
+    return t === null && e.length > 0 ? 0 : -1
+}
+
+function K8(e, t) {
+    let {
+        nullBitmap: r
+    } = e;
+    if (!r || e.nullCount <= 0) return -1;
+    let i = 0;
+    for (let n of new Zo(r, e.offset + (t || 0), e.length, r, cg)) {
+        if (!n) return i;
+        ++i
+    }
+    return -1
+}
+
+function ht(e, t, r) {
+    if (t === void 0) return -1;
+    if (t === null) switch (e.typeId) {
+        case v.Union:
+            break;
+        case v.Dictionary:
+            break;
+        default:
+            return K8(e, r)
+    }
+    let i = fe.getVisitFn(e),
+        n = to(t);
+    for (let s = (r || 0) - 1, o = e.length; ++s < o;)
+        if (n(i(e, s))) return s;
+    return -1
+}
+
+function iP(e, t, r) {
+    let i = fe.getVisitFn(e),
+        n = to(t);
+    for (let s = (r || 0) - 1, o = e.length; ++s < o;)
+        if (n(i(e, s))) return s;
+    return -1
+}
+tt.prototype.visitNull = Z8;
+tt.prototype.visitBool = ht;
+tt.prototype.visitInt = ht;
+tt.prototype.visitInt8 = ht;
+tt.prototype.visitInt16 = ht;
+tt.prototype.visitInt32 = ht;
+tt.prototype.visitInt64 = ht;
+tt.prototype.visitUint8 = ht;
+tt.prototype.visitUint16 = ht;
+tt.prototype.visitUint32 = ht;
+tt.prototype.visitUint64 = ht;
+tt.prototype.visitFloat = ht;
+tt.prototype.visitFloat16 = ht;
+tt.prototype.visitFloat32 = ht;
+tt.prototype.visitFloat64 = ht;
+tt.prototype.visitUtf8 = ht;
+tt.prototype.visitLargeUtf8 = ht;
+tt.prototype.visitBinary = ht;
+tt.prototype.visitLargeBinary = ht;
+tt.prototype.visitFixedSizeBinary = ht;
+tt.prototype.visitDate = ht;
+tt.prototype.visitDateDay = ht;
+tt.prototype.visitDateMillisecond = ht;
+tt.prototype.visitTimestamp = ht;
+tt.prototype.visitTimestampSecond = ht;
+tt.prototype.visitTimestampMillisecond = ht;
+tt.prototype.visitTimestampMicrosecond = ht;
+tt.prototype.visitTimestampNanosecond = ht;
+tt.prototype.visitTime = ht;
+tt.prototype.visitTimeSecond = ht;
+tt.prototype.visitTimeMillisecond = ht;
+tt.prototype.visitTimeMicrosecond = ht;
+tt.prototype.visitTimeNanosecond = ht;
+tt.prototype.visitDecimal = ht;
+tt.prototype.visitList = ht;
+tt.prototype.visitStruct = ht;
+tt.prototype.visitUnion = ht;
+tt.prototype.visitDenseUnion = iP;
+tt.prototype.visitSparseUnion = iP;
+tt.prototype.visitDictionary = ht;
+tt.prototype.visitInterval = ht;
+tt.prototype.visitIntervalDayTime = ht;
+tt.prototype.visitIntervalYearMonth = ht;
+tt.prototype.visitDuration = ht;
+tt.prototype.visitDurationSecond = ht;
+tt.prototype.visitDurationMillisecond = ht;
+tt.prototype.visitDurationMicrosecond = ht;
+tt.prototype.visitDurationNanosecond = ht;
+tt.prototype.visitFixedSizeList = ht;
+tt.prototype.visitMap = ht;
+var Jo = new tt;
+var et = class extends J {};
+
+function lt(e) {
+    let {
+        type: t
+    } = e;
+    if (e.nullCount === 0 && e.stride === 1 && (t.typeId === v.Timestamp || t instanceof se && t.bitWidth !== 64 || t instanceof xi && t.bitWidth !== 64 || t instanceof or && t.precision !== kt.HALF)) return new If(e.data.length, i => {
+        let n = e.data[i];
+        return n.values.subarray(0, n.length)[Symbol.iterator]()
+    });
+    let r = 0;
+    return new If(e.data.length, i => {
+        let s = e.data[i].length,
+            o = e.slice(r, r + s);
+        return r += s, new hw(o)
+    })
+}
+var hw = class {
+    constructor(t) {
+        this.vector = t, this.index = 0
+    }
+    next() {
+        return this.index < this.vector.length ? {
+            value: this.vector.get(this.index++)
+        } : {
+            done: !0,
+            value: null
+        }
+    } [Symbol.iterator]() {
+        return this
+    }
+};
+et.prototype.visitNull = lt;
+et.prototype.visitBool = lt;
+et.prototype.visitInt = lt;
+et.prototype.visitInt8 = lt;
+et.prototype.visitInt16 = lt;
+et.prototype.visitInt32 = lt;
+et.prototype.visitInt64 = lt;
+et.prototype.visitUint8 = lt;
+et.prototype.visitUint16 = lt;
+et.prototype.visitUint32 = lt;
+et.prototype.visitUint64 = lt;
+et.prototype.visitFloat = lt;
+et.prototype.visitFloat16 = lt;
+et.prototype.visitFloat32 = lt;
+et.prototype.visitFloat64 = lt;
+et.prototype.visitUtf8 = lt;
+et.prototype.visitLargeUtf8 = lt;
+et.prototype.visitBinary = lt;
+et.prototype.visitLargeBinary = lt;
+et.prototype.visitFixedSizeBinary = lt;
+et.prototype.visitDate = lt;
+et.prototype.visitDateDay = lt;
+et.prototype.visitDateMillisecond = lt;
+et.prototype.visitTimestamp = lt;
+et.prototype.visitTimestampSecond = lt;
+et.prototype.visitTimestampMillisecond = lt;
+et.prototype.visitTimestampMicrosecond = lt;
+et.prototype.visitTimestampNanosecond = lt;
+et.prototype.visitTime = lt;
+et.prototype.visitTimeSecond = lt;
+et.prototype.visitTimeMillisecond = lt;
+et.prototype.visitTimeMicrosecond = lt;
+et.prototype.visitTimeNanosecond = lt;
+et.prototype.visitDecimal = lt;
+et.prototype.visitList = lt;
+et.prototype.visitStruct = lt;
+et.prototype.visitUnion = lt;
+et.prototype.visitDenseUnion = lt;
+et.prototype.visitSparseUnion = lt;
+et.prototype.visitDictionary = lt;
+et.prototype.visitInterval = lt;
+et.prototype.visitIntervalDayTime = lt;
+et.prototype.visitIntervalYearMonth = lt;
+et.prototype.visitDuration = lt;
+et.prototype.visitDurationSecond = lt;
+et.prototype.visitDurationMillisecond = lt;
+et.prototype.visitDurationMicrosecond = lt;
+et.prototype.visitDurationNanosecond = lt;
+et.prototype.visitFixedSizeList = lt;
+et.prototype.visitMap = lt;
+var Nc = new et;
+var nP, sP = {},
+    oP = {},
+    St = class e {
+        constructor(t) {
+            var r, i, n;
+            let s = t[0] instanceof e ? t.flatMap(a => a.data) : t;
+            if (s.length === 0 || s.some(a => !(a instanceof Ct))) throw new TypeError("Vector constructor expects an Array of Data instances.");
+            let o = (r = s[0]) === null || r === void 0 ? void 0 : r.type;
+            switch (s.length) {
+                case 0:
+                    this._offsets = [0];
+                    break;
+                case 1: {
+                    let {
+                        get: a,
+                        set: c,
+                        indexOf: l
+                    } = sP[o.typeId], u = s[0];
+                    this.isValid = f => Rf(u, f), this.get = f => a(u, f), this.set = (f, h) => c(u, f, h), this.indexOf = f => l(u, f), this._offsets = [0, u.length];
+                    break
+                }
+                default:
+                    Object.setPrototypeOf(this, oP[o.typeId]), this._offsets = ug(s);
+                    break
+            }
+            this.data = s, this.type = o, this.stride = vr(o), this.numChildren = (n = (i = o.children) === null || i === void 0 ? void 0 : i.length) !== null && n !== void 0 ? n : 0, this.length = this._offsets.at(-1)
+        }
+        get byteLength() {
+            return this.data.reduce((t, r) => t + r.byteLength, 0)
+        }
+        get nullable() {
+            return rP(this.data)
+        }
+        get nullCount() {
+            return lg(this.data)
+        }
+        get ArrayType() {
+            return this.type.ArrayType
+        }
+        get[Symbol.toStringTag]() {
+            return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`
+        }
+        get VectorName() {
+            return `${v[this.type.typeId]}Vector`
+        }
+        isValid(t) {
+            return !1
+        }
+        get(t) {
+            return null
+        }
+        set(t, r) {}
+        indexOf(t, r) {
+            return -1
+        }
+        includes(t, r) {
+            return this.indexOf(t, r) > -1
+        } [Symbol.iterator]() {
+            return Nc.visit(this)
+        }
+        concat(...t) {
+            return new e(this.data.concat(t.flatMap(r => r.data).flat(Number.POSITIVE_INFINITY)))
+        }
+        slice(t, r) {
+            return new e(Af(this, t, r, ({
+                data: i,
+                _offsets: n
+            }, s, o) => fg(i, n, s, o)))
+        }
+        toJSON() {
+            return [...this]
+        }
+        toArray() {
+            let {
+                type: t,
+                data: r,
+                length: i,
+                stride: n,
+                ArrayType: s
+            } = this;
+            switch (t.typeId) {
+                case v.Int:
+                case v.Float:
+                case v.Decimal:
+                case v.Time:
+                case v.Timestamp:
+                    switch (r.length) {
+                        case 0:
+                            return new s;
+                        case 1:
+                            return r[0].values.subarray(0, i * n);
+                        default:
+                            return r.reduce((o, {
+                                values: a,
+                                length: c
+                            }) => (o.array.set(a.subarray(0, c * n), o.offset), o.offset += c * n, o), {
+                                array: new s(i * n),
+                                offset: 0
+                            }).array
+                    }
+            }
+            return [...this]
+        }
+        toString() {
+            return `[${[...this].join(",")}]`
+        }
+        getChild(t) {
+            var r;
+            return this.getChildAt((r = this.type.children) === null || r === void 0 ? void 0 : r.findIndex(i => i.name === t))
+        }
+        getChildAt(t) {
+            return t > -1 && t < this.numChildren ? new e(this.data.map(({
+                children: r
+            }) => r[t])) : null
+        }
+        get isMemoized() {
+            return X.isDictionary(this.type) ? this.data[0].dictionary.isMemoized : !1
+        }
+        memoize() {
+            if (X.isDictionary(this.type)) {
+                let t = new pg(this.data[0].dictionary),
+                    r = this.data.map(i => {
+                        let n = i.clone();
+                        return n.dictionary = t, n
+                    });
+                return new e(r)
+            }
+            return new pg(this)
+        }
+        unmemoize() {
+            if (X.isDictionary(this.type) && this.isMemoized) {
+                let t = this.data[0].dictionary.unmemoize(),
+                    r = this.data.map(i => {
+                        let n = i.clone();
+                        return n.dictionary = t, n
+                    });
+                return new e(r)
+            }
+            return this
+        }
+    };
+nP = Symbol.toStringTag;
+St[nP] = (e => {
+    e.type = X.prototype, e.data = [], e.length = 0, e.stride = 1, e.numChildren = 0, e._offsets = new Uint32Array([0]), e[Symbol.isConcatSpreadable] = !0;
+    let t = Object.keys(v).map(r => v[r]).filter(r => typeof r == "number" && r !== v.NONE);
+    for (let r of t) {
+        let i = fe.getVisitFnByTypeId(r),
+            n = Ee.getVisitFnByTypeId(r),
+            s = Jo.getVisitFnByTypeId(r);
+        sP[r] = {
+            get: i,
+            set: n,
+            indexOf: s
+        }, oP[r] = Object.create(e, {
+            isValid: {
+                value: Oc(Rf)
+            },
+            get: {
+                value: Oc(fe.getVisitFnByTypeId(r))
+            },
+            set: {
+                value: hg(Ee.getVisitFnByTypeId(r))
+            },
+            indexOf: {
+                value: dg(Jo.getVisitFnByTypeId(r))
+            }
+        })
+    }
+    return "Vector"
+})(St.prototype);
+var pg = class e extends St {
+    constructor(t) {
+        super(t.data);
+        let r = this.get,
+            i = this.set,
+            n = this.slice,
+            s = new Array(this.length);
+        Object.defineProperty(this, "get", {
+            value(o) {
+                let a = s[o];
+                if (a !== void 0) return a;
+                let c = r.call(this, o);
+                return s[o] = c, c
+            }
+        }), Object.defineProperty(this, "set", {
+            value(o, a) {
+                i.call(this, o, a), s[o] = a
+            }
+        }), Object.defineProperty(this, "slice", {
+            value: (o, a) => new e(n.call(this, o, a))
+        }), Object.defineProperty(this, "isMemoized", {
+            value: !0
+        }), Object.defineProperty(this, "unmemoize", {
+            value: () => new St(this.data)
+        }), Object.defineProperty(this, "memoize", {
+            value: () => this
+        })
+    }
+};
+
+function aP(e) {
+    if (!e || e.length <= 0) return function(n) {
+        return !0
+    };
+    let t = "",
+        r = e.filter(i => i === i);
+    return r.length > 0 && (t = `
+    switch (x) {${r.map(i=>`
+        case ${G8(i)}:`).join("")}
+            return false;
+    }`), e.length !== r.length && (t = `if (x !== x) return false;
+${t}`), new Function("x", `${t}
+return true;`)
+}
+
+function G8(e) {
+    return typeof e != "bigint" ? yi(e) : `${yi(e)}n`
+}
+
+function dw(e, t) {
+    let r = Math.ceil(e) * t - 1;
+    return (r - r % 64 + 64 || 64) / t
+}
+
+function cP(e, t = 0) {
+    return e.length >= t ? e.subarray(0, t) : lf(new e.constructor(t), e, 0)
+}
+var Ei = class {
+        constructor(t, r = 0, i = 1) {
+            this.length = Math.ceil(r / i), this.buffer = new t(this.length), this.stride = i, this.BYTES_PER_ELEMENT = t.BYTES_PER_ELEMENT, this.ArrayType = t
+        }
+        get byteLength() {
+            return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT
+        }
+        get reservedLength() {
+            return this.buffer.length / this.stride
+        }
+        get reservedByteLength() {
+            return this.buffer.byteLength
+        }
+        set(t, r) {
+            return this
+        }
+        append(t) {
+            return this.set(this.length, t)
+        }
+        reserve(t) {
+            if (t > 0) {
+                this.length += t;
+                let r = this.stride,
+                    i = this.length * r,
+                    n = this.buffer.length;
+                i >= n && this._resize(n === 0 ? dw(i * 1, this.BYTES_PER_ELEMENT) : dw(i * 2, this.BYTES_PER_ELEMENT))
+            }
+            return this
+        }
+        flush(t = this.length) {
+            t = dw(t * this.stride, this.BYTES_PER_ELEMENT);
+            let r = cP(this.buffer, t);
+            return this.clear(), r
+        }
+        clear() {
+            return this.length = 0, this.buffer = new this.ArrayType, this
+        }
+        _resize(t) {
+            return this.buffer = cP(this.buffer, t)
+        }
+    },
+    qn = class extends Ei {
+        last() {
+            return this.get(this.length - 1)
+        }
+        get(t) {
+            return this.buffer[t]
+        }
+        set(t, r) {
+            return this.reserve(t - this.length + 1), this.buffer[t * this.stride] = r, this
+        }
+    },
+    Bc = class extends qn {
+        constructor() {
+            super(Uint8Array, 0, 1 / 8), this.numValid = 0
+        }
+        get numInvalid() {
+            return this.length - this.numValid
+        }
+        get(t) {
+            return this.buffer[t >> 3] >> t % 8 & 1
+        }
+        set(t, r) {
+            let {
+                buffer: i
+            } = this.reserve(t - this.length + 1), n = t >> 3, s = t % 8, o = i[n] >> s & 1;
+            return r ? o === 0 && (i[n] |= 1 << s, ++this.numValid) : o === 1 && (i[n] &= ~(1 << s), --this.numValid), this
+        }
+        clear() {
+            return this.numValid = 0, super.clear()
+        }
+    },
+    Fc = class extends qn {
+        constructor(t) {
+            super(t.OffsetArrayType, 1, 1)
+        }
+        append(t) {
+            return this.set(this.length - 1, t)
+        }
+        set(t, r) {
+            let i = this.length - 1,
+                n = this.reserve(t - i + 1).buffer;
+            return i < t++ && i >= 0 && n.fill(n[i], i, t), n[t] = n[t - 1] + r, this
+        }
+        flush(t = this.length - 1) {
+            return t > this.length && this.set(t - 1, this.BYTES_PER_ELEMENT > 4 ? BigInt(0) : 0), super.flush(t + 1)
+        }
+    };
+var $t = class {
+    static throughNode(t) {
+        throw new Error('"throughNode" not available in this environment')
+    }
+    static throughDOM(t) {
+        throw new Error('"throughDOM" not available in this environment')
+    }
+    constructor({
+        type: t,
+        nullValues: r
+    }) {
+        this.length = 0, this.finished = !1, this.type = t, this.children = [], this.nullValues = r, this.stride = vr(t), this._nulls = new Bc, r && r.length > 0 && (this._isValid = aP(r))
+    }
+    toVector() {
+        return new St([this.flush()])
+    }
+    get ArrayType() {
+        return this.type.ArrayType
+    }
+    get nullCount() {
+        return this._nulls.numInvalid
+    }
+    get numChildren() {
+        return this.children.length
+    }
+    get byteLength() {
+        let t = 0,
+            {
+                _offsets: r,
+                _values: i,
+                _nulls: n,
+                _typeIds: s,
+                children: o
+            } = this;
+        return r && (t += r.byteLength), i && (t += i.byteLength), n && (t += n.byteLength), s && (t += s.byteLength), o.reduce((a, c) => a + c.byteLength, t)
+    }
+    get reservedLength() {
+        return this._nulls.reservedLength
+    }
+    get reservedByteLength() {
+        let t = 0;
+        return this._offsets && (t += this._offsets.reservedByteLength), this._values && (t += this._values.reservedByteLength), this._nulls && (t += this._nulls.reservedByteLength), this._typeIds && (t += this._typeIds.reservedByteLength), this.children.reduce((r, i) => r + i.reservedByteLength, t)
+    }
+    get valueOffsets() {
+        return this._offsets ? this._offsets.buffer : null
+    }
+    get values() {
+        return this._values ? this._values.buffer : null
+    }
+    get nullBitmap() {
+        return this._nulls ? this._nulls.buffer : null
+    }
+    get typeIds() {
+        return this._typeIds ? this._typeIds.buffer : null
+    }
+    append(t) {
+        return this.set(this.length, t)
+    }
+    isValid(t) {
+        return this._isValid(t)
+    }
+    set(t, r) {
+        return this.setValid(t, this.isValid(r)) && this.setValue(t, r), this
+    }
+    setValue(t, r) {
+        this._setValue(this, t, r)
+    }
+    setValid(t, r) {
+        return this.length = this._nulls.set(t, +r).length, r
+    }
+    addChild(t, r = `${this.numChildren}`) {
+        throw new Error(`Cannot append children to non-nested type "${this.type}"`)
+    }
+    getChildAt(t) {
+        return this.children[t] || null
+    }
+    flush() {
+        let t, r, i, n, {
+            type: s,
+            length: o,
+            nullCount: a,
+            _typeIds: c,
+            _offsets: l,
+            _values: u,
+            _nulls: f
+        } = this;
+        (r = c?.flush(o)) ? n = l?.flush(o): (n = l?.flush(o)) ? t = u?.flush(l.last()) : t = u?.flush(o), a > 0 && (i = f?.flush(o));
+        let h = this.children.map(d => d.flush());
+        return this.clear(), ft({
+            type: s,
+            length: o,
+            nullCount: a,
+            children: h,
+            child: h[0],
+            data: t,
+            typeIds: r,
+            nullBitmap: i,
+            valueOffsets: n
+        })
+    }
+    finish() {
+        this.finished = !0;
+        for (let t of this.children) t.finish();
+        return this
+    }
+    clear() {
+        var t, r, i, n;
+        this.length = 0, (t = this._nulls) === null || t === void 0 || t.clear(), (r = this._values) === null || r === void 0 || r.clear(), (i = this._offsets) === null || i === void 0 || i.clear(), (n = this._typeIds) === null || n === void 0 || n.clear();
+        for (let s of this.children) s.clear();
+        return this
+    }
+};
+$t.prototype.length = 1;
+$t.prototype.stride = 1;
+$t.prototype.children = null;
+$t.prototype.finished = !1;
+$t.prototype.nullValues = null;
+$t.prototype._isValid = () => !0;
+var he = class extends $t {
+        constructor(t) {
+            super(t), this._values = new qn(this.ArrayType, 0, this.stride)
+        }
+        setValue(t, r) {
+            let i = this._values;
+            return i.reserve(t - i.length + 1), super.setValue(t, r)
+        }
+    },
+    ar = class extends $t {
+        constructor(t) {
+            super(t), this._pendingLength = 0, this._offsets = new Fc(t.type)
+        }
+        setValue(t, r) {
+            let i = this._pending || (this._pending = new Map),
+                n = i.get(t);
+            n && (this._pendingLength -= n.length), this._pendingLength += r instanceof cn ? r[Yr].length : r.length, i.set(t, r)
+        }
+        setValid(t, r) {
+            return super.setValid(t, r) ? !0 : ((this._pending || (this._pending = new Map)).set(t, void 0), !1)
+        }
+        clear() {
+            return this._pendingLength = 0, this._pending = void 0, super.clear()
+        }
+        flush() {
+            return this._flush(), super.flush()
+        }
+        finish() {
+            return this._flush(), super.finish()
+        }
+        _flush() {
+            let t = this._pending,
+                r = this._pendingLength;
+            return this._pendingLength = 0, this._pending = void 0, t && t.size > 0 && this._flushPending(t, r), this
+        }
+    };
+var Qo = class {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    offset() {
+        return this.bb.readInt64(this.bb_pos)
+    }
+    metaDataLength() {
+        return this.bb.readInt32(this.bb_pos + 8)
+    }
+    bodyLength() {
+        return this.bb.readInt64(this.bb_pos + 16)
+    }
+    static sizeOf() {
+        return 24
+    }
+    static createBlock(t, r, i, n) {
+        return t.prep(8, 24), t.writeInt64(BigInt(n ?? 0)), t.pad(4), t.writeInt32(i), t.writeInt64(BigInt(r ?? 0)), t.offset()
+    }
+};
+var Sr = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsFooter(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsFooter(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    version() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt16(this.bb_pos + t) : Bt.V1
+    }
+    schema(t) {
+        let r = this.bb.__offset(this.bb_pos, 6);
+        return r ? (t || new sr).__init(this.bb.__indirect(this.bb_pos + r), this.bb) : null
+    }
+    dictionaries(t, r) {
+        let i = this.bb.__offset(this.bb_pos, 8);
+        return i ? (r || new Qo).__init(this.bb.__vector(this.bb_pos + i) + t * 24, this.bb) : null
+    }
+    dictionariesLength() {
+        let t = this.bb.__offset(this.bb_pos, 8);
+        return t ? this.bb.__vector_len(this.bb_pos + t) : 0
+    }
+    recordBatches(t, r) {
+        let i = this.bb.__offset(this.bb_pos, 10);
+        return i ? (r || new Qo).__init(this.bb.__vector(this.bb_pos + i) + t * 24, this.bb) : null
+    }
+    recordBatchesLength() {
+        let t = this.bb.__offset(this.bb_pos, 10);
+        return t ? this.bb.__vector_len(this.bb_pos + t) : 0
+    }
+    customMetadata(t, r) {
+        let i = this.bb.__offset(this.bb_pos, 12);
+        return i ? (r || new me).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null
+    }
+    customMetadataLength() {
+        let t = this.bb.__offset(this.bb_pos, 12);
+        return t ? this.bb.__vector_len(this.bb_pos + t) : 0
+    }
+    static startFooter(t) {
+        t.startObject(5)
+    }
+    static addVersion(t, r) {
+        t.addFieldInt16(0, r, Bt.V1)
+    }
+    static addSchema(t, r) {
+        t.addFieldOffset(1, r, 0)
+    }
+    static addDictionaries(t, r) {
+        t.addFieldOffset(2, r, 0)
+    }
+    static startDictionariesVector(t, r) {
+        t.startVector(24, r, 8)
+    }
+    static addRecordBatches(t, r) {
+        t.addFieldOffset(3, r, 0)
+    }
+    static startRecordBatchesVector(t, r) {
+        t.startVector(24, r, 8)
+    }
+    static addCustomMetadata(t, r) {
+        t.addFieldOffset(4, r, 0)
+    }
+    static createCustomMetadataVector(t, r) {
+        t.startVector(4, r.length, 4);
+        for (let i = r.length - 1; i >= 0; i--) t.addOffset(r[i]);
+        return t.endVector()
+    }
+    static startCustomMetadataVector(t, r) {
+        t.startVector(4, r, 4)
+    }
+    static endFooter(t) {
+        return t.endObject()
+    }
+    static finishFooterBuffer(t, r) {
+        t.finish(r)
+    }
+    static finishSizePrefixedFooterBuffer(t, r) {
+        t.finish(r, void 0, !0)
+    }
+};
+var Nt = class e {
+    constructor(t = [], r, i, n = Bt.V5) {
+        this.fields = t || [], this.metadata = r || new Map, i || (i = pw(t)), this.dictionaries = i, this.metadataVersion = n
+    }
+    get[Symbol.toStringTag]() {
+        return "Schema"
+    }
+    get names() {
+        return this.fields.map(t => t.name)
+    }
+    toString() {
+        return `Schema<{ ${this.fields.map((t,r)=>`${r}: ${t}`).join(", ")} }>`
+    }
+    select(t) {
+        let r = new Set(t),
+            i = this.fields.filter(n => r.has(n.name));
+        return new e(i, this.metadata)
+    }
+    selectAt(t) {
+        let r = t.map(i => this.fields[i]).filter(Boolean);
+        return new e(r, this.metadata)
+    }
+    assign(...t) {
+        let r = t[0] instanceof e ? t[0] : Array.isArray(t[0]) ? new e(t[0]) : new e(t),
+            i = [...this.fields],
+            n = mg(mg(new Map, this.metadata), r.metadata),
+            s = r.fields.filter(a => {
+                let c = i.findIndex(l => l.name === a.name);
+                return ~c ? (i[c] = a.clone({
+                    metadata: mg(mg(new Map, i[c].metadata), a.metadata)
+                })) && !1 : !0
+            }),
+            o = pw(s, new Map);
+        return new e([...i, ...s], n, new Map([...this.dictionaries, ...o]))
+    }
+};
+Nt.prototype.fields = null;
+Nt.prototype.metadata = null;
+Nt.prototype.dictionaries = null;
+var xt = class e {
+    static new(...t) {
+        let [r, i, n, s] = t;
+        return t[0] && typeof t[0] == "object" && ({
+            name: r
+        } = t[0], i === void 0 && (i = t[0].type), n === void 0 && (n = t[0].nullable), s === void 0 && (s = t[0].metadata)), new e(`${r}`, i, n, s)
+    }
+    constructor(t, r, i = !1, n) {
+        this.name = t, this.type = r, this.nullable = i, this.metadata = n || new Map
+    }
+    get typeId() {
+        return this.type.typeId
+    }
+    get[Symbol.toStringTag]() {
+        return "Field"
+    }
+    toString() {
+        return `${this.name}: ${this.type}`
+    }
+    clone(...t) {
+        let [r, i, n, s] = t;
+        return !t[0] || typeof t[0] != "object" ? [r = this.name, i = this.type, n = this.nullable, s = this.metadata] = t : {
+            name: r = this.name,
+            type: i = this.type,
+            nullable: n = this.nullable,
+            metadata: s = this.metadata
+        } = t[0], e.new(r, i, n, s)
+    }
+};
+xt.prototype.type = null;
+xt.prototype.name = null;
+xt.prototype.nullable = null;
+xt.prototype.metadata = null;
+
+function mg(e, t) {
+    return new Map([...e || new Map, ...t || new Map])
+}
+
+function pw(e, t = new Map) {
+    for (let r = -1, i = e.length; ++r < i;) {
+        let s = e[r].type;
+        if (X.isDictionary(s)) {
+            if (!t.has(s.id)) t.set(s.id, s.dictionary);
+            else if (t.get(s.id) !== s.dictionary) throw new Error("Cannot create Schema containing two different dictionaries with the same Id")
+        }
+        s.children && s.children.length > 0 && pw(s.children, t)
+    }
+    return t
+}
+var J8 = qo,
+    Q8 = xr,
+    Zn = class {
+        static decode(t) {
+            t = new Q8(at(t));
+            let r = Sr.getRootAsFooter(t),
+                i = Nt.decode(r.schema(), new Map, r.version());
+            return new mw(i, r)
+        }
+        static encode(t) {
+            let r = new J8,
+                i = Nt.encode(r, t.schema);
+            Sr.startRecordBatchesVector(r, t.numRecordBatches);
+            for (let o of [...t.recordBatches()].slice().reverse()) Kn.encode(r, o);
+            let n = r.endVector();
+            Sr.startDictionariesVector(r, t.numDictionaries);
+            for (let o of [...t.dictionaryBatches()].slice().reverse()) Kn.encode(r, o);
+            let s = r.endVector();
+            return Sr.startFooter(r), Sr.addSchema(r, i), Sr.addVersion(r, Bt.V5), Sr.addRecordBatches(r, n), Sr.addDictionaries(r, s), Sr.finishFooterBuffer(r, Sr.endFooter(r)), r.asUint8Array()
+        }
+        get numRecordBatches() {
+            return this._recordBatches.length
+        }
+        get numDictionaries() {
+            return this._dictionaryBatches.length
+        }
+        constructor(t, r = Bt.V5, i, n) {
+            this.schema = t, this.version = r, i && (this._recordBatches = i), n && (this._dictionaryBatches = n)
+        }* recordBatches() {
+            for (let t, r = -1, i = this.numRecordBatches; ++r < i;)(t = this.getRecordBatch(r)) && (yield t)
+        }* dictionaryBatches() {
+            for (let t, r = -1, i = this.numDictionaries; ++r < i;)(t = this.getDictionaryBatch(r)) && (yield t)
+        }
+        getRecordBatch(t) {
+            return t >= 0 && t < this.numRecordBatches && this._recordBatches[t] || null
+        }
+        getDictionaryBatch(t) {
+            return t >= 0 && t < this.numDictionaries && this._dictionaryBatches[t] || null
+        }
+    };
+var mw = class extends Zn {
+        get numRecordBatches() {
+            return this._footer.recordBatchesLength()
+        }
+        get numDictionaries() {
+            return this._footer.dictionariesLength()
+        }
+        constructor(t, r) {
+            super(t, r.version()), this._footer = r
+        }
+        getRecordBatch(t) {
+            if (t >= 0 && t < this.numRecordBatches) {
+                let r = this._footer.recordBatches(t);
+                if (r) return Kn.decode(r)
+            }
+            return null
+        }
+        getDictionaryBatch(t) {
+            if (t >= 0 && t < this.numDictionaries) {
+                let r = this._footer.dictionaries(t);
+                if (r) return Kn.decode(r)
+            }
+            return null
+        }
+    },
+    Kn = class e {
+        static decode(t) {
+            return new e(t.metaDataLength(), t.bodyLength(), t.offset())
+        }
+        static encode(t, r) {
+            let {
+                metaDataLength: i
+            } = r, n = BigInt(r.offset), s = BigInt(r.bodyLength);
+            return Qo.createBlock(t, n, i, s)
+        }
+        constructor(t, r, i) {
+            this.metaDataLength = t, this.offset = Kt(i), this.bodyLength = Kt(r)
+        }
+    };
+var Wt = Object.freeze({
+        done: !0,
+        value: void 0
+    }),
+    Mf = class {
+        constructor(t) {
+            this._json = t
+        }
+        get schema() {
+            return this._json.schema
+        }
+        get batches() {
+            return this._json.batches || []
+        }
+        get dictionaries() {
+            return this._json.dictionaries || []
+        }
+    },
+    ta = class {
+        tee() {
+            return this._getDOMStream().tee()
+        }
+        pipe(t, r) {
+            return this._getNodeStream().pipe(t, r)
+        }
+        pipeTo(t, r) {
+            return this._getDOMStream().pipeTo(t, r)
+        }
+        pipeThrough(t, r) {
+            return this._getDOMStream().pipeThrough(t, r)
+        }
+        _getDOMStream() {
+            return this._DOMStream || (this._DOMStream = this.toDOMStream())
+        }
+        _getNodeStream() {
+            return this._nodeStream || (this._nodeStream = this.toNodeStream())
+        }
+    },
+    gg = class extends ta {
+        constructor() {
+            super(), this._values = [], this.resolvers = [], this._closedPromise = new Promise(t => this._closedPromiseResolve = t)
+        }
+        get closed() {
+            return this._closedPromise
+        }
+        cancel(t) {
+            return H(this, void 0, void 0, function*() {
+                yield this.return(t)
+            })
+        }
+        write(t) {
+            this._ensureOpen() && (this.resolvers.length <= 0 ? this._values.push(t) : this.resolvers.shift().resolve({
+                done: !1,
+                value: t
+            }))
+        }
+        abort(t) {
+            this._closedPromiseResolve && (this.resolvers.length <= 0 ? this._error = {
+                error: t
+            } : this.resolvers.shift().reject({
+                done: !0,
+                value: t
+            }))
+        }
+        close() {
+            if (this._closedPromiseResolve) {
+                let {
+                    resolvers: t
+                } = this;
+                for (; t.length > 0;) t.shift().resolve(Wt);
+                this._closedPromiseResolve(), this._closedPromiseResolve = void 0
+            }
+        } [Symbol.asyncIterator]() {
+            return this
+        }
+        toDOMStream(t) {
+            return Ae.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, t)
+        }
+        toNodeStream(t) {
+            return Ae.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, t)
+        }
+        throw (t) {
+            return H(this, void 0, void 0, function*() {
+                return yield this.abort(t), Wt
+            })
+        }
+        return (t) {
+            return H(this, void 0, void 0, function*() {
+                return yield this.close(), Wt
+            })
+        }
+        read(t) {
+            return H(this, void 0, void 0, function*() {
+                return (yield this.next(t, "read")).value
+            })
+        }
+        peek(t) {
+            return H(this, void 0, void 0, function*() {
+                return (yield this.next(t, "peek")).value
+            })
+        }
+        next(...t) {
+            return this._values.length > 0 ? Promise.resolve({
+                done: !1,
+                value: this._values.shift()
+            }) : this._error ? Promise.reject({
+                done: !0,
+                value: this._error.error
+            }) : this._closedPromiseResolve ? new Promise((r, i) => {
+                this.resolvers.push({
+                    resolve: r,
+                    reject: i
+                })
+            }) : Promise.resolve(Wt)
+        }
+        _ensureOpen() {
+            if (this._closedPromiseResolve) return !0;
+            throw new Error("AsyncQueue is closed")
+        }
+    };
+var ln = class extends gg {
+        write(t) {
+            if ((t = at(t)).byteLength > 0) return super.write(t)
+        }
+        toString(t = !1) {
+            return t ? af(this.toUint8Array(!0)) : this.toUint8Array(!1).then(af)
+        }
+        toUint8Array(t = !1) {
+            return t ? br(this._values)[0] : H(this, void 0, void 0, function*() {
+                var r, i, n, s;
+                let o = [],
+                    a = 0;
+                try {
+                    for (var c = !0, l = fi(this), u; u = yield l.next(), r = u.done, !r; c = !0) {
+                        s = u.value, c = !1;
+                        let f = s;
+                        o.push(f), a += f.byteLength
+                    }
+                } catch (f) {
+                    i = {
+                        error: f
+                    }
+                } finally {
+                    try {
+                        !c && !r && (n = l.return) && (yield n.call(l))
+                    } finally {
+                        if (i) throw i.error
+                    }
+                }
+                return br(o, a)[0]
+            })
+        }
+    },
+    un = class {
+        constructor(t) {
+            t && (this.source = new gw(Ae.fromIterable(t)))
+        } [Symbol.iterator]() {
+            return this
+        }
+        next(t) {
+            return this.source.next(t)
+        }
+        throw (t) {
+            return this.source.throw(t)
+        }
+        return (t) {
+            return this.source.return(t)
+        }
+        peek(t) {
+            return this.source.peek(t)
+        }
+        read(t) {
+            return this.source.read(t)
+        }
+    },
+    qr = class e {
+        constructor(t) {
+            t instanceof e ? this.source = t.source : t instanceof ln ? this.source = new Gn(Ae.fromAsyncIterable(t)) : Am(t) ? this.source = new Gn(Ae.fromNodeStream(t)) : cf(t) ? this.source = new Gn(Ae.fromDOMStream(t)) : vm(t) ? this.source = new Gn(Ae.fromDOMStream(t.body)) : hi(t) ? this.source = new Gn(Ae.fromIterable(t)) : yr(t) ? this.source = new Gn(Ae.fromAsyncIterable(t)) : $r(t) && (this.source = new Gn(Ae.fromAsyncIterable(t)))
+        } [Symbol.asyncIterator]() {
+            return this
+        }
+        next(t) {
+            return this.source.next(t)
+        }
+        throw (t) {
+            return this.source.throw(t)
+        }
+        return (t) {
+            return this.source.return(t)
+        }
+        get closed() {
+            return this.source.closed
+        }
+        cancel(t) {
+            return this.source.cancel(t)
+        }
+        peek(t) {
+            return this.source.peek(t)
+        }
+        read(t) {
+            return this.source.read(t)
+        }
+    },
+    gw = class {
+        constructor(t) {
+            this.source = t
+        }
+        cancel(t) {
+            this.return(t)
+        }
+        peek(t) {
+            return this.next(t, "peek").value
+        }
+        read(t) {
+            return this.next(t, "read").value
+        }
+        next(t, r = "read") {
+            return this.source.next({
+                cmd: r,
+                size: t
+            })
+        }
+        throw (t) {
+            return Object.create(this.source.throw && this.source.throw(t) || Wt)
+        }
+        return (t) {
+            return Object.create(this.source.return && this.source.return(t) || Wt)
+        }
+    },
+    Gn = class {
+        constructor(t) {
+            this.source = t, this._closedPromise = new Promise(r => this._closedPromiseResolve = r)
+        }
+        cancel(t) {
+            return H(this, void 0, void 0, function*() {
+                yield this.return(t)
+            })
+        }
+        get closed() {
+            return this._closedPromise
+        }
+        read(t) {
+            return H(this, void 0, void 0, function*() {
+                return (yield this.next(t, "read")).value
+            })
+        }
+        peek(t) {
+            return H(this, void 0, void 0, function*() {
+                return (yield this.next(t, "peek")).value
+            })
+        }
+        next(t, r = "read") {
+            return H(this, void 0, void 0, function*() {
+                return yield this.source.next({
+                    cmd: r,
+                    size: t
+                })
+            })
+        }
+        throw (t) {
+            return H(this, void 0, void 0, function*() {
+                let r = this.source.throw && (yield this.source.throw(t)) || Wt;
+                return this._closedPromiseResolve && this._closedPromiseResolve(), this._closedPromiseResolve = void 0, Object.create(r)
+            })
+        }
+        return (t) {
+            return H(this, void 0, void 0, function*() {
+                let r = this.source.return && (yield this.source.return(t)) || Wt;
+                return this._closedPromiseResolve && this._closedPromiseResolve(), this._closedPromiseResolve = void 0, Object.create(r)
+            })
+        }
+    };
+var Pf = class extends un {
+        constructor(t, r) {
+            super(), this.position = 0, this.buffer = at(t), this.size = r === void 0 ? this.buffer.byteLength : r
+        }
+        readInt32(t) {
+            let {
+                buffer: r,
+                byteOffset: i
+            } = this.readAt(t, 4);
+            return new DataView(r, i).getInt32(0, !0)
+        }
+        seek(t) {
+            return this.position = Math.min(t, this.size), t < this.size
+        }
+        read(t) {
+            let {
+                buffer: r,
+                size: i,
+                position: n
+            } = this;
+            return r && n < i ? (typeof t != "number" && (t = Number.POSITIVE_INFINITY), this.position = Math.min(i, n + Math.min(i - n, t)), r.subarray(n, this.position)) : null
+        }
+        readAt(t, r) {
+            let i = this.buffer,
+                n = Math.min(this.size, t + r);
+            return i ? i.subarray(t, n) : new Uint8Array(r)
+        }
+        close() {
+            this.buffer && (this.buffer = null)
+        }
+        throw (t) {
+            return this.close(), {
+                done: !0,
+                value: t
+            }
+        }
+        return (t) {
+            return this.close(), {
+                done: !0,
+                value: t
+            }
+        }
+    },
+    eo = class extends qr {
+        constructor(t, r) {
+            super(), this.position = 0, this._handle = t, typeof r == "number" ? this.size = r : this._pending = H(this, void 0, void 0, function*() {
+                this.size = (yield t.stat()).size, delete this._pending
+            })
+        }
+        readInt32(t) {
+            return H(this, void 0, void 0, function*() {
+                let {
+                    buffer: r,
+                    byteOffset: i
+                } = yield this.readAt(t, 4);
+                return new DataView(r, i).getInt32(0, !0)
+            })
+        }
+        seek(t) {
+            return H(this, void 0, void 0, function*() {
+                return this._pending && (yield this._pending), this.position = Math.min(t, this.size), t < this.size
+            })
+        }
+        read(t) {
+            return H(this, void 0, void 0, function*() {
+                this._pending && (yield this._pending);
+                let {
+                    _handle: r,
+                    size: i,
+                    position: n
+                } = this;
+                if (r && n < i) {
+                    typeof t != "number" && (t = Number.POSITIVE_INFINITY);
+                    let s = n,
+                        o = 0,
+                        a = 0,
+                        c = Math.min(i, s + Math.min(i - s, t)),
+                        l = new Uint8Array(Math.max(0, (this.position = c) - s));
+                    for (;
+                        (s += a) < c && (o += a) < l.byteLength;)({
+                        bytesRead: a
+                    } = yield r.read(l, o, l.byteLength - o, s));
+                    return l
+                }
+                return null
+            })
+        }
+        readAt(t, r) {
+            return H(this, void 0, void 0, function*() {
+                this._pending && (yield this._pending);
+                let {
+                    _handle: i,
+                    size: n
+                } = this;
+                if (i && t + r < n) {
+                    let s = Math.min(n, t + r),
+                        o = new Uint8Array(s - t);
+                    return (yield i.read(o, 0, r, t)).buffer
+                }
+                return new Uint8Array(r)
+            })
+        }
+        close() {
+            return H(this, void 0, void 0, function*() {
+                let t = this._handle;
+                this._handle = null, t && (yield t.close())
+            })
+        }
+        throw (t) {
+            return H(this, void 0, void 0, function*() {
+                return yield this.close(), {
+                    done: !0,
+                    value: t
+                }
+            })
+        }
+        return (t) {
+            return H(this, void 0, void 0, function*() {
+                return yield this.close(), {
+                    done: !0,
+                    value: t
+                }
+            })
+        }
+    };
+var yw = {};
+Ze(yw, {
+    BaseInt64: () => Cf,
+    Int128: () => Of,
+    Int64: () => Jn,
+    Uint64: () => Gt
+});
+
+function Dc(e) {
+    return e < 0 && (e = 4294967295 + e + 1), `0x${e.toString(16)}`
+}
+var Lc = 8,
+    _w = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8],
+    Cf = class {
+        constructor(t) {
+            this.buffer = t
+        }
+        high() {
+            return this.buffer[1]
+        }
+        low() {
+            return this.buffer[0]
+        }
+        _times(t) {
+            let r = new Uint32Array([this.buffer[1] >>> 16, this.buffer[1] & 65535, this.buffer[0] >>> 16, this.buffer[0] & 65535]),
+                i = new Uint32Array([t.buffer[1] >>> 16, t.buffer[1] & 65535, t.buffer[0] >>> 16, t.buffer[0] & 65535]),
+                n = r[3] * i[3];
+            this.buffer[0] = n & 65535;
+            let s = n >>> 16;
+            return n = r[2] * i[3], s += n, n = r[3] * i[2] >>> 0, s += n, this.buffer[0] += s << 16, this.buffer[1] = s >>> 0 < n ? 65536 : 0, this.buffer[1] += s >>> 16, this.buffer[1] += r[1] * i[3] + r[2] * i[2] + r[3] * i[1], this.buffer[1] += r[0] * i[3] + r[1] * i[2] + r[2] * i[1] + r[3] * i[0] << 16, this
+        }
+        _plus(t) {
+            let r = this.buffer[0] + t.buffer[0] >>> 0;
+            this.buffer[1] += t.buffer[1], r < this.buffer[0] >>> 0 && ++this.buffer[1], this.buffer[0] = r
+        }
+        lessThan(t) {
+            return this.buffer[1] < t.buffer[1] || this.buffer[1] === t.buffer[1] && this.buffer[0] < t.buffer[0]
+        }
+        equals(t) {
+            return this.buffer[1] === t.buffer[1] && this.buffer[0] == t.buffer[0]
+        }
+        greaterThan(t) {
+            return t.lessThan(this)
+        }
+        hex() {
+            return `${Dc(this.buffer[1])} ${Dc(this.buffer[0])}`
+        }
+    },
+    Gt = class e extends Cf {
+        times(t) {
+            return this._times(t), this
+        }
+        plus(t) {
+            return this._plus(t), this
+        }
+        static from(t, r = new Uint32Array(2)) {
+            return e.fromString(typeof t == "string" ? t : t.toString(), r)
+        }
+        static fromNumber(t, r = new Uint32Array(2)) {
+            return e.fromString(t.toString(), r)
+        }
+        static fromString(t, r = new Uint32Array(2)) {
+            let i = t.length,
+                n = new e(r);
+            for (let s = 0; s < i;) {
+                let o = Lc < i - s ? Lc : i - s,
+                    a = new e(new Uint32Array([Number.parseInt(t.slice(s, s + o), 10), 0])),
+                    c = new e(new Uint32Array([_w[o], 0]));
+                n.times(c), n.plus(a), s += o
+            }
+            return n
+        }
+        static convertArray(t) {
+            let r = new Uint32Array(t.length * 2);
+            for (let i = -1, n = t.length; ++i < n;) e.from(t[i], new Uint32Array(r.buffer, r.byteOffset + 2 * i * 4, 2));
+            return r
+        }
+        static multiply(t, r) {
+            return new e(new Uint32Array(t.buffer)).times(r)
+        }
+        static add(t, r) {
+            return new e(new Uint32Array(t.buffer)).plus(r)
+        }
+    },
+    Jn = class e extends Cf {
+        negate() {
+            return this.buffer[0] = ~this.buffer[0] + 1, this.buffer[1] = ~this.buffer[1], this.buffer[0] == 0 && ++this.buffer[1], this
+        }
+        times(t) {
+            return this._times(t), this
+        }
+        plus(t) {
+            return this._plus(t), this
+        }
+        lessThan(t) {
+            let r = this.buffer[1] << 0,
+                i = t.buffer[1] << 0;
+            return r < i || r === i && this.buffer[0] < t.buffer[0]
+        }
+        static from(t, r = new Uint32Array(2)) {
+            return e.fromString(typeof t == "string" ? t : t.toString(), r)
+        }
+        static fromNumber(t, r = new Uint32Array(2)) {
+            return e.fromString(t.toString(), r)
+        }
+        static fromString(t, r = new Uint32Array(2)) {
+            let i = t.startsWith("-"),
+                n = t.length,
+                s = new e(r);
+            for (let o = i ? 1 : 0; o < n;) {
+                let a = Lc < n - o ? Lc : n - o,
+                    c = new e(new Uint32Array([Number.parseInt(t.slice(o, o + a), 10), 0])),
+                    l = new e(new Uint32Array([_w[a], 0]));
+                s.times(l), s.plus(c), o += a
+            }
+            return i ? s.negate() : s
+        }
+        static convertArray(t) {
+            let r = new Uint32Array(t.length * 2);
+            for (let i = -1, n = t.length; ++i < n;) e.from(t[i], new Uint32Array(r.buffer, r.byteOffset + 2 * i * 4, 2));
+            return r
+        }
+        static multiply(t, r) {
+            return new e(new Uint32Array(t.buffer)).times(r)
+        }
+        static add(t, r) {
+            return new e(new Uint32Array(t.buffer)).plus(r)
+        }
+    },
+    Of = class e {
+        constructor(t) {
+            this.buffer = t
+        }
+        high() {
+            return new Jn(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2))
+        }
+        low() {
+            return new Jn(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2))
+        }
+        negate() {
+            return this.buffer[0] = ~this.buffer[0] + 1, this.buffer[1] = ~this.buffer[1], this.buffer[2] = ~this.buffer[2], this.buffer[3] = ~this.buffer[3], this.buffer[0] == 0 && ++this.buffer[1], this.buffer[1] == 0 && ++this.buffer[2], this.buffer[2] == 0 && ++this.buffer[3], this
+        }
+        times(t) {
+            let r = new Gt(new Uint32Array([this.buffer[3], 0])),
+                i = new Gt(new Uint32Array([this.buffer[2], 0])),
+                n = new Gt(new Uint32Array([this.buffer[1], 0])),
+                s = new Gt(new Uint32Array([this.buffer[0], 0])),
+                o = new Gt(new Uint32Array([t.buffer[3], 0])),
+                a = new Gt(new Uint32Array([t.buffer[2], 0])),
+                c = new Gt(new Uint32Array([t.buffer[1], 0])),
+                l = new Gt(new Uint32Array([t.buffer[0], 0])),
+                u = Gt.multiply(s, l);
+            this.buffer[0] = u.low();
+            let f = new Gt(new Uint32Array([u.high(), 0]));
+            return u = Gt.multiply(n, l), f.plus(u), u = Gt.multiply(s, c), f.plus(u), this.buffer[1] = f.low(), this.buffer[3] = f.lessThan(u) ? 1 : 0, this.buffer[2] = f.high(), new Gt(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2)).plus(Gt.multiply(i, l)).plus(Gt.multiply(n, c)).plus(Gt.multiply(s, a)), this.buffer[3] += Gt.multiply(r, l).plus(Gt.multiply(i, c)).plus(Gt.multiply(n, a)).plus(Gt.multiply(s, o)).low(), this
+        }
+        plus(t) {
+            let r = new Uint32Array(4);
+            return r[3] = this.buffer[3] + t.buffer[3] >>> 0, r[2] = this.buffer[2] + t.buffer[2] >>> 0, r[1] = this.buffer[1] + t.buffer[1] >>> 0, r[0] = this.buffer[0] + t.buffer[0] >>> 0, r[0] < this.buffer[0] >>> 0 && ++r[1], r[1] < this.buffer[1] >>> 0 && ++r[2], r[2] < this.buffer[2] >>> 0 && ++r[3], this.buffer[3] = r[3], this.buffer[2] = r[2], this.buffer[1] = r[1], this.buffer[0] = r[0], this
+        }
+        hex() {
+            return `${Dc(this.buffer[3])} ${Dc(this.buffer[2])} ${Dc(this.buffer[1])} ${Dc(this.buffer[0])}`
+        }
+        static multiply(t, r) {
+            return new e(new Uint32Array(t.buffer)).times(r)
+        }
+        static add(t, r) {
+            return new e(new Uint32Array(t.buffer)).plus(r)
+        }
+        static from(t, r = new Uint32Array(4)) {
+            return e.fromString(typeof t == "string" ? t : t.toString(), r)
+        }
+        static fromNumber(t, r = new Uint32Array(4)) {
+            return e.fromString(t.toString(), r)
+        }
+        static fromString(t, r = new Uint32Array(4)) {
+            let i = t.startsWith("-"),
+                n = t.length,
+                s = new e(r);
+            for (let o = i ? 1 : 0; o < n;) {
+                let a = Lc < n - o ? Lc : n - o,
+                    c = new e(new Uint32Array([Number.parseInt(t.slice(o, o + a), 10), 0, 0, 0])),
+                    l = new e(new Uint32Array([_w[a], 0, 0, 0]));
+                s.times(l), s.plus(c), o += a
+            }
+            return i ? s.negate() : s
+        }
+        static convertArray(t) {
+            let r = new Uint32Array(t.length * 4);
+            for (let i = -1, n = t.length; ++i < n;) e.from(t[i], new Uint32Array(r.buffer, r.byteOffset + 4 * 4 * i, 4));
+            return r
+        }
+    };
+var Nf = class extends J {
+        constructor(t, r, i, n, s = Bt.V5) {
+            super(), this.nodesIndex = -1, this.buffersIndex = -1, this.bytes = t, this.nodes = r, this.buffers = i, this.dictionaries = n, this.metadataVersion = s
+        }
+        visit(t) {
+            return super.visit(t instanceof xt ? t.type : t)
+        }
+        visitNull(t, {
+            length: r
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r
+            })
+        }
+        visitBool(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                data: this.readData(t)
+            })
+        }
+        visitInt(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                data: this.readData(t)
+            })
+        }
+        visitFloat(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                data: this.readData(t)
+            })
+        }
+        visitUtf8(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                valueOffsets: this.readOffsets(t),
+                data: this.readData(t)
+            })
+        }
+        visitLargeUtf8(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                valueOffsets: this.readOffsets(t),
+                data: this.readData(t)
+            })
+        }
+        visitBinary(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                valueOffsets: this.readOffsets(t),
+                data: this.readData(t)
+            })
+        }
+        visitLargeBinary(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                valueOffsets: this.readOffsets(t),
+                data: this.readData(t)
+            })
+        }
+        visitFixedSizeBinary(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                data: this.readData(t)
+            })
+        }
+        visitDate(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                data: this.readData(t)
+            })
+        }
+        visitTimestamp(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                data: this.readData(t)
+            })
+        }
+        visitTime(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                data: this.readData(t)
+            })
+        }
+        visitDecimal(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                data: this.readData(t)
+            })
+        }
+        visitList(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                valueOffsets: this.readOffsets(t),
+                child: this.visit(t.children[0])
+            })
+        }
+        visitStruct(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                children: this.visitMany(t.children)
+            })
+        }
+        visitUnion(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return this.metadataVersion < Bt.V5 && this.readNullBitmap(t, i), t.mode === Vt.Sparse ? this.visitSparseUnion(t, {
+                length: r,
+                nullCount: i
+            }) : this.visitDenseUnion(t, {
+                length: r,
+                nullCount: i
+            })
+        }
+        visitDenseUnion(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                typeIds: this.readTypeIds(t),
+                valueOffsets: this.readOffsets(t),
+                children: this.visitMany(t.children)
+            })
+        }
+        visitSparseUnion(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                typeIds: this.readTypeIds(t),
+                children: this.visitMany(t.children)
+            })
+        }
+        visitDictionary(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                data: this.readData(t.indices),
+                dictionary: this.readDictionary(t)
+            })
+        }
+        visitInterval(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                data: this.readData(t)
+            })
+        }
+        visitDuration(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                data: this.readData(t)
+            })
+        }
+        visitFixedSizeList(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                child: this.visit(t.children[0])
+            })
+        }
+        visitMap(t, {
+            length: r,
+            nullCount: i
+        } = this.nextFieldNode()) {
+            return ft({
+                type: t,
+                length: r,
+                nullCount: i,
+                nullBitmap: this.readNullBitmap(t, i),
+                valueOffsets: this.readOffsets(t),
+                child: this.visit(t.children[0])
+            })
+        }
+        nextFieldNode() {
+            return this.nodes[++this.nodesIndex]
+        }
+        nextBufferRange() {
+            return this.buffers[++this.buffersIndex]
+        }
+        readNullBitmap(t, r, i = this.nextBufferRange()) {
+            return r > 0 && this.readData(t, i) || new Uint8Array(0)
+        }
+        readOffsets(t, r) {
+            return this.readData(t, r)
+        }
+        readTypeIds(t, r) {
+            return this.readData(t, r)
+        }
+        readData(t, {
+            length: r,
+            offset: i
+        } = this.nextBufferRange()) {
+            return this.bytes.subarray(i, i + r)
+        }
+        readDictionary(t) {
+            return this.dictionaries.get(t.id)
+        }
+    },
+    _g = class extends Nf {
+        constructor(t, r, i, n, s) {
+            super(new Uint8Array(0), r, i, n, s), this.sources = t
+        }
+        readNullBitmap(t, r, {
+            offset: i
+        } = this.nextBufferRange()) {
+            return r <= 0 ? new Uint8Array(0) : Go(this.sources[i])
+        }
+        readOffsets(t, {
+            offset: r
+        } = this.nextBufferRange()) {
+            return yt(Uint8Array, yt(t.OffsetArrayType, this.sources[r]))
+        }
+        readTypeIds(t, {
+            offset: r
+        } = this.nextBufferRange()) {
+            return yt(Uint8Array, yt(t.ArrayType, this.sources[r]))
+        }
+        readData(t, {
+            offset: r
+        } = this.nextBufferRange()) {
+            let {
+                sources: i
+            } = this;
+            return X.isTimestamp(t) ? yt(Uint8Array, Jn.convertArray(i[r])) : (X.isInt(t) || X.isTime(t)) && t.bitWidth === 64 || X.isDuration(t) ? yt(Uint8Array, Jn.convertArray(i[r])) : X.isDate(t) && t.unit === ue.MILLISECOND ? yt(Uint8Array, Jn.convertArray(i[r])) : X.isDecimal(t) ? yt(Uint8Array, Of.convertArray(i[r])) : X.isBinary(t) || X.isLargeBinary(t) || X.isFixedSizeBinary(t) ? tV(i[r]) : X.isBool(t) ? Go(i[r]) : X.isUtf8(t) || X.isLargeUtf8(t) ? en(i[r].join("")) : yt(Uint8Array, yt(t.ArrayType, i[r].map(n => +n)))
+        }
+    };
+
+function tV(e) {
+    let t = e.join(""),
+        r = new Uint8Array(t.length / 2);
+    for (let i = 0; i < t.length; i += 2) r[i >> 1] = Number.parseInt(t.slice(i, i + 2), 16);
+    return r
+}
+var kc = class extends ar {
+    constructor(t) {
+        super(t), this._values = new Ei(Uint8Array)
+    }
+    get byteLength() {
+        let t = this._pendingLength + this.length * 4;
+        return this._offsets && (t += this._offsets.byteLength), this._values && (t += this._values.byteLength), this._nulls && (t += this._nulls.byteLength), t
+    }
+    setValue(t, r) {
+        return super.setValue(t, at(r))
+    }
+    _flushPending(t, r) {
+        let i = this._offsets,
+            n = this._values.reserve(r).buffer,
+            s = 0;
+        for (let [o, a] of t)
+            if (a === void 0) i.set(o, 0);
+            else {
+                let c = a.length;
+                n.set(a, s), i.set(o, c), s += c
+            }
+    }
+};
+var Uc = class extends ar {
+    constructor(t) {
+        super(t), this._values = new Ei(Uint8Array)
+    }
+    get byteLength() {
+        let t = this._pendingLength + this.length * 4;
+        return this._offsets && (t += this._offsets.byteLength), this._values && (t += this._values.byteLength), this._nulls && (t += this._nulls.byteLength), t
+    }
+    setValue(t, r) {
+        return super.setValue(t, at(r))
+    }
+    _flushPending(t, r) {
+        let i = this._offsets,
+            n = this._values.reserve(r).buffer,
+            s = 0;
+        for (let [o, a] of t)
+            if (a === void 0) i.set(o, BigInt(0));
+            else {
+                let c = a.length;
+                n.set(a, s), i.set(o, BigInt(c)), s += c
+            }
+    }
+};
+var yg = class extends $t {
+    constructor(t) {
+        super(t), this._values = new Bc
+    }
+    setValue(t, r) {
+        this._values.set(t, +r)
+    }
+};
+var ea = class extends he {};
+ea.prototype._setValue = Gx;
+var Bf = class extends ea {};
+Bf.prototype._setValue = Hm;
+var Ff = class extends ea {};
+Ff.prototype._setValue = $m;
+var Df = class extends he {};
+Df.prototype._setValue = tw;
+var bg = class extends $t {
+    constructor({
+        type: t,
+        nullValues: r,
+        dictionaryHashFunction: i
+    }) {
+        super({
+            type: new Tr(t.dictionary, t.indices, t.id, t.isOrdered)
+        }), this._nulls = null, this._dictionaryOffset = 0, this._keysToIndices = Object.create(null), this.indices = ra({
+            type: this.type.indices,
+            nullValues: r
+        }), this.dictionary = ra({
+            type: this.type.dictionary,
+            nullValues: null
+        }), typeof i == "function" && (this.valueToKey = i)
+    }
+    get values() {
+        return this.indices.values
+    }
+    get nullCount() {
+        return this.indices.nullCount
+    }
+    get nullBitmap() {
+        return this.indices.nullBitmap
+    }
+    get byteLength() {
+        return this.indices.byteLength + this.dictionary.byteLength
+    }
+    get reservedLength() {
+        return this.indices.reservedLength + this.dictionary.reservedLength
+    }
+    get reservedByteLength() {
+        return this.indices.reservedByteLength + this.dictionary.reservedByteLength
+    }
+    isValid(t) {
+        return this.indices.isValid(t)
+    }
+    setValid(t, r) {
+        let i = this.indices;
+        return r = i.setValid(t, r), this.length = i.length, r
+    }
+    setValue(t, r) {
+        let i = this._keysToIndices,
+            n = this.valueToKey(r),
+            s = i[n];
+        return s === void 0 && (i[n] = s = this._dictionaryOffset + this.dictionary.append(r).length - 1), this.indices.setValue(t, s)
+    }
+    flush() {
+        let t = this.type,
+            r = this._dictionary,
+            i = this.dictionary.toVector(),
+            n = this.indices.flush().clone(t);
+        return n.dictionary = r ? r.concat(i) : i, this.finished || (this._dictionaryOffset += i.length), this._dictionary = n.dictionary, this.clear(), n
+    }
+    finish() {
+        return this.indices.finish(), this.dictionary.finish(), this._dictionaryOffset = 0, this._keysToIndices = Object.create(null), super.finish()
+    }
+    clear() {
+        return this.indices.clear(), this.dictionary.clear(), super.clear()
+    }
+    valueToKey(t) {
+        return typeof t == "string" ? t : `${t}`
+    }
+};
+var Lf = class extends he {};
+Lf.prototype._setValue = Kx;
+var xg = class extends $t {
+    setValue(t, r) {
+        let [i] = this.children, n = t * this.stride;
+        for (let s = -1, o = r.length; ++s < o;) i.set(n + s, r[s])
+    }
+    addChild(t, r = "0") {
+        if (this.numChildren > 0) throw new Error("FixedSizeListBuilder can only have one child.");
+        let i = this.children.push(t);
+        return this.type = new vi(this.type.listSize, new xt(r, t.type, !0)), i
+    }
+};
+var ia = class extends he {
+        setValue(t, r) {
+            this._values.set(t, r)
+        }
+    },
+    wg = class extends ia {
+        setValue(t, r) {
+            super.setValue(t, Sf(r))
+        }
+    },
+    Tg = class extends ia {},
+    vg = class extends ia {};
+var na = class extends he {};
+na.prototype._setValue = ew;
+var kf = class extends na {};
+kf.prototype._setValue = tg;
+var Uf = class extends na {};
+Uf.prototype._setValue = eg;
+var Qn = class extends he {};
+Qn.prototype._setValue = rw;
+var Vf = class extends Qn {};
+Vf.prototype._setValue = rg;
+var zf = class extends Qn {};
+zf.prototype._setValue = ig;
+var Wf = class extends Qn {};
+Wf.prototype._setValue = ng;
+var jf = class extends Qn {};
+jf.prototype._setValue = sg;
+var Zr = class extends he {
+        setValue(t, r) {
+            this._values.set(t, r)
+        }
+    },
+    Sg = class extends Zr {},
+    Ag = class extends Zr {},
+    Eg = class extends Zr {},
+    Ig = class extends Zr {},
+    Rg = class extends Zr {},
+    Mg = class extends Zr {},
+    Pg = class extends Zr {},
+    Cg = class extends Zr {};
+var Og = class extends ar {
+    constructor(t) {
+        super(t), this._offsets = new Fc(t.type)
+    }
+    addChild(t, r = "0") {
+        if (this.numChildren > 0) throw new Error("ListBuilder can only have one child.");
+        return this.children[this.numChildren] = t, this.type = new wi(new xt(r, t.type, !0)), this.numChildren - 1
+    }
+    _flushPending(t) {
+        let r = this._offsets,
+            [i] = this.children;
+        for (let [n, s] of t)
+            if (typeof s > "u") r.set(n, 0);
+            else {
+                let o = s,
+                    a = o.length,
+                    c = r.set(n, a).buffer[n];
+                for (let l = -1; ++l < a;) i.set(c + l, o[l])
+            }
+    }
+};
+var Ng = class extends ar {
+    set(t, r) {
+        return super.set(t, r)
+    }
+    setValue(t, r) {
+        let i = r instanceof Map ? r : new Map(Object.entries(r)),
+            n = this._pending || (this._pending = new Map),
+            s = n.get(t);
+        s && (this._pendingLength -= s.size), this._pendingLength += i.size, n.set(t, i)
+    }
+    addChild(t, r = `${this.numChildren}`) {
+        if (this.numChildren > 0) throw new Error("ListBuilder can only have one child.");
+        return this.children[this.numChildren] = t, this.type = new Si(new xt(r, t.type, !0), this.type.keysSorted), this.numChildren - 1
+    }
+    _flushPending(t) {
+        let r = this._offsets,
+            [i] = this.children;
+        for (let [n, s] of t)
+            if (s === void 0) r.set(n, 0);
+            else {
+                let {
+                    [n]: o, [n + 1]: a
+                } = r.set(n, s.size).buffer;
+                for (let c of s.entries())
+                    if (i.set(o, c), ++o >= a) break
+            }
+    }
+};
+var Bg = class extends $t {
+    setValue(t, r) {}
+    setValid(t, r) {
+        return this.length = Math.max(t + 1, this.length), r
+    }
+};
+var Fg = class extends $t {
+    setValue(t, r) {
+        let {
+            children: i,
+            type: n
+        } = this;
+        switch (Array.isArray(r) || r.constructor) {
+            case !0:
+                return n.children.forEach((s, o) => i[o].set(t, r[o]));
+            case Map:
+                return n.children.forEach((s, o) => i[o].set(t, r.get(s.name)));
+            default:
+                return n.children.forEach((s, o) => i[o].set(t, r[s.name]))
+        }
+    }
+    setValid(t, r) {
+        return super.setValid(t, r) || this.children.forEach(i => i.setValid(t, r)), r
+    }
+    addChild(t, r = `${this.numChildren}`) {
+        let i = this.children.push(t);
+        return this.type = new zt([...this.type.children, new xt(r, t.type, !0)]), i
+    }
+};
+var ts = class extends he {};
+ts.prototype._setValue = Jx;
+var Hf = class extends ts {};
+Hf.prototype._setValue = Xm;
+var $f = class extends ts {};
+$f.prototype._setValue = Ym;
+var Xf = class extends ts {};
+Xf.prototype._setValue = qm;
+var Yf = class extends ts {};
+Yf.prototype._setValue = Zm;
+var es = class extends he {};
+es.prototype._setValue = Qx;
+var qf = class extends es {};
+qf.prototype._setValue = Km;
+var Zf = class extends es {};
+Zf.prototype._setValue = Gm;
+var Kf = class extends es {};
+Kf.prototype._setValue = Jm;
+var Gf = class extends es {};
+Gf.prototype._setValue = Qm;
+var Vc = class extends $t {
+        constructor(t) {
+            super(t), this._typeIds = new qn(Int8Array, 0, 1), typeof t.valueToChildTypeId == "function" && (this._valueToChildTypeId = t.valueToChildTypeId)
+        }
+        get typeIdToChildIndex() {
+            return this.type.typeIdToChildIndex
+        }
+        append(t, r) {
+            return this.set(this.length, t, r)
+        }
+        set(t, r, i) {
+            return i === void 0 && (i = this._valueToChildTypeId(this, r, t)), this.setValue(t, r, i), this
+        }
+        setValue(t, r, i) {
+            this._typeIds.set(t, i);
+            let n = this.type.typeIdToChildIndex[i],
+                s = this.children[n];
+            s?.set(t, r)
+        }
+        addChild(t, r = `${this.children.length}`) {
+            let i = this.children.push(t),
+                {
+                    type: {
+                        children: n,
+                        mode: s,
+                        typeIds: o
+                    }
+                } = this,
+                a = [...n, new xt(r, t.type)];
+            return this.type = new Ti(s, [...o, i], a), i
+        }
+        _valueToChildTypeId(t, r, i) {
+            throw new Error("Cannot map UnionBuilder value to child typeId. Pass the `childTypeId` as the second argument to unionBuilder.append(), or supply a `valueToChildTypeId` function as part of the UnionBuilder constructor options.")
+        }
+    },
+    Dg = class extends Vc {},
+    Lg = class extends Vc {
+        constructor(t) {
+            super(t), this._offsets = new qn(Int32Array)
+        }
+        setValue(t, r, i) {
+            let n = this._typeIds.set(t, i).buffer[t],
+                s = this.getChildAt(this.type.typeIdToChildIndex[n]),
+                o = this._offsets.set(t, s.length).buffer[t];
+            s?.set(o, r)
+        }
+    };
+var Jf = class extends ar {
+    constructor(t) {
+        super(t), this._values = new Ei(Uint8Array)
+    }
+    get byteLength() {
+        let t = this._pendingLength + this.length * 4;
+        return this._offsets && (t += this._offsets.byteLength), this._values && (t += this._values.byteLength), this._nulls && (t += this._nulls.byteLength), t
+    }
+    setValue(t, r) {
+        return super.setValue(t, en(r))
+    }
+    _flushPending(t, r) {}
+};
+Jf.prototype._flushPending = kc.prototype._flushPending;
+var Qf = class extends ar {
+    constructor(t) {
+        super(t), this._values = new Ei(Uint8Array)
+    }
+    get byteLength() {
+        let t = this._pendingLength + this.length * 4;
+        return this._offsets && (t += this._offsets.byteLength), this._values && (t += this._values.byteLength), this._nulls && (t += this._nulls.byteLength), t
+    }
+    setValue(t, r) {
+        return super.setValue(t, en(r))
+    }
+    _flushPending(t, r) {}
+};
+Qf.prototype._flushPending = Uc.prototype._flushPending;
+var bw = class extends J {
+        visitNull() {
+            return Bg
+        }
+        visitBool() {
+            return yg
+        }
+        visitInt() {
+            return Zr
+        }
+        visitInt8() {
+            return Sg
+        }
+        visitInt16() {
+            return Ag
+        }
+        visitInt32() {
+            return Eg
+        }
+        visitInt64() {
+            return Ig
+        }
+        visitUint8() {
+            return Rg
+        }
+        visitUint16() {
+            return Mg
+        }
+        visitUint32() {
+            return Pg
+        }
+        visitUint64() {
+            return Cg
+        }
+        visitFloat() {
+            return ia
+        }
+        visitFloat16() {
+            return wg
+        }
+        visitFloat32() {
+            return Tg
+        }
+        visitFloat64() {
+            return vg
+        }
+        visitUtf8() {
+            return Jf
+        }
+        visitLargeUtf8() {
+            return Qf
+        }
+        visitBinary() {
+            return kc
+        }
+        visitLargeBinary() {
+            return Uc
+        }
+        visitFixedSizeBinary() {
+            return Lf
+        }
+        visitDate() {
+            return ea
+        }
+        visitDateDay() {
+            return Bf
+        }
+        visitDateMillisecond() {
+            return Ff
+        }
+        visitTimestamp() {
+            return ts
+        }
+        visitTimestampSecond() {
+            return Hf
+        }
+        visitTimestampMillisecond() {
+            return $f
+        }
+        visitTimestampMicrosecond() {
+            return Xf
+        }
+        visitTimestampNanosecond() {
+            return Yf
+        }
+        visitTime() {
+            return es
+        }
+        visitTimeSecond() {
+            return qf
+        }
+        visitTimeMillisecond() {
+            return Zf
+        }
+        visitTimeMicrosecond() {
+            return Kf
+        }
+        visitTimeNanosecond() {
+            return Gf
+        }
+        visitDecimal() {
+            return Df
+        }
+        visitList() {
+            return Og
+        }
+        visitStruct() {
+            return Fg
+        }
+        visitUnion() {
+            return Vc
+        }
+        visitDenseUnion() {
+            return Lg
+        }
+        visitSparseUnion() {
+            return Dg
+        }
+        visitDictionary() {
+            return bg
+        }
+        visitInterval() {
+            return na
+        }
+        visitIntervalDayTime() {
+            return kf
+        }
+        visitIntervalYearMonth() {
+            return Uf
+        }
+        visitDuration() {
+            return Qn
+        }
+        visitDurationSecond() {
+            return Vf
+        }
+        visitDurationMillisecond() {
+            return zf
+        }
+        visitDurationMicrosecond() {
+            return Wf
+        }
+        visitDurationNanosecond() {
+            return jf
+        }
+        visitFixedSizeList() {
+            return xg
+        }
+        visitMap() {
+            return Ng
+        }
+    },
+    lP = new bw;
+var rt = class extends J {
+    compareSchemas(t, r) {
+        return t === r || r instanceof t.constructor && this.compareManyFields(t.fields, r.fields)
+    }
+    compareManyFields(t, r) {
+        return t === r || Array.isArray(t) && Array.isArray(r) && t.length === r.length && t.every((i, n) => this.compareFields(i, r[n]))
+    }
+    compareFields(t, r) {
+        return t === r || r instanceof t.constructor && t.name === r.name && t.nullable === r.nullable && this.visit(t.type, r.type)
+    }
+};
+
+function $e(e, t) {
+    return t instanceof e.constructor
+}
+
+function sa(e, t) {
+    return e === t || $e(e, t)
+}
+
+function rs(e, t) {
+    return e === t || $e(e, t) && e.bitWidth === t.bitWidth && e.isSigned === t.isSigned
+}
+
+function kg(e, t) {
+    return e === t || $e(e, t) && e.precision === t.precision
+}
+
+function eV(e, t) {
+    return e === t || $e(e, t) && e.byteWidth === t.byteWidth
+}
+
+function xw(e, t) {
+    return e === t || $e(e, t) && e.unit === t.unit
+}
+
+function th(e, t) {
+    return e === t || $e(e, t) && e.unit === t.unit && e.timezone === t.timezone
+}
+
+function eh(e, t) {
+    return e === t || $e(e, t) && e.unit === t.unit && e.bitWidth === t.bitWidth
+}
+
+function rV(e, t) {
+    return e === t || $e(e, t) && e.children.length === t.children.length && fn.compareManyFields(e.children, t.children)
+}
+
+function iV(e, t) {
+    return e === t || $e(e, t) && e.children.length === t.children.length && fn.compareManyFields(e.children, t.children)
+}
+
+function ww(e, t) {
+    return e === t || $e(e, t) && e.mode === t.mode && e.typeIds.every((r, i) => r === t.typeIds[i]) && fn.compareManyFields(e.children, t.children)
+}
+
+function nV(e, t) {
+    return e === t || $e(e, t) && e.id === t.id && e.isOrdered === t.isOrdered && fn.visit(e.indices, t.indices) && fn.visit(e.dictionary, t.dictionary)
+}
+
+function Tw(e, t) {
+    return e === t || $e(e, t) && e.unit === t.unit
+}
+
+function rh(e, t) {
+    return e === t || $e(e, t) && e.unit === t.unit
+}
+
+function sV(e, t) {
+    return e === t || $e(e, t) && e.listSize === t.listSize && e.children.length === t.children.length && fn.compareManyFields(e.children, t.children)
+}
+
+function oV(e, t) {
+    return e === t || $e(e, t) && e.keysSorted === t.keysSorted && e.children.length === t.children.length && fn.compareManyFields(e.children, t.children)
+}
+rt.prototype.visitNull = sa;
+rt.prototype.visitBool = sa;
+rt.prototype.visitInt = rs;
+rt.prototype.visitInt8 = rs;
+rt.prototype.visitInt16 = rs;
+rt.prototype.visitInt32 = rs;
+rt.prototype.visitInt64 = rs;
+rt.prototype.visitUint8 = rs;
+rt.prototype.visitUint16 = rs;
+rt.prototype.visitUint32 = rs;
+rt.prototype.visitUint64 = rs;
+rt.prototype.visitFloat = kg;
+rt.prototype.visitFloat16 = kg;
+rt.prototype.visitFloat32 = kg;
+rt.prototype.visitFloat64 = kg;
+rt.prototype.visitUtf8 = sa;
+rt.prototype.visitLargeUtf8 = sa;
+rt.prototype.visitBinary = sa;
+rt.prototype.visitLargeBinary = sa;
+rt.prototype.visitFixedSizeBinary = eV;
+rt.prototype.visitDate = xw;
+rt.prototype.visitDateDay = xw;
+rt.prototype.visitDateMillisecond = xw;
+rt.prototype.visitTimestamp = th;
+rt.prototype.visitTimestampSecond = th;
+rt.prototype.visitTimestampMillisecond = th;
+rt.prototype.visitTimestampMicrosecond = th;
+rt.prototype.visitTimestampNanosecond = th;
+rt.prototype.visitTime = eh;
+rt.prototype.visitTimeSecond = eh;
+rt.prototype.visitTimeMillisecond = eh;
+rt.prototype.visitTimeMicrosecond = eh;
+rt.prototype.visitTimeNanosecond = eh;
+rt.prototype.visitDecimal = sa;
+rt.prototype.visitList = rV;
+rt.prototype.visitStruct = iV;
+rt.prototype.visitUnion = ww;
+rt.prototype.visitDenseUnion = ww;
+rt.prototype.visitSparseUnion = ww;
+rt.prototype.visitDictionary = nV;
+rt.prototype.visitInterval = Tw;
+rt.prototype.visitIntervalDayTime = Tw;
+rt.prototype.visitIntervalYearMonth = Tw;
+rt.prototype.visitDuration = rh;
+rt.prototype.visitDurationSecond = rh;
+rt.prototype.visitDurationMillisecond = rh;
+rt.prototype.visitDurationMicrosecond = rh;
+rt.prototype.visitDurationNanosecond = rh;
+rt.prototype.visitFixedSizeList = sV;
+rt.prototype.visitMap = oV;
+var fn = new rt;
+
+function oa(e, t) {
+    return fn.compareSchemas(e, t)
+}
+
+function uP(e, t) {
+    return fn.compareFields(e, t)
+}
+
+function fP(e, t) {
+    return fn.visit(e, t)
+}
+
+function ra(e) {
+    let t = e.type,
+        r = new(lP.getVisitFn(t)())(e);
+    if (t.children && t.children.length > 0) {
+        let i = e.children || [],
+            n = {
+                nullValues: e.nullValues
+            },
+            s = Array.isArray(i) ? (o, a) => i[a] || n : ({
+                name: o
+            }) => i[o] || n;
+        for (let [o, a] of t.children.entries()) {
+            let {
+                type: c
+            } = a, l = s(a, o);
+            r.children.push(ra(Object.assign(Object.assign({}, l), {
+                type: c
+            })))
+        }
+    }
+    return r
+}
+
+function Ug(e, t) {
+    return aV(e, t.map(r => r.data.concat()))
+}
+
+function aV(e, t) {
+    let r = [...e.fields],
+        i = [],
+        n = {
+            numBatches: t.reduce((f, h) => Math.max(f, h.length), 0)
+        },
+        s = 0,
+        o = 0,
+        a = -1,
+        c = t.length,
+        l, u = [];
+    for (; n.numBatches-- > 0;) {
+        for (o = Number.POSITIVE_INFINITY, a = -1; ++a < c;) u[a] = l = t[a].shift(), o = Math.min(o, l ? l.length : o);
+        Number.isFinite(o) && (u = cV(r, o, u, t, n), o > 0 && (i[s++] = ft({
+            type: new zt(r),
+            length: o,
+            nullCount: 0,
+            children: u.slice()
+        })))
+    }
+    return [e = e.assign(r), i.map(f => new ee(e, f))]
+}
+
+function cV(e, t, r, i, n) {
+    var s;
+    let o = (t + 63 & -64) >> 3;
+    for (let a = -1, c = i.length; ++a < c;) {
+        let l = r[a],
+            u = l?.length;
+        if (u >= t) u === t ? r[a] = l : (r[a] = l.slice(0, t), n.numBatches = Math.max(n.numBatches, i[a].unshift(l.slice(t, u - t))));
+        else {
+            let f = e[a];
+            e[a] = f.clone({
+                nullable: !0
+            }), r[a] = (s = l?._changeLengthAndBackfillNullBitmap(t)) !== null && s !== void 0 ? s : ft({
+                type: f.type,
+                length: t,
+                nullCount: t,
+                nullBitmap: new Uint8Array(o)
+            })
+        }
+    }
+    return r
+}
+var hP, cr = class e {
+    constructor(...t) {
+        var r, i;
+        if (t.length === 0) return this.batches = [], this.schema = new Nt([]), this._offsets = [0], this;
+        let n, s;
+        t[0] instanceof Nt && (n = t.shift()), t.at(-1) instanceof Uint32Array && (s = t.pop());
+        let o = c => {
+                if (c) {
+                    if (c instanceof ee) return [c];
+                    if (c instanceof e) return c.batches;
+                    if (c instanceof Ct) {
+                        if (c.type instanceof zt) return [new ee(new Nt(c.type.children), c)]
+                    } else {
+                        if (Array.isArray(c)) return c.flatMap(l => o(l));
+                        if (typeof c[Symbol.iterator] == "function") return [...c].flatMap(l => o(l));
+                        if (typeof c == "object") {
+                            let l = Object.keys(c),
+                                u = l.map(d => new St([c[d]])),
+                                f = n ?? new Nt(l.map((d, p) => new xt(String(d), u[p].type, u[p].nullable))),
+                                [, h] = Ug(f, u);
+                            return h.length === 0 ? [new ee(c)] : h
+                        }
+                    }
+                }
+                return []
+            },
+            a = t.flatMap(c => o(c));
+        if (n = (i = n ?? ((r = a[0]) === null || r === void 0 ? void 0 : r.schema)) !== null && i !== void 0 ? i : new Nt([]), !(n instanceof Nt)) throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
+        for (let c of a) {
+            if (!(c instanceof ee)) throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
+            if (!oa(n, c.schema)) throw new TypeError("Table and inner RecordBatch schemas must be equivalent.")
+        }
+        this.schema = n, this.batches = a, this._offsets = s ?? ug(this.data)
+    }
+    get data() {
+        return this.batches.map(({
+            data: t
+        }) => t)
+    }
+    get numCols() {
+        return this.schema.fields.length
+    }
+    get numRows() {
+        return this.data.reduce((t, r) => t + r.length, 0)
+    }
+    get nullCount() {
+        return this._nullCount === -1 && (this._nullCount = lg(this.data)), this._nullCount
+    }
+    isValid(t) {
+        return !1
+    }
+    get(t) {
+        return null
+    }
+    set(t, r) {}
+    indexOf(t, r) {
+        return -1
+    } [Symbol.iterator]() {
+        return this.batches.length > 0 ? Nc.visit(new St(this.data)) : new Array(0)[Symbol.iterator]()
+    }
+    toArray() {
+        return [...this]
+    }
+    toString() {
+        return `[
+  ${this.toArray().join(`,
+  `)}
+]`
+    }
+    concat(...t) {
+        let r = this.schema,
+            i = this.data.concat(t.flatMap(({
+                data: n
+            }) => n));
+        return new e(r, i.map(n => new ee(r, n)))
+    }
+    slice(t, r) {
+        let i = this.schema;
+        [t, r] = Af({
+            length: this.numRows
+        }, t, r);
+        let n = fg(this.data, this._offsets, t, r);
+        return new e(i, n.map(s => new ee(i, s)))
+    }
+    getChild(t) {
+        return this.getChildAt(this.schema.fields.findIndex(r => r.name === t))
+    }
+    getChildAt(t) {
+        if (t > -1 && t < this.schema.fields.length) {
+            let r = this.data.map(i => i.children[t]);
+            if (r.length === 0) {
+                let {
+                    type: i
+                } = this.schema.fields[t], n = ft({
+                    type: i,
+                    length: 0,
+                    nullCount: 0
+                });
+                r.push(n._changeLengthAndBackfillNullBitmap(this.numRows))
+            }
+            return new St(r)
+        }
+        return null
+    }
+    setChild(t, r) {
+        var i;
+        return this.setChildAt((i = this.schema.fields) === null || i === void 0 ? void 0 : i.findIndex(n => n.name === t), r)
+    }
+    setChildAt(t, r) {
+        let i = this.schema,
+            n = [...this.batches];
+        if (t > -1 && t < this.numCols) {
+            r || (r = new St([ft({
+                type: new He,
+                length: this.numRows
+            })]));
+            let s = i.fields.slice(),
+                o = s[t].clone({
+                    type: r.type
+                }),
+                a = this.schema.fields.map((c, l) => this.getChildAt(l));
+            [s[t], a[t]] = [o, r], [i, n] = Ug(i, a)
+        }
+        return new e(i, n)
+    }
+    select(t) {
+        let r = this.schema.fields.reduce((i, n, s) => i.set(n.name, s), new Map);
+        return this.selectAt(t.map(i => r.get(i)).filter(i => i > -1))
+    }
+    selectAt(t) {
+        let r = this.schema.selectAt(t),
+            i = this.batches.map(n => n.selectAt(t));
+        return new e(r, i)
+    }
+    assign(t) {
+        let r = this.schema.fields,
+            [i, n] = t.schema.fields.reduce((a, c, l) => {
+                let [u, f] = a, h = r.findIndex(d => d.name === c.name);
+                return ~h ? f[h] = l : u.push(l), a
+            }, [
+                [],
+                []
+            ]),
+            s = this.schema.assign(t.schema),
+            o = [...r.map((a, c) => [c, n[c]]).map(([a, c]) => c === void 0 ? this.getChildAt(a) : t.getChildAt(c)), ...i.map(a => t.getChildAt(a))].filter(Boolean);
+        return new e(...Ug(s, o))
+    }
+};
+hP = Symbol.toStringTag;
+cr[hP] = (e => (e.schema = null, e.batches = [], e._offsets = new Uint32Array([0]), e._nullCount = -1, e[Symbol.isConcatSpreadable] = !0, e.isValid = Oc(Rf), e.get = Oc(fe.getVisitFn(v.Struct)), e.set = hg(Ee.getVisitFn(v.Struct)), e.indexOf = dg(Jo.getVisitFn(v.Struct)), "Table"))(cr.prototype);
+var pP, ee = class e {
+    constructor(...t) {
+        switch (t.length) {
+            case 2: {
+                if ([this.schema] = t, !(this.schema instanceof Nt)) throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
+                if ([, this.data = ft({
+                        nullCount: 0,
+                        type: new zt(this.schema.fields),
+                        children: this.schema.fields.map(r => ft({
+                            type: r.type,
+                            nullCount: 0
+                        }))
+                    })] = t, !(this.data instanceof Ct)) throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
+                [this.schema, this.data] = dP(this.schema, this.data.children);
+                break
+            }
+            case 1: {
+                let [r] = t, {
+                    fields: i,
+                    children: n,
+                    length: s
+                } = Object.keys(r).reduce((c, l, u) => (c.children[u] = r[l], c.length = Math.max(c.length, r[l].length), c.fields[u] = xt.new({
+                    name: l,
+                    type: r[l].type,
+                    nullable: !0
+                }), c), {
+                    length: 0,
+                    fields: new Array,
+                    children: new Array
+                }), o = new Nt(i), a = ft({
+                    type: new zt(i),
+                    length: s,
+                    children: n,
+                    nullCount: 0
+                });
+                [this.schema, this.data] = dP(o, a.children, s);
+                break
+            }
+            default:
+                throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.")
+        }
+    }
+    get dictionaries() {
+        return this._dictionaries || (this._dictionaries = mP(this.schema.fields, this.data.children))
+    }
+    get numCols() {
+        return this.schema.fields.length
+    }
+    get numRows() {
+        return this.data.length
+    }
+    get nullCount() {
+        return this.data.nullCount
+    }
+    isValid(t) {
+        return this.data.getValid(t)
+    }
+    get(t) {
+        return fe.visit(this.data, t)
+    }
+    set(t, r) {
+        return Ee.visit(this.data, t, r)
+    }
+    indexOf(t, r) {
+        return Jo.visit(this.data, t, r)
+    } [Symbol.iterator]() {
+        return Nc.visit(new St([this.data]))
+    }
+    toArray() {
+        return [...this]
+    }
+    concat(...t) {
+        return new cr(this.schema, [this, ...t])
+    }
+    slice(t, r) {
+        let [i] = new St([this.data]).slice(t, r).data;
+        return new e(this.schema, i)
+    }
+    getChild(t) {
+        var r;
+        return this.getChildAt((r = this.schema.fields) === null || r === void 0 ? void 0 : r.findIndex(i => i.name === t))
+    }
+    getChildAt(t) {
+        return t > -1 && t < this.schema.fields.length ? new St([this.data.children[t]]) : null
+    }
+    setChild(t, r) {
+        var i;
+        return this.setChildAt((i = this.schema.fields) === null || i === void 0 ? void 0 : i.findIndex(n => n.name === t), r)
+    }
+    setChildAt(t, r) {
+        let i = this.schema,
+            n = this.data;
+        if (t > -1 && t < this.numCols) {
+            r || (r = new St([ft({
+                type: new He,
+                length: this.numRows
+            })]));
+            let s = i.fields.slice(),
+                o = n.children.slice(),
+                a = s[t].clone({
+                    type: r.type
+                });
+            [s[t], o[t]] = [a, r.data[0]], i = new Nt(s, new Map(this.schema.metadata)), n = ft({
+                type: new zt(s),
+                children: o
+            })
+        }
+        return new e(i, n)
+    }
+    select(t) {
+        let r = this.schema.select(t),
+            i = new zt(r.fields),
+            n = [];
+        for (let s of t) {
+            let o = this.schema.fields.findIndex(a => a.name === s);
+            ~o && (n[o] = this.data.children[o])
+        }
+        return new e(r, ft({
+            type: i,
+            length: this.numRows,
+            children: n
+        }))
+    }
+    selectAt(t) {
+        let r = this.schema.selectAt(t),
+            i = t.map(s => this.data.children[s]).filter(Boolean),
+            n = ft({
+                type: new zt(r.fields),
+                length: this.numRows,
+                children: i
+            });
+        return new e(r, n)
+    }
+};
+pP = Symbol.toStringTag;
+ee[pP] = (e => (e._nullCount = -1, e[Symbol.isConcatSpreadable] = !0, "RecordBatch"))(ee.prototype);
+
+function dP(e, t, r = t.reduce((i, n) => Math.max(i, n.length), 0)) {
+    var i;
+    let n = [...e.fields],
+        s = [...t],
+        o = (r + 63 & -64) >> 3;
+    for (let [a, c] of e.fields.entries()) {
+        let l = t[a];
+        (!l || l.length !== r) && (n[a] = c.clone({
+            nullable: !0
+        }), s[a] = (i = l?._changeLengthAndBackfillNullBitmap(r)) !== null && i !== void 0 ? i : ft({
+            type: c.type,
+            length: r,
+            nullCount: r,
+            nullBitmap: new Uint8Array(o)
+        }))
+    }
+    return [e.assign(n), ft({
+        type: new zt(n),
+        length: r,
+        children: s
+    })]
+}
+
+function mP(e, t, r = new Map) {
+    var i, n;
+    if (((i = e?.length) !== null && i !== void 0 ? i : 0) > 0 && e?.length === t?.length)
+        for (let s = -1, o = e.length; ++s < o;) {
+            let {
+                type: a
+            } = e[s], c = t[s];
+            for (let l of [c, ...((n = c?.dictionary) === null || n === void 0 ? void 0 : n.data) || []]) mP(a.children, l?.children, r);
+            if (X.isDictionary(a)) {
+                let {
+                    id: l
+                } = a;
+                if (!r.has(l)) c?.dictionary && r.set(l, c.dictionary);
+                else if (r.get(l) !== c.dictionary) throw new Error("Cannot create Schema containing two different dictionaries with the same Id")
+            }
+        }
+    return r
+}
+var aa = class extends ee {
+    constructor(t) {
+        let r = t.fields.map(n => ft({
+                type: n.type
+            })),
+            i = ft({
+                type: new zt(t.fields),
+                nullCount: 0,
+                children: r
+            });
+        super(t, i)
+    }
+};
+var Ii = class e {
+    constructor() {
+        this.bb = null, this.bb_pos = 0
+    }
+    __init(t, r) {
+        return this.bb_pos = t, this.bb = r, this
+    }
+    static getRootAsMessage(t, r) {
+        return (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    static getSizePrefixedRootAsMessage(t, r) {
+        return t.setPosition(t.position() + 4), (r || new e).__init(t.readInt32(t.position()) + t.position(), t)
+    }
+    version() {
+        let t = this.bb.__offset(this.bb_pos, 4);
+        return t ? this.bb.readInt16(this.bb_pos + t) : Bt.V1
+    }
+    headerType() {
+        let t = this.bb.__offset(this.bb_pos, 6);
+        return t ? this.bb.readUint8(this.bb_pos + t) : vt.NONE
+    }
+    header(t) {
+        let r = this.bb.__offset(this.bb_pos, 8);
+        return r ? this.bb.__union(t, this.bb_pos + r) : null
+    }
+    bodyLength() {
+        let t = this.bb.__offset(this.bb_pos, 10);
+        return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0")
+    }
+    customMetadata(t, r) {
+        let i = this.bb.__offset(this.bb_pos, 12);
+        return i ? (r || new me).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + t * 4), this.bb) : null
+    }
+    customMetadataLength() {
+        let t = this.bb.__offset(this.bb_pos, 12);
+        return t ? this.bb.__vector_len(this.bb_pos + t) : 0
+    }
+    static startMessage(t) {
+        t.startObject(5)
+    }
+    static addVersion(t, r) {
+        t.addFieldInt16(0, r, Bt.V1)
+    }
+    static addHeaderType(t, r) {
+        t.addFieldInt8(1, r, vt.NONE)
+    }
+    static addHeader(t, r) {
+        t.addFieldOffset(2, r, 0)
+    }
+    static addBodyLength(t, r) {
+        t.addFieldInt64(3, r, BigInt("0"))
+    }
+    static addCustomMetadata(t, r) {
+        t.addFieldOffset(4, r, 0)
+    }
+    static createCustomMetadataVector(t, r) {
+        t.startVector(4, r.length, 4);
+        for (let i = r.length - 1; i >= 0; i--) t.addOffset(r[i]);
+        return t.endVector()
+    }
+    static startCustomMetadataVector(t, r) {
+        t.startVector(4, r, 4)
+    }
+    static endMessage(t) {
+        return t.endObject()
+    }
+    static finishMessageBuffer(t, r) {
+        t.finish(r)
+    }
+    static finishSizePrefixedMessageBuffer(t, r) {
+        t.finish(r, void 0, !0)
+    }
+    static createMessage(t, r, i, n, s, o) {
+        return e.startMessage(t), e.addVersion(t, r), e.addHeaderType(t, i), e.addHeader(t, n), e.addBodyLength(t, s), e.addCustomMetadata(t, o), e.endMessage(t)
+    }
+};
+var vw = class extends J {
+        visit(t, r) {
+            return t == null || r == null ? void 0 : super.visit(t, r)
+        }
+        visitNull(t, r) {
+            return bf.startNull(r), bf.endNull(r)
+        }
+        visitInt(t, r) {
+            return mi.startInt(r), mi.addBitWidth(r, t.bitWidth), mi.addIsSigned(r, t.isSigned), mi.endInt(r)
+        }
+        visitFloat(t, r) {
+            return Zs.startFloatingPoint(r), Zs.addPrecision(r, t.precision), Zs.endFloatingPoint(r)
+        }
+        visitBinary(t, r) {
+            return pf.startBinary(r), pf.endBinary(r)
+        }
+        visitLargeBinary(t, r) {
+            return gf.startLargeBinary(r), gf.endLargeBinary(r)
+        }
+        visitBool(t, r) {
+            return mf.startBool(r), mf.endBool(r)
+        }
+        visitUtf8(t, r) {
+            return wf.startUtf8(r), wf.endUtf8(r)
+        }
+        visitLargeUtf8(t, r) {
+            return _f.startLargeUtf8(r), _f.endLargeUtf8(r)
+        }
+        visitDecimal(t, r) {
+            return on.startDecimal(r), on.addScale(r, t.scale), on.addPrecision(r, t.precision), on.addBitWidth(r, t.bitWidth), on.endDecimal(r)
+        }
+        visitDate(t, r) {
+            return $s.startDate(r), $s.addUnit(r, t.unit), $s.endDate(r)
+        }
+        visitTime(t, r) {
+            return Bn.startTime(r), Bn.addUnit(r, t.unit), Bn.addBitWidth(r, t.bitWidth), Bn.endTime(r)
+        }
+        visitTimestamp(t, r) {
+            let i = t.timezone && r.createString(t.timezone) || void 0;
+            return Fn.startTimestamp(r), Fn.addUnit(r, t.unit), i !== void 0 && Fn.addTimezone(r, i), Fn.endTimestamp(r)
+        }
+        visitInterval(t, r) {
+            return Ks.startInterval(r), Ks.addUnit(r, t.unit), Ks.endInterval(r)
+        }
+        visitDuration(t, r) {
+            return Xs.startDuration(r), Xs.addUnit(r, t.unit), Xs.endDuration(r)
+        }
+        visitList(t, r) {
+            return yf.startList(r), yf.endList(r)
+        }
+        visitStruct(t, r) {
+            return xf.startStruct_(r), xf.endStruct_(r)
+        }
+        visitUnion(t, r) {
+            gi.startTypeIdsVector(r, t.typeIds.length);
+            let i = gi.createTypeIdsVector(r, t.typeIds);
+            return gi.startUnion(r), gi.addMode(r, t.mode), gi.addTypeIds(r, i), gi.endUnion(r)
+        }
+        visitDictionary(t, r) {
+            let i = this.visit(t.indices, r);
+            return sn.startDictionaryEncoding(r), sn.addId(r, BigInt(t.id)), sn.addIsOrdered(r, t.isOrdered), i !== void 0 && sn.addIndexType(r, i), sn.endDictionaryEncoding(r)
+        }
+        visitFixedSizeBinary(t, r) {
+            return Ys.startFixedSizeBinary(r), Ys.addByteWidth(r, t.byteWidth), Ys.endFixedSizeBinary(r)
+        }
+        visitFixedSizeList(t, r) {
+            return qs.startFixedSizeList(r), qs.addListSize(r, t.listSize), qs.endFixedSizeList(r)
+        }
+        visitMap(t, r) {
+            return Gs.startMap(r), Gs.addKeysSorted(r, t.keysSorted), Gs.endMap(r)
+        }
+    },
+    Vg = new vw;
+
+function bP(e, t = new Map) {
+    return new Nt(uV(e, t), zg(e.metadata), t)
+}
+
+function Sw(e) {
+    return new Ie(e.count, wP(e.columns), TP(e.columns))
+}
+
+function xP(e) {
+    return new ur(Sw(e.data), e.id, e.isDelta)
+}
+
+function uV(e, t) {
+    return (e.fields || []).filter(Boolean).map(r => xt.fromJSON(r, t))
+}
+
+function gP(e, t) {
+    return (e.children || []).filter(Boolean).map(r => xt.fromJSON(r, t))
+}
+
+function wP(e) {
+    return (e || []).reduce((t, r) => [...t, new Kr(r.count, fV(r.VALIDITY)), ...wP(r.children)], [])
+}
+
+function TP(e, t = []) {
+    for (let r = -1, i = (e || []).length; ++r < i;) {
+        let n = e[r];
+        n.VALIDITY && t.push(new lr(t.length, n.VALIDITY.length)), n.TYPE_ID && t.push(new lr(t.length, n.TYPE_ID.length)), n.OFFSET && t.push(new lr(t.length, n.OFFSET.length)), n.DATA && t.push(new lr(t.length, n.DATA.length)), t = TP(n.children, t)
+    }
+    return t
+}
+
+function fV(e) {
+    return (e || []).reduce((t, r) => t + +(r === 0), 0)
+}
+
+function vP(e, t) {
+    let r, i, n, s, o, a;
+    return !t || !(s = e.dictionary) ? (o = yP(e, gP(e, t)), n = new xt(e.name, o, e.nullable, zg(e.metadata))) : t.has(r = s.id) ? (i = (i = s.indexType) ? _P(i) : new an, a = new Tr(t.get(r), i, r, s.isOrdered), n = new xt(e.name, a, e.nullable, zg(e.metadata))) : (i = (i = s.indexType) ? _P(i) : new an, t.set(r, o = yP(e, gP(e, t))), a = new Tr(o, i, r, s.isOrdered), n = new xt(e.name, a, e.nullable, zg(e.metadata))), n || null
+}
+
+function zg(e = []) {
+    return new Map(e.map(({
+        key: t,
+        value: r
+    }) => [t, r]))
+}
+
+function _P(e) {
+    return new se(e.isSigned, e.bitWidth)
+}
+
+function yP(e, t) {
+    let r = e.type.name;
+    switch (r) {
+        case "NONE":
+            return new He;
+        case "null":
+            return new He;
+        case "binary":
+            return new Dn;
+        case "largebinary":
+            return new Ln;
+        case "utf8":
+            return new kn;
+        case "largeutf8":
+            return new Un;
+        case "bool":
+            return new Vn;
+        case "list":
+            return new wi((t || [])[0]);
+        case "struct":
+            return new zt(t || []);
+        case "struct_":
+            return new zt(t || [])
+    }
+    switch (r) {
+        case "int": {
+            let i = e.type;
+            return new se(i.isSigned, i.bitWidth)
+        }
+        case "floatingpoint": {
+            let i = e.type;
+            return new or(kt[i.precision])
+        }
+        case "decimal": {
+            let i = e.type;
+            return new zn(i.scale, i.precision, i.bitWidth)
+        }
+        case "date": {
+            let i = e.type;
+            return new Wn(ue[i.unit])
+        }
+        case "time": {
+            let i = e.type;
+            return new xi(Y[i.unit], i.bitWidth)
+        }
+        case "timestamp": {
+            let i = e.type;
+            return new jn(Y[i.unit], i.timezone)
+        }
+        case "interval": {
+            let i = e.type;
+            return new Hn(xe[i.unit])
+        }
+        case "duration": {
+            let i = e.type;
+            return new $n(Y[i.unit])
+        }
+        case "union": {
+            let i = e.type,
+                [n, ...s] = (i.mode + "").toLowerCase(),
+                o = n.toUpperCase() + s.join("");
+            return new Ti(Vt[o], i.typeIds || [], t || [])
+        }
+        case "fixedsizebinary": {
+            let i = e.type;
+            return new Xn(i.byteWidth)
+        }
+        case "fixedsizelist": {
+            let i = e.type;
+            return new vi(i.listSize, (t || [])[0])
+        }
+        case "map": {
+            let i = e.type;
+            return new Si((t || [])[0], i.keysSorted)
+        }
+    }
+    throw new Error(`Unrecognized type: "${r}"`)
+}
+var hV = qo,
+    dV = xr,
+    fr = class e {
+        static fromJSON(t, r) {
+            let i = new e(0, Bt.V5, r);
+            return i._createHeader = pV(t, r), i
+        }
+        static decode(t) {
+            t = new dV(at(t));
+            let r = Ii.getRootAsMessage(t),
+                i = r.bodyLength(),
+                n = r.version(),
+                s = r.headerType(),
+                o = new e(i, n, s);
+            return o._createHeader = mV(r, s), o
+        }
+        static encode(t) {
+            let r = new hV,
+                i = -1;
+            return t.isSchema() ? i = Nt.encode(r, t.header()) : t.isRecordBatch() ? i = Ie.encode(r, t.header()) : t.isDictionaryBatch() && (i = ur.encode(r, t.header())), Ii.startMessage(r), Ii.addVersion(r, Bt.V5), Ii.addHeader(r, i), Ii.addHeaderType(r, t.headerType), Ii.addBodyLength(r, BigInt(t.bodyLength)), Ii.finishMessageBuffer(r, Ii.endMessage(r)), r.asUint8Array()
+        }
+        static from(t, r = 0) {
+            if (t instanceof Nt) return new e(0, Bt.V5, vt.Schema, t);
+            if (t instanceof Ie) return new e(r, Bt.V5, vt.RecordBatch, t);
+            if (t instanceof ur) return new e(r, Bt.V5, vt.DictionaryBatch, t);
+            throw new Error(`Unrecognized Message header: ${t}`)
+        }
+        get type() {
+            return this.headerType
+        }
+        get version() {
+            return this._version
+        }
+        get headerType() {
+            return this._headerType
+        }
+        get bodyLength() {
+            return this._bodyLength
+        }
+        header() {
+            return this._createHeader()
+        }
+        isSchema() {
+            return this.headerType === vt.Schema
+        }
+        isRecordBatch() {
+            return this.headerType === vt.RecordBatch
+        }
+        isDictionaryBatch() {
+            return this.headerType === vt.DictionaryBatch
+        }
+        constructor(t, r, i, n) {
+            this._version = r, this._headerType = i, this.body = new Uint8Array(0), n && (this._createHeader = () => n), this._bodyLength = Kt(t)
+        }
+    },
+    Ie = class {
+        get nodes() {
+            return this._nodes
+        }
+        get length() {
+            return this._length
+        }
+        get buffers() {
+            return this._buffers
+        }
+        constructor(t, r, i) {
+            this._nodes = r, this._buffers = i, this._length = Kt(t)
+        }
+    },
+    ur = class {
+        get id() {
+            return this._id
+        }
+        get data() {
+            return this._data
+        }
+        get isDelta() {
+            return this._isDelta
+        }
+        get length() {
+            return this.data.length
+        }
+        get nodes() {
+            return this.data.nodes
+        }
+        get buffers() {
+            return this.data.buffers
+        }
+        constructor(t, r, i = !1) {
+            this._data = t, this._isDelta = i, this._id = Kt(r)
+        }
+    },
+    lr = class {
+        constructor(t, r) {
+            this.offset = Kt(t), this.length = Kt(r)
+        }
+    },
+    Kr = class {
+        constructor(t, r) {
+            this.length = Kt(t), this.nullCount = Kt(r)
+        }
+    };
+
+function pV(e, t) {
+    return () => {
+        switch (t) {
+            case vt.Schema:
+                return Nt.fromJSON(e);
+            case vt.RecordBatch:
+                return Ie.fromJSON(e);
+            case vt.DictionaryBatch:
+                return ur.fromJSON(e)
+        }
+        throw new Error(`Unrecognized Message type: { name: ${vt[t]}, type: ${t} }`)
+    }
+}
+
+function mV(e, t) {
+    return () => {
+        switch (t) {
+            case vt.Schema:
+                return Nt.decode(e.header(new sr), new Map, e.version());
+            case vt.RecordBatch:
+                return Ie.decode(e.header(new wr), e.version());
+            case vt.DictionaryBatch:
+                return ur.decode(e.header(new Nn), e.version())
+        }
+        throw new Error(`Unrecognized Message type: { name: ${vt[t]}, type: ${t} }`)
+    }
+}
+xt.encode = EV;
+xt.decode = SV;
+xt.fromJSON = vP;
+Nt.encode = AV;
+Nt.decode = gV;
+Nt.fromJSON = bP;
+Ie.encode = IV;
+Ie.decode = _V;
+Ie.fromJSON = Sw;
+ur.encode = RV;
+ur.decode = yV;
+ur.fromJSON = xP;
+Kr.encode = MV;
+Kr.decode = xV;
+lr.encode = PV;
+lr.decode = bV;
+
+function gV(e, t = new Map, r = Bt.V5) {
+    let i = vV(e, t);
+    return new Nt(i, Wg(e), t, r)
+}
+
+function _V(e, t = Bt.V5) {
+    if (e.compression() !== null) throw new Error("Record batch compression not implemented");
+    return new Ie(e.length(), wV(e), TV(e, t))
+}
+
+function yV(e, t = Bt.V5) {
+    return new ur(Ie.decode(e.data(), t), e.id(), e.isDelta())
+}
+
+function bV(e) {
+    return new lr(e.offset(), e.length())
+}
+
+function xV(e) {
+    return new Kr(e.length(), e.nullCount())
+}
+
+function wV(e) {
+    let t = [];
+    for (let r, i = -1, n = -1, s = e.nodesLength(); ++i < s;)(r = e.nodes(i)) && (t[++n] = Kr.decode(r));
+    return t
+}
+
+function TV(e, t) {
+    let r = [];
+    for (let i, n = -1, s = -1, o = e.buffersLength(); ++n < o;)(i = e.buffers(n)) && (t < Bt.V4 && (i.bb_pos += 8 * (n + 1)), r[++s] = lr.decode(i));
+    return r
+}
+
+function vV(e, t) {
+    let r = [];
+    for (let i, n = -1, s = -1, o = e.fieldsLength(); ++n < o;)(i = e.fields(n)) && (r[++s] = xt.decode(i, t));
+    return r
+}
+
+function SP(e, t) {
+    let r = [];
+    for (let i, n = -1, s = -1, o = e.childrenLength(); ++n < o;)(i = e.children(n)) && (r[++s] = xt.decode(i, t));
+    return r
+}
+
+function SV(e, t) {
+    let r, i, n, s, o, a;
+    return !t || !(a = e.dictionary()) ? (n = EP(e, SP(e, t)), i = new xt(e.name(), n, e.nullable(), Wg(e))) : t.has(r = Kt(a.id())) ? (s = (s = a.indexType()) ? AP(s) : new an, o = new Tr(t.get(r), s, r, a.isOrdered()), i = new xt(e.name(), o, e.nullable(), Wg(e))) : (s = (s = a.indexType()) ? AP(s) : new an, t.set(r, n = EP(e, SP(e, t))), o = new Tr(n, s, r, a.isOrdered()), i = new xt(e.name(), o, e.nullable(), Wg(e))), i || null
+}
+
+function Wg(e) {
+    let t = new Map;
+    if (e)
+        for (let r, i, n = -1, s = Math.trunc(e.customMetadataLength()); ++n < s;)(r = e.customMetadata(n)) && (i = r.key()) != null && t.set(i, r.value());
+    return t
+}
+
+function AP(e) {
+    return new se(e.isSigned(), e.bitWidth())
+}
+
+function EP(e, t) {
+    let r = e.typeType();
+    switch (r) {
+        case Ut.NONE:
+            return new He;
+        case Ut.Null:
+            return new He;
+        case Ut.Binary:
+            return new Dn;
+        case Ut.LargeBinary:
+            return new Ln;
+        case Ut.Utf8:
+            return new kn;
+        case Ut.LargeUtf8:
+            return new Un;
+        case Ut.Bool:
+            return new Vn;
+        case Ut.List:
+            return new wi((t || [])[0]);
+        case Ut.Struct_:
+            return new zt(t || [])
+    }
+    switch (r) {
+        case Ut.Int: {
+            let i = e.type(new mi);
+            return new se(i.isSigned(), i.bitWidth())
+        }
+        case Ut.FloatingPoint: {
+            let i = e.type(new Zs);
+            return new or(i.precision())
+        }
+        case Ut.Decimal: {
+            let i = e.type(new on);
+            return new zn(i.scale(), i.precision(), i.bitWidth())
+        }
+        case Ut.Date: {
+            let i = e.type(new $s);
+            return new Wn(i.unit())
+        }
+        case Ut.Time: {
+            let i = e.type(new Bn);
+            return new xi(i.unit(), i.bitWidth())
+        }
+        case Ut.Timestamp: {
+            let i = e.type(new Fn);
+            return new jn(i.unit(), i.timezone())
+        }
+        case Ut.Interval: {
+            let i = e.type(new Ks);
+            return new Hn(i.unit())
+        }
+        case Ut.Duration: {
+            let i = e.type(new Xs);
+            return new $n(i.unit())
+        }
+        case Ut.Union: {
+            let i = e.type(new gi);
+            return new Ti(i.mode(), i.typeIdsArray() || [], t || [])
+        }
+        case Ut.FixedSizeBinary: {
+            let i = e.type(new Ys);
+            return new Xn(i.byteWidth())
+        }
+        case Ut.FixedSizeList: {
+            let i = e.type(new qs);
+            return new vi(i.listSize(), (t || [])[0])
+        }
+        case Ut.Map: {
+            let i = e.type(new Gs);
+            return new Si((t || [])[0], i.keysSorted())
+        }
+    }
+    throw new Error(`Unrecognized type: "${Ut[r]}" (${r})`)
+}
+
+function AV(e, t) {
+    let r = t.fields.map(s => xt.encode(e, s));
+    sr.startFieldsVector(e, r.length);
+    let i = sr.createFieldsVector(e, r),
+        n = t.metadata && t.metadata.size > 0 ? sr.createCustomMetadataVector(e, [...t.metadata].map(([s, o]) => {
+            let a = e.createString(`${s}`),
+                c = e.createString(`${o}`);
+            return me.startKeyValue(e), me.addKey(e, a), me.addValue(e, c), me.endKeyValue(e)
+        })) : -1;
+    return sr.startSchema(e), sr.addFields(e, i), sr.addEndianness(e, CV ? Hs.Little : Hs.Big), n !== -1 && sr.addCustomMetadata(e, n), sr.endSchema(e)
+}
+
+function EV(e, t) {
+    let r = -1,
+        i = -1,
+        n = -1,
+        s = t.type,
+        o = t.typeId;
+    X.isDictionary(s) ? (o = s.dictionary.typeId, n = Vg.visit(s, e), i = Vg.visit(s.dictionary, e)) : i = Vg.visit(s, e);
+    let a = (s.children || []).map(u => xt.encode(e, u)),
+        c = Oe.createChildrenVector(e, a),
+        l = t.metadata && t.metadata.size > 0 ? Oe.createCustomMetadataVector(e, [...t.metadata].map(([u, f]) => {
+            let h = e.createString(`${u}`),
+                d = e.createString(`${f}`);
+            return me.startKeyValue(e), me.addKey(e, h), me.addValue(e, d), me.endKeyValue(e)
+        })) : -1;
+    return t.name && (r = e.createString(t.name)), Oe.startField(e), Oe.addType(e, i), Oe.addTypeType(e, o), Oe.addChildren(e, c), Oe.addNullable(e, !!t.nullable), r !== -1 && Oe.addName(e, r), n !== -1 && Oe.addDictionary(e, n), l !== -1 && Oe.addCustomMetadata(e, l), Oe.endField(e)
+}
+
+function IV(e, t) {
+    let r = t.nodes || [],
+        i = t.buffers || [];
+    wr.startNodesVector(e, r.length);
+    for (let o of r.slice().reverse()) Kr.encode(e, o);
+    let n = e.endVector();
+    wr.startBuffersVector(e, i.length);
+    for (let o of i.slice().reverse()) lr.encode(e, o);
+    let s = e.endVector();
+    return wr.startRecordBatch(e), wr.addLength(e, BigInt(t.length)), wr.addNodes(e, n), wr.addBuffers(e, s), wr.endRecordBatch(e)
+}
+
+function RV(e, t) {
+    let r = Ie.encode(e, t.data);
+    return Nn.startDictionaryBatch(e), Nn.addId(e, BigInt(t.id)), Nn.addIsDelta(e, t.isDelta), Nn.addData(e, r), Nn.endDictionaryBatch(e)
+}
+
+function MV(e, t) {
+    return Sc.createFieldNode(e, BigInt(t.length), BigInt(t.nullCount))
+}
+
+function PV(e, t) {
+    return vc.createBuffer(e, BigInt(t.offset), BigInt(t.length))
+}
+var CV = (() => {
+    let e = new ArrayBuffer(2);
+    return new DataView(e).setInt16(0, 256, !0), new Int16Array(e)[0] === 256
+})();
+var Ew = e => `Expected ${vt[e]} Message in stream, but was null or length 0.`,
+    Iw = e => `Header pointer of flatbuffer-encoded ${vt[e]} Message is null or length 0.`,
+    IP = (e, t) => `Expected to read ${e} metadata bytes, but only read ${t}.`,
+    RP = (e, t) => `Expected to read ${e} bytes for message body, but only read ${t}.`,
+    zc = class {
+        constructor(t) {
+            this.source = t instanceof un ? t : new un(t)
+        } [Symbol.iterator]() {
+            return this
+        }
+        next() {
+            let t;
+            return (t = this.readMetadataLength()).done ? Wt : t.value === -1 && (t = this.readMetadataLength()).done ? Wt : (t = this.readMetadata(t.value)).done ? Wt : t
+        }
+        throw (t) {
+            return this.source.throw(t)
+        }
+        return (t) {
+            return this.source.return(t)
+        }
+        readMessage(t) {
+            let r;
+            if ((r = this.next()).done) return null;
+            if (t != null && r.value.headerType !== t) throw new Error(Ew(t));
+            return r.value
+        }
+        readMessageBody(t) {
+            if (t <= 0) return new Uint8Array(0);
+            let r = at(this.source.read(t));
+            if (r.byteLength < t) throw new Error(RP(t, r.byteLength));
+            return r.byteOffset % 8 === 0 && r.byteOffset + r.byteLength <= r.buffer.byteLength ? r : r.slice()
+        }
+        readSchema(t = !1) {
+            let r = vt.Schema,
+                i = this.readMessage(r),
+                n = i?.header();
+            if (t && !n) throw new Error(Iw(r));
+            return n
+        }
+        readMetadataLength() {
+            let t = this.source.read(jg),
+                r = t && new xr(t),
+                i = r?.readInt32(0) || 0;
+            return {
+                done: i === 0,
+                value: i
+            }
+        }
+        readMetadata(t) {
+            let r = this.source.read(t);
+            if (!r) return Wt;
+            if (r.byteLength < t) throw new Error(IP(t, r.byteLength));
+            return {
+                done: !1,
+                value: fr.decode(r)
+            }
+        }
+    },
+    ih = class {
+        constructor(t, r) {
+            this.source = t instanceof qr ? t : Tm(t) ? new eo(t, r) : new qr(t)
+        } [Symbol.asyncIterator]() {
+            return this
+        }
+        next() {
+            return H(this, void 0, void 0, function*() {
+                let t;
+                return (t = yield this.readMetadataLength()).done ? Wt : t.value === -1 && (t = yield this.readMetadataLength()).done ? Wt : (t = yield this.readMetadata(t.value)).done ? Wt : t
+            })
+        }
+        throw (t) {
+            return H(this, void 0, void 0, function*() {
+                return yield this.source.throw(t)
+            })
+        }
+        return (t) {
+            return H(this, void 0, void 0, function*() {
+                return yield this.source.return(t)
+            })
+        }
+        readMessage(t) {
+            return H(this, void 0, void 0, function*() {
+                let r;
+                if ((r = yield this.next()).done) return null;
+                if (t != null && r.value.headerType !== t) throw new Error(Ew(t));
+                return r.value
+            })
+        }
+        readMessageBody(t) {
+            return H(this, void 0, void 0, function*() {
+                if (t <= 0) return new Uint8Array(0);
+                let r = at(yield this.source.read(t));
+                if (r.byteLength < t) throw new Error(RP(t, r.byteLength));
+                return r.byteOffset % 8 === 0 && r.byteOffset + r.byteLength <= r.buffer.byteLength ? r : r.slice()
+            })
+        }
+        readSchema(t = !1) {
+            return H(this, void 0, void 0, function*() {
+                let r = vt.Schema,
+                    i = yield this.readMessage(r), n = i?.header();
+                if (t && !n) throw new Error(Iw(r));
+                return n
+            })
+        }
+        readMetadataLength() {
+            return H(this, void 0, void 0, function*() {
+                let t = yield this.source.read(jg), r = t && new xr(t), i = r?.readInt32(0) || 0;
+                return {
+                    done: i === 0,
+                    value: i
+                }
+            })
+        }
+        readMetadata(t) {
+            return H(this, void 0, void 0, function*() {
+                let r = yield this.source.read(t);
+                if (!r) return Wt;
+                if (r.byteLength < t) throw new Error(IP(t, r.byteLength));
+                return {
+                    done: !1,
+                    value: fr.decode(r)
+                }
+            })
+        }
+    },
+    nh = class extends zc {
+        constructor(t) {
+            super(new Uint8Array(0)), this._schema = !1, this._body = [], this._batchIndex = 0, this._dictionaryIndex = 0, this._json = t instanceof Mf ? t : new Mf(t)
+        }
+        next() {
+            let {
+                _json: t
+            } = this;
+            if (!this._schema) return this._schema = !0, {
+                done: !1,
+                value: fr.fromJSON(t.schema, vt.Schema)
+            };
+            if (this._dictionaryIndex < t.dictionaries.length) {
+                let r = t.dictionaries[this._dictionaryIndex++];
+                return this._body = r.data.columns, {
+                    done: !1,
+                    value: fr.fromJSON(r, vt.DictionaryBatch)
+                }
+            }
+            if (this._batchIndex < t.batches.length) {
+                let r = t.batches[this._batchIndex++];
+                return this._body = r.columns, {
+                    done: !1,
+                    value: fr.fromJSON(r, vt.RecordBatch)
+                }
+            }
+            return this._body = [], Wt
+        }
+        readMessageBody(t) {
+            return r(this._body);
+
+            function r(i) {
+                return (i || []).reduce((n, s) => [...n, ...s.VALIDITY && [s.VALIDITY] || [], ...s.TYPE_ID && [s.TYPE_ID] || [], ...s.OFFSET && [s.OFFSET] || [], ...s.DATA && [s.DATA] || [], ...r(s.children)], [])
+            }
+        }
+        readMessage(t) {
+            let r;
+            if ((r = this.next()).done) return null;
+            if (t != null && r.value.headerType !== t) throw new Error(Ew(t));
+            return r.value
+        }
+        readSchema() {
+            let t = vt.Schema,
+                r = this.readMessage(t),
+                i = r?.header();
+            if (!r || !i) throw new Error(Iw(t));
+            return i
+        }
+    },
+    jg = 4,
+    Aw = "ARROW1",
+    Wc = new Uint8Array(Aw.length);
+for (let e = 0; e < Aw.length; e += 1) Wc[e] = Aw.codePointAt(e);
+
+function Hg(e, t = 0) {
+    for (let r = -1, i = Wc.length; ++r < i;)
+        if (Wc[r] !== e[t + r]) return !1;
+    return !0
+}
+var jc = Wc.length,
+    Rw = jc + jg,
+    MP = jc * 2 + jg;
+var Ar = class e extends ta {
+        constructor(t) {
+            super(), this._impl = t
+        }
+        get closed() {
+            return this._impl.closed
+        }
+        get schema() {
+            return this._impl.schema
+        }
+        get autoDestroy() {
+            return this._impl.autoDestroy
+        }
+        get dictionaries() {
+            return this._impl.dictionaries
+        }
+        get numDictionaries() {
+            return this._impl.numDictionaries
+        }
+        get numRecordBatches() {
+            return this._impl.numRecordBatches
+        }
+        get footer() {
+            return this._impl.isFile() ? this._impl.footer : null
+        }
+        isSync() {
+            return this._impl.isSync()
+        }
+        isAsync() {
+            return this._impl.isAsync()
+        }
+        isFile() {
+            return this._impl.isFile()
+        }
+        isStream() {
+            return this._impl.isStream()
+        }
+        next() {
+            return this._impl.next()
+        }
+        throw (t) {
+            return this._impl.throw(t)
+        }
+        return (t) {
+            return this._impl.return(t)
+        }
+        cancel() {
+            return this._impl.cancel()
+        }
+        reset(t) {
+            return this._impl.reset(t), this._DOMStream = void 0, this._nodeStream = void 0, this
+        }
+        open(t) {
+            let r = this._impl.open(t);
+            return yr(r) ? r.then(() => this) : this
+        }
+        readRecordBatch(t) {
+            return this._impl.isFile() ? this._impl.readRecordBatch(t) : null
+        } [Symbol.iterator]() {
+            return this._impl[Symbol.iterator]()
+        } [Symbol.asyncIterator]() {
+            return this._impl[Symbol.asyncIterator]()
+        }
+        toDOMStream() {
+            return Ae.toDOMStream(this.isSync() ? {
+                [Symbol.iterator]: () => this
+            } : {
+                [Symbol.asyncIterator]: () => this
+            })
+        }
+        toNodeStream() {
+            return Ae.toNodeStream(this.isSync() ? {
+                [Symbol.iterator]: () => this
+            } : {
+                [Symbol.asyncIterator]: () => this
+            }, {
+                objectMode: !0
+            })
+        }
+        static throughNode(t) {
+            throw new Error('"throughNode" not available in this environment')
+        }
+        static throughDOM(t, r) {
+            throw new Error('"throughDOM" not available in this environment')
+        }
+        static from(t) {
+            return t instanceof e ? t : xm(t) ? NV(t) : Tm(t) ? DV(t) : yr(t) ? H(this, void 0, void 0, function*() {
+                return yield e.from(yield t)
+            }) : vm(t) || cf(t) || Am(t) || $r(t) ? FV(new qr(t)) : BV(new un(t))
+        }
+        static readAll(t) {
+            return t instanceof e ? t.isSync() ? PP(t) : CP(t) : xm(t) || ArrayBuffer.isView(t) || hi(t) || wm(t) ? PP(t) : CP(t)
+        }
+    },
+    is = class extends Ar {
+        constructor(t) {
+            super(t), this._impl = t
+        }
+        readAll() {
+            return [...this]
+        } [Symbol.iterator]() {
+            return this._impl[Symbol.iterator]()
+        } [Symbol.asyncIterator]() {
+            return _r(this, arguments, function*() {
+                yield pt(yield* wc(fi(this[Symbol.iterator]())))
+            })
+        }
+    },
+    ca = class extends Ar {
+        constructor(t) {
+            super(t), this._impl = t
+        }
+        readAll() {
+            var t, r, i, n;
+            return H(this, void 0, void 0, function*() {
+                let s = new Array;
+                try {
+                    for (var o = !0, a = fi(this), c; c = yield a.next(), t = c.done, !t; o = !0) {
+                        n = c.value, o = !1;
+                        let l = n;
+                        s.push(l)
+                    }
+                } catch (l) {
+                    r = {
+                        error: l
+                    }
+                } finally {
+                    try {
+                        !o && !t && (i = a.return) && (yield i.call(a))
+                    } finally {
+                        if (r) throw r.error
+                    }
+                }
+                return s
+            })
+        } [Symbol.iterator]() {
+            throw new Error("AsyncRecordBatchStreamReader is not Iterable")
+        } [Symbol.asyncIterator]() {
+            return this._impl[Symbol.asyncIterator]()
+        }
+    },
+    la = class extends is {
+        constructor(t) {
+            super(t), this._impl = t
+        }
+    },
+    $g = class extends ca {
+        constructor(t) {
+            super(t), this._impl = t
+        }
+    },
+    Xg = class {
+        get numDictionaries() {
+            return this._dictionaryIndex
+        }
+        get numRecordBatches() {
+            return this._recordBatchIndex
+        }
+        constructor(t = new Map) {
+            this.closed = !1, this.autoDestroy = !0, this._dictionaryIndex = 0, this._recordBatchIndex = 0, this.dictionaries = t
+        }
+        isSync() {
+            return !1
+        }
+        isAsync() {
+            return !1
+        }
+        isFile() {
+            return !1
+        }
+        isStream() {
+            return !1
+        }
+        reset(t) {
+            return this._dictionaryIndex = 0, this._recordBatchIndex = 0, this.schema = t, this.dictionaries = new Map, this
+        }
+        _loadRecordBatch(t, r) {
+            let i = this._loadVectors(t, r, this.schema.fields),
+                n = ft({
+                    type: new zt(this.schema.fields),
+                    length: t.length,
+                    children: i
+                });
+            return new ee(this.schema, n)
+        }
+        _loadDictionaryBatch(t, r) {
+            let {
+                id: i,
+                isDelta: n
+            } = t, {
+                dictionaries: s,
+                schema: o
+            } = this, a = s.get(i);
+            if (n || !a) {
+                let c = o.dictionaries.get(i),
+                    l = this._loadVectors(t.data, r, [c]);
+                return (a && n ? a.concat(new St(l)) : new St(l)).memoize()
+            }
+            return a.memoize()
+        }
+        _loadVectors(t, r, i) {
+            return new Nf(r, t.nodes, t.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(i)
+        }
+    },
+    Hc = class extends Xg {
+        constructor(t, r) {
+            super(r), this._reader = xm(t) ? new nh(this._handle = t) : new zc(this._handle = t)
+        }
+        isSync() {
+            return !0
+        }
+        isStream() {
+            return !0
+        } [Symbol.iterator]() {
+            return this
+        }
+        cancel() {
+            !this.closed && (this.closed = !0) && (this.reset()._reader.return(), this._reader = null, this.dictionaries = null)
+        }
+        open(t) {
+            return this.closed || (this.autoDestroy = OP(this, t), this.schema || (this.schema = this._reader.readSchema()) || this.cancel()), this
+        }
+        throw (t) {
+            return !this.closed && this.autoDestroy && (this.closed = !0) ? this.reset()._reader.throw(t) : Wt
+        }
+        return (t) {
+            return !this.closed && this.autoDestroy && (this.closed = !0) ? this.reset()._reader.return(t) : Wt
+        }
+        next() {
+            if (this.closed) return Wt;
+            let t, {
+                _reader: r
+            } = this;
+            for (; t = this._readNextMessageAndValidate();)
+                if (t.isSchema()) this.reset(t.header());
+                else if (t.isRecordBatch()) {
+                this._recordBatchIndex++;
+                let i = t.header(),
+                    n = r.readMessageBody(t.bodyLength);
+                return {
+                    done: !1,
+                    value: this._loadRecordBatch(i, n)
+                }
+            } else if (t.isDictionaryBatch()) {
+                this._dictionaryIndex++;
+                let i = t.header(),
+                    n = r.readMessageBody(t.bodyLength),
+                    s = this._loadDictionaryBatch(i, n);
+                this.dictionaries.set(i.id, s)
+            }
+            return this.schema && this._recordBatchIndex === 0 ? (this._recordBatchIndex++, {
+                done: !1,
+                value: new aa(this.schema)
+            }) : this.return()
+        }
+        _readNextMessageAndValidate(t) {
+            return this._reader.readMessage(t)
+        }
+    },
+    $c = class extends Xg {
+        constructor(t, r) {
+            super(r), this._reader = new ih(this._handle = t)
+        }
+        isAsync() {
+            return !0
+        }
+        isStream() {
+            return !0
+        } [Symbol.asyncIterator]() {
+            return this
+        }
+        cancel() {
+            return H(this, void 0, void 0, function*() {
+                !this.closed && (this.closed = !0) && (yield this.reset()._reader.return(), this._reader = null, this.dictionaries = null)
+            })
+        }
+        open(t) {
+            return H(this, void 0, void 0, function*() {
+                return this.closed || (this.autoDestroy = OP(this, t), this.schema || (this.schema = yield this._reader.readSchema()) || (yield this.cancel())), this
+            })
+        }
+        throw (t) {
+            return H(this, void 0, void 0, function*() {
+                return !this.closed && this.autoDestroy && (this.closed = !0) ? yield this.reset()._reader.throw(t): Wt
+            })
+        }
+        return (t) {
+            return H(this, void 0, void 0, function*() {
+                return !this.closed && this.autoDestroy && (this.closed = !0) ? yield this.reset()._reader.return(t): Wt
+            })
+        }
+        next() {
+            return H(this, void 0, void 0, function*() {
+                if (this.closed) return Wt;
+                let t, {
+                    _reader: r
+                } = this;
+                for (; t = yield this._readNextMessageAndValidate();)
+                    if (t.isSchema()) yield this.reset(t.header());
+                    else if (t.isRecordBatch()) {
+                    this._recordBatchIndex++;
+                    let i = t.header(),
+                        n = yield r.readMessageBody(t.bodyLength);
+                    return {
+                        done: !1,
+                        value: this._loadRecordBatch(i, n)
+                    }
+                } else if (t.isDictionaryBatch()) {
+                    this._dictionaryIndex++;
+                    let i = t.header(),
+                        n = yield r.readMessageBody(t.bodyLength), s = this._loadDictionaryBatch(i, n);
+                    this.dictionaries.set(i.id, s)
+                }
+                return this.schema && this._recordBatchIndex === 0 ? (this._recordBatchIndex++, {
+                    done: !1,
+                    value: new aa(this.schema)
+                }) : yield this.return()
+            })
+        }
+        _readNextMessageAndValidate(t) {
+            return H(this, void 0, void 0, function*() {
+                return yield this._reader.readMessage(t)
+            })
+        }
+    },
+    Yg = class extends Hc {
+        get footer() {
+            return this._footer
+        }
+        get numDictionaries() {
+            return this._footer ? this._footer.numDictionaries : 0
+        }
+        get numRecordBatches() {
+            return this._footer ? this._footer.numRecordBatches : 0
+        }
+        constructor(t, r) {
+            super(t instanceof Pf ? t : new Pf(t), r)
+        }
+        isSync() {
+            return !0
+        }
+        isFile() {
+            return !0
+        }
+        open(t) {
+            if (!this.closed && !this._footer) {
+                this.schema = (this._footer = this._readFooter()).schema;
+                for (let r of this._footer.dictionaryBatches()) r && this._readDictionaryBatch(this._dictionaryIndex++)
+            }
+            return super.open(t)
+        }
+        readRecordBatch(t) {
+            var r;
+            if (this.closed) return null;
+            this._footer || this.open();
+            let i = (r = this._footer) === null || r === void 0 ? void 0 : r.getRecordBatch(t);
+            if (i && this._handle.seek(i.offset)) {
+                let n = this._reader.readMessage(vt.RecordBatch);
+                if (n?.isRecordBatch()) {
+                    let s = n.header(),
+                        o = this._reader.readMessageBody(n.bodyLength);
+                    return this._loadRecordBatch(s, o)
+                }
+            }
+            return null
+        }
+        _readDictionaryBatch(t) {
+            var r;
+            let i = (r = this._footer) === null || r === void 0 ? void 0 : r.getDictionaryBatch(t);
+            if (i && this._handle.seek(i.offset)) {
+                let n = this._reader.readMessage(vt.DictionaryBatch);
+                if (n?.isDictionaryBatch()) {
+                    let s = n.header(),
+                        o = this._reader.readMessageBody(n.bodyLength),
+                        a = this._loadDictionaryBatch(s, o);
+                    this.dictionaries.set(s.id, a)
+                }
+            }
+        }
+        _readFooter() {
+            let {
+                _handle: t
+            } = this, r = t.size - Rw, i = t.readInt32(r), n = t.readAt(r - i, i);
+            return Zn.decode(n)
+        }
+        _readNextMessageAndValidate(t) {
+            var r;
+            if (this._footer || this.open(), this._footer && this._recordBatchIndex < this.numRecordBatches) {
+                let i = (r = this._footer) === null || r === void 0 ? void 0 : r.getRecordBatch(this._recordBatchIndex);
+                if (i && this._handle.seek(i.offset)) return this._reader.readMessage(t)
+            }
+            return null
+        }
+    },
+    Mw = class extends $c {
+        get footer() {
+            return this._footer
+        }
+        get numDictionaries() {
+            return this._footer ? this._footer.numDictionaries : 0
+        }
+        get numRecordBatches() {
+            return this._footer ? this._footer.numRecordBatches : 0
+        }
+        constructor(t, ...r) {
+            let i = typeof r[0] != "number" ? r.shift() : void 0,
+                n = r[0] instanceof Map ? r.shift() : void 0;
+            super(t instanceof eo ? t : new eo(t, i), n)
+        }
+        isFile() {
+            return !0
+        }
+        isAsync() {
+            return !0
+        }
+        open(t) {
+            let r = Object.create(null, {
+                open: {
+                    get: () => super.open
+                }
+            });
+            return H(this, void 0, void 0, function*() {
+                if (!this.closed && !this._footer) {
+                    this.schema = (this._footer = yield this._readFooter()).schema;
+                    for (let i of this._footer.dictionaryBatches()) i && (yield this._readDictionaryBatch(this._dictionaryIndex++))
+                }
+                return yield r.open.call(this, t)
+            })
+        }
+        readRecordBatch(t) {
+            var r;
+            return H(this, void 0, void 0, function*() {
+                if (this.closed) return null;
+                this._footer || (yield this.open());
+                let i = (r = this._footer) === null || r === void 0 ? void 0 : r.getRecordBatch(t);
+                if (i && (yield this._handle.seek(i.offset))) {
+                    let n = yield this._reader.readMessage(vt.RecordBatch);
+                    if (n?.isRecordBatch()) {
+                        let s = n.header(),
+                            o = yield this._reader.readMessageBody(n.bodyLength);
+                        return this._loadRecordBatch(s, o)
+                    }
+                }
+                return null
+            })
+        }
+        _readDictionaryBatch(t) {
+            var r;
+            return H(this, void 0, void 0, function*() {
+                let i = (r = this._footer) === null || r === void 0 ? void 0 : r.getDictionaryBatch(t);
+                if (i && (yield this._handle.seek(i.offset))) {
+                    let n = yield this._reader.readMessage(vt.DictionaryBatch);
+                    if (n?.isDictionaryBatch()) {
+                        let s = n.header(),
+                            o = yield this._reader.readMessageBody(n.bodyLength), a = this._loadDictionaryBatch(s, o);
+                        this.dictionaries.set(s.id, a)
+                    }
+                }
+            })
+        }
+        _readFooter() {
+            return H(this, void 0, void 0, function*() {
+                let {
+                    _handle: t
+                } = this;
+                t._pending && (yield t._pending);
+                let r = t.size - Rw,
+                    i = yield t.readInt32(r), n = yield t.readAt(r - i, i);
+                return Zn.decode(n)
+            })
+        }
+        _readNextMessageAndValidate(t) {
+            return H(this, void 0, void 0, function*() {
+                if (this._footer || (yield this.open()), this._footer && this._recordBatchIndex < this.numRecordBatches) {
+                    let r = this._footer.getRecordBatch(this._recordBatchIndex);
+                    if (r && (yield this._handle.seek(r.offset))) return yield this._reader.readMessage(t)
+                }
+                return null
+            })
+        }
+    },
+    Pw = class extends Hc {
+        constructor(t, r) {
+            super(t, r)
+        }
+        _loadVectors(t, r, i) {
+            return new _g(r, t.nodes, t.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(i)
+        }
+    };
+
+function OP(e, t) {
+    return t && typeof t.autoDestroy == "boolean" ? t.autoDestroy : e.autoDestroy
+}
+
+function* PP(e) {
+    let t = Ar.from(e);
+    try {
+        if (!t.open({
+                autoDestroy: !1
+            }).closed)
+            do yield t; while (!t.reset().open().closed)
+    } finally {
+        t.cancel()
+    }
+}
+
+function CP(e) {
+    return _r(this, arguments, function*() {
+        let r = yield pt(Ar.from(e));
+        try {
+            if (!(yield pt(r.open({
+                    autoDestroy: !1
+                }))).closed)
+                do yield yield pt(r); while (!(yield pt(r.reset().open())).closed)
+        } finally {
+            yield pt(r.cancel())
+        }
+    })
+}
+
+function NV(e) {
+    return new is(new Pw(e))
+}
+
+function BV(e) {
+    let t = e.peek(jc + 7 & -8);
+    return t && t.byteLength >= 4 ? Hg(t) ? new la(new Yg(e.read())) : new is(new Hc(e)) : new is(new Hc(function*() {}()))
+}
+
+function FV(e) {
+    return H(this, void 0, void 0, function*() {
+        let t = yield e.peek(jc + 7 & -8);
+        return t && t.byteLength >= 4 ? Hg(t) ? new la(new Yg(yield e.read())) : new ca(new $c(e)) : new ca(new $c(function() {
+            return _r(this, arguments, function*() {})
+        }()))
+    })
+}
+
+function DV(e) {
+    return H(this, void 0, void 0, function*() {
+        let {
+            size: t
+        } = yield e.stat(), r = new eo(e, t);
+        return t >= MP && Hg(yield r.readAt(0, jc + 7 & -8)) ? new $g(new Mw(r)) : new ca(new $c(r))
+    })
+}
+var Yt = class e extends J {
+    static assemble(...t) {
+        let r = n => n.flatMap(s => Array.isArray(s) ? r(s) : s instanceof ee ? s.data.children : s.data),
+            i = new e;
+        return i.visitMany(r(t)), i
+    }
+    constructor() {
+        super(), this._byteLength = 0, this._nodes = [], this._buffers = [], this._bufferRegions = []
+    }
+    visit(t) {
+        if (t instanceof St) return this.visitMany(t.data), this;
+        let {
+            type: r
+        } = t;
+        if (!X.isDictionary(r)) {
+            let {
+                length: i
+            } = t;
+            if (i > 2147483647) throw new RangeError("Cannot write arrays larger than 2^31 - 1 in length");
+            if (X.isUnion(r)) this.nodes.push(new Kr(i, 0));
+            else {
+                let {
+                    nullCount: n
+                } = t;
+                X.isNull(r) || Ri.call(this, n <= 0 ? new Uint8Array(0) : Ko(t.offset, i, t.nullBitmap)), this.nodes.push(new Kr(i, n))
+            }
+        }
+        return super.visit(t)
+    }
+    visitNull(t) {
+        return this
+    }
+    visitDictionary(t) {
+        return this.visit(t.clone(t.type.indices))
+    }
+    get nodes() {
+        return this._nodes
+    }
+    get buffers() {
+        return this._buffers
+    }
+    get byteLength() {
+        return this._byteLength
+    }
+    get bufferRegions() {
+        return this._bufferRegions
+    }
+};
+
+function Ri(e) {
+    let t = e.byteLength + 7 & -8;
+    return this.buffers.push(e), this.bufferRegions.push(new lr(this._byteLength, t)), this._byteLength += t, this
+}
+
+function LV(e) {
+    var t;
+    let {
+        type: r,
+        length: i,
+        typeIds: n,
+        valueOffsets: s
+    } = e;
+    if (Ri.call(this, n), r.mode === Vt.Sparse) return Cw.call(this, e);
+    if (r.mode === Vt.Dense) {
+        if (e.offset <= 0) return Ri.call(this, s), Cw.call(this, e);
+        {
+            let o = new Int32Array(i),
+                a = Object.create(null),
+                c = Object.create(null);
+            for (let l, u, f = -1; ++f < i;)(l = n[f]) !== void 0 && ((u = a[l]) === void 0 && (u = a[l] = s[f]), o[f] = s[f] - u, c[l] = ((t = c[l]) !== null && t !== void 0 ? t : 0) + 1);
+            Ri.call(this, o), this.visitMany(e.children.map((l, u) => {
+                let f = r.typeIds[u],
+                    h = a[f],
+                    d = c[f];
+                return l.slice(h, Math.min(i, d))
+            }))
+        }
+    }
+    return this
+}
+
+function kV(e) {
+    let t;
+    return e.nullCount >= e.length ? Ri.call(this, new Uint8Array(0)) : (t = e.values) instanceof Uint8Array ? Ri.call(this, Ko(e.offset, e.length, t)) : Ri.call(this, Go(e.values))
+}
+
+function ns(e) {
+    return Ri.call(this, e.values.subarray(0, e.length * e.stride))
+}
+
+function qg(e) {
+    let {
+        length: t,
+        values: r,
+        valueOffsets: i
+    } = e, n = Kt(i[0]), s = Kt(i[t]), o = Math.min(s - n, r.byteLength - n);
+    return Ri.call(this, Im(-n, t + 1, i)), Ri.call(this, r.subarray(n, n + o)), this
+}
+
+function Ow(e) {
+    let {
+        length: t,
+        valueOffsets: r
+    } = e;
+    if (r) {
+        let {
+            [0]: i, [t]: n
+        } = r;
+        return Ri.call(this, Im(-i, t + 1, r)), this.visit(e.children[0].slice(i, n - i))
+    }
+    return this.visit(e.children[0])
+}
+
+function Cw(e) {
+    return this.visitMany(e.type.children.map((t, r) => e.children[r]).filter(Boolean))[0]
+}
+Yt.prototype.visitBool = kV;
+Yt.prototype.visitInt = ns;
+Yt.prototype.visitFloat = ns;
+Yt.prototype.visitUtf8 = qg;
+Yt.prototype.visitLargeUtf8 = qg;
+Yt.prototype.visitBinary = qg;
+Yt.prototype.visitLargeBinary = qg;
+Yt.prototype.visitFixedSizeBinary = ns;
+Yt.prototype.visitDate = ns;
+Yt.prototype.visitTimestamp = ns;
+Yt.prototype.visitTime = ns;
+Yt.prototype.visitDecimal = ns;
+Yt.prototype.visitList = Ow;
+Yt.prototype.visitStruct = Cw;
+Yt.prototype.visitUnion = LV;
+Yt.prototype.visitInterval = ns;
+Yt.prototype.visitDuration = ns;
+Yt.prototype.visitFixedSizeList = Ow;
+Yt.prototype.visitMap = Ow;
+var ua = class extends ta {
+        static throughNode(t) {
+            throw new Error('"throughNode" not available in this environment')
+        }
+        static throughDOM(t, r) {
+            throw new Error('"throughDOM" not available in this environment')
+        }
+        constructor(t) {
+            super(), this._position = 0, this._started = !1, this._sink = new ln, this._schema = null, this._dictionaryBlocks = [], this._recordBatchBlocks = [], this._dictionaryDeltaOffsets = new Map, je(t) || (t = {
+                autoDestroy: !0,
+                writeLegacyIpcFormat: !1
+            }), this._autoDestroy = typeof t.autoDestroy == "boolean" ? t.autoDestroy : !0, this._writeLegacyIpcFormat = typeof t.writeLegacyIpcFormat == "boolean" ? t.writeLegacyIpcFormat : !1
+        }
+        toString(t = !1) {
+            return this._sink.toString(t)
+        }
+        toUint8Array(t = !1) {
+            return this._sink.toUint8Array(t)
+        }
+        writeAll(t) {
+            return yr(t) ? t.then(r => this.writeAll(r)) : $r(t) ? Bw(this, t) : Nw(this, t)
+        }
+        get closed() {
+            return this._sink.closed
+        } [Symbol.asyncIterator]() {
+            return this._sink[Symbol.asyncIterator]()
+        }
+        toDOMStream(t) {
+            return this._sink.toDOMStream(t)
+        }
+        toNodeStream(t) {
+            return this._sink.toNodeStream(t)
+        }
+        close() {
+            return this.reset()._sink.close()
+        }
+        abort(t) {
+            return this.reset()._sink.abort(t)
+        }
+        finish() {
+            return this._autoDestroy ? this.close() : this.reset(this._sink, this._schema), this
+        }
+        reset(t = this._sink, r = null) {
+            return t === this._sink || t instanceof ln ? this._sink = t : (this._sink = new ln, t && XR(t) ? this.toDOMStream({
+                type: "bytes"
+            }).pipeTo(t) : t && YR(t) && this.toNodeStream({
+                objectMode: !1
+            }).pipe(t)), this._started && this._schema && this._writeFooter(this._schema), this._started = !1, this._dictionaryBlocks = [], this._recordBatchBlocks = [], this._dictionaryDeltaOffsets = new Map, (!r || !oa(r, this._schema)) && (r == null ? (this._position = 0, this._schema = null) : (this._started = !0, this._schema = r, this._writeSchema(r))), this
+        }
+        write(t) {
+            let r = null;
+            if (this._sink) {
+                if (t == null) return this.finish() && void 0;
+                if (t instanceof cr && !(r = t.schema)) return this.finish() && void 0;
+                if (t instanceof ee && !(r = t.schema)) return this.finish() && void 0
+            } else throw new Error("RecordBatchWriter is closed");
+            if (r && !oa(r, this._schema)) {
+                if (this._started && this._autoDestroy) return this.close();
+                this.reset(this._sink, r)
+            }
+            t instanceof ee ? t instanceof aa || this._writeRecordBatch(t) : t instanceof cr ? this.writeAll(t.batches) : hi(t) && this.writeAll(t)
+        }
+        _writeMessage(t, r = 8) {
+            let i = r - 1,
+                n = fr.encode(t),
+                s = n.byteLength,
+                o = this._writeLegacyIpcFormat ? 4 : 8,
+                a = s + o + i & ~i,
+                c = a - s - o;
+            return t.headerType === vt.RecordBatch ? this._recordBatchBlocks.push(new Kn(a, t.bodyLength, this._position)) : t.headerType === vt.DictionaryBatch && this._dictionaryBlocks.push(new Kn(a, t.bodyLength, this._position)), this._writeLegacyIpcFormat || this._write(Int32Array.of(-1)), this._write(Int32Array.of(a - o)), s > 0 && this._write(n), this._writePadding(c)
+        }
+        _write(t) {
+            if (this._started) {
+                let r = at(t);
+                r && r.byteLength > 0 && (this._sink.write(r), this._position += r.byteLength)
+            }
+            return this
+        }
+        _writeSchema(t) {
+            return this._writeMessage(fr.from(t))
+        }
+        _writeFooter(t) {
+            return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0))
+        }
+        _writeMagic() {
+            return this._write(Wc)
+        }
+        _writePadding(t) {
+            return t > 0 ? this._write(new Uint8Array(t)) : this
+        }
+        _writeRecordBatch(t) {
+            let {
+                byteLength: r,
+                nodes: i,
+                bufferRegions: n,
+                buffers: s
+            } = Yt.assemble(t), o = new Ie(t.numRows, i, n), a = fr.from(o, r);
+            return this._writeDictionaries(t)._writeMessage(a)._writeBodyBuffers(s)
+        }
+        _writeDictionaryBatch(t, r, i = !1) {
+            this._dictionaryDeltaOffsets.set(r, t.length + (this._dictionaryDeltaOffsets.get(r) || 0));
+            let {
+                byteLength: n,
+                nodes: s,
+                bufferRegions: o,
+                buffers: a
+            } = Yt.assemble(new St([t])), c = new Ie(t.length, s, o), l = new ur(c, r, i), u = fr.from(l, n);
+            return this._writeMessage(u)._writeBodyBuffers(a)
+        }
+        _writeBodyBuffers(t) {
+            let r, i, n;
+            for (let s = -1, o = t.length; ++s < o;)(r = t[s]) && (i = r.byteLength) > 0 && (this._write(r), (n = (i + 7 & -8) - i) > 0 && this._writePadding(n));
+            return this
+        }
+        _writeDictionaries(t) {
+            for (let [r, i] of t.dictionaries) {
+                let n = this._dictionaryDeltaOffsets.get(r) || 0;
+                if (n === 0 || (i = i?.slice(n)).length > 0)
+                    for (let s of i.data) this._writeDictionaryBatch(s, r, n > 0), n += s.length
+            }
+            return this
+        }
+    },
+    sh = class e extends ua {
+        static writeAll(t, r) {
+            let i = new e(r);
+            return yr(t) ? t.then(n => i.writeAll(n)) : $r(t) ? Bw(i, t) : Nw(i, t)
+        }
+    },
+    oh = class e extends ua {
+        static writeAll(t) {
+            let r = new e;
+            return yr(t) ? t.then(i => r.writeAll(i)) : $r(t) ? Bw(r, t) : Nw(r, t)
+        }
+        constructor() {
+            super(), this._autoDestroy = !0
+        }
+        _writeSchema(t) {
+            return this._writeMagic()._writePadding(2)
+        }
+        _writeFooter(t) {
+            let r = Zn.encode(new Zn(t, Bt.V5, this._recordBatchBlocks, this._dictionaryBlocks));
+            return super._writeFooter(t)._write(r)._write(Int32Array.of(r.byteLength))._writeMagic()
+        }
+    };
+
+function Nw(e, t) {
+    let r = t;
+    t instanceof cr && (r = t.batches, e.reset(void 0, t.schema));
+    for (let i of r) e.write(i);
+    return e.finish()
+}
+
+function Bw(e, t) {
+    var r, i, n, s, o, a, c;
+    return H(this, void 0, void 0, function*() {
+        try {
+            for (r = !0, i = fi(t); n = yield i.next(), s = n.done, !s; r = !0) {
+                c = n.value, r = !1;
+                let l = c;
+                e.write(l)
+            }
+        } catch (l) {
+            o = {
+                error: l
+            }
+        } finally {
+            try {
+                !r && !s && (a = i.return) && (yield a.call(i))
+            } finally {
+                if (o) throw o.error
+            }
+        }
+        return e.finish()
+    })
+}
+
+function NP(e, t) {
+    if ($r(e)) return VV(e, t);
+    if (hi(e)) return UV(e, t);
+    throw new Error("toDOMStream() must be called with an Iterable or AsyncIterable")
+}
+
+function UV(e, t) {
+    let r = null,
+        i = t?.type === "bytes" || !1,
+        n = t?.highWaterMark || Math.pow(2, 24);
+    return new ReadableStream(Object.assign(Object.assign({}, t), {
+        start(o) {
+            s(o, r || (r = e[Symbol.iterator]()))
+        },
+        pull(o) {
+            r ? s(o, r) : o.close()
+        },
+        cancel() {
+            (r?.return && r.return() || !0) && (r = null)
+        }
+    }), Object.assign({
+        highWaterMark: i ? n : void 0
+    }, t));
+
+    function s(o, a) {
+        let c, l = null,
+            u = o.desiredSize || null;
+        for (; !(l = a.next(i ? u : null)).done;)
+            if (ArrayBuffer.isView(l.value) && (c = at(l.value)) && (u != null && i && (u = u - c.byteLength + 1), l.value = c), o.enqueue(l.value), u != null && --u <= 0) return;
+        o.close()
+    }
+}
+
+function VV(e, t) {
+    let r = null,
+        i = t?.type === "bytes" || !1,
+        n = t?.highWaterMark || Math.pow(2, 24);
+    return new ReadableStream(Object.assign(Object.assign({}, t), {
+        start(o) {
+            return H(this, void 0, void 0, function*() {
+                yield s(o, r || (r = e[Symbol.asyncIterator]()))
+            })
+        },
+        pull(o) {
+            return H(this, void 0, void 0, function*() {
+                r ? yield s(o, r): o.close()
+            })
+        },
+        cancel() {
+            return H(this, void 0, void 0, function*() {
+                (r?.return && (yield r.return()) || !0) && (r = null)
+            })
+        }
+    }), Object.assign({
+        highWaterMark: i ? n : void 0
+    }, t));
+
+    function s(o, a) {
+        return H(this, void 0, void 0, function*() {
+            let c, l = null,
+                u = o.desiredSize || null;
+            for (; !(l = yield a.next(i ? u : null)).done;)
+                if (ArrayBuffer.isView(l.value) && (c = at(l.value)) && (u != null && i && (u = u - c.byteLength + 1), l.value = c), o.enqueue(l.value), u != null && --u <= 0) return;
+            o.close()
+        })
+    }
+}
+
+function DP(e) {
+    return new Fw(e)
+}
+var Fw = class {
+        constructor(t) {
+            this._numChunks = 0, this._finished = !1, this._bufferedSize = 0;
+            let {
+                ["readableStrategy"]: r, ["writableStrategy"]: i, ["queueingStrategy"]: n = "count"
+            } = t, s = HR(t, ["readableStrategy", "writableStrategy", "queueingStrategy"]);
+            this._controller = null, this._builder = ra(s), this._getSize = n !== "bytes" ? BP : FP;
+            let {
+                ["highWaterMark"]: o = n === "bytes" ? Math.pow(2, 14) : 1e3
+            } = Object.assign({}, r), {
+                ["highWaterMark"]: a = n === "bytes" ? Math.pow(2, 14) : 1e3
+            } = Object.assign({}, i);
+            this.readable = new ReadableStream({
+                cancel: () => {
+                    this._builder.clear()
+                },
+                pull: c => {
+                    this._maybeFlush(this._builder, this._controller = c)
+                },
+                start: c => {
+                    this._maybeFlush(this._builder, this._controller = c)
+                }
+            }, {
+                highWaterMark: o,
+                size: n !== "bytes" ? BP : FP
+            }), this.writable = new WritableStream({
+                abort: () => {
+                    this._builder.clear()
+                },
+                write: () => {
+                    this._maybeFlush(this._builder, this._controller)
+                },
+                close: () => {
+                    this._maybeFlush(this._builder.finish(), this._controller)
+                }
+            }, {
+                highWaterMark: a,
+                size: c => this._writeValueAndReturnChunkSize(c)
+            })
+        }
+        _writeValueAndReturnChunkSize(t) {
+            let r = this._bufferedSize;
+            return this._bufferedSize = this._getSize(this._builder.append(t)), this._bufferedSize - r
+        }
+        _maybeFlush(t, r) {
+            r != null && (this._bufferedSize >= r.desiredSize && ++this._numChunks && this._enqueue(r, t.toVector()), t.finished && ((t.length > 0 || this._numChunks === 0) && ++this._numChunks && this._enqueue(r, t.toVector()), !this._finished && (this._finished = !0) && this._enqueue(r, null)))
+        }
+        _enqueue(t, r) {
+            this._bufferedSize = 0, this._controller = null, r == null ? t.close() : t.enqueue(r)
+        }
+    },
+    BP = e => {
+        var t;
+        return (t = e?.length) !== null && t !== void 0 ? t : 0
+    },
+    FP = e => {
+        var t;
+        return (t = e?.byteLength) !== null && t !== void 0 ? t : 0
+    };
+
+function Zg(e, t) {
+    let r = new ln,
+        i = null,
+        n = new ReadableStream({
+            cancel() {
+                return H(this, void 0, void 0, function*() {
+                    yield r.close()
+                })
+            },
+            start(a) {
+                return H(this, void 0, void 0, function*() {
+                    yield o(a, i || (i = yield s()))
+                })
+            },
+            pull(a) {
+                return H(this, void 0, void 0, function*() {
+                    i ? yield o(a, i): a.close()
+                })
+            }
+        });
+    return {
+        writable: new WritableStream(r, Object.assign({
+            highWaterMark: Math.pow(2, 14)
+        }, e)),
+        readable: n
+    };
+
+    function s() {
+        return H(this, void 0, void 0, function*() {
+            return yield(yield Ar.from(r)).open(t)
+        })
+    }
+
+    function o(a, c) {
+        return H(this, void 0, void 0, function*() {
+            let l = a.desiredSize,
+                u = null;
+            for (; !(u = yield c.next()).done;)
+                if (a.enqueue(u.value), l != null && --l <= 0) return;
+            a.close()
+        })
+    }
+}
+
+function Kg(e, t) {
+    let r = new this(e),
+        i = new qr(r),
+        n = new ReadableStream({
+            cancel() {
+                return H(this, void 0, void 0, function*() {
+                    yield i.cancel()
+                })
+            },
+            pull(o) {
+                return H(this, void 0, void 0, function*() {
+                    yield s(o)
+                })
+            },
+            start(o) {
+                return H(this, void 0, void 0, function*() {
+                    yield s(o)
+                })
+            }
+        }, Object.assign({
+            highWaterMark: Math.pow(2, 14)
+        }, t));
+    return {
+        writable: new WritableStream(r, e),
+        readable: n
+    };
+
+    function s(o) {
+        return H(this, void 0, void 0, function*() {
+            let a = null,
+                c = o.desiredSize;
+            for (; a = yield i.read(c || null);)
+                if (o.enqueue(a), c != null && (c -= a.byteLength) <= 0) return;
+            o.close()
+        })
+    }
+}
+
+function ah(e) {
+    let t = Ar.from(e);
+    return yr(t) ? t.then(r => ah(r)) : t.isAsync() ? t.readAll().then(r => new cr(r)) : new cr(t.readAll())
+}
+var WV = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, Xx), yw), lw), Yx), zx), cw), Hx), {
+    compareSchemas: oa,
+    compareFields: uP,
+    compareTypes: fP
+});
+Ae.toDOMStream = NP;
+$t.throughDOM = DP;
+Ar.throughDOM = Zg;
+la.throughDOM = Zg;
+is.throughDOM = Zg;
+ua.throughDOM = Kg;
+oh.throughDOM = Kg;
+sh.throughDOM = Kg;
+var fa = {};
+fa.EPSILON = 1e-12;
+fa.debug = !0;
+fa.precision = 4;
+fa.printTypes = !1;
+fa.printDegrees = !1;
+fa.printRowMajor = !0;
+
+function LP(e) {
+    return Array.isArray(e) || ArrayBuffer.isView(e) && e.length !== void 0
+}
+
+function kP(e) {
+    return e.clone ? e.clone() : new Array(e)
+}
+
+function HV(e, t) {
+    if (LP(e)) {
+        for (var r = kP(e), i = 0; i < r.length; ++i) r[i] = t(r[i], i, r);
+        return r
+    }
+    return t(e)
+}
+
+function hn(e, t, r) {
+    return HV(e, function(i) {
+        return Math.max(t, Math.min(r, i))
+    })
+}
+var F, UP = new TextDecoder("utf-8", {
+    ignoreBOM: !0,
+    fatal: !0
+});
+UP.decode();
+var Gg = new Uint8Array;
+
+function ch() {
+    return Gg.byteLength === 0 && (Gg = new Uint8Array(F.memory.buffer)), Gg
+}
+
+function hr(e, t) {
+    return UP.decode(ch().subarray(e, e + t))
+}
+var ss = new Array(32).fill(void 0);
+ss.push(void 0, null, !0, !1);
+var lh = ss.length;
+
+function Rt(e) {
+    lh === ss.length && ss.push(ss.length + 1);
+    let t = lh;
+    return lh = ss[t], ss[t] = e, t
+}
+
+function wt(e) {
+    return ss[e]
+}
+
+function XV(e) {
+    e < 36 || (ss[e] = lh, lh = e)
+}
+
+function Ne(e) {
+    let t = wt(e);
+    return XV(e), t
+}
+
+function Lw(e) {
+    let t = typeof e;
+    if (t == "number" || t == "boolean" || e == null) return `${e}`;
+    if (t == "string") return `"${e}"`;
+    if (t == "symbol") {
+        let n = e.description;
+        return n == null ? "Symbol" : `Symbol(${n})`
+    }
+    if (t == "function") {
+        let n = e.name;
+        return typeof n == "string" && n.length > 0 ? `Function(${n})` : "Function"
+    }
+    if (Array.isArray(e)) {
+        let n = e.length,
+            s = "[";
+        n > 0 && (s += Lw(e[0]));
+        for (let o = 1; o < n; o++) s += ", " + Lw(e[o]);
+        return s += "]", s
+    }
+    let r = /\[object ([^\]]+)\]/.exec(toString.call(e)),
+        i;
+    if (r.length > 1) i = r[1];
+    else return toString.call(e);
+    if (i == "Object") try {
+        return "Object(" + JSON.stringify(e) + ")"
+    } catch {
+        return "Object"
+    }
+    return e instanceof Error ? `${e.name}: ${e.message}
+${e.stack}` : i
+}
+var da = 0,
+    Jg = new TextEncoder("utf-8"),
+    YV = typeof Jg.encodeInto == "function" ? function(e, t) {
+        return Jg.encodeInto(e, t)
+    } : function(e, t) {
+        let r = Jg.encode(e);
+        return t.set(r), {
+            read: e.length,
+            written: r.length
+        }
+    };
+
+function Dw(e, t, r) {
+    if (r === void 0) {
+        let a = Jg.encode(e),
+            c = t(a.length);
+        return ch().subarray(c, c + a.length).set(a), da = a.length, c
+    }
+    let i = e.length,
+        n = t(i),
+        s = ch(),
+        o = 0;
+    for (; o < i; o++) {
+        let a = e.charCodeAt(o);
+        if (a > 127) break;
+        s[n + o] = a
+    }
+    if (o !== i) {
+        o !== 0 && (e = e.slice(o)), n = r(n, i, i = o + e.length * 3);
+        let a = ch().subarray(n + o, n + i),
+            c = YV(e, a);
+        o += c.written
+    }
+    return da = o, n
+}
+var Qg = new Int32Array;
+
+function it() {
+    return Qg.byteLength === 0 && (Qg = new Int32Array(F.memory.buffer)), Qg
+}
+
+function qV(e, t, r, i) {
+    let n = {
+            a: e,
+            b: t,
+            cnt: 1,
+            dtor: r
+        },
+        s = (...o) => {
+            n.cnt++;
+            let a = n.a;
+            n.a = 0;
+            try {
+                return i(a, n.b, ...o)
+            } finally {
+                --n.cnt === 0 ? F.__wbindgen_export_2.get(n.dtor)(a, n.b) : n.a = a
+            }
+        };
+    return s.original = n, s
+}
+
+function ZV(e, t, r) {
+    F._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h3585afe01e623669(e, t, Rt(r))
+}
+var Xe = new Uint32Array(2),
+    ha = new BigInt64Array(Xe.buffer),
+    t_ = new BigUint64Array;
+
+function KV() {
+    return t_.byteLength === 0 && (t_ = new BigUint64Array(F.memory.buffer)), t_
+}
+
+function GV(e, t) {
+    return KV().subarray(e / 8, e / 8 + t)
+}
+
+function JV(e, t) {
+    let r = t(e.length * 1);
+    return ch().set(e, r / 1), da = e.length, r
+}
+
+function VP(e) {
+    try {
+        let n = F.__wbindgen_add_to_stack_pointer(-16),
+            s = JV(e, F.__wbindgen_malloc),
+            o = da;
+        F.readParquet(n, s, o);
+        var t = it()[n / 4 + 0],
+            r = it()[n / 4 + 1],
+            i = it()[n / 4 + 2];
+        if (i) throw Ne(r);
+        return Ne(t)
+    } finally {
+        F.__wbindgen_add_to_stack_pointer(16)
+    }
+}
+
+function QV(e) {
+    return e == null
+}
+
+function Mi(e, t) {
+    try {
+        return e.apply(this, t)
+    } catch (r) {
+        F.__wbindgen_exn_store(Rt(r))
+    }
+}
+
+function tz(e, t, r, i) {
+    F.wasm_bindgen__convert__closures__invoke2_mut__haace1f71440c779f(e, t, Rt(r), Rt(i))
+}
+var pwt = Object.freeze({
+        UNCOMPRESSED: 0,
+        0: "UNCOMPRESSED",
+        SNAPPY: 1,
+        1: "SNAPPY",
+        GZIP: 2,
+        2: "GZIP",
+        BROTLI: 3,
+        3: "BROTLI",
+        LZ4: 4,
+        4: "LZ4",
+        ZSTD: 5,
+        5: "ZSTD",
+        LZ4_RAW: 6,
+        6: "LZ4_RAW"
+    }),
+    mwt = Object.freeze({
+        PLAIN: 0,
+        0: "PLAIN",
+        PLAIN_DICTIONARY: 1,
+        1: "PLAIN_DICTIONARY",
+        RLE: 2,
+        2: "RLE",
+        BIT_PACKED: 3,
+        3: "BIT_PACKED",
+        DELTA_BINARY_PACKED: 4,
+        4: "DELTA_BINARY_PACKED",
+        DELTA_LENGTH_BYTE_ARRAY: 5,
+        5: "DELTA_LENGTH_BYTE_ARRAY",
+        DELTA_BYTE_ARRAY: 6,
+        6: "DELTA_BYTE_ARRAY",
+        RLE_DICTIONARY: 7,
+        7: "RLE_DICTIONARY",
+        BYTE_STREAM_SPLIT: 8,
+        8: "BYTE_STREAM_SPLIT"
+    }),
+    gwt = Object.freeze({
+        V1: 0,
+        0: "V1",
+        V2: 1,
+        1: "V2"
+    }),
+    kw = class e {
+        static __wrap(t) {
+            let r = Object.create(e.prototype);
+            return r.ptr = t, r
+        }
+        __destroy_into_raw() {
+            let t = this.ptr;
+            return this.ptr = 0, t
+        }
+        free() {
+            let t = this.__destroy_into_raw();
+            F.__wbg_arrowschema_free(t)
+        }
+        copy() {
+            let t = F.arrowschema_copy(this.ptr);
+            return e.__wrap(t)
+        }
+    },
+    Uw = class e {
+        static __wrap(t) {
+            let r = Object.create(e.prototype);
+            return r.ptr = t, r
+        }
+        __destroy_into_raw() {
+            let t = this.ptr;
+            return this.ptr = 0, t
+        }
+        free() {
+            let t = this.__destroy_into_raw();
+            F.__wbg_columnchunkmetadata_free(t)
+        }
+        filePath() {
+            try {
+                let i = F.__wbindgen_add_to_stack_pointer(-16);
+                F.columnchunkmetadata_filePath(i, this.ptr);
+                var t = it()[i / 4 + 0],
+                    r = it()[i / 4 + 1];
+                let n;
+                return t !== 0 && (n = hr(t, r).slice(), F.__wbindgen_free(t, r * 1)), n
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16)
+            }
+        }
+        fileOffset() {
+            try {
+                let i = F.__wbindgen_add_to_stack_pointer(-16);
+                F.columnchunkmetadata_fileOffset(i, this.ptr);
+                var t = it()[i / 4 + 0],
+                    r = it()[i / 4 + 1];
+                return Xe[0] = t, Xe[1] = r, ha[0]
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16)
+            }
+        }
+        pathInSchema() {
+            try {
+                let i = F.__wbindgen_add_to_stack_pointer(-16);
+                F.columnchunkmetadata_pathInSchema(i, this.ptr);
+                var t = it()[i / 4 + 0],
+                    r = it()[i / 4 + 1];
+                return hr(t, r)
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16), F.__wbindgen_free(t, r)
+            }
+        }
+        statistics_exist() {
+            try {
+                let n = F.__wbindgen_add_to_stack_pointer(-16);
+                F.columnchunkmetadata_statistics_exist(n, this.ptr);
+                var t = it()[n / 4 + 0],
+                    r = it()[n / 4 + 1],
+                    i = it()[n / 4 + 2];
+                if (i) throw Ne(r);
+                return t !== 0
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16)
+            }
+        }
+        getStatisticsMinValue() {
+            try {
+                let n = F.__wbindgen_add_to_stack_pointer(-16);
+                F.columnchunkmetadata_getStatisticsMinValue(n, this.ptr);
+                var t = it()[n / 4 + 0],
+                    r = it()[n / 4 + 1],
+                    i = it()[n / 4 + 2];
+                if (i) throw Ne(r);
+                return Ne(t)
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16)
+            }
+        }
+        getStatisticsMaxValue() {
+            try {
+                let n = F.__wbindgen_add_to_stack_pointer(-16);
+                F.columnchunkmetadata_getStatisticsMaxValue(n, this.ptr);
+                var t = it()[n / 4 + 0],
+                    r = it()[n / 4 + 1],
+                    i = it()[n / 4 + 2];
+                if (i) throw Ne(r);
+                return Ne(t)
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16)
+            }
+        }
+        getStatisticsNullCount() {
+            try {
+                let n = F.__wbindgen_add_to_stack_pointer(-16);
+                F.columnchunkmetadata_getStatisticsNullCount(n, this.ptr);
+                var t = it()[n / 4 + 0],
+                    r = it()[n / 4 + 1],
+                    i = it()[n / 4 + 2];
+                if (i) throw Ne(r);
+                return Ne(t)
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16)
+            }
+        }
+        numValues() {
+            try {
+                let i = F.__wbindgen_add_to_stack_pointer(-16);
+                F.columnchunkmetadata_numValues(i, this.ptr);
+                var t = it()[i / 4 + 0],
+                    r = it()[i / 4 + 1];
+                return Xe[0] = t, Xe[1] = r, ha[0]
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16)
+            }
+        }
+        compressedSize() {
+            try {
+                let i = F.__wbindgen_add_to_stack_pointer(-16);
+                F.columnchunkmetadata_compressedSize(i, this.ptr);
+                var t = it()[i / 4 + 0],
+                    r = it()[i / 4 + 1];
+                return Xe[0] = t, Xe[1] = r, ha[0]
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16)
+            }
+        }
+        uncompressedSize() {
+            try {
+                let i = F.__wbindgen_add_to_stack_pointer(-16);
+                F.columnchunkmetadata_uncompressedSize(i, this.ptr);
+                var t = it()[i / 4 + 0],
+                    r = it()[i / 4 + 1];
+                return Xe[0] = t, Xe[1] = r, ha[0]
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16)
+            }
+        }
+        dataPageOffset() {
+            try {
+                let i = F.__wbindgen_add_to_stack_pointer(-16);
+                F.columnchunkmetadata_dataPageOffset(i, this.ptr);
+                var t = it()[i / 4 + 0],
+                    r = it()[i / 4 + 1];
+                return Xe[0] = t, Xe[1] = r, ha[0]
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16)
+            }
+        }
+        hasIndexPage() {
+            return F.columnchunkmetadata_hasIndexPage(this.ptr) !== 0
+        }
+        indexPageOffset() {
+            try {
+                let n = F.__wbindgen_add_to_stack_pointer(-16);
+                F.columnchunkmetadata_indexPageOffset(n, this.ptr);
+                var t = it()[n / 4 + 0],
+                    r = it()[n / 4 + 1],
+                    i = it()[n / 4 + 2];
+                return Xe[0] = r, Xe[1] = i, t === 0 ? void 0 : ha[0]
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16)
+            }
+        }
+        dictionaryPageOffset() {
+            try {
+                let n = F.__wbindgen_add_to_stack_pointer(-16);
+                F.columnchunkmetadata_dictionaryPageOffset(n, this.ptr);
+                var t = it()[n / 4 + 0],
+                    r = it()[n / 4 + 1],
+                    i = it()[n / 4 + 2];
+                return Xe[0] = r, Xe[1] = i, t === 0 ? void 0 : ha[0]
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16)
+            }
+        }
+        numColumnEncodings() {
+            return F.columnchunkmetadata_numColumnEncodings(this.ptr) >>> 0
+        }
+        byteRange() {
+            try {
+                let n = F.__wbindgen_add_to_stack_pointer(-16);
+                F.columnchunkmetadata_byteRange(n, this.ptr);
+                var t = it()[n / 4 + 0],
+                    r = it()[n / 4 + 1],
+                    i = GV(t, r).slice();
+                return F.__wbindgen_free(t, r * 8), i
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16)
+            }
+        }
+    };
+var Vw = class e {
+        static __wrap(t) {
+            let r = Object.create(e.prototype);
+            return r.ptr = t, r
+        }
+        __destroy_into_raw() {
+            let t = this.ptr;
+            return this.ptr = 0, t
+        }
+        free() {
+            let t = this.__destroy_into_raw();
+            F.__wbg_filemetadata_free(t)
+        }
+        copy() {
+            let t = F.filemetadata_copy(this.ptr);
+            return e.__wrap(t)
+        }
+        version() {
+            return F.filemetadata_version(this.ptr)
+        }
+        numRows() {
+            return F.filemetadata_numRows(this.ptr) >>> 0
+        }
+        createdBy() {
+            try {
+                let i = F.__wbindgen_add_to_stack_pointer(-16);
+                F.filemetadata_createdBy(i, this.ptr);
+                var t = it()[i / 4 + 0],
+                    r = it()[i / 4 + 1];
+                let n;
+                return t !== 0 && (n = hr(t, r).slice(), F.__wbindgen_free(t, r * 1)), n
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16)
+            }
+        }
+        numRowGroups() {
+            return F.filemetadata_numRowGroups(this.ptr) >>> 0
+        }
+        rowGroup(t) {
+            let r = F.filemetadata_rowGroup(this.ptr, t);
+            return zw.__wrap(r)
+        }
+        schema() {
+            let t = F.filemetadata_schema(this.ptr);
+            return Ww.__wrap(t)
+        }
+        keyValueMetadata() {
+            try {
+                let n = F.__wbindgen_add_to_stack_pointer(-16);
+                F.filemetadata_keyValueMetadata(n, this.ptr);
+                var t = it()[n / 4 + 0],
+                    r = it()[n / 4 + 1],
+                    i = it()[n / 4 + 2];
+                if (i) throw Ne(r);
+                return Ne(t)
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16)
+            }
+        }
+        arrowSchema() {
+            try {
+                let n = F.__wbindgen_add_to_stack_pointer(-16);
+                F.filemetadata_arrowSchema(n, this.ptr);
+                var t = it()[n / 4 + 0],
+                    r = it()[n / 4 + 1],
+                    i = it()[n / 4 + 2];
+                if (i) throw Ne(r);
+                return kw.__wrap(t)
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16)
+            }
+        }
+    },
+    zw = class e {
+        static __wrap(t) {
+            let r = Object.create(e.prototype);
+            return r.ptr = t, r
+        }
+        __destroy_into_raw() {
+            let t = this.ptr;
+            return this.ptr = 0, t
+        }
+        free() {
+            let t = this.__destroy_into_raw();
+            F.__wbg_rowgroupmetadata_free(t)
+        }
+        numRows() {
+            return F.rowgroupmetadata_numRows(this.ptr) >>> 0
+        }
+        numColumns() {
+            return F.rowgroupmetadata_numColumns(this.ptr) >>> 0
+        }
+        column(t) {
+            let r = F.rowgroupmetadata_column(this.ptr, t);
+            return Uw.__wrap(r)
+        }
+        totalByteSize() {
+            return F.rowgroupmetadata_totalByteSize(this.ptr) >>> 0
+        }
+        compressedSize() {
+            return F.rowgroupmetadata_compressedSize(this.ptr) >>> 0
+        }
+    },
+    Ww = class e {
+        static __wrap(t) {
+            let r = Object.create(e.prototype);
+            return r.ptr = t, r
+        }
+        __destroy_into_raw() {
+            let t = this.ptr;
+            return this.ptr = 0, t
+        }
+        free() {
+            let t = this.__destroy_into_raw();
+            F.__wbg_schemadescriptor_free(t)
+        }
+        name() {
+            try {
+                let i = F.__wbindgen_add_to_stack_pointer(-16);
+                F.schemadescriptor_name(i, this.ptr);
+                var t = it()[i / 4 + 0],
+                    r = it()[i / 4 + 1];
+                return hr(t, r)
+            } finally {
+                F.__wbindgen_add_to_stack_pointer(16), F.__wbindgen_free(t, r)
+            }
+        }
+        numColumns() {
+            return F.schemadescriptor_numColumns(this.ptr) >>> 0
+        }
+        numFields() {
+            return F.schemadescriptor_numFields(this.ptr) >>> 0
+        }
+    };
+async function ez(e, t) {
+    if (typeof Response == "function" && e instanceof Response) {
+        if (typeof WebAssembly.instantiateStreaming == "function") try {
+            return await WebAssembly.instantiateStreaming(e, t)
+        } catch (i) {
+            if (e.headers.get("Content-Type") != "application/wasm") console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", i);
+            else throw i
+        }
+        let r = await e.arrayBuffer();
+        return await WebAssembly.instantiate(r, t)
+    } else {
+        let r = await WebAssembly.instantiate(e, t);
+        return r instanceof WebAssembly.Instance ? {
+            instance: r,
+            module: e
+        } : r
+    }
+}
+
+function rz() {
+    let e = {};
+    return e.wbg = {}, e.wbg.__wbg_filemetadata_new = function(t) {
+        let r = Vw.__wrap(t);
+        return Rt(r)
+    }, e.wbg.__wbindgen_string_new = function(t, r) {
+        let i = hr(t, r);
+        return Rt(i)
+    }, e.wbg.__wbindgen_object_drop_ref = function(t) {
+        Ne(t)
+    }, e.wbg.__wbindgen_error_new = function(t, r) {
+        let i = new Error(hr(t, r));
+        return Rt(i)
+    }, e.wbg.__wbindgen_bigint_new = function(t, r) {
+        let i = BigInt(hr(t, r));
+        return Rt(i)
+    }, e.wbg.__wbindgen_number_new = function(t) {
+        return Rt(t)
+    }, e.wbg.__wbindgen_object_clone_ref = function(t) {
+        let r = wt(t);
+        return Rt(r)
+    }, e.wbg.__wbg_String_7462bcc0fcdbaf7d = function(t, r) {
+        let i = String(wt(r)),
+            n = Dw(i, F.__wbindgen_malloc, F.__wbindgen_realloc),
+            s = da;
+        it()[t / 4 + 1] = s, it()[t / 4 + 0] = n
+    }, e.wbg.__wbg_set_e93b31d47b90bff6 = function(t, r, i) {
+        wt(t)[Ne(r)] = Ne(i)
+    }, e.wbg.__wbindgen_cb_drop = function(t) {
+        let r = Ne(t).original;
+        return r.cnt-- == 1 ? (r.a = 0, !0) : !1
+    }, e.wbg.__wbg_get_aab8f8a9b87125ad = function() {
+        return Mi(function(t, r, i, n) {
+            let s = wt(r).get(hr(i, n));
+            var o = QV(s) ? 0 : Dw(s, F.__wbindgen_malloc, F.__wbindgen_realloc),
+                a = da;
+            it()[t / 4 + 1] = a, it()[t / 4 + 0] = o
+        }, arguments)
+    }, e.wbg.__wbg_set_b5c36262f65fae92 = function() {
+        return Mi(function(t, r, i, n, s) {
+            wt(t).set(hr(r, i), hr(n, s))
+        }, arguments)
+    }, e.wbg.__wbg_instanceof_Response_240e67e5796c3c6b = function(t) {
+        return wt(t) instanceof Response
+    }, e.wbg.__wbg_headers_aa309e800cf75016 = function(t) {
+        let r = wt(t).headers;
+        return Rt(r)
+    }, e.wbg.__wbg_arrayBuffer_ccd485f4d2929b08 = function() {
+        return Mi(function(t) {
+            let r = wt(t).arrayBuffer();
+            return Rt(r)
+        }, arguments)
+    }, e.wbg.__wbg_headers_0aeca08d4e61e2e7 = function(t) {
+        let r = wt(t).headers;
+        return Rt(r)
+    }, e.wbg.__wbg_newwithstrandinit_de7c409ec8538105 = function() {
+        return Mi(function(t, r, i) {
+            let n = new Request(hr(t, r), wt(i));
+            return Rt(n)
+        }, arguments)
+    }, e.wbg.__wbg_instanceof_Window_42f092928baaee84 = function(t) {
+        return wt(t) instanceof Window
+    }, e.wbg.__wbg_fetch_9a5cb9d8a96004d0 = function(t, r) {
+        let i = wt(t).fetch(wt(r));
+        return Rt(i)
+    }, e.wbg.__wbg_newnoargs_971e9a5abe185139 = function(t, r) {
+        let i = new Function(hr(t, r));
+        return Rt(i)
+    }, e.wbg.__wbg_new_ac586205e4424583 = function() {
+        return Rt(new Map)
+    }, e.wbg.__wbg_call_33d7bcddbbfa394a = function() {
+        return Mi(function(t, r) {
+            let i = wt(t).call(wt(r));
+            return Rt(i)
+        }, arguments)
+    }, e.wbg.__wbg_new_e6a9fecc2bf26696 = function() {
+        let t = new Object;
+        return Rt(t)
+    }, e.wbg.__wbindgen_is_string = function(t) {
+        return typeof wt(t) == "string"
+    }, e.wbg.__wbg_self_fd00a1ef86d1b2ed = function() {
+        return Mi(function() {
+            let t = self.self;
+            return Rt(t)
+        }, arguments)
+    }, e.wbg.__wbg_window_6f6e346d8bbd61d7 = function() {
+        return Mi(function() {
+            let t = window.window;
+            return Rt(t)
+        }, arguments)
+    }, e.wbg.__wbg_globalThis_3348936ac49df00a = function() {
+        return Mi(function() {
+            let t = globalThis.globalThis;
+            return Rt(t)
+        }, arguments)
+    }, e.wbg.__wbg_global_67175caf56f55ca9 = function() {
+        return Mi(function() {
+            let t = global.global;
+            return Rt(t)
+        }, arguments)
+    }, e.wbg.__wbindgen_is_undefined = function(t) {
+        return wt(t) === void 0
+    }, e.wbg.__wbg_new_3ee7ebe9952c1fbd = function(t, r) {
+        let i = new Error(hr(t, r));
+        return Rt(i)
+    }, e.wbg.__wbg_call_65af9f665ab6ade5 = function() {
+        return Mi(function(t, r, i) {
+            let n = wt(t).call(wt(r), wt(i));
+            return Rt(n)
+        }, arguments)
+    }, e.wbg.__wbg_set_a55cff623a9eaa21 = function(t, r, i) {
+        let n = wt(t).set(wt(r), wt(i));
+        return Rt(n)
+    }, e.wbg.__wbg_new_52205195aa880fc2 = function(t, r) {
+        try {
+            var i = {
+                    a: t,
+                    b: r
+                },
+                n = (o, a) => {
+                    let c = i.a;
+                    i.a = 0;
+                    try {
+                        return tz(c, i.b, o, a)
+                    } finally {
+                        i.a = c
+                    }
+                };
+            let s = new Promise(n);
+            return Rt(s)
+        } finally {
+            i.a = i.b = 0
+        }
+    }, e.wbg.__wbg_resolve_0107b3a501450ba0 = function(t) {
+        let r = Promise.resolve(wt(t));
+        return Rt(r)
+    }, e.wbg.__wbg_then_18da6e5453572fc8 = function(t, r) {
+        let i = wt(t).then(wt(r));
+        return Rt(i)
+    }, e.wbg.__wbg_then_e5489f796341454b = function(t, r, i) {
+        let n = wt(t).then(wt(r), wt(i));
+        return Rt(n)
+    }, e.wbg.__wbg_buffer_34f5ec9f8a838ba0 = function(t) {
+        let r = wt(t).buffer;
+        return Rt(r)
+    }, e.wbg.__wbg_newwithbyteoffsetandlength_88fdad741db1b182 = function(t, r, i) {
+        let n = new Uint8Array(wt(t), r >>> 0, i >>> 0);
+        return Rt(n)
+    }, e.wbg.__wbg_new_cda198d9dbc6d7ea = function(t) {
+        let r = new Uint8Array(wt(t));
+        return Rt(r)
+    }, e.wbg.__wbg_set_1a930cfcda1a8067 = function(t, r, i) {
+        wt(t).set(wt(r), i >>> 0)
+    }, e.wbg.__wbg_length_51f19f73d6d9eff3 = function(t) {
+        return wt(t).length
+    }, e.wbg.__wbg_newwithlength_66e5530e7079ea1b = function(t) {
+        let r = new Uint8Array(t >>> 0);
+        return Rt(r)
+    }, e.wbg.__wbg_set_2762e698c2f5b7e0 = function() {
+        return Mi(function(t, r, i) {
+            return Reflect.set(wt(t), wt(r), wt(i))
+        }, arguments)
+    }, e.wbg.__wbindgen_debug_string = function(t, r) {
+        let i = Lw(wt(r)),
+            n = Dw(i, F.__wbindgen_malloc, F.__wbindgen_realloc),
+            s = da;
+        it()[t / 4 + 1] = s, it()[t / 4 + 0] = n
+    }, e.wbg.__wbindgen_throw = function(t, r) {
+        throw new Error(hr(t, r))
+    }, e.wbg.__wbindgen_memory = function() {
+        let t = F.memory;
+        return Rt(t)
+    }, e.wbg.__wbindgen_closure_wrapper1383 = function(t, r, i) {
+        let n = qV(t, r, 531, ZV);
+        return Rt(n)
+    }, e
+}
+
+function iz(e, t) {
+    return F = e.exports, zP.__wbindgen_wasm_module = t, t_ = new BigUint64Array, Qg = new Int32Array, Gg = new Uint8Array, F
+}
+async function zP(e) {
+    let t = "files/js/vendor/parquet-wasm/arrow2_bg.wasm";
+    typeof e > "u" && (e = new URL(t, window.location.origin));
+    let r = rz();
+    (typeof e == "string" || typeof Request == "function" && e instanceof Request || typeof URL == "function" && e instanceof URL) && (e = fetch(e));
+    let {
+        instance: i,
+        module: n
+    } = await ez(await e, r);
+    return iz(i, n)
+}
+var WP = zP;
+async function sz({
     model: e,
     el: t
 }) {
     let r = new Map,
         i = new Map,
-        s = 20,
-        n = async D => {
-            let V = D.map(Z => `${N}/real_transcript_tiles_mosaic/transcripts_tile_${Z.tileX}_${Z.tileY}.parquet`);
-            var z = await l(r, V),
-                Y = m(z);
-            Zi = Y.getChild("name").toArray();
-            var G = A(Y);
-            return G
-        }, o = async D => {
-            let V = D.map(et => `${N}/cell_segmentation_v2/cell_tile_${et.tileX}_${et.tileY}.parquet`);
-            var z = await l(i, V),
-                Y = z.map(et => E(et)),
-                G = d(Y),
-                Z = y(G);
-            return Z
+        n = 20,
+        s = async L => {
+            let W = L.map(mt => `${B}/real_transcript_tiles_mosaic/transcripts_tile_${mt.tileX}_${mt.tileY}.parquet`);
+            var j = await l(r, W),
+                ot = p(j);
+            pa = ot.getChild("name").toArray();
+            var bt = T(ot);
+            return bt
+        }, o = async L => {
+            let W = L.map(Et => `${B}/cell_segmentation_v2/cell_tile_${Et.tileX}_${Et.tileY}.parquet`);
+            var j = await l(i, W),
+                ot = j.map(Et => S(Et)),
+                bt = d(ot),
+                mt = y(bt);
+            return mt
         }, a = async ({
-            height: D,
-            width: V,
-            zoom: z,
-            target: Y
+            height: L,
+            width: W,
+            zoom: j,
+            target: ot
         }) => {
-            let G = Math.pow(2, z),
-                [Z, et] = Y,
-                Ht = V / (2 * G),
-                ee = D / (2 * G),
-                or = Z - Ht,
-                re = Z + Ht,
-                ke = et - ee,
-                rn = et + ee,
-                Cr = u(or, re, ke, rn, uh);
-            var mh = Cr.length;
-            if (mh < Js) {
-                let _h = n(Cr),
-                    aa = new Fe({
-                        ...jt.props,
-                        data: _h
+            let bt = Math.pow(2, j),
+                [mt, Et] = ot,
+                qe = W / (2 * bt),
+                dr = L / (2 * bt),
+                mn = mt - qe,
+                pr = mt + qe,
+                Ci = Et - dr,
+                Zc = Et + dr,
+                fs = h(mn, pr, Ci, Zc, r_);
+            var o_ = fs.length;
+            if (o_ < Xc) {
+                let a_ = s(fs),
+                    uh = new ui({
+                        ...Ye.props,
+                        data: a_
                     }),
-                    ca = o(Cr),
-                    sn = new rr({
-                        ...gh.props,
-                        data: ca
+                    fh = o(fs),
+                    Kc = new Qi({
+                        ...s_.props,
+                        data: fh
                     });
-                en.setProps({
-                    layers: [sr, wr, sn, Ki, aa]
+                qc.setProps({
+                    layers: [dn, os, Kc, ma, uh]
                 })
-            } else en.setProps({
-                layers: [sr, wr, Ki]
+            } else qc.setProps({
+                layers: [dn, os, ma]
             })
-        }, c = D => {
-            let V = new Uint8Array(D),
-                z = hh.readParquet(V);
-            return LT.tableFromIPC(z)
-        }, l = async (D, V) => Promise.all(V.map(z => h(D, z))), h = async (D, V) => {
-            let z;
-            if (D.has(V)) z = D.get(V), D.delete(V), D.set(V, z);
+        }, c = L => {
+            let W = new Uint8Array(L),
+                j = VP(W);
+            return ah(j)
+        }, l = async (L, W) => Promise.all(W.map(j => u(L, j))), u = async (L, W) => {
+            let j;
+            if (L.has(W)) j = L.get(W), L.delete(W), L.set(W, j);
             else {
-                let G = await (await fetch(V, H.fetch)).arrayBuffer();
-                if (z = c(G), D.size >= s) {
-                    let Z = D.keys().next().value;
-                    D.delete(Z)
-                }
-                D.set(V, z)
-            }
-            return z
-        }, f = (D, V, z) => {
-            let Y;
-            return (...G) => {
-                let Z = this,
-                    et = () => {
-                        Y = null, z || D.apply(Z, G)
+                let bt = await (await fetch(W, K.fetch)).arrayBuffer();
+                if (j = c(bt), L.size >= n) {
+                    let mt = L.keys().next().value;
+                    L.delete(mt)
+                }
+                L.set(W, j)
+            }
+            return j
+        }, f = (L, W, j) => {
+            let ot;
+            return (...bt) => {
+                let mt = this,
+                    Et = () => {
+                        ot = null, j || L.apply(mt, bt)
                     },
-                    Ht = z && !Y;
-                clearTimeout(Y), Y = setTimeout(et, V), Ht && D.apply(Z, G)
+                    qe = j && !ot;
+                clearTimeout(ot), ot = setTimeout(Et, W), qe && L.apply(mt, bt)
             }
-        }, u = (D, V, z, Y, G) => {
-            let Z = Math.floor(D / G),
-                et = Math.floor(V / G),
-                Ht = Math.floor(z / G),
-                ee = Math.floor(Y / G),
-                or = [];
-            for (let re = Z; re <= et; re++)
-                for (let ke = Ht; ke <= ee; ke++) or.push({
-                    tileX: re,
-                    tileY: ke,
-                    name: re + "_" + ke
+        }, h = (L, W, j, ot, bt) => {
+            let mt = Math.floor(L / bt),
+                Et = Math.floor(W / bt),
+                qe = Math.floor(j / bt),
+                dr = Math.floor(ot / bt),
+                mn = [];
+            for (let pr = mt; pr <= Et; pr++)
+                for (let Ci = qe; Ci <= dr; Ci++) mn.push({
+                    tileX: pr,
+                    tileY: Ci,
+                    name: pr + "_" + Ci
                 });
-            return or
-        }, d = D => {
-            let V = {
+            return mn
+        }, d = L => {
+            let W = {
                 length: 0,
                 startIndices: new Int32Array,
                 attributes: {
                     getPolygon: {
                         value: new Float64Array,
                         size: 2
                     }
                 }
             };
-            return D.forEach((z, Y) => {
-                V.length += z.length;
-                let G = V.attributes.getPolygon.value.length / 2,
-                    Z = z.startIndices;
-                if (Y > 0) {
-                    Z = new Int32Array(z.startIndices.length);
-                    for (let et = 0; et < z.startIndices.length; et++) Z[et] = z.startIndices[et] + G
-                }
-                V.startIndices = new Int32Array([...V.startIndices, ...Z.slice(Y > 0 ? 1 : 0)]), V.attributes.getPolygon.value = new Float64Array([...V.attributes.getPolygon.value, ...z.attributes.getPolygon.value])
-            }), V
-        }, m = D => {
-            if (D.length === 0) return null;
-            let V = D[0];
-            for (let z = 1; z < D.length; z++) V = V.concat(D[z]);
-            return V
-        }, y = D => {
-            let V = [],
+            return L.forEach((j, ot) => {
+                W.length += j.length;
+                let bt = W.attributes.getPolygon.value.length / 2,
+                    mt = j.startIndices;
+                if (ot > 0) {
+                    mt = new Int32Array(j.startIndices.length);
+                    for (let Et = 0; Et < j.startIndices.length; Et++) mt[Et] = j.startIndices[Et] + bt
+                }
+                W.startIndices = new Int32Array([...W.startIndices, ...mt.slice(ot > 0 ? 1 : 0)]), W.attributes.getPolygon.value = new Float64Array([...W.attributes.getPolygon.value, ...j.attributes.getPolygon.value])
+            }), W
+        }, p = L => {
+            if (L.length === 0) return null;
+            let W = L[0];
+            for (let j = 1; j < L.length; j++) W = W.concat(L[j]);
+            return W
+        }, y = L => {
+            let W = [],
                 {
-                    startIndices: z,
-                    attributes: Y
-                } = D,
-                G = Y.getPolygon.value,
-                Z = z.length - 1;
-            for (let et = 0; et < Z; ++et) {
-                let Ht = z[et] * 2,
-                    ee = z[et + 1] * 2,
-                    or = [];
-                for (let re = Ht; re < ee; re += 2) {
-                    let ke = G[re],
-                        rn = G[re + 1];
-                    or.push([ke, rn])
+                    startIndices: j,
+                    attributes: ot
+                } = L,
+                bt = ot.getPolygon.value,
+                mt = j.length - 1;
+            for (let Et = 0; Et < mt; ++Et) {
+                let qe = j[Et] * 2,
+                    dr = j[Et + 1] * 2,
+                    mn = [];
+                for (let pr = qe; pr < dr; pr += 2) {
+                    let Ci = bt[pr],
+                        Zc = bt[pr + 1];
+                    mn.push([Ci, Zc])
                 }
-                V.push(or)
+                W.push(mn)
             }
-            return V
-        }, x = async (D, V) => {
+            return W
+        }, b = async (L, W) => {
             try {
-                let Y = await (await fetch(D, V)).arrayBuffer();
-                return c(Y)
-            } catch (z) {
-                return console.error("Error loading data:", z), []
+                let ot = await (await fetch(L, W)).arrayBuffer();
+                return c(ot)
+            } catch (j) {
+                return console.error("Error loading data:", j), []
             }
-        }, A = D => {
+        }, T = L => {
             try {
-                let V = D.getChild("geometry").getChildAt(0).data.map(Y => Y.values).reduce((Y, G) => {
-                    let Z = new Float64Array(Y.length + G.length);
-                    return Z.set(Y), Z.set(G, Y.length), Z
+                let W = L.getChild("geometry").getChildAt(0).data.map(ot => ot.values).reduce((ot, bt) => {
+                    let mt = new Float64Array(ot.length + bt.length);
+                    return mt.set(ot), mt.set(bt, ot.length), mt
                 }, new Float64Array(0));
                 return {
-                    length: D.numRows,
+                    length: L.numRows,
                     attributes: {
                         getPosition: {
-                            value: V,
+                            value: W,
                             size: 2
                         }
                     }
                 }
-            } catch (V) {
-                return console.error("Error loading data:", V), []
+            } catch (W) {
+                return console.error("Error loading data:", W), []
             }
-        }, v = D => {
-            if (D.index === -1 || !D.layer) return null;
-            let V = D.index,
-                z;
-            return D.layer.id === "cell-layer" ? z = De[D.index] : D.layer.id === "trx-layer" && (z = Zi[D.index]), {
-                html: `<div>${z}</div?`
+        }, I = L => {
+            if (L.index === -1 || !L.layer) return null;
+            let W = L.index,
+                j;
+            return L.layer.id === "cell-layer" ? j = Pi[L.index] : L.layer.id === "trx-layer" && (j = pa[L.index]), {
+                html: `<div>${j}</div?`
             };
             return null
         };
-    var E = D => {
-        var V = D.getChildAt(0),
-            z = V.data[0].valueOffsets,
-            Y = V.getChildAt(0).data[0].valueOffsets,
-            G = V.getChildAt(0).getChildAt(0).getChildAt(0),
-            Z = G.data[0].values;
-        let et = new Int32Array(z.length);
-        for (let ee = 0; ee < et.length; ++ee) et[ee] = Y[z[ee]];
-        var Ht = {
-            length: D.numRows,
-            startIndices: et,
+    var S = L => {
+        var W = L.getChildAt(0),
+            j = W.data[0].valueOffsets,
+            ot = W.getChildAt(0).data[0].valueOffsets,
+            bt = W.getChildAt(0).getChildAt(0).getChildAt(0),
+            mt = bt.data[0].values;
+        let Et = new Int32Array(j.length);
+        for (let dr = 0; dr < Et.length; ++dr) Et[dr] = ot[j[dr]];
+        var qe = {
+            length: L.numRows,
+            startIndices: Et,
             attributes: {
                 getPolygon: {
-                    value: Z,
+                    value: mt,
                     size: 2
                 }
             }
         };
-        return Ht
+        return qe
     };
     let R = e.get("token_traitlet"),
-        M = e.get("ini_x"),
+        P = e.get("ini_x"),
         C = e.get("ini_y"),
-        B = e.get("ini_zoom"),
-        L = e.get("max_image_zoom"),
+        V = e.get("ini_zoom"),
+        U = e.get("max_image_zoom"),
         k = e.get("bounce_time"),
-        N = e.get("base_url"),
-        H = {
+        B = e.get("base_url"),
+        K = {
             fetch: {
                 headers: {
                     Authorization: `Bearer ${R}`
                 }
             }
         },
-        $ = "cellbound",
-        X = `${N}/pyramid_images/${$}.image.dzi`,
-        xt = await (await fetch(X, H.fetch)).text(),
-        ne = new DOMParser().parseFromString(xt, "text/xml"),
-        It = {
-            height: Number(ne.getElementsByTagName("Size")[0].attributes.Height.value),
-            width: Number(ne.getElementsByTagName("Size")[0].attributes.Width.value),
-            tileSize: Number(ne.getElementsByTagName("Image")[0].attributes.TileSize.value)
+        st = "cellbound",
+        G = `${B}/pyramid_images/${st}.image.dzi`,
+        oe = await (await fetch(G, K.fetch)).text(),
+        Er = new DOMParser().parseFromString(oe, "text/xml"),
+        Re = {
+            height: Number(Er.getElementsByTagName("Size")[0].attributes.Height.value),
+            width: Number(Er.getElementsByTagName("Size")[0].attributes.Width.value),
+            tileSize: Number(Er.getElementsByTagName("Image")[0].attributes.TileSize.value)
         };
-    class ci extends ri {
+    class ro extends Ds {
         getShaders() {
-            let V = super.getShaders();
-            return V.inject = {
+            let W = super.getShaders();
+            return W.inject = {
                 "fs:#decl": "uniform vec3 uColor; uniform float uOpacityScale;",
                 "fs:DECKGL_FILTER_COLOR": `
             // Convert color to grayscale and apply opacity scale
             float grayscale = ((color.r + color.g + color.b) / 3.0) * uOpacityScale;
             // Clamp grayscale to valid range
             grayscale = clamp(grayscale, 0.0, 1.0);
             // Apply custom color and scaled opacity
             color = vec4(uColor, grayscale);
           `
-            }, V
+            }, W
         }
-        updateState(V) {
-            super.updateState(V);
+        updateState(W) {
+            super.updateState(W);
             let {
-                props: z,
-                oldProps: Y
-            } = V;
-            (z.color !== Y.color || z.opacityScale !== Y.opacityScale) && this.setState({
+                props: j,
+                oldProps: ot
+            } = W;
+            (j.color !== ot.color || j.opacityScale !== ot.opacityScale) && this.setState({
                 uniforms: {
-                    uColor: z.color.map(G => G / 255),
-                    uOpacityScale: z.opacityScale
+                    uColor: j.color.map(bt => bt / 255),
+                    uOpacityScale: j.opacityScale
                 }
             })
         }
-        draw(V) {
+        draw(W) {
             let {
-                uniforms: z
+                uniforms: j
             } = this.state;
             super.draw({
-                ...V,
+                ...W,
                 uniforms: {
-                    ...V.uniforms,
-                    ...z
+                    ...W.uniforms,
+                    ...j
                 }
             })
         }
     }
-    let wr = new ai({
-            tileSize: It.tileSize,
+    let os = new js({
+            tileSize: Re.tileSize,
             refinementStrategy: "no-overlap",
             minZoom: -7,
             maxZoom: 0,
             maxCacheSize: 20,
-            extent: [0, 0, It.width, It.height],
+            extent: [0, 0, Re.width, Re.height],
             getTileData: ({
-                index: D
+                index: L
             }) => {
                 let {
-                    x: V,
-                    y: z,
-                    z: Y
-                } = D, G = `${N}/pyramid_images/${$}.image_files/${L+Y}/${V}_${z}.jpeg`;
-                return kT(G, H).then(Z => Z).catch(Z => (console.error("Failed to load tile:", Z), null))
+                    x: W,
+                    y: j,
+                    z: ot
+                } = L, bt = `${B}/pyramid_images/${st}.image_files/${U+ot}/${W}_${j}.jpeg`;
+                return uc(bt, K).then(mt => mt).catch(mt => (console.error("Failed to load tile:", mt), null))
             },
-            renderSubLayers: D => {
+            renderSubLayers: L => {
                 let {
                     bbox: {
-                        left: V,
-                        bottom: z,
-                        right: Y,
-                        top: G
+                        left: W,
+                        bottom: j,
+                        right: ot,
+                        top: bt
                     }
-                } = D.tile, {
-                    width: Z,
-                    height: et
-                } = It;
-                return new ci(D, {
+                } = L.tile, {
+                    width: mt,
+                    height: Et
+                } = Re;
+                return new ro(L, {
                     data: null,
-                    image: D.data,
-                    bounds: [Sr.clamp(V, 0, Z), Sr.clamp(z, 0, et), Sr.clamp(Y, 0, Z), Sr.clamp(G, 0, et)],
+                    image: L.data,
+                    bounds: [hn(W, 0, mt), hn(j, 0, Et), hn(ot, 0, mt), hn(bt, 0, Et)],
                     color: [255, 0, 0],
                     opacityScale: 3
                 })
             }
         }),
-        fh = "dapi",
-        sr = new ai({
+        e_ = "dapi",
+        dn = new js({
             id: "tile_layer_2",
-            tileSize: It.tileSize,
+            tileSize: Re.tileSize,
             refinementStrategy: "no-overlap",
             minZoom: -7,
             maxZoom: 0,
             maxCacheSize: 20,
-            extent: [0, 0, It.width, It.height],
+            extent: [0, 0, Re.width, Re.height],
             getTileData: ({
-                index: D
+                index: L
             }) => {
                 let {
-                    x: V,
-                    y: z,
-                    z: Y
-                } = D, G = `${N}/pyramid_images/${fh}.image_files/${L+Y}/${V}_${z}.jpeg`;
-                return kT(G, H).then(Z => Z).catch(Z => (console.error("Failed to load tile:", Z), null))
+                    x: W,
+                    y: j,
+                    z: ot
+                } = L, bt = `${B}/pyramid_images/${e_}.image_files/${U+ot}/${W}_${j}.jpeg`;
+                return uc(bt, K).then(mt => mt).catch(mt => (console.error("Failed to load tile:", mt), null))
             },
-            renderSubLayers: D => {
+            renderSubLayers: L => {
                 let {
                     bbox: {
-                        left: V,
-                        bottom: z,
-                        right: Y,
-                        top: G
+                        left: W,
+                        bottom: j,
+                        right: ot,
+                        top: bt
                     }
-                } = D.tile, {
-                    width: Z,
-                    height: et
-                } = It;
-                return new ri(D, {
+                } = L.tile, {
+                    width: mt,
+                    height: Et
+                } = Re;
+                return new Ds(L, {
                     data: null,
-                    image: D.data,
-                    bounds: [Sr.clamp(V, 0, Z), Sr.clamp(z, 0, et), Sr.clamp(Y, 0, Z), Sr.clamp(G, 0, et)]
+                    image: L.data,
+                    bounds: [hn(W, 0, mt), hn(j, 0, Et), hn(ot, 0, mt), hn(bt, 0, Et)]
                 })
             }
         }),
-        uh = 1e3,
-        Js = 15,
-        dh = f(a, k);
-    await hh.default();
-    let ph = N + "/real_cells_mosaic.parquet";
-    var St = await x(ph, H.fetch),
-        nr = A(St);
-    let dt = N + "/meta_gene.parquet";
-    var Rt = await x(dt, H.fetch);
-    let li = [],
-        vr = [],
-        Rr = Rt.getChild("__index_level_0__"),
-        Pr = Rt.getChild("color");
-    Rr && Pr && (li = Rr.toArray(), vr = Pr.toArray());
-    let Mr = {};
-
-    function oe(D) {
-        D = D.replace(/^#/, "");
-        let V = 0,
-            z = 0,
-            Y = 0;
-        return D.length === 3 ? (V = parseInt(D.charAt(0) + D.charAt(0), 16), z = parseInt(D.charAt(1) + D.charAt(1), 16), Y = parseInt(D.charAt(2) + D.charAt(2), 16)) : D.length === 6 && (V = parseInt(D.substring(0, 2), 16), z = parseInt(D.substring(2, 4), 16), Y = parseInt(D.substring(4, 6), 16)), [V, z, Y]
+        r_ = 1e3,
+        Xc = 15,
+        i_ = f(a, k);
+    console.log("about to default pq"), await WP();
+    let n_ = B + "/real_cells_mosaic.parquet";
+    var ge = await b(n_, K.fetch),
+        pn = T(ge);
+    let Jt = B + "/meta_gene.parquet";
+    var we = await b(Jt, K.fetch);
+    let io = [],
+        as = [],
+        cs = we.getChild("__index_level_0__"),
+        ls = we.getChild("color");
+    cs && ls && (io = cs.toArray(), as = ls.toArray());
+    let us = {};
+
+    function Ir(L) {
+        L = L.replace(/^#/, "");
+        let W = 0,
+            j = 0,
+            ot = 0;
+        return L.length === 3 ? (W = parseInt(L.charAt(0) + L.charAt(0), 16), j = parseInt(L.charAt(1) + L.charAt(1), 16), ot = parseInt(L.charAt(2) + L.charAt(2), 16)) : L.length === 6 && (W = parseInt(L.substring(0, 2), 16), j = parseInt(L.substring(2, 4), 16), ot = parseInt(L.substring(4, 6), 16)), [W, j, ot]
     }
-    li.forEach((D, V) => {
-        Mr[D] = oe(vr[V])
+    io.forEach((L, W) => {
+        us[L] = Ir(as[W])
     });
-    let De = St.getChild("name").toArray(),
-        Zi, Ki = new Fe({
+    let Pi = ge.getChild("name").toArray(),
+        pa, ma = new ui({
             id: "cell-layer",
-            data: nr,
+            data: pn,
             getRadius: 5,
             pickable: !0,
             getColor: [0, 0, 255, 240],
-            onClick: D => {
-                console.log("click!!"), console.log(D.index), console.log(De[D.index])
+            onClick: L => {
+                console.log("click!!"), console.log(L.index), console.log(Pi[L.index])
             }
         });
-    var Qi = [];
-    let jt = new Fe({
+    var ga = [];
+    let Ye = new ui({
             id: "trx-layer",
-            data: Qi,
+            data: ga,
             getRadius: .5,
             pickable: !0,
-            getColor: (D, V) => {
-                var z = Zi[V.index],
-                    Y = Mr[z];
-                return [Y[0], Y[1], Y[2], 255]
+            getColor: (L, W) => {
+                var j = pa[W.index],
+                    ot = us[j];
+                return [ot[0], ot[1], ot[2], 255]
             }
         }),
-        gh = new rr({
+        s_ = new Qi({
             id: "path_layer",
             data: [],
             pickable: !0,
             widthScale: 3,
             widthMinPixels: 1,
-            getPath: D => D,
-            getColor: D => [255, 255, 255, 150],
+            getPath: L => L,
+            getColor: L => [255, 255, 255, 150],
             widthUnits: "pixels"
         }),
-        tn = document.createElement("div");
-    tn.style.height = "800px";
-    let en = new ji({
-        parent: tn,
+        Yc = document.createElement("div");
+    Yc.style.height = "800px";
+    let qc = new ko({
+        parent: Yc,
         controller: {
             doubleClickZoom: !1
         },
         initialViewState: {
-            target: [M, C, 0],
-            zoom: B
+            target: [P, C, 0],
+            zoom: V
         },
-        views: [new Xi({
+        views: [new Vo({
             id: "ortho"
         })],
-        layers: [sr, wr, Ki],
+        layers: [dn, os, ma],
         onViewStateChange: ({
-            viewState: D
-        }) => (dh(D), D),
-        getTooltip: v
+            viewState: L
+        }) => (i_(L), L),
+        getTooltip: I
     });
-    return t.appendChild(tn), () => en.finalize()
+    return t.appendChild(Yc), () => qc.finalize()
 }
-var cZ = {
-    render: vC
+var xwt = {
+    render: sz
 };
 export {
-    cZ as
-    default, vC as render
+    xwt as
+    default, sz as render
 };
 /*! Bundled license information:
 
 hammerjs/hammer.js:
   (*! Hammer.JS - v2.0.7 - 2016-04-22
    * http://hammerjs.github.io/
    *
```

### Comparing `celldega-0.1.1/README.md` & `celldega-0.1.2/README.md`

 * *Files identical despite different names*

### Comparing `celldega-0.1.1/pyproject.toml` & `celldega-0.1.2/pyproject.toml`

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 [build-system]
 requires = ["hatchling"]
 build-backend = "hatchling.build"
 
 [project]
 name = "celldega"
-version = "0.1.1"
+version = "0.1.2"
 dependencies = ["anywidget"]
 readme = "README.md"
 
 [project.optional-dependencies]
 dev = ["watchfiles", "jupyterlab"]
 
 # automatically add the dev feature to the default env (e.g., hatch shell)
```

### Comparing `celldega-0.1.1/PKG-INFO` & `celldega-0.1.2/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.3
 Name: celldega
-Version: 0.1.1
+Version: 0.1.2
 Requires-Dist: anywidget
 Provides-Extra: dev
 Requires-Dist: jupyterlab; extra == 'dev'
 Requires-Dist: watchfiles; extra == 'dev'
 Description-Content-Type: text/markdown
 
 # celldega
```

